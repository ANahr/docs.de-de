<Type Name="Cer" FullName="System.Runtime.ConstrainedExecution.Cer">
  <TypeSignature Language="C#" Value="public enum Cer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed Cer extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ConstrainedExecution.Cer" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Gibt eine Methode-Verhalten, wenn in einem eingeschränkten Ausführungsbereich aufgerufen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.ConstrainedExecution.Cer> Enumeration gibt das Verhalten einer Methode, den Typ oder die Assembly in einem eingeschränkten Ausführungsbereich (CER). Verwenden Sie eines der drei verfügbaren Werte, um anzugeben, dass die Entität erfolgreich ist, hat keine Kenntnis von einem eingeschränkten Ausführungsbereich sonst möglicherweise (deterministisch) in der Lage, Erfolg oder Fehler melden.  
  
 Eine Ausführungsbereich garantiert, die ausgeführt wird, der Codebereich an ununterbrochen ausgeführt, selbst wenn eine asynchrone Ausnahme z. B. eine abgebrochene Thread-Out-of-Memory-Ausnahme oder ein Stapelüberlauf ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Runtime.ConstrainedExecution.Cer> -Enumeration fest, wenn eine constrained Execution Region für eine Methode angeben. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute.%23ctor%2A> Konstruktor.  
  
 [!code-csharp[System.Runtime.ConstrainedExecution#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.ConstrainedExecution/cs/program.cs#3)]
 [!code-vb[System.Runtime.ConstrainedExecution#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.ConstrainedExecution/vb/program.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="MayFail">
      <MemberSignature Language="C#" Value="MayFail" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.ConstrainedExecution.Cer MayFail = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.ConstrainedExecution.Cer.MayFail" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ConstrainedExecution.Cer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ausnahmebedingungen könnte die Methode fehl. In diesem Fall meldet die Methode zurück an die aufrufende Methode, ob es erfolgreich war oder nicht. Die Methode muss einen CER um Methodentext, um sicherzustellen, dass er den Rückgabewert melden kann, verfügen.</summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.ConstrainedExecution.Cer None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.ConstrainedExecution.Cer.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ConstrainedExecution.Cer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Methode, den Typ oder die Assembly verfügt über kein Konzept für einen CER. CER-Garantien können nicht genutzt werden. Dies impliziert Folgendes:</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Ausnahmebedingungen könnte die Methode fehl.  
  
-   Die Methode kann oder möglicherweise nicht Bericht, der fehlgeschlagen ist (es ist nicht deterministisch).  
  
-   Die Methode wird nicht mit CERs Bedenken geschrieben (Dies ist das wahrscheinlichste Szenario).  
  
 Wenn eine Methode, den Typ oder die Assembly nicht explizit markiert wurde erfolgreich ist, wird es implizit markiert als `Cer.None`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Success">
      <MemberSignature Language="C#" Value="Success" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.ConstrainedExecution.Cer Success = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.ConstrainedExecution.Cer.Success" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ConstrainedExecution.Cer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ausnahmebedingungen ist sichergestellt, dass die Methode erfolgreich ausgeführt werden. Sie sollten immer erstellen einen CER um die Methode, die aufgerufen wird, selbst wenn sie von innerhalb einer nicht eingeschränkten Ausführungsbereich aufgerufen wird. Eine Methode ist erfolgreich, wenn dies wird erreicht, was beabsichtigt ist. Markieren Sie z. B. <see cref="P:System.Collections.ArrayList.Count" /> mit <c>ReliabilityContractAttribute(CER.Success) markiert</c> impliziert, dass es in einem eingeschränkten Ausführungsbereich ausgeführt wird, stets die Anzahl der Elemente im zurückgibt, wenn die <see cref="T:System.Collections.ArrayList" /> und lassen Sie niemals die interne Felder in einem unbestimmten Zustand.</summary>
      </Docs>
    </Member>
  </Members>
</Type>
