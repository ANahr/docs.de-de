<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet eine Reihe von <see langword="static" /> (<see langword="Shared" /> in Visual Basic) Methoden zum Abfragen von Objekten, die implementieren <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden in dieser Klasse geben Sie eine Implementierung der Standardabfrageoperatoren zum Abfragen von implementiert Datenquellen, <xref:System.Collections.Generic.IEnumerable%601>. Die Standardabfrageoperatoren sind allgemeine Methoden, die Folgen der [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] Muster und ermöglichen es Ihnen, Durchlauf, Filter- und projektionsvorgänge Vorgänge in einer express. NET-basierte Programmiersprache Ihrer Wahl.  
  
 Der Großteil der Methoden in dieser Klasse werden als Erweiterungsmethoden, mit denen erweitern definiert <xref:System.Collections.Generic.IEnumerable%601>. Dies bedeutet, sie können aufgerufen werden, wie eine Instanzmethode für jedes Objekt, das implementiert <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Methoden, die in einer Abfrage verwendet werden, die eine Sequenz von Werten zurückgibt belegen keine die Zieldaten, bis das Abfrageobjekt aufgelistet wird. Dies wird als verzögerte Ausführung bezeichnet. Methoden, die in einer Abfrage verwendet werden, die einen Singletonwert zurückgibt, ausführen und die Zieldaten sofort nutzen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die aggregiert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> Methode vereinfacht die Ausführen einer Berechnung auf eine Sequenz von Werten. Diese Methode funktioniert durch Aufrufen von `func` einmal für jedes Element im `source` Ausnahme der ersten. Jedes Mal `func` aufgerufen wird, <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> übergibt Sie sowohl das Element aus der Sequenz und einen Aggregatwert (als erstes Argument für `func`). Das erste Element der `source` wird als erster Aggregatwert verwendet. Das Ergebnis des `func` ersetzt den vorherigen aggregierten Wert. <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>Gibt das endgültige Ergebnis `func`.  
  
 Diese Überladung von der <xref:System.Linq.Enumerable.Aggregate%2A> Methode nicht für alle Fälle geeignet, da das erste Element der verwendet wird, `source` als Anfangswert aggregieren. Wählen Sie eine andere Überladung, wenn der Rückgabewert nur die Elemente enthalten soll `source` , die eine bestimmte Bedingung erfüllen. Diese Überladung ist z. B. nicht zuverlässige, wenn Sie zum Berechnen der Summe der geraden Zahlen in möchten `source`. Das Ergebnis wird sein falsch, wenn das erste Element anstelle sogar ungerade ist.  
  
 Zur Vereinfachung der allgemeinen Aggregationsvorgänge Standardabfrageoperatoren auch allgemeine Zählmethode einschließen <xref:System.Linq.Enumerable.Count%2A>, und vier numerische Aggregationsmethoden, nämlich <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, und <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Reihenfolge von Wörtern in einer Zeichenfolge mit umkehren <xref:System.Linq.Enumerable.Aggregate%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <param name="source">Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die aggregiert.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> Methode vereinfacht die Ausführen einer Berechnung auf eine Sequenz von Werten. Diese Methode funktioniert durch Aufrufen von `func` einmal für jedes Element im `source`. Jedes Mal `func` aufgerufen wird, <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> übergibt Sie sowohl das Element aus der Sequenz und einen Aggregatwert (als erstes Argument für `func`). Der Wert, der die `seed` Parameter wird als erster Aggregatwert verwendet. Das Ergebnis des `func` ersetzt den vorherigen aggregierten Wert. <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>Gibt das endgültige Ergebnis `func`.  
  
 Zur Vereinfachung der allgemeinen Aggregationsvorgänge Standardabfrageoperatoren auch allgemeine Zählmethode einschließen <xref:System.Linq.Enumerable.Count%2A>, und vier numerische Aggregationsmethoden, nämlich <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, und <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Aggregate%2A> eine Akkumulatorfunktion angewendet, und verwenden einen Ausgangswert.  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die aggregiert.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet, und der Ergebniswert wird mit der angegebenen Funktion ausgewählt.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> Methode vereinfacht die Ausführen einer Berechnung auf eine Sequenz von Werten. Diese Methode funktioniert durch Aufrufen von `func` einmal für jedes Element im `source`. Jedes Mal `func` aufgerufen wird, <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> übergibt Sie sowohl das Element aus der Sequenz und einen Aggregatwert (als erstes Argument für `func`). Der Wert, der die `seed` Parameter wird als erster Aggregatwert verwendet. Das Ergebnis des `func` ersetzt den vorherigen aggregierten Wert. Das endgültige Ergebnis `func` übergeben `resultSelector` das endgültige Ergebnis des abzurufenden <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>.  
  
 Zur Vereinfachung der allgemeinen Aggregationsvorgänge Standardabfrageoperatoren auch allgemeine Zählmethode einschließen <xref:System.Linq.Enumerable.Count%2A>, und vier numerische Aggregationsmethoden, nämlich <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, und <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Aggregate%2A> eine Akkumulatorfunktion und eine Ergebnisauswahl angewendet.  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="func" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , enthält die Elemente, die das Prädikat angewendet.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob alle Elemente einer Sequenz eine Bedingung erfüllen.</summary>
        <returns>
          <see langword="true" />Wenn jedes Element der Quellsequenz den Test im angegebenen Prädikat besteht, oder wenn die Sequenz leer ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt keinen alle Elemente einer Auflistung zurück. Stattdessen bestimmt, ob alle Elemente einer Auflistung eine Bedingung erfüllen.  
  
 Die Enumeration von `source` wird beendet, sobald das Ergebnis bestimmt werden kann.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into All()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.All%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.All%2A> zu bestimmen, ob alle Elemente in einer Sequenz eine Bedingung erfüllen. Variable `allStartWithB` ist "true", wenn alle Pet-Namen mit "B" beginnen oder das `pets` Array ist leer.  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 Der boolesche Wert, der die <xref:System.Linq.Enumerable.All%2A> Methodenrückgabe wird im Prädikat in der Regel verwendet eine `where` -Klausel (`Where` -Klausel in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) oder ein direkter Aufruf der <xref:System.Linq.Enumerable.Where%2A> Methode. Das folgende Beispiel zeigt diese Verwendung von der `All` Methode.  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> zu suchende überprüft.</param>
        <summary>Bestimmt, ob eine Sequenz Elemente enthält.</summary>
        <returns>
          <see langword="true" />Wenn die Quellsequenz Elemente enthält. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt keinen Element einer Auflistung zurück. Stattdessen bestimmt, ob die Auflistung Elemente enthält.  
  
 Die Enumeration von `source` wird beendet, sobald das Ergebnis bestimmt werden kann.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Any()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Any%2A> zu bestimmen, ob eine Sequenz Elemente enthält.  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 Der boolesche Wert, der die <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methodenrückgabe wird im Prädikat in der Regel verwendet eine `where` -Klausel (`Where` -Klausel in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) oder ein direkter Aufruf der <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Methode. Das folgende Beispiel zeigt diese Verwendung von der `Any` Methode.  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente das Prädikat angewendet.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob ein Element einer Sequenz eine Bedingung erfüllt.</summary>
        <returns>
          <see langword="true" />Wenn Elemente in der Quellsequenz den Test im angegebenen Prädikat erfolgreich überprüft; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt keinen Element einer Auflistung zurück. Stattdessen bestimmt, ob alle Elemente einer Auflistung eine Bedingung erfüllen.  
  
 Die Enumeration von `source` wird beendet, sobald das Ergebnis bestimmt werden kann.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Any()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Any%2A> zu bestimmen, ob ein Element in einer Sequenz eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten.</param>
        <param name="element">Der an <paramref name="source" /> anzufügende Wert.</param>
        <summary>Fügt einen Wert an das Ende der Sequenz an.</summary>
        <returns>Eine neue Sequenz, die mit <paramref name="element" /> endet.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, geben Sie als <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Gibt die Eingabe als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisiert zurück</summary>
        <returns>Die als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisierte Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode hat keine Auswirkungen außer so ändern Sie den Typ der Zeitpunkt der Kompilierung des `source` von einem Typ, der implementiert <xref:System.Collections.Generic.IEnumerable%601> zu <xref:System.Collections.Generic.IEnumerable%601> selbst.  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>kann verwendet werden, um die Auswahl zwischen abfrageimplementierungen, wenn eine Sequenz implementiert <xref:System.Collections.Generic.IEnumerable%601> aber verfügt auch über einen anderen Satz von öffentlichen Abfragemethoden zur Verfügung. Angenommen, eine generische Klasse `Table` implementiert <xref:System.Collections.Generic.IEnumerable%601> und verfügt über eigene Methoden wie `Where`, `Select`, und `SelectMany`, einen Aufruf von `Where` würde die öffentliche Aufrufen `Where` Methode `Table`. Ein `Table` Typ, der eine Datenbanktabelle steht möglicherweise eine `Where` Methode, die das Prädikatargument als einer Ausdrucksbaumstruktur dar und die Struktur für die Remoteausführung in SQL konvertiert. Wenn Remoteausführung nicht, z. B. erwünscht ist, da das Prädikat eine lokale Methode ruft die <xref:System.Linq.Enumerable.AsEnumerable%2A> Methode kann verwendet werden, um die benutzerdefinierten Methoden ausblenden und stattdessen die Standardabfrageoperatoren verfügbar machen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> einen Ausblenden des benutzerdefinierten `Where` Methode, wenn die Implementierung der Standardabfrageoperator-Operator gewünscht wird.  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> berechnen den Durchschnitt einer Sequenz von Werten.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Summe der Elemente zu groß für die Darstellung als eine <xref:System.Double>, Methodenrückgabe positiv oder minus unendlich.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Summe der Elemente zu groß für die Darstellung als eine <xref:System.Double>, Methodenrückgabe positiv oder minus unendlich.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> einen Durchschnittswert berechnet.  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" /> Werte für die Berechnung des Mittelwerts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" /> Werte.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Quelle.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> einen Durchschnittswert berechnet.  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, die Berechnung des Mittelwerts.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Average()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> einen Durchschnittswert berechnet.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, der die Elemente eines umgewandelt <c>Quelle</c> an.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.IEnumerable" /> , enthält die Elemente, die in den Typ umgewandelt werden <c>TResult</c>.</param>
        <summary>Wandelt die Elemente einer <see cref="T:System.Collections.IEnumerable" /> in den angegebenen Typ.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , enthält jedes Element der Quellsequenz in den angegebenen Typ umgewandelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> Methode ermöglicht die Standardabfrageoperatoren, die für nicht generische Auflistungen aufgerufen werden soll, indem Sie die erforderlichen Informationen angeben. Z. B. <xref:System.Collections.ArrayList> implementiert nicht <xref:System.Collections.Generic.IEnumerable%601>, aber durch Aufrufen von <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> auf die <xref:System.Collections.ArrayList> -Objekt Standardabfrageoperatoren können dann die Sequenz verwendet werden.  
  
 Wenn ein Element umgewandelt werden kann, um geben `TResult`, diese Methode löst eine Ausnahme. Um nur die Elemente abzurufen, die in den Typ umgewandelt werden können `TResult`, verwenden Sie die <xref:System.Linq.Enumerable.OfType%2A> Methode anstelle von <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 In einem Abfrageausdruck übersetzt eine explizit typisierte Iterationsvariable in einen Aufruf von <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>. Dieses Beispiel zeigt die Syntax für eine explizit typisierte Bereichsvariable.  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> So aktivieren Sie die Verwendung von Standardabfrageoperatoren auf eine <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Ein Element in der Sequenz kann nicht Typ umgewandelt werden <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Die erste zu verkettende Sequenz.</param>
        <param name="second">Die Sequenz, die mit der ersten Sequenz verkettet werden soll.</param>
        <summary>Verkettet zwei Sequenzen.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die die verketteten Elemente der zwei Eingabesequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode unterscheidet sich von der <xref:System.Linq.Enumerable.Union%2A> Methode da die <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methodenrückgabe die ursprünglichen Elemente der Eingabesequenzen. Die <xref:System.Linq.Enumerable.Union%2A> Methodenrückgabe nur eindeutige Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> um zwei Sequenzen zu verketten.  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 Eine alternative Möglichkeit zum Verketten zweier Sequenzen wird zum Erstellen einer Auflistung, z. B. ein Array von Sequenzen an, und wenden Sie dann die <xref:System.Linq.Enumerable.SelectMany%2A> -Methode, und übergeben sie die Identity-Selektor-Funktion. Das folgende Beispiel zeigt diese Verwendung von <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <summary>Bestimmt, ob eine Sequenz ein angegebenes Element enthält, mithilfe des Standardgleichheitsvergleichs.</summary>
        <returns>
          <see langword="true" />Wenn die Quellsequenz ein Element, die den angegebenen Wert verfügt enthält; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Collections.Generic.ICollection%601>die `Contains` -Methode in dieser Implementierung wird aufgerufen, um das Resultset zu erzielen. Andernfalls wird diese Methode bestimmt, ob `source` das angegebene Element enthält.  
  
 Die Enumeration wird beendet, sobald ein übereinstimmendes Element gefunden wird.  
  
 Elemente werden auf den angegebenen Wert mithilfe des Standardgleichheitsvergleichs verglichen <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> bestimmt, ob ein Array ein bestimmtes Element enthält.  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <param name="comparer">Ein Gleichheitsvergleich zum Vergleichen von Werten.</param>
        <summary>Bestimmt, ob eine Sequenz ein angegebenes Element enthält, mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see langword="true" />Wenn die Quellsequenz ein Element, die den angegebenen Wert verfügt enthält; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Enumeration wird beendet, sobald ein übereinstimmendes Element gefunden wird.  
  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird zum Vergleichen von Elementen mit dem angegebenen Wert verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Gleichheitsvergleich implementieren, die verwendet werden können die <xref:System.Linq.Enumerable.Contains%2A> Methode.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie dieses Vergleichs implementiert haben, können Sie eine Sequenz von `Product` Objekte in der <xref:System.Linq.Enumerable.Contains%2A> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <summary>Gibt die Anzahl der Elemente in einer Sequenz zurück.</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Collections.Generic.ICollection%601>, diese Implementierung verwendet, um die Anzahl von Elementen abzurufen. Andernfalls wird diese Methode bestimmt die Anzahl.  
  
 Verwenden der <xref:System.Linq.Enumerable.LongCount%2A> Methode, wenn Sie erwarten, und das Ergebnis größer als zulässig sein soll <xref:System.Int32.MaxValue>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Count()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum zählen der Elemente in einem Array.  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente im <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz Elemente enthält, getestet und gezählt werden.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine Zahl, die darstellt, wie viele Elemente in der angegebenen Sequenz eine Bedingung erfüllen.</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Collections.Generic.ICollection%601>, diese Implementierung verwendet, um die Anzahl von Elementen abzurufen. Andernfalls wird diese Methode bestimmt die Anzahl.  
  
 Verwenden Sie die <xref:System.Linq.Enumerable.LongCount%2A> Methode, wenn Sie erwarten, und das Ergebnis größer als zulässig sein soll <xref:System.Int32.MaxValue>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Count()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> , die Elemente in einem Array zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente im <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, für die ein Standardwert zurückgegeben werden soll, wenn sie leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz, oder Standardwert des Typparameters in einer singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> -Objekt, das den Standardwert für die <paramref name="TSource" /> geben, wenn <paramref name="source" /> leer ist; andernfalls, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
 Diese Methode kann verwendet werden, um einen linken äußeren Join zu erzeugen, zusammen mit den <xref:System.Linq.Enumerable.GroupJoin%2A>) Methode.  
  
   
  
## Examples  
 Die folgenden Codebeispiele veranschaulichen <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> um einen Standardwert anzugeben, für den Fall, dass die Quellsequenz leer ist.  
  
 Dieses Beispiel verwendet eine nicht leere Sequenz.  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 In diesem Beispiel wird eine leere Sequenz verwendet.  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, für die der angegebene Wert zurückgegeben werden soll, wenn sie leer ist.</param>
        <param name="defaultValue">Der Wert, der zurückgegeben werden soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz oder den angegebenen Wert in einer singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> enthält <paramref name="defaultValue" /> Wenn <paramref name="source" /> leer ist; andernfalls, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Diese Methode kann verwendet werden, um einen linken äußeren Join zu erzeugen, zusammen mit den <xref:System.Linq.Enumerable.GroupJoin%2A>) Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode und einen Standardwert angeben. Die erste Sequenz nicht leer ist, und die zweite Sequenz leer ist.  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ergebnissequenz ist nicht sortiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten zurück.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die unterschiedliche Elemente aus der Quellsequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methodenrückgabe eine ungeordnete Sequenz, die keine doppelten Werte enthält. Er verwendet den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, um Werte zu vergleichen.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Distinct` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Distinct%2A>.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um die Werte der Typen verglichen, die Implementierung der <xref:System.IEquatable%601> generische Schnittstelle. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren, und geben Sie eigene <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den Typ.  
  
 Ein Beispiel, verwendet <xref:System.Collections.Generic.IEqualityComparer%601> zum Definieren eines benutzerdefinierten Vergleichs finden Sie unter <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> unterschiedliche Elemente aus einer Sequenz von ganzen Zahlen zurückgegeben.  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 Wenn Sie unterschiedliche Elemente aus einer Sequenz von Objekten eines benutzerdefinierten Datentyps zurückgeben möchten, müssen Sie implementieren die <xref:System.IEquatable%601> generische Schnittstelle in der Klasse. Im folgenden Codebeispiel wird veranschaulicht, wie zum Implementieren dieser Schnittstelle in einem benutzerdefinierten Datentyp aus, und geben Sie <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie eine Sequenz von `Product` Objekte in der <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die unterschiedliche Elemente aus der Quellsequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methodenrückgabe eine ungeordnete Sequenz, die keine doppelten Werte enthält. Wenn c`omparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte zu vergleichen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Gleichheitsvergleich implementieren, die verwendet werden können die <xref:System.Linq.Enumerable.Distinct%2A> Methode.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie dieses Vergleichs implementiert haben, können Sie eine Sequenz von `Product` Objekte in der <xref:System.Linq.Enumerable.Distinct%2A> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf ein Element zurückgegeben.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element am angegebenen Index in einer Sequenz zurück.</summary>
        <returns>Das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Collections.Generic.IList%601>, diese Implementierung wird verwendet, um das Element am angegebenen Index abzurufen. Andernfalls ruft diese Methode das angegebene Element ab.  
  
 Diese Methode löst eine Ausnahme aus, wenn `index` liegt außerhalb des gültigen Bereichs. Um stattdessen einen Standardwert zurückgeben, wenn der angegebene Index außerhalb des gültigen Bereichs ist, verwenden die <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ElementAt%2A> auf ein Element an einer bestimmten Position zurück.  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 oder größer als oder gleich der Anzahl der Elemente im <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf ein Element zurückgegeben.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer Sequenz oder einen Standardwert zurück, wenn der Index außerhalb des gültigen Bereichs liegt.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />), wenn der Index außerhalb der Begrenzungen der Quellsequenz liegt, andernfalls das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ des `source` implementiert <xref:System.Collections.Generic.IList%601>, diese Implementierung wird verwendet, um das Element am angegebenen Index abzurufen. Andernfalls ruft diese Methode das angegebene Element ab.  
  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung von <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>. Dieses Beispiel verwendet einen Index, der außerhalb der Grenzen des Arrays ist.  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Der Typ, der an den Typparameter der zurückgegebenen generischen zugewiesen <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
        <summary>Gibt ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die das angegebenen Typargument ist.</summary>
        <returns>Ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Typargument <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Empty%60%601> Methode speichert eine leere Sequenz vom Typ `TResult`. Wenn das zurückgegebene Objekt aufgezählt wird, führt er keine Elemente.  
  
 In einigen Fällen diese Methode eignet sich für einer leeren Sequenz an eine benutzerdefinierte Methode übergeben, akzeptiert eine <xref:System.Collections.Generic.IEnumerable%601>. Kann auch ein neutrales Element für Methoden generieren, wie z. B. verwendet werden <xref:System.Linq.Enumerable.Union%2A>. Finden Sie im Beispielabschnitt für ein Beispiel für diese Verwendung von <xref:System.Linq.Enumerable.Empty%60%601>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Empty%60%601> zum Generieren eines leeren <xref:System.Collections.Generic.IEnumerable%601>.  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 Das folgende Codebeispiel veranschaulicht eine mögliche Anwendung der der <xref:System.Linq.Enumerable.Empty%60%601> Methode. Die <xref:System.Linq.Enumerable.Aggregate%2A> Methode auf eine Auflistung von Zeichenfolgenarrays angewendet wird. Die Elemente der einzelnen Arrays in der Auflistung werden hinzugefügt, auf das resultierende <xref:System.Collections.Generic.IEnumerable%601> nur, wenn das Array mit vier oder mehr Elemente enthält. <xref:System.Linq.Enumerable.Empty%2A>wird verwendet, um den Startwert für generieren <xref:System.Linq.Enumerable.Aggregate%2A> da Wenn kein Array in der Auflistung vier oder mehr Elemente enthält, die nur die leere Sequenz zurückgegeben wird.  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, die auch in der ersten Sequenz auftreten, führt dazu, dass diese Elemente aus der zurückgegebenen Sequenz entfernt werden soll.</param>
        <summary>Erzeugt die Differenzmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die Differenzmenge zweier Mengen ist definiert als die Elemente der ersten Menge, die in der zweiten Menge nicht angezeigt werden.  
  
> [!NOTE]
>  Diese Methode gibt die Elemente in `first` , die erscheinen nicht im `second`. Es ist auch nicht zurückgeben dieser Elemente im `second` , die erscheinen nicht im `first`.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um die Werte der Typen verglichen, die Implementierung der <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren, und geben Sie eigene <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den Typ.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode zum Vergleichen von zwei Sequenzen von Zahlen und Elemente zurückgegeben, die nur in der ersten Sequenz angezeigt werden.  
  
 [!code-csharp[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 Wenn Sie die Sequenzen von Objekten eines benutzerdefinierten Datentyps vergleichen möchten, müssen Sie implementieren die <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle in einem Helperclass. Im folgenden Codebeispiel wird veranschaulicht, wie zum Implementieren dieser Schnittstelle in einem benutzerdefinierten Datentyp aus, und geben Sie <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekte in der <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente, die auch in der ersten Sequenz auftreten, führt dazu, dass diese Elemente aus der zurückgegebenen Sequenz entfernt werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt die Differenzmenge von zwei Sequenzen unter Verwendung des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn c`omparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte zu vergleichen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Gleichheitsvergleich implementieren, die verwendet werden können die <xref:System.Linq.Enumerable.Except%2A> Methode.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie dieses Vergleichs implementiert haben, können Sie Sequenzen von `Product` Objekte in der <xref:System.Linq.Enumerable.Except%2A> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> um das erste Element der zurückzugeben.</param>
        <summary>Gibt das erste Element einer Sequenz zurück.</summary>
        <returns>Das erste Element in der angegebenen Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode löst eine Ausnahme aus, wenn `source` enthält keine Elemente. Um stattdessen einen Standardwert zurückgeben, wenn die Quellsequenz leer ist, verwenden die <xref:System.Linq.Enumerable.FirstOrDefault%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf das erste Element eines Arrays zurück.  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element in einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das erste Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Methode löst eine Ausnahme aus, wenn kein übereinstimmendes Element, in gefunden wird `source`. Um stattdessen einen Standardwert zurück, wenn kein übereinstimmendes Element gefunden wird, verwenden die <xref:System.Linq.Enumerable.FirstOrDefault%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> auf das erste Element eines Arrays zurück, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> um das erste Element der zurückzugeben.</param>
        <summary>Gibt das erste Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist, andernfalls das erste Element im <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
 Die <xref:System.Linq.Enumerable.FirstOrDefault%2A> Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen Standardwert außer angeben möchten `default(TSource)`, verwenden Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode wie im Beispielabschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf ein leeres Array.  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 In einigen Fällen den Wert des `default(TSource)` ist nicht der Standardwert, die Sie verwenden, wenn die Auflistung keine Elemente enthält. Statt überprüft das Ergebnis für das unbeabsichtigten Standardwert, und ändern diese bei Bedarf, können Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode, um den Standardwert angeben, die Sie verwenden, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf das erste Element abzurufen. Im folgenden Codebeispiel werden beide Verfahren verwendet, um einen Standardwert von 1 zu erhalten, wenn eine Auflistung von numerischen Monate leer ist. Da der Standardwert für eine ganze Zahl 0 (null) das keine Monat entspricht ist, muss der Standardwert stattdessen mit 1 angegeben. Nach Ausführung die Abfrage beendet wurde, wird das erste Ergebnisvariable für das unbeabsichtigten Standardwert überprüft. Die zweite Ergebnisvariable wird mithilfe von <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> an den Standardwert 1.  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element der Sequenz zurück, das eine Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Wenn <paramref name="source" /> leer ist oder wenn kein Element vom angegebenen Test besteht <paramref name="predicate" />ist, andernfalls das erste Element im <paramref name="source" /> , die vom angegebene übergibt <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> durch die Übergabe in einem Prädikat. Im zweiten Aufruf der Methode ist gibt es kein Element im Array, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> in c# oder <c>IEnumerable (Of IGrouping (Of TKey, TSource))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , in denen Jede <see cref="T:System.Linq.IGrouping`2" /> Objekt enthält eine Sequenz von Objekten und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
> [!NOTE]
>  Beispiele für `GroupBy`, finden Sie unter den folgenden Themen.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> -Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602> Objekten, eines für jedes distinct-Schlüssel, der aufgetreten ist. Ein <xref:System.Linq.IGrouping%602> ist eine <xref:System.Collections.Generic.IEnumerable%601> , die verfügt auch über einen Schlüssel, der seine Elemente zugeordnet.  
  
 Die <xref:System.Linq.IGrouping%602> Objekte werden in einer Reihenfolge entsprechend der Reihenfolge der Elemente im ergab `source` , die den ersten Schlüssel für jede erstellte <xref:System.Linq.IGrouping%602>. Elemente in einer Gruppierung werden in der Reihenfolge zurückgegeben, dass `source`.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 In der Abfrageausdruckssyntax ein `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>. Weitere Informationen und Verwendungsbeispiele finden Sie unter [Gruppenklausel](~/docs/csharp/language-reference/keywords/group-clause.md) und [Group By-Klausel](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und vergleicht die Schlüssel mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> in c# oder <c>IEnumerable (Of IGrouping (Of TKey, TSource))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , in denen Jede <see cref="T:System.Linq.IGrouping`2" /> Objekt enthält eine Auflistung von Objekten und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
> [!NOTE]
>  Beispiele für `GroupBy`, finden Sie unter den folgenden Themen.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> -Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602> Objekten, eines für jedes distinct-Schlüssel, der aufgetreten ist. Ein <xref:System.Linq.IGrouping%602> ist eine <xref:System.Collections.Generic.IEnumerable%601> , die verfügt auch über einen Schlüssel, der seine Elemente zugeordnet.  
  
 Die <xref:System.Linq.IGrouping%602> Objekte werden in einer Reihenfolge entsprechend der Reihenfolge der Elemente im ergab `source` , die den ersten Schlüssel für jede erstellte <xref:System.Linq.IGrouping%602>. Elemente in einer Gruppierung werden in der Reihenfolge zurückgegeben, dass `source`.  
  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 Wenn zwei Schlüssel gleich gemäß ausmachen `comparer`, der erste Schlüssel wird als Schlüssel für die Gruppierung ausgewählt.  
  
 In der Abfrageausdruckssyntax ein `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>. Weitere Informationen und Verwendungsbeispiele finden Sie unter [Gruppenklausel](~/docs/csharp/language-reference/keywords/group-clause.md) und [Group By-Klausel](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente im <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion auf jedes Quellelement zugeordnet, auf ein Element in der <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und projiziert die Elemente für jede Gruppe mithilfe einer angegebenen Funktion.</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> in c# oder <c>IEnumerable (Of IGrouping (Of TKey, TElement))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] wobei jedes <see cref="T:System.Linq.IGrouping`2" /> Objekt enthält eine Auflistung von Objekten des Typs <paramref name="TElement" /> und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> -Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602> Objekten, eines für jedes distinct-Schlüssel, der aufgetreten ist. Ein <xref:System.Linq.IGrouping%602> ist eine <xref:System.Collections.Generic.IEnumerable%601> , die verfügt auch über einen Schlüssel, der seine Elemente zugeordnet.  
  
 Die <xref:System.Linq.IGrouping%602> Objekte werden in einer Reihenfolge entsprechend der Reihenfolge der Elemente im ergab `source` , die den ersten Schlüssel für jede erstellte <xref:System.Linq.IGrouping%602>. Elemente in einer Gruppierung werden zurückgegeben, in der angegebenen Reihenfolge an, die Elemente, die sie erstellt `source`.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> zum Gruppieren der Elemente einer Sequenz.  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 In der Abfrageausdruckssyntax ein `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>. Die Übersetzung des Abfrageausdrucks im folgenden Beispiel wird die Abfrage im obigen Beispiel entspricht.  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  In einem [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfrageausdruck, der Element- und Ausdrücke für Schlüssel auftreten in umgekehrter Reihenfolge die Positionen ihrer Argumente in einem Aufruf der <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente im <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer Schlüsselauswahlfunktion. Die Schlüssel werden mithilfe eines Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> in c# oder <c>IEnumerable (Of IGrouping (Of TKey, TElement))</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] wobei jedes <see cref="T:System.Linq.IGrouping`2" /> Objekt enthält eine Auflistung von Objekten des Typs <paramref name="TElement" /> und einen Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
> [!NOTE]
>  Beispiele für `GroupBy`, finden Sie unter den folgenden Themen.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> -Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602> Objekten, eines für jedes distinct-Schlüssel, der aufgetreten ist. Ein <xref:System.Linq.IGrouping%602> ist eine <xref:System.Collections.Generic.IEnumerable%601> , die verfügt auch über einen Schlüssel, der seine Elemente zugeordnet.  
  
 Die <xref:System.Linq.IGrouping%602> Objekte werden in einer Reihenfolge entsprechend der Reihenfolge der Elemente im ergab `source` , die den ersten Schlüssel für jede erstellte <xref:System.Linq.IGrouping%602>. Elemente in einer Gruppierung werden zurückgegeben, in der angegebenen Reihenfolge an, die Elemente, die sie erstellt `source`.  
  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 Wenn zwei Schlüssel gleich gemäß ausmachen `comparer`, der erste Schlüssel wird als Schlüssel für die Gruppierung ausgewählt.  
  
 In der Abfrageausdruckssyntax ein `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>. Weitere Informationen und Verwendungsbeispiele finden Sie unter [Gruppenklausel](~/docs/csharp/language-reference/keywords/group-clause.md) und [Group By-Klausel](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert.</summary>
        <returns>Eine Auflistung von Elementen des Typs <paramref name="TResult" /> , in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Abfrageausdruckssyntax ein `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29> zum Gruppieren der Elemente einer Sequenz und eine Sequenz von Ergebnissen vom Typ projizieren `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Eine Auflistung von Elementen des Typs <paramref name="TResult" /> , in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Auflistung von Elementen des Typs <paramref name="TResult" /> , in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Abfrageausdruckssyntax ein `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29> die projizierten Elemente einer Sequenz gruppieren und dann eine Sequenz von Ergebnissen vom Typ projizieren `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts zurückgegebenes <c>ResultSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren Elemente gruppiert.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüsselwerte werden mithilfe eines angegebenen Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Auflistung von Elementen des Typs <paramref name="TResult" /> , in dem jedes Element eine Projektion über eine Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die Elemente des Typs enthält <paramref name="TResult" /> , die durch Ausführen eines Group Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, zum Hashen und Vergleichen von Schlüsseln verwendet wird.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>erzeugt hierarchische Ergebnisse, dies bedeutet, dass Elemente aus `outer` mit Auflistungen von übereinstimmenden Elementen aus gekoppelt sind `inner`. `GroupJoin`ermöglicht es Ihnen, Ihre Ergebnisse als Grundlage für eine ganze Gruppe von Übereinstimmungen für jedes Element der `outer`.  
  
> [!NOTE]
>  Wenn es keine zugehörigen Elemente in sind `inner` für ein angegebenes Element der `outer`, die Abfolge der Übereinstimmungen für dieses Element leer, werden jedoch weiterhin in den Ergebnissen angezeigt wird.  
  
 Die `resultSelector` Funktion wird nur jeweils einmal für jeden `outer` -Element zusammen mit der eine Auflistung aller der `inner` die entsprechenden Elemente der `outer` Element. Dies unterscheidet sich von der <xref:System.Linq.Enumerable.Join%2A> Methode, in dem die Ergebnisauswahlfunktion aufgerufen wird, auf-Paaren, die ein Element aus enthalten `outer` und ein Element aus `inner`.  
  
 `GroupJoin`behält die Reihenfolge der Elemente des `outer`, und für jedes Element der `outer`, die Reihenfolge der übereinstimmenden Elemente aus `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>verfügt über keine direkte Entsprechung herkömmliche relationale Datenbanken bedeutet. Diese Methode implementiert jedoch eine übergeordnete Menge innerer und linker äußerer Verknüpfungen. Beide dieser Vorgänge können im Hinblick auf eines Group Joins geschrieben werden. Finden Sie unter [Joinvorgängen](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 In der Abfrageausdruckssyntax ein `join … into` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Group Join` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.GroupJoin%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29> zum Ausführen eines Group Joins von zwei Sequenzen.  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die Elemente des Typs enthält <paramref name="TResult" /> , die durch Ausführen eines Group Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Wenn c`omparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, zum Hashen und Vergleichen von Schlüsseln verwendet wird.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>erzeugt hierarchische Ergebnisse, dies bedeutet, dass Elemente aus `outer` mit Auflistungen von übereinstimmenden Elementen aus gekoppelt sind `inner`. `GroupJoin`ermöglicht es Ihnen, Ihre Ergebnisse als Grundlage für eine ganze Gruppe von Übereinstimmungen für jedes Element der `outer`.  
  
> [!NOTE]
>  Wenn es keine zugehörigen Elemente in sind `inner` für ein angegebenes Element der `outer`, die Abfolge der Übereinstimmungen für dieses Element leer, werden jedoch weiterhin in den Ergebnissen angezeigt wird.  
  
 Die `resultSelector` Funktion wird nur jeweils einmal für jeden `outer` -Element zusammen mit der eine Auflistung aller der `inner` die entsprechenden Elemente der `outer` Element. Dies unterscheidet sich von der <xref:System.Linq.Enumerable.Join%2A> Methode in der die Ergebnisauswahlfunktion aufgerufen wird, auf-Paaren, die ein Element aus enthalten `outer` und ein Element aus `inner`.  
  
 `GroupJoin`behält die Reihenfolge der Elemente des `outer`, und für jedes Element der `outer`, die Reihenfolge der übereinstimmenden Elemente aus `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>verfügt über keine direkte Entsprechung herkömmliche relationale Datenbanken bedeutet. Diese Methode implementiert jedoch eine übergeordnete Menge innerer und linker äußerer Verknüpfungen. Beide dieser Vorgänge können im Hinblick auf eines Group Joins geschrieben werden. Finden Sie unter [Joinvorgängen](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente, die auch in der ersten Sequenz zurückgegeben.</param>
        <summary>Erzeugt die Schnittmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die Schnittmenge zweier Mengen A und B ist als die Gruppe definiert, die alle Elemente von A, die auch in B vorhanden, aber keine anderen Elemente enthält.  
  
 Wenn das Objekt, das von dieser Methode zurückgegebene aufgelistet, <xref:System.Linq.Enumerable.Intersect%2A> ergibt unterschiedliche Elemente, die in beiden Sequenzen in der Reihenfolge, in Reihenfolge, auftreten `first`.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um die Werte der Typen verglichen, die Implementierung der <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren, und geben Sie eigene <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den Typ.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> die Elemente, die angezeigt werden in beiden Sequenzen von ganzen Zahlen zurückgegeben.  
  
 [!code-csharp[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 Wenn Sie die Sequenzen von Objekten mit einem benutzerdefinierten Datentyp vergleichen möchten, müssen Sie implementieren die <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle in einer Hilfsklasse. Im folgenden Codebeispiel wird veranschaulicht, wie zum Implementieren dieser Schnittstelle in einem benutzerdefinierten Datentyp aus, und geben Sie <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekte in der <xref:System.Linq.Enumerable.Intersect%2A> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente, die auch in <c>zweite</c> zurückgegeben werden.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente, die auch in der ersten Sequenz zurückgegeben.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt die Schnittmenge von zwei Sequenzen unter Verwendung des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die Schnittmenge zweier Mengen A und B ist als die Gruppe definiert, die alle Elemente von A, die auch in B vorhanden, aber keine anderen Elemente enthält.  
  
 Wenn das Objekt, das von dieser Methode zurückgegebene aufgelistet, <xref:System.Linq.Enumerable.Intersect%2A> ergibt unterschiedliche Elemente, die in beiden Sequenzen in der Reihenfolge, in Reihenfolge, auftreten `first`.  
  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte zu vergleichen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Gleichheitsvergleich implementieren, die verwendet werden können die <xref:System.Linq.Enumerable.Intersect%2A> Methode.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie dieses Vergleichs implementiert haben, können Sie Sequenzen von `Product` Objekte in der <xref:System.Linq.Enumerable.Intersect%2A> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf übereinstimmenden Schlüsseln. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die Elemente des Typs hat <paramref name="TResult" /> , die durch Ausführen eines inner Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, zum Hashen und Vergleichen von Schlüsseln verwendet wird.  
  
 Ein Join bezieht sich auf den Vorgang, der die Elemente von zwei Quellen mit Informationen, die auf Grundlage eines gemeinsamen Schlüssels korreliert. <xref:System.Linq.Enumerable.Join%2A>Schaltet die beiden Informationsquellen und die Schlüssel, mit denen sie zusammen in einem Methodenaufruf abgeglichen werden. Dies unterscheidet sich von der Verwendung von `SelectMany`, wofür die mehr als ein Methodenaufruf an den gleichen Vorgang auszuführen.  
  
 <xref:System.Linq.Enumerable.Join%2A>behält die Reihenfolge der Elemente des `outer`, und für jedes dieser Elemente, die Reihenfolge der übereinstimmenden Elemente von `inner`.  
  
 In der Abfrageausdruckssyntax ein `join` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Join` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Join%2A>.  
  
 Bei relationalen Datenbanken die <xref:System.Linq.Enumerable.Join%2A> Methode implementiert einen inneren Equi-Join. "Innere" bedeutet, dass nur Elemente, die eine Übereinstimmung in die andere Sequenz in den Ergebnissen enthalten sind. ' Equi-Join "ist eine Verknüpfung in die die Schlüssel auf Gleichheit verglichen werden. Ein linker äußerer Join-Vorgang hat keine dedizierte Standardabfrageoperator, kann aber mit ausgeführt werden die <xref:System.Linq.Enumerable.GroupJoin%2A> Methode. Finden Sie unter [Joinvorgängen](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29> eine innere Verknüpfung zweier Sequenzen basierend auf einem gemeinsamen Schlüssel ausführen.  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente zweier Sequenzen basierend auf übereinstimmenden Schlüsseln. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die Elemente des Typs hat <paramref name="TResult" /> , die durch Ausführen eines inner Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Wenn c`omparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, zum Hashen und Vergleichen von Schlüsseln verwendet wird.  
  
 Ein Join bezieht sich auf den Vorgang, der die Elemente von zwei Quellen mit Informationen, die auf Grundlage eines gemeinsamen Schlüssels korreliert. <xref:System.Linq.Enumerable.Join%2A>Schaltet die beiden Informationsquellen und die Schlüssel, mit denen sie zusammen in einem Methodenaufruf abgeglichen werden. Dies unterscheidet sich von der Verwendung von `SelectMany`, wofür die mehr als ein Methodenaufruf an den gleichen Vorgang auszuführen.  
  
 <xref:System.Linq.Enumerable.Join%2A>behält die Reihenfolge der Elemente des `outer`, und für jedes dieser Elemente, die Reihenfolge der übereinstimmenden Elemente von `inner`.  
  
 Bei relationalen Datenbanken die <xref:System.Linq.Enumerable.Join%2A> Methode implementiert einen inneren Equi-Join. "Innere" bedeutet, dass nur Elemente, die eine Übereinstimmung in die andere Sequenz in den Ergebnissen enthalten sind. ' Equi-Join "ist eine Verknüpfung in die die Schlüssel auf Gleichheit verglichen werden. Ein linker äußerer Join-Vorgang hat keine dedizierte Standardabfrageoperator, kann aber mit ausgeführt werden die <xref:System.Linq.Enumerable.GroupJoin%2A> Methode. Finden Sie unter [Joinvorgängen](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" />oder <paramref name="inner" /> oder <paramref name="outerKeySelector" /> oder <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> das letzte Element zurückgegeben.</param>
        <summary>Gibt das letzte Element einer Sequenz zurück.</summary>
        <returns>Der Wert an der letzten Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode löst eine Ausnahme aus, wenn `source` enthält keine Elemente. Um stattdessen einen Standardwert zurückgeben, wenn die Quellsequenz leer ist, verwenden die <xref:System.Linq.Enumerable.LastOrDefault%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf das letzte Element eines Arrays zurück.  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das letzte Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Methode löst eine Ausnahme aus, wenn kein übereinstimmendes Element, in gefunden wird `source`. Um stattdessen einen Standardwert zurück, wenn kein übereinstimmendes Element gefunden wird, verwenden die <xref:System.Linq.Enumerable.LastOrDefault%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> auf das letzte Element eines Arrays zurück, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> das letzte Element zurückgegeben.</param>
        <summary>Gibt das letzte Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Wenn die Quellsequenz leer ist, andernfalls das letzte Element in der <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
 Die <xref:System.Linq.Enumerable.LastOrDefault%2A> Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen Standardwert außer angeben möchten `default(TSource)`, verwenden Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode wie im Beispielabschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf ein leeres Array.  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 In einigen Fällen den Wert des `default(TSource)` ist nicht der Standardwert, die Sie verwenden, wenn die Auflistung keine Elemente enthält. Statt überprüft das Ergebnis für das unbeabsichtigten Standardwert, und ändern diese bei Bedarf, können Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode, um den Standardwert angeben, die Sie verwenden, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf das letzte Element abzurufen. Im folgenden Codebeispiel werden beide Verfahren verwendet, um einen Standardwert von 1 zu erhalten, wenn eine Auflistung von numerischen Tage des Monats leer ist. Da der Standardwert für eine ganze Zahl 0 (null) das nicht zu einem beliebigen Tag des Monats entspricht ist, muss der Standardwert stattdessen mit 1 angegeben. Nach Ausführung die Abfrage beendet wurde, wird das erste Ergebnisvariable für das unbeabsichtigten Standardwert überprüft. Die zweite Ergebnisvariable wird mithilfe von <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> an den Standardwert 1.  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> auf ein Element zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz, das eine Bedingung erfüllt, oder einen Standardwert zurück, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) Wenn die Sequenz leer ist oder wenn keine Elemente in der Prädikatfunktion; den Test erfolgreich, andernfalls das letzte Element, das der Test in der Prädikatfunktion erfolgreich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> durch die Übergabe in einem Prädikat. Im zweiten Aufruf der Methode ist gibt es kein Element in der Sequenz, die die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die die zu zählende Elemente enthält.</param>
        <summary>Gibt eine <see cref="T:System.Int64" /> , die die Gesamtanzahl von Elementen in einer Sequenz darstellt.</summary>
        <returns>Die Anzahl der Elemente in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode statt <xref:System.Linq.Enumerable.Count%2A> Wenn Sie erwarten, dass das Ergebnis größer als <xref:System.Int32.MaxValue>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into LongCount()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum zählen der Elemente in einem Array.  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine <see cref="T:System.Int64" /> , die darstellt, wie viele Elemente in einer Sequenz eine Bedingung erfüllen.</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode statt <xref:System.Linq.Enumerable.Count%2A> Wenn Sie erwarten, dass das Ergebnis größer als <xref:System.Int32.MaxValue>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into LongCount()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> , die Elemente in einem Array zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der übereinstimmenden Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von <see cref="T:System.Double" /> Werte.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Decimal&gt; </c> in c# oder <c>Nullable (Of Decimal)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;doppelte&gt; </c> in c# oder <c>Nullable (Of Double)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int32&gt; </c> in c# oder <c>Nullable (Of Int32)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int64&gt; </c> in c# oder <c>Nullable (Of Int64)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;einzelne&gt; </c> in c# oder <c>Nullable (Of Single)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" /> Werte für den Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den größten Wert in einer Sequenz von <see cref="T:System.Single" /> Werte.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> auf den Höchstwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Maximalwert in einer generischen Sequenz zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Typ `TSource` implementiert <xref:System.IComparable%601>die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode, dass diese Implementierung verwendet, um Werte zu vergleichen. Andernfalls gilt: Wenn Typ `TSource` implementiert <xref:System.IComparable>, diese Implementierung wird verwendet, um Werte zu vergleichen.  
  
 Wenn `TSource` einen Referenztyp darstellt und die Quellsequenz ist leer oder enthält nur die Werte, die `null`, gibt diese Methode `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum Bestimmen des maximalen Werts in einer Sequenz von <xref:System.IComparable%601> Objekte.  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt die maximale <see cref="T:System.Decimal" /> Wert.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Decimal>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt die maximale <see cref="T:System.Double" /> Wert.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Double>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt die maximale <see cref="T:System.Int32" /> Wert.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Int32>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt die maximale <see cref="T:System.Int64" /> Wert.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Int64>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt die maximale nullable <see cref="T:System.Decimal" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Decimal&gt; </c> in c# oder <c>Nullable (Of Decimal)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Decimal>` in c# oder `Nullable(Of Decimal)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt die maximale nullable <see cref="T:System.Double" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;doppelte&gt; </c> in c# oder <c>Nullable (Of Double)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Double>` in c# oder `Nullable(Of Double)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt die maximale nullable <see cref="T:System.Int32" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Int32&gt; </c> in c# oder <c>Nullable (Of Int32)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Int32>` in c# oder `Nullable(Of Int32)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt die maximale nullable <see cref="T:System.Int64" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Int64&gt; </c> in c# oder <c>Nullable (Of Int64)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Int64>` in c# oder `Nullable(Of Int64)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt die maximale nullable <see cref="T:System.Single" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;einzelne&gt; </c> in c# oder <c>Nullable (Of Single)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , entspricht dem maximalen Wert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Single>` in c# oder `Nullable(Of Single)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt die maximale <see cref="T:System.Single" /> Wert.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Single>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des vom zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer generischen Sequenz und gibt den resultierenden Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Typ `TResult` implementiert <xref:System.IComparable%601>, diese Methode, dass diese Implementierung verwendet, um Werte zu vergleichen. Andernfalls gilt: Wenn Typ `TResult` implementiert <xref:System.IComparable>, diese Implementierung wird verwendet, um Werte zu vergleichen.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Max()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Höchstwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von <see cref="T:System.Double" /> Werte.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Decimal&gt; </c> in c# oder <c>Nullable (Of Decimal)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;doppelte&gt; </c> in c# oder <c>Nullable (Of Double)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int32&gt; </c> in c# oder <c>Nullable (Of Int32)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int64&gt; </c> in c# oder <c>Nullable (Of Int64)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte.</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;einzelne&gt; </c> in c# oder <c>Nullable (Of Single)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Wenn die Quellsequenz leer ist oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" /> Werte auf den Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer Sequenz von <see cref="T:System.Single" /> Werte.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> auf den Mindestwert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den kleinsten Wert in einer generischen Sequenz zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Typ `TSource` implementiert <xref:System.IComparable%601>, diese Methode, dass diese Implementierung verwendet, um Werte zu vergleichen. Andernfalls gilt: Wenn Typ `TSource` implementiert <xref:System.IComparable>, diese Implementierung wird verwendet, um Werte zu vergleichen.  
  
 Wenn `TSource` einen Referenztyp darstellt und die Quellsequenz ist leer oder enthält nur die Werte, die `null`, gibt diese Funktion `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum Bestimmen des minimalen Werts in einer Sequenz von <xref:System.IComparable%601> Objekte.  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den kleinsten <see cref="T:System.Decimal" /> Wert.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Decimal>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den kleinsten <see cref="T:System.Double" /> Wert.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Double>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den kleinsten <see cref="T:System.Int32" /> Wert.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Int32>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den kleinsten <see cref="T:System.Int64" /> Wert.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Int64>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt den kleinsten NULL-Werte zu <see cref="T:System.Decimal" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Decimal&gt; </c> in c# oder <c>Nullable (Of Decimal)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> -Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Decimal>` in c# oder `Nullable(Of Decimal)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt den kleinsten NULL-Werte zu <see cref="T:System.Double" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;doppelte&gt; </c> in c# oder <c>Nullable (Of Double)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> -Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Double>` in c# oder `Nullable(Of Double)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt den kleinsten NULL-Werte zu <see cref="T:System.Int32" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Int32&gt; </c> in c# oder <c>Nullable (Of Int32)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> -Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`, die projiziert die Elemente der Quelle in einen numerischen Typ, insbesondere `Nullable<Int32>` in c# oder `Nullable(Of Int32)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt den kleinsten NULL-Werte zu <see cref="T:System.Int64" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Int64&gt; </c> in c# oder <c>Nullable (Of Int64)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> -Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Int64>` in c# oder `Nullable(Of Int64)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer Sequenz und gibt den kleinsten NULL-Werte zu <see cref="T:System.Single" /> Wert.</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;einzelne&gt; </c> in c# oder <c>Nullable (Of Single)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die auf den Mindestwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Single>` in c# oder `Nullable(Of Single)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den kleinsten <see cref="T:System.Single" /> Wert.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> -Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601> zum Vergleichen von Werten.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Single>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />keine Elemente enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des vom zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft eine Transformationsfunktion für jedes Element einer generischen Sequenz und gibt den resultierenden Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Typ `TResult` implementiert <xref:System.IComparable%601>, diese Methode, dass diese Implementierung verwendet, um Werte zu vergleichen. Andernfalls gilt: Wenn Typ `TResult` implementiert <xref:System.IComparable>, diese Implementierung wird verwendet, um Werte zu vergleichen.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Min()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> auf den Mindestwert in einer Sequenz von projizierten Werte zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, nach dem die Elemente der Sequenz gefiltert werden sollen.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.IEnumerable" /> , deren Elemente gefiltert.</param>
        <summary>Filtert die Elemente einer <see cref="T:System.Collections.IEnumerable" /> anhand eines angegebenen Typs.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die Elemente aus der Eingabesequenz vom Typ enthält <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29> nur die Elemente in der Methodenrückgabe `source` in den Typ umgewandelt werden kann `TResult`. Stattdessen eine Ausnahme empfangen wird, wenn ein Element Typ umgewandelt werden kann `TResult`, verwenden Sie <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Diese Methode ist eine der wenigen Standardabfrageoperator-Methoden, die für eine Sammlung angewendet werden können, deren nicht parametrisierten Typ, z. B. ein <xref:System.Collections.ArrayList>. Grund hierfür ist, <xref:System.Linq.Enumerable.OfType%2A> erweitert den Typ <xref:System.Collections.IEnumerable>. <xref:System.Linq.Enumerable.OfType%2A>nicht nur auf Sammlungen basierend auf angewendet werden auf den parametrisierten <xref:System.Collections.Generic.IEnumerable%601> aufweisen, aber Sammlungen basierend auf den nicht parametrisierten <xref:System.Collections.IEnumerable> auch geben.  
  
 Durch Anwenden von <xref:System.Linq.Enumerable.OfType%2A> für eine Sammlung, die implementiert <xref:System.Collections.IEnumerable>, erhalten Sie die Möglichkeit, die die Auflistung mit den Standardabfrageoperatoren Abfragen. Z. B. ein Typargument angeben <xref:System.Object> auf <xref:System.Linq.Enumerable.OfType%2A> würde ein Objekt des Typs zurückgeben `IEnumerable<Object>` in c# oder `IEnumerable(Of Object)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], auf denen die Standardabfrageoperatoren angewendet werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.OfType%2A> zum Filtern der Elemente von einem <xref:System.Collections.IEnumerable>.  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 Zwei Methoden definiert werden, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, dies ist der Rückgabetyp dieser Methode. Diese zwei Methoden, nämlich `ThenBy` und `ThenByDescending`, können Sie zusätzliche Kriterien zum Sortieren einer Sequenz angeben. `ThenBy`und `ThenByDescending` auch Zurückgeben einer <xref:System.Linq.IOrderedEnumerable%601>, was bedeutet, dass eine beliebige Anzahl von aufeinander folgende Aufrufe von `ThenBy` oder `ThenByDescending` vorgenommen werden können.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Diese Methode vergleicht die Schlüssel mithilfe des Standardvergleichs <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
 In der Abfrageausdruckssyntax ein `orderby` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Order By` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.OrderBy%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> die Elemente einer Sequenz sortiert.  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 Zwei Methoden definiert werden, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, dies ist der Rückgabetyp dieser Methode. Diese zwei Methoden, nämlich `ThenBy` und `ThenByDescending`, können Sie zusätzliche Kriterien zum Sortieren einer Sequenz angeben. `ThenBy`und `ThenByDescending` auch Zurückgeben einer <xref:System.Linq.IOrderedEnumerable%601>, was bedeutet, dass eine beliebige Anzahl von aufeinander folgende Aufrufe von `ThenBy` oder `ThenByDescending` vorgenommen werden können.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 Ein Beispiel dieser Methode finden Sie unter <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>.  
  
 Zwei Methoden definiert werden, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, dies ist der Rückgabetyp dieser Methode. Diese zwei Methoden, nämlich `ThenBy` und `ThenByDescending`, können Sie zusätzliche Kriterien zum Sortieren einer Sequenz angeben. `ThenBy`und `ThenByDescending` auch Zurückgeben einer <xref:System.Linq.IOrderedEnumerable%601>, was bedeutet, dass eine beliebige Anzahl von aufeinander folgende Aufrufe von `ThenBy` oder `ThenByDescending` vorgenommen werden können.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Diese Methode vergleicht die Schlüssel mithilfe des Standardvergleichs <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
 In der Abfrageausdruckssyntax ein `orderby descending` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Order By Descending` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.OrderByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in absteigender Reihenfolge.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 Zwei Methoden definiert werden, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, dies ist der Rückgabetyp dieser Methode. Diese zwei Methoden, nämlich `ThenBy` und `ThenByDescending`, können Sie zusätzliche Kriterien zum Sortieren einer Sequenz angeben. `ThenBy`und `ThenByDescending` auch Zurückgeben einer <xref:System.Linq.IOrderedEnumerable%601>, was bedeutet, dass eine beliebige Anzahl von aufeinander folgende Aufrufe von `ThenBy` oder `ThenByDescending` vorgenommen werden können.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> zum Sortieren der Elemente einer Sequenz in absteigender Reihenfolge nach einer Transform-Funktion mit einem benutzerdefinierten Vergleich.  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Wertesequenz.</param>
        <param name="element">Der <paramref name="source" /> voranzustellende Wert.</param>
        <summary>Fügt einen Wert am Anfang der Sequenz ein.</summary>
        <returns>Eine neue Sequenz, die mit <paramref name="element" /> beginnt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>        
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Wert der ersten ganzen Zahl in der Sequenz.</param>
        <param name="count">Die Anzahl der aufeinander folgenden ganzen Zahlen, die generiert werden sollen.</param>
        <summary>Generiert eine Sequenz von ganzen Zahlen in einem angegebenen Bereich.</summary>
        <returns>Ein <c>IEnumerable&lt;Int32&gt; </c> in c# oder <c>IEnumerable (Of Int32)</c> in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] , die einen Bereich sequenzieller ganzer Zahlen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Range%2A> um eine Sequenz von Werten zu generieren.  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="start" /> + <paramref name="count" />-1 ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Werts, der in der Ergebnissequenz wiederholt werden soll.</typeparam>
        <param name="element">Der zu wiederholende Wert.</param>
        <param name="count">Die gewünschte Anzahl der Wiederholungen des Werts in der generierten Sequenz.</param>
        <summary>Generiert eine Sequenz, die einen wiederholten Wert enthält.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die einen wiederholten Wert enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Repeat%2A> um eine Sequenz von einen wiederholten Wert zu generieren.  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine umzukehrende Sequenz von Werten.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einer Sequenz.</summary>
        <returns>Eine Sequenz , deren Elemente den Elementen der Eingabesequenz in umgekehrter Reihenfolge entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Im Gegensatz zu <xref:System.Linq.Enumerable.OrderBy%2A>, gibt diese Methode Sortierung berücksichtigt nicht die tatsächlichen Werte selbst die Reihenfolge. Stattdessen gibt es nur die Elemente in umgekehrter Reihenfolge aus dem sie erstellt wurden von der zugrunde liegenden Datenquelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Reverse%2A> die Reihenfolge der Elemente in einem Array Reihenfolge umgekehrt werden soll.  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des vom zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Formular durch Einbinden der Index des Elements an.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der Transformationsfunktion für jedes Element der <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Das erste Argument für `selector` stellt das Element zu verarbeiten. Das zweite Argument `selector` den nullbasierten Index des Elements in der Quellsequenz darstellt. Dies kann nützlich sein, wenn die Elemente in einer bekannten Reihenfolge und Sie ein Element mit einem Element an einem bestimmten Index z. B. tun möchten. Es kann auch nützlich sein, wenn der Index von einem oder mehreren Elementen abgerufen werden sollen.  
  
 Bei dieser Projektionsmethode muss die Transformationsfunktion `selector`, um einen Wert für jeden Wert in der Quellsequenz erzeugen `source`. Wenn `selector` gibt einen Wert, der selbst eine Auflistung zurück, es liegt im Ermessen der Consumer die Untersequenzen manuell durchlaufen. In einem solchen Fall kann es besser für Ihre Abfrage zurückgeben eine einzelne zusammengeführte Sequenz von Werten sein. Um dies zu erreichen, verwenden die <xref:System.Linq.Enumerable.SelectMany%2A> Methode anstelle von <xref:System.Linq.Enumerable.Select%2A>. Obwohl `SelectMany` funktioniert ähnlich wie `Select`, es unterscheidet sich darin, dass die Transformationsfunktion eine Auflistung, die zurückgegeben von erweitert wird, `SelectMany` vor der Rückgabe.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29> projizieren auf eine Sequenz von Werten und der Index jedes Elements verwenden.  
  
 [!code-csharp[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ des vom zurückgegebenen Werts <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der Transformationsfunktion für jedes Element der <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Bei dieser Projektionsmethode muss die Transformationsfunktion `selector`, um einen Wert für jeden Wert in der Quellsequenz erzeugen `source`. Wenn `selector` gibt einen Wert, der selbst eine Auflistung zurück, es liegt im Ermessen der Consumer die Untersequenzen manuell durchlaufen. In einem solchen Fall kann es besser für Ihre Abfrage zurückgeben eine einzelne zusammengeführte Sequenz von Werten sein. Um dies zu erreichen, verwenden die <xref:System.Linq.Enumerable.SelectMany%2A> Methode anstelle von <xref:System.Linq.Enumerable.Select%2A>. Obwohl `SelectMany` funktioniert ähnlich wie `Select`, es unterscheidet sich darin, dass die Transformationsfunktion eine Auflistung, die zurückgegeben von erweitert wird, `SelectMany` vor der Rückgabe.  
  
 In der Abfrageausdruckssyntax ein `select` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Select` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Select%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> Projekt über eine Sequenz von Werten.  
  
 [!code-csharp[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Sequenz zurückgegebenes <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der 1: n-Transformationsfunktion für jedes Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> Methode zählt die Eingabesequenz, mithilfe einer Transformationsfunktion zum Zuordnen der einzelnen Elemente in einer <xref:System.Collections.Generic.IEnumerable%601>, und listet auf, und die Elemente jeder solcher ergibt <xref:System.Collections.Generic.IEnumerable%601> Objekt. D. h. für jedes Element der `source`, `selector` wird aufgerufen, und es wird eine Sequenz von Werten zurückgegeben. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>fasst dann diese zweidimensionale Auflistung von Auflistungen in einem eindimensionalen <xref:System.Collections.Generic.IEnumerable%601> und gibt ihn zurück. Wenn eine Abfrage verwendet beispielsweise <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> die Aufträge abgerufen (des Typs `Order`) für jeden Kunden in einer Datenbank, ist das Ergebnis vom Typ `IEnumerable<Order>` in c# oder `IEnumerable(Of Order)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Stattdessen verwendet die Abfrage <xref:System.Linq.Enumerable.Select%2A> um die Aufträge zu erhalten, wird die Auflistung von Auflistungen von Aufträgen nicht kombiniert und das Ergebnis ist vom Typ `IEnumerable<List<Order>>` in c# oder `IEnumerable(Of List(Of Order))` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Abfrageausdruckssyntax jede `from` -Klausel ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `From` -Klausel ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) nach der Erstkonfiguration übersetzt auf einen Aufruf von <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> eine 1: n-Projektion über einem Array ausgeführt.  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Sequenz zurückgegebenes <c>Selektor</c>.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, und fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen. Der Index jedes Quellelements wird im projizierten Format des jeweiligen Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der 1: n-Transformationsfunktion für jedes Element einer Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> Methode zählt die Eingabesequenz, mithilfe einer Transformationsfunktion zum Zuordnen der einzelnen Elemente in einer <xref:System.Collections.Generic.IEnumerable%601>, und listet auf, und die Elemente jeder solcher ergibt <xref:System.Collections.Generic.IEnumerable%601> Objekt. D. h. für jedes Element der `source`, `selector` wird aufgerufen, und es wird eine Sequenz von Werten zurückgegeben. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>fasst dann diese zweidimensionale Auflistung von Auflistungen in einem eindimensionalen <xref:System.Collections.Generic.IEnumerable%601> und gibt ihn zurück. Wenn eine Abfrage verwendet beispielsweise <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> die Aufträge abgerufen (des Typs `Order`) für jeden Kunden in einer Datenbank, ist das Ergebnis vom Typ `IEnumerable<Order>` in c# oder `IEnumerable(Of Order)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Stattdessen verwendet die Abfrage <xref:System.Linq.Enumerable.Select%2A> um die Aufträge zu erhalten, wird die Auflistung von Auflistungen von Aufträgen nicht kombiniert und das Ergebnis ist vom Typ `IEnumerable<List<Order>>` in c# oder `IEnumerable(Of List(Of Order))` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Das erste Argument für `selector` stellt das Element zu verarbeiten. Das zweite Argument `selector` den nullbasierten Index des Elements in der Quellsequenz darstellt. Dies kann nützlich sein, wenn die Elemente in einer bekannten Reihenfolge und Sie ein Element mit einem Element an einem bestimmten Index z. B. tun möchten. Es kann auch nützlich sein, wenn der Index von einem oder mehreren Elementen abgerufen werden sollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> eine 1: n-Projektion über ein Array ausführen und den Index jedes äußeren Elements verwenden.  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente erhobene <c>CollectionSelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformationsfunktion, die auf jedes Element der Eingabesequenz angewendet werden soll.</param>
        <param name="resultSelector">Eine Transformationsfunktion, die auf jedes Element der Sequenz intermediate angewendet.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der 1: n-Transformationsfunktion <paramref name="collectionSelector" /> für jedes Element der <paramref name="source" /> und anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden Quellelemente zu einem Ergebniselement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> Methode ist nützlich, wenn Sie keine behalten Sie die Elemente eines `source` innerhalb des Bereichs für Abfragelogik, die auftritt, nachdem der Aufruf von <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Ein Codebeispiel hierfür finden Sie im Beispielabschnitt. Liegt eine bidirektionale Beziehung zwischen Objekten des Typs `TSource` und Objekte des Typs `TCollection`, d. h. wenn ein Objekt des Typs `TCollection` enthält eine Eigenschaft zum Abrufen der `TSource` Objekt ab, die es erstellt wurde, Sie ist dies nicht erforderlich Überladen von <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Stattdessen können Sie <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> und navigieren Sie zurück zu den `TSource` -Objekt über die `TCollection` Objekt.  
  
 Abfrageausdruckssyntax jede `from` -Klausel ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `From` -Klausel ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) nach der Erstkonfiguration übersetzt auf einen Aufruf von <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> eine 1: n-Projektion über ein Array ausführen und verwenden eine Ergebnisauswahlfunktion entsprechenden Elemente der Quellsequenz im Bereich für den letzten Aufruf von beibehalten `Select`.  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente erhobene <c>CollectionSelector</c>.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Transformationsfunktion, die auf jedes Element der Sequenz intermediate angewendet.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf. Der Index jedes Quellelements wird im projizierten Zwischenformat des jeweiligen Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , dessen Elemente sind das Ergebnis eines Aufrufs der 1: n-Transformationsfunktion <paramref name="collectionSelector" /> für jedes Element der <paramref name="source" /> und anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden Quellelemente zu einem Ergebniselement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> Methode ist nützlich, wenn Sie keine behalten Sie die Elemente eines `source` innerhalb des Bereichs für Abfragelogik, die auftritt, nachdem der Aufruf von <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Ein Codebeispiel hierfür finden Sie im Beispielabschnitt. Liegt eine bidirektionale Beziehung zwischen Objekten des Typs `TSource` und Objekte des Typs `TCollection`, d. h. wenn ein Objekt des Typs `TCollection` enthält eine Eigenschaft zum Abrufen der `TSource` Objekt ab, die es erstellt wurde, Sie ist dies nicht erforderlich Überladen von <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Stattdessen können Sie <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> und navigieren Sie zurück zu den `TSource` -Objekt über die `TCollection` Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> für den Vergleich <c>zweiten</c>.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , mit der ersten Sequenz verglichen werden soll.</param>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind, indem die Elemente mithilfe des Standardgleichheitsvergleichs für ihren Typ verglichen werden.</summary>
        <returns>
          <see langword="true" />Wenn die zwei Quellsequenzen von gleicher Länge sind und die entsprechenden Elemente der Standardgleichheitsvergleich für ihren Typ gleich sind; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode zählt die zwei Quellsequenzen parallel und vergleicht entsprechende Elemente mithilfe des Standardgleichheitsvergleichs für `TSource`, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>. Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um die Werte der Typen verglichen, die Implementierung der <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren, und geben Sie eigene <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den Typ.  
  
   
  
## Examples  
 Die folgenden Codebeispiele veranschaulichen <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> zu bestimmen, ob zwei Sequenzen gleich sind. In den ersten beiden Beispielen bestimmt die Methode an, ob die verglichenen Sequenzen Verweise auf dieselben Objekte enthalten. Im dritten und vierten Beispiel vergleicht die Methode die tatsächlichen Daten der Objekte innerhalb der Sequenzen.  
  
 In diesem Beispiel wird sind die Sequenzen gleich.  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 Im folgenden Codebeispiel wird vergleicht zwei Sequenzen, die nicht gleich sind. Beachten Sie, dass die Sequenzen identische Daten enthalten, aber da die Objekte, die sie enthalten andere Verweise verfügen, die Sequenzen sind nicht als gleich betrachtet.  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 Wenn Sie die eigentlichen Daten der Objekte in den Sequenzen nicht nur die Verweise vergleichen möchten, müssen Sie implementieren die <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle in der Klasse. Im folgenden Codebeispiel wird veranschaulicht, wie zum Implementieren dieser Schnittstelle in eine Hilfsklasse, und geben Sie <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekte in der <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> für den Vergleich <c>zweiten</c>.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , mit der ersten Sequenz verglichen werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, der zum Vergleichen von Elementen verwendet werden soll.</param>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind, indem ihre Elemente mithilfe eines angegebenen verglichen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see langword="true" />Wenn die zwei Quellsequenzen von gleicher Länge sind und die entsprechenden Elemente gleich gemäß vergleichen <paramref name="comparer" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode zählt die zwei Quellsequenzen parallel und vergleicht entsprechende Elemente mithilfe des angegebenen <xref:System.Collections.Generic.IEqualityComparer%601>. Wenn c`omparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, zum Vergleichen von Elementen verwendet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Gleichheitsvergleich implementieren, die verwendet werden können die <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie dieses Vergleichs implementiert haben, können Sie Sequenzen von `Product` Objekte in der <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> deren einzige Element zurückgegeben.</param>
        <summary>Gibt das einzige Element einer Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode löst eine Ausnahme aus, wenn die Eingabesequenz leer ist. Die stattdessen zurückgegeben `null` verwenden, wenn die Eingabesequenz leer ist, <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> das einzige Element eines Arrays auswählen.  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> löst eine Ausnahme aus, wenn die Sequenz nicht genau ein Element enthält.  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Eingabesequenz enthält mehr als ein Element.  
  
 - oder -   
  
 Die Eingabesequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurückzugebenden ein einzelnes Element aus.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt, und löst eine Ausnahme aus, wenn mehrere solche Elemente vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz, das eine Bedingung erfüllt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Methode löst eine Ausnahme aus, wenn die Eingabesequenz kein übereinstimmendes Element enthält. Die stattdessen zurückgegeben `null` verwenden, wenn kein übereinstimmendes Element gefunden wird, <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> das einzige Element eines Arrays auswählen, die eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> löst eine Ausnahme aus, wenn die Sequenz nicht genau ein Element enthält, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Mehr als ein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
 - oder -   
  
 Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> deren einzige Element zurückgegeben.</param>
        <summary>Gibt das einzige Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehr als ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz, oder <see langword="default" />(<paramref name="TSource" />) Wenn die Sequenz keine Elemente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
 Die <xref:System.Linq.Enumerable.SingleOrDefault%2A> Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen Standardwert außer angeben möchten `default(TSource)`, verwenden Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode wie im Beispielabschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> das einzige Element eines Arrays auswählen.  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> gibt einen Standardwert zurück, wenn die Sequenz nicht genau ein Element enthält.  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 In einigen Fällen den Wert des `default(TSource)` ist nicht der Standardwert, die Sie verwenden, wenn die Auflistung keine Elemente enthält. Statt überprüft das Ergebnis für das unbeabsichtigten Standardwert, und ändern diese bei Bedarf, können Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> Methode, um den Standardwert angeben, die Sie verwenden, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> um das Element abzurufen. Im folgenden Codebeispiel werden beide Verfahren verwendet, um einen Standardwert von 1 zu erhalten, wenn eine Auflistung von Seitenzahlen leer ist. Da der Standardwert für eine ganze Zahl 0 (null), die nicht in der Regel eine gültige Seitenzahl ist, muss der Standardwert stattdessen mit 1 angegeben. Nach Ausführung die Abfrage beendet wurde, wird das erste Ergebnisvariable für das unbeabsichtigten Standardwert überprüft. Die zweite Ergebnisvariable wird mithilfe von <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> an den Standardwert 1.  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Eingabesequenz enthält mehr als ein Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurückzugebenden ein einzelnes Element aus.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz, das eine angegebene Bedingung erfüllt, oder einen Standardwert zurück, wenn kein solches Element vorhanden ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente die Bedingung erfüllen.</summary>
        <returns>Das einzige Element der Eingabesequenz, das die Bedingung erfüllt oder <see langword="default" />(<paramref name="TSource" />), wenn kein solches Element gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Referenztypen und Typen ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> das einzige Element eines Arrays auswählen, die eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> gibt einen Standardwert zurück, wenn die Sequenz nicht genau ein Element enthält, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> aus dem Elemente zurückgegeben.</param>
        <param name="count">Die Anzahl der Elemente, die übersprungen werden sollen, bevor die übrigen Elemente zurückgegeben werden.</param>
        <summary>Überspringt eine festgelegte Anzahl von Elementen in einer Sequenz und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , enthält die Elemente, die nach dem angegebenen Index in der Eingabesequenz auftreten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Wenn `source` enthält weniger als `count` Elemente, die eine leere <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben wird. Wenn `count` ist kleiner oder gleich 0 (null), alle Elemente des `source` werden zurückgegeben.  
  
 Die <xref:System.Linq.Enumerable.Take%2A> und <xref:System.Linq.Enumerable.Skip%2A> Methoden sind funktionale ergänzt. Erhält eine Sequenz `coll` und einer ganzen Zahl `n`, verketten die Ergebnisse der `coll.Take(n)` und `coll.Skip(n)` ergibt die gleiche Sequenz wie `coll`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Skip` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Skip%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Skip%2A> auf eine angegebene Anzahl von Elementen in einem sortierten Array übersprungen und die übrigen Elemente zurück.  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> aus dem Elemente zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung "true ist", und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , enthält die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe, die nicht vom angegebenen Test bestehen <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Methode mit verzögerter Ausführung implementiert wird. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Diese Methode überprüft jedes Element von `source` mit `predicate` und überspringt das Element, wenn das Ergebnis ist `true`. Nach der Rückkehr der Prädikatfunktion `false` nach einem Element, das dieses Element und die übrigen Elemente in `source` werden zurückgegeben, und es sind keine weiteren Aufrufe von `predicate`.  
  
 Wenn `predicate` gibt `true` für alle Elemente in der Sequenz, ein leeres <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben wird.  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> Methoden sind funktionale ergänzt. Erhält eine Sequenz `coll` einer reinen Funktion `p`, verketten die Ergebnisse der `coll.TakeWhile(p)` und `coll.SkipWhile(p)` ergibt die gleiche Sequenz wie `coll`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Skip While` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Elemente eines Arrays zu überspringen, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> aus dem Elemente zurückgegeben.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung "true ist", und gibt dann die übrigen Elemente zurück. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , enthält die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe, die nicht vom angegebenen Test bestehen <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> Methode überprüft jedes Element von `source` mit `predicate` und überspringt das Element, wenn das Ergebnis ist `true`. Nach der Rückkehr der Prädikatfunktion `false` nach einem Element, das dieses Element und die übrigen Elemente in `source` werden zurückgegeben, und es sind keine weiteren Aufrufe von `predicate`.  
  
 Wenn `predicate` gibt `true` für alle Elemente in der Sequenz, ein leeres <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben wird.  
  
 Das erste Argument der `predicate` stellt das zu testende Element. Das zweite Argument stellt den nullbasierten Index des Elements in `source`.  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> Methoden sind funktionale ergänzt. Erhält eine Sequenz `coll` einer reinen Funktion `p`, verketten die Ergebnisse der `coll.TakeWhile(p)` und `coll.SkipWhile(p)` ergibt die gleiche Sequenz wie `coll`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Skip While` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> Elemente eines Arrays zu überspringen, solange eine Bedingung, die abhängig von der Index des Elements "true" ist.  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> NULL, wenn der Methodenrückgabe `source` enthält keine Elemente.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Decimal" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis für den Wiederherstellungsdienst enthalten Werte, die sind `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Double" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Int32" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Int64" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von NULL-Werte zu <see cref="T:System.Single" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Summe der Werte einer Sequenz.  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" /> zum Berechnen der Summe der Werte.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" /> Werte.</summary>
        <returns>Die Summe der Werte in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> Summe der Werte einer Sequenz.  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Decimal>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Double>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Int32>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Int64>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Decimal" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis ist nicht enthalten Werte, die `null`.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Decimal>` in c# oder `Nullable(Of Decimal)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Double" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Double>` in c# oder `Nullable(Of Double)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int32" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Int32>` in c# oder `Nullable(Of Int32)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Int64" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Int64>` in c# oder `Nullable(Of Int64)` in[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von NULL-Werte zulassen <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt NULL, wenn `source` enthält keine Elemente.  
  
 Das Ergebnis enthält keine Werte, die `null`.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ speziell `Nullable<Single>` in c# oder `Nullable(Of Single)` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen eine Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" /> Werte, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> NULL, wenn der Methodenrückgabe `source` enthält keine Elemente.  
  
 Sie können diese Methode auf eine Sequenz von beliebigen Werten anwenden, wenn Sie eine Funktion bereitstellen `selector`,-Projekten die Mitglieder der `source` in einen numerischen Typ, insbesondere <xref:System.Single>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Aggregate Into Sum()` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> Summe der projizierten Werte in einer Sequenz.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der zurückzugebenden Elemente.</param>
        <summary>Gibt eine angegebene Anzahl von zusammenhängenden Elementen vom Anfang einer Sequenz zurück.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die die angegebene Anzahl von Elementen vom Anfang der Eingabesequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 <xref:System.Linq.Enumerable.Take%2A>Listet `source` und Elemente bis ergibt `count` Elemente zurückgegeben wurden oder `source` keine Elemente mehr enthält. Wenn `count` überschreitet die Anzahl der Elemente im `source`, alle Elemente des `source` werden zurückgegeben.  
  
 Wenn `count` ist kleiner oder gleich 0 (null), `source` ist nicht aufgelistet, und es wird eine leere <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben wird.  
  
 Die <xref:System.Linq.Enumerable.Take%2A> und <xref:System.Linq.Enumerable.Skip%2A> Methoden sind funktionale ergänzt. Erhält eine Sequenz `coll` und einer ganzen Zahl `n`, verketten die Ergebnisse der `coll.Take(n)` und `coll.Skip(n)` ergibt die gleiche Sequenz wie `coll`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Take` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Take%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Take%2A> Elemente vom Anfang einer Sequenz zurückgegeben.  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Eine Sequenz, aus der Elemente zurückgegeben.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung "true" ist.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , enthält die Elemente aus der Eingabesequenz, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Methode überprüft jedes Element von `source` mit `predicate` und gibt das Element aus, wenn das Ergebnis ist `true`. Enumeration wird beendet, wenn die Prädikatfunktion zurückgibt `false` nach einem Element oder wenn `source` keine Elemente mehr enthält.  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> Methoden sind funktionale ergänzt. Erhält eine Sequenz `coll` einer reinen Funktion `p`, verketten die Ergebnisse der `coll.TakeWhile(p)` und `coll.SkipWhile(p)` ergibt die gleiche Sequenz wie `coll`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Take While` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> Elemente vom Anfang einer Sequenz zurückgegeben werden, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung "true" ist. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die Elemente aus der Eingabesequenz, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich, enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> Methode überprüft jedes Element von `source` mit `predicate` und gibt das Element aus, wenn das Ergebnis ist `true`. Enumeration wird beendet, wenn die Prädikatfunktion zurückgibt `false` nach einem Element oder wenn `source` keine Elemente mehr enthält.  
  
 Das erste Argument der `predicate` stellt das zu testende Element. Das zweite Argument stellt den nullbasierten Index des Elements in `source`.  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> Methoden sind funktionale ergänzt. Erhält eine Sequenz `coll` einer reinen Funktion `p`, verketten die Ergebnisse der `coll.TakeWhile(p)` und `coll.SkipWhile(p)` ergibt die gleiche Sequenz wie `coll`.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Take While` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> zurückzugebenden Elemente vom Anfang einer Sequenz, solange eine Bedingung, der Index des Elements verwendet "true" ist.  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, also auch den Rückgabetyp dieser Methoden. Dieser Entwurf ermöglicht es Ihnen, mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von anwenden <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Diese Methode vergleicht die Schlüssel mithilfe des Standardvergleichs <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
 In der Abfrageausdruckssyntax ein `orderby [first criterion], [second criterion]` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Order By [first criterion], [second criterion]` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.ThenBy%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> um eine nachfolgende Sortierung der Elemente in einer Sequenz durchführen.  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, also auch den Rückgabetyp dieser Methoden. Dieser Entwurf ermöglicht es Ihnen, mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von anwenden <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach einem Schlüssel durch.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, also auch den Rückgabetyp dieser Methoden. Dieser Entwurf ermöglicht es Ihnen, mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von anwenden <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Diese Sortiermethode vergleicht Schlüssel mithilfe des Standardvergleichs <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
 In [!INCLUDE[csprcs](~/includes/csprcs-md.md)] Abfragen Ausdruckssyntax, ein `orderby [first criterion], [second criterion] descending` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] Abfragen Ausdruckssyntax, ein `Order By [first criterion], [second criterion] Descending` -Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach mithilfe eines angegebenen Vergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> , dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Um eine Sequenz von den Werten der Elemente selbst zu sortieren, geben Sie die Identity-Funktion (`x => x` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `Function(x) x` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) für `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ erweitern <xref:System.Linq.IOrderedEnumerable%601>, also auch den Rückgabetyp dieser Methoden. Dieser Entwurf ermöglicht es Ihnen, mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von anwenden <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> erbt von <xref:System.Collections.Generic.IEnumerable%601>, Sie können Aufrufen <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufs von <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>. Auf diese Weise führt eine neue primäre Sortierung, die zuvor festgelegte Sortierung ignoriert.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 Diese Methode führt eine stabile Sortierung. Das heißt, ist die Schlüssel der zwei Elemente gleich sind, die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung die Reihenfolge der Elemente nicht den gleichen Schlüssel verfügen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> um eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge mit einem benutzerdefinierten Vergleich durchführen.  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen eines Arrays aus.</param>
        <summary>Erstellt ein Array aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Ein Array, das die Elemente aus der Eingabesequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode erzwingt die sofortige abfrageauswertung und gibt ein Array, das die Ergebnisse der Abfrage enthält. Sie können diese Methode der Abfrage anfügen, um eine zwischengespeicherte Kopie der Abfrageergebnisse zu erhalten.  
  
 <xref:System.Linq.Enumerable.ToList%2A>verhält sich ähnlich, gibt jedoch eine <xref:System.Collections.Generic.List%601> anstelle eines Arrays.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ToArray%2A> zum Erzwingen der unmittelbaren abfrageauswertung und ein Array von Ergebnissen zurück.  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Collections.Generic.Dictionary`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt eine <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> Methode verwendet den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> zum Erstellen einer <xref:System.Collections.Generic.Dictionary%602> mithilfe einer Schlüsselauswahlfunktion.  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="keySelector" />erzeugt einen Schlüssel mit <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />erzeugt doppelte Schlüssel für zwei Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ der zurückgegebene Schlüssel <c>KeySelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Collections.Generic.Dictionary`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt eine <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="keySelector" />erzeugt einen Schlüssel mit <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />erzeugt doppelte Schlüssel für zwei Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Collections.Generic.Dictionary`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformierenfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Methode verwendet den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="keySelector" />erzeugt einen Schlüssel mit <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />erzeugt doppelte Schlüssel für zwei Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Collections.Generic.Dictionary`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt eine <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="keySelector" />erzeugt einen Schlüssel mit <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" />erzeugt doppelte Schlüssel für zwei Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Collections.Generic.List`1" /> aus.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.List`1" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.List`1" /> , die Elemente aus der Eingabesequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode erzwingt die sofortige abfrageauswertung und gibt eine <xref:System.Collections.Generic.List%601> , die die Ergebnisse der Abfrage enthält. Sie können diese Methode der Abfrage anfügen, um eine zwischengespeicherte Kopie der Abfrageergebnisse zu erhalten.  
  
 <xref:System.Linq.Enumerable.ToArray%2A>Gibt ein Array anstelle eines jedoch verhält sich ähnlich wie eine <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ToList%2A> zum Erzwingen der unmittelbaren abfrageauswertung und Zurückgeben einer <xref:System.Collections.Generic.List%601> , die die Ergebnisse der Abfrage enthält.  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Linq.Lookup`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> Methode gibt ein <xref:System.Linq.Lookup%602>, ein 1: n-Wörterbuch, das für eine Sammlung von Werten Schlüssel zugeordnet ist. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, die eine 1: 1-Zuordnung von Schlüsseln in einzelne Werte durchführt.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Linq.Lookup`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Methode gibt ein <xref:System.Linq.Lookup%602>, ein 1: n-Wörterbuch, das für eine Sammlung von Werten Schlüssel zugeordnet ist. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von der eine <xref:System.Collections.Generic.Dictionary%602>, die eine 1: 1-Zuordnung von Schlüsseln in einzelne Werte durchführt.  
  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Linq.Lookup`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformierenfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Methode gibt ein <xref:System.Linq.Lookup%602>, ein 1: n-Wörterbuch, das für eine Sammlung von Werten Schlüssel zugeordnet ist. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, die eine 1: 1-Zuordnung von Schlüsseln in einzelne Werte durchführt.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> zum Erstellen einer <xref:System.Linq.Lookup%602> mithilfe einer Schlüsselauswahlfunktion und einer Elementauswahlfunktion.  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels zurückgegebenes <c>KeySelector</c>.</typeparam>
        <typeparam name="TElement">Der Typ des vom zurückgegebenen Werts <c>ElementSelector</c>.</typeparam>
        <param name="source">Die <see cref="T:System.Collections.Generic.IEnumerable`1" /> zum Erstellen einer <see cref="T:System.Linq.Lookup`2" /> aus.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt eine <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Methode gibt ein <xref:System.Linq.Lookup%602>, ein 1: n-Wörterbuch, das für eine Sammlung von Werten Schlüssel zugeordnet ist. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, die eine 1: 1-Zuordnung von Schlüsseln in einzelne Werte durchführt.  
  
 Wenn `comparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente bilden die erste Menge für die Union.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente bilden den zweiten Satz für die Union.</param>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Diese Methode schließt Duplikate aus der zurückgegebenen Menge. Dies ist ein unterschiedliches Verhalten zur die <xref:System.Linq.Enumerable.Concat%2A> Methode, die alle Elemente in den Eingabesequenzen, einschließlich der doppelten zurückgibt.  
  
 Der Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um die Werte der Typen verglichen, die Implementierung der <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren, und geben Sie eigene <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den Typ.  
  
 Wenn das Objekt, das von dieser Methode zurückgegebene aufgelistet, <xref:System.Linq.Enumerable.Union%2A> listet `first` und `second` in dieser Reihenfolge und jedes Element, das noch nicht zurückgegeben wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum Abrufen der Union von zwei Sequenzen von ganzen Zahlen.  
  
 [!code-csharp[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 Wenn Sie die Sequenzen von Objekten mit einem benutzerdefinierten Datentyp vergleichen möchten, müssen Sie implementieren die <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle in einem Helperclass. Im folgenden Codebeispiel wird veranschaulicht, wie zum Implementieren dieser Schnittstelle in einem benutzerdefinierten Datentyp aus, und geben Sie <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekte in der <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente bilden die erste Menge für die Union.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , deren unterschiedliche Elemente bilden den zweiten Satz für die Union.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.IEnumerable`1" /> , die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Wenn c`omparer` ist `null`, den Standardgleichheitsvergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte zu vergleichen.  
  
 Wenn das Objekt, das von dieser Methode zurückgegebene aufgelistet, <xref:System.Linq.Enumerable.Union%2A> listet `first` und `second` in dieser Reihenfolge und jedes Element, das noch nicht zurückgegeben wurde.  
  
 Die <xref:System.Linq.Enumerable.Concat%2A> -Methode unterscheidet sich von der <xref:System.Linq.Enumerable.Union%2A> Methode da die <xref:System.Linq.Enumerable.Concat%2A> Methode gibt alle Elemente in den Eingabesequenzen Duplikate, einschließlich zurück, wohingegen <xref:System.Linq.Enumerable.Union%2A> nur eindeutige Werte zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Gleichheitsvergleich implementieren, die verwendet werden können die <xref:System.Linq.Enumerable.Union%2A> Methode.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie dieses Vergleichs implementiert haben, können Sie Sequenzen von `Product` Objekte in der <xref:System.Linq.Enumerable.Union%2A> Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zu filtern.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> enthält Elemente aus der Eingabesequenz, die die Bedingung erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 In der Abfrageausdruckssyntax ein `where` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) oder `Where` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)])-Klausel übersetzt werden, auf einen Aufruf von <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> um eine Sequenz zu filtern.  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente des <c>Quelle</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zu filtern.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat. In der Logik der Prädikatfunktion wird der Index der einzelnen Elemente verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> enthält Elemente aus der Eingabesequenz, die die Bedingung erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Das erste Argument der `predicate` stellt das zu testende Element. Das zweite Argument stellt den nullbasierten Index des Elements in `source`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> zum Filtern einer Sequenz basierend auf ein Prädikat, das den Index der einzelnen Elemente umfasst.  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Eingabesequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Eingabesequenz.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Ergebnissequenz.</typeparam>
        <param name="first">Die erste Sequenz zusammenführen.</param>
        <param name="second">Die zweite Sequenz, die zusammengeführt werden soll.</param>
        <param name="resultSelector">Eine Funktion, die angibt, wie die Elemente von zwei Sequenzen zusammengeführt.</param>
        <summary>Wendet eine angegebene Funktion auf die entsprechenden Elemente von zwei Sequenzen eine Sequenz der Ergebnisse erzeugen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> , zusammengeführte Elemente von zwei Eingabesequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mit verzögerter Ausführung implementiert. Die sofortige ist der Rückgabewert ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich ist. Die Abfrage dargestellt, die von dieser Methode wird nicht ausgeführt, bis das Objekt aufgelistet wird entweder durch Aufrufen seiner `GetEnumerator` Methode direkt oder mithilfe von `foreach` in [!INCLUDE[csprcs](~/includes/csprcs-md.md)] oder `For Each` in [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Die Methode führt jedes Element der ersten Sequenz mit einem Element mit dem gleichen Index in der zweiten Sequenz zusammen. Wenn die Sequenzen nicht die gleiche Anzahl von Elementen verfügen, führt die Methode Sequenzen zusammen, bis das Ende eines dieser Elemente erreicht. Z. B. wenn eine Sequenz verfügt über drei Elemente und die andere vier hat, müssen der Ergebnissequenz nur drei Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Enumerable.Zip%2A> Methode, um zwei Sequenzen zusammenzuführen.  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
