<Type Name="XamlDirective" FullName="System.Xaml.XamlDirective">
  <TypeSignature Language="C#" Value="public class XamlDirective : System.Xaml.XamlMember" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlDirective extends System.Xaml.XamlMember" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlDirective" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xaml.XamlMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet die Verwendung von XAML-Typsystembezeichner für ein Element, wenn das Element ebenfalls eine XAML-Direktive ist. XAML-Readern und XAML-Writer die <see cref="T:System.Xaml.XamlDirective" /> Bezeichner während der Verarbeitung der Element-Knoten. Der Bezeichner wird verwendet, wenn der XAML-Reader positioniert ist, auf eine <see cref="F:System.Xaml.XamlNodeType.StartMember" /> und <see cref="P:System.Xaml.XamlMember.IsDirective" /> ist <see langword="true" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>erwartete Werte bietet für die Verwendung von XAML-Typsystem, wenn das Element eine XAML-Direktive ist. Definitionsgemäß verfügt eine XAML-Direktive, die stets die gleichen Ergebnisse für eine Teilmenge der Merkmale der <xref:System.Xaml.XamlMember> Eigenschaften und die gleichen Systeminformationen für die Verwendung von XAML-Typ wird für alle möglichen XAML-Direktiven gemeldet. Die Berichterstattung für die Verwendung von XAML-Typ den Systemmerkmalen, die spezifisch für Direktiven sind erfolgt durch interne Verhalten oder außer Kraft von <xref:System.Xaml.XamlMember> `Lookup*` virtuelle Member in der <xref:System.Xaml.XamlDirective> Klasse.  
  
 Die folgende Liste zeigt die zurückgegebenen Ergebnisse einer XAML-Direktive für <xref:System.Xaml.XamlMember> Wenn das Element ist tatsächlich eine <xref:System.Xaml.XamlDirective>:  
  
-   <xref:System.Xaml.XamlMember.LookupCustomAttributeProvider%2A>ist immer `null`.  
  
-   <xref:System.Xaml.XamlMember.DeferringLoader%2A>ist immer `null`.  
  
-   <xref:System.Xaml.XamlMember.DependsOn%2A>ist immer `null`.  
  
-   <xref:System.Xaml.XamlMember.IsAmbient%2A>ist immer `false`.  
  
-   <xref:System.Xaml.XamlMember.IsAttachable%2A>ist immer `false`.  
  
-   <xref:System.Xaml.XamlMember.IsDirective%2A>ist immer `true`.  
  
-   <xref:System.Xaml.XamlMember.IsEvent%2A>ist immer `false`.  
  
-   <xref:System.Xaml.XamlMember.IsReadOnly%2A>ist immer `false`.  
  
-   <xref:System.Xaml.XamlMember.IsReadPublic%2A>ist immer `true`.  
  
-   <xref:System.Xaml.XamlMember.IsWritePublic%2A>ist immer `true`.  
  
 Darüber hinaus die interne Unterstützung für <xref:System.Xaml.XamlMember.DeclaringType%2A> nicht festgelegt und gibt `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlDirective>ist eine <xref:System.Xaml.XamlMember> Unterklasse. Wie bei <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlDirective> sicherheitsüberlegungen hinsichtlich wie XAML-Typsystem Access-Berichte verfügt. Siehe <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.#ctor(System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Die primäre Verwendung von XAML-Namespace, in denen dies <see cref="T:System.Xaml.XamlDirective" /> können vorhanden sein.</param>
        <param name="name">Den identifizierenden Namen der <see cref="T:System.Xaml.XamlDirective" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Xaml.XamlDirective" /> -Klasse und gibt Werte für einen Namen und einem einzigen XAML-Namespace. Verwenden Sie diese Signatur nur, wenn Sie möchten oder erwarten <see cref="P:System.Xaml.XamlMember.IsUnknown" /> Bericht <see langword="true" /> für die Direktive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Diese Signatur des Konstruktors generiert immer einen Bezeichner für die Richtlinie, auf dem <xref:System.Xaml.XamlMember.IsUnknown%2A> Berichte `true` für die XAML-Typsystem. Wenn die erforderlichen Informationen verfügbar ist (der Unterstützungstyp und ein Informationselement des Text-Syntax für die Konvertierung) und Sie möchten einen Bezeichner, der Anwenden der Richtlinie, verwenden, kann die <xref:System.Xaml.XamlDirective.%23ctor%2A?displayProperty=nameWithType> Konstruktorsignatur stattdessen.  
  
 Wenn Sie die folgende Signatur verwenden die <xref:System.Xaml.XamlDirective.AllowedLocation%2A> Wert für die Instanz <xref:System.Xaml.Schema.AllowedMemberLocations.Any>; und die <xref:System.Xaml.XamlMember.Type%2A> Wert und <xref:System.Xaml.XamlMember.TypeConverter%2A> Wert sind beide `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlDirective (System.Collections.Generic.IEnumerable&lt;string&gt; xamlNamespaces, string name, System.Xaml.XamlType xamlType, System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; typeConverter, System.Xaml.Schema.AllowedMemberLocations allowedLocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; xamlNamespaces, string name, class System.Xaml.XamlType xamlType, class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; typeConverter, valuetype System.Xaml.Schema.AllowedMemberLocations allowedLocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.Xaml.XamlType,System.Xaml.Schema.XamlValueConverter{System.ComponentModel.TypeConverter},System.Xaml.Schema.AllowedMemberLocations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xamlNamespaces" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
        <Parameter Name="typeConverter" Type="System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" />
        <Parameter Name="allowedLocation" Type="System.Xaml.Schema.AllowedMemberLocations" />
      </Parameters>
      <Docs>
        <param name="xamlNamespaces">Ein Satz von XAML-Namespaces, in denen dies <see cref="T:System.Xaml.XamlDirective" /> vorhanden sein kann, als ein zählbarer Satz von Bezeichnerzeichenfolgen übergeben.</param>
        <param name="name">Den identifizierenden Namen der <see cref="T:System.Xaml.XamlDirective" />.</param>
        <param name="xamlType">Der XAML-Typ, der die sichert die <see cref="T:System.Xaml.XamlDirective" />.</param>
        <param name="typeConverter">Der Typkonverter, die von diesem <see cref="T:System.Xaml.XamlDirective" /> für die Konvertierung von Text Syntax verwendet.</param>
        <param name="allowedLocation">Der Wert der <see cref="T:System.Xaml.Schema.AllowedMemberLocations" /> Enumeration.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Xaml.XamlDirective" /> -Klasse und gibt Werte für jeden-Case-Wert, der eine <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor zum Generieren einer <xref:System.Xaml.XamlDirective> , die gibt keine Auskunft über <xref:System.Xaml.XamlMember.IsUnknown%2A> als `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="xamlType" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedLocation">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.AllowedMemberLocations AllowedLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xaml.Schema.AllowedMemberLocations AllowedLocation" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlDirective.AllowedLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.AllowedMemberLocations</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, die Typen der Verwendung von XAML-Knoten ab, in denen die Richtlinie angegeben werden.</summary>
        <value>Ein Wert aus der Enumeration. Die Standardeinstellung ist die Enumeration Standardeinstellung, bei <see cref="F:System.Xaml.Schema.AllowedMemberLocations.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diesen Wert festlegen, der <xref:System.Xaml.XamlDirective.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%2CSystem.Xaml.XamlType%2CSystem.Xaml.Schema.XamlValueConverter%7BSystem.ComponentModel.TypeConverter%7D%2CSystem.Xaml.Schema.AllowedMemberLocations%29> Konstruktorsignatur. Wenn Sie mit Erstellen der <xref:System.Xaml.XamlDirective.%23ctor%28System.String%2CSystem.String%29> die Signatur des Konstruktors, der <xref:System.Xaml.XamlDirective.AllowedLocation%2A> Wert für die Instanz <xref:System.Xaml.Schema.AllowedMemberLocations.Any>. Die Instanz jedoch immer meldet <xref:System.Xaml.XamlMember.IsUnknown%2A> als `true`. Dieses Verhalten wirkt sich in der Regel auf versuchen, Schreiben Objekt Diagramme bereit und wirkt sich auch auf anderen praktischen Verwendungsmöglichkeiten von einem <xref:System.Xaml.XamlMember> Wert.  
  
 Sie in der Regel würde nicht erstellen Sie eine XAML-Direktive Groß-/Kleinschreibung, in denen <xref:System.Xaml.XamlDirective.AllowedLocation%2A> ist <xref:System.Xaml.Schema.AllowedMemberLocations?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für dieses Objekt zurück.</summary>
        <returns>Ein Hashcode als ganze Zahl.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.GetXamlNamespaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von XAML-Namespaces zurück, in dem diesem XAML-Member vorhanden sind.</summary>
        <returns>Eine Liste von XAML-Namespacebezeichner als Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung von XAML-Namespacebezeichner sind Zeichenfolgen, die in der Regel in Form einer Zeichenfolge Uniform Resource Identifier (URI) entsprechend den üblichen Konventionen für XAML- und XML-Namespaces angezeigt werden. Wenn die Liste mehrere Elemente enthält, das erste Element im Satz wird in der Regel der relevanten primäre Verwendung von XAML-Namespace für Verarbeitungszwecke und anderen Elemente sind Alternativen. <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A?displayProperty=nameWithType>mit dieser Anordnung verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupCustomAttributeProvider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Reflection.ICustomAttributeProvider" /> Implementierung. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da eine XAML-Direktive benutzerdefinierte Attribute enthalten kann, gibt diese Implementierung immer `null`. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupDeferringLoader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Objekt, das während des verzögerten Ladens von XAML deklarierten Objekten verwendet wird. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da eine Direktive Laden verzögert haben kann, gibt diese Implementierung immer `null`. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected override sealed System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupDependsOn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von <see cref="T:System.Xaml.XamlMember" /> Objekte. Die Liste gibt die Elemente, in dem abhängigkeitsbeziehungen für Initialisierungsreihenfolge vorhanden, relativ zu dieser ist <see cref="T:System.Xaml.XamlMember" />. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da eine XAML-Direktive Initialisierungsreihenfolge aufweisen kann, gibt diese Implementierung immer `null`. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupInvoker" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> zugeordneten eine <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <returns>Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Informationen für diesen <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, durch Aufrufe von <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Diese Implementierung gibt eine interne statische <xref:System.Xaml.Schema.XamlMemberInvoker> Wert, der in das XAML-Typsystem für Direktiven spezifisch ist. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsAmbient" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlMember" /> wird gemeldet, als ambient-Eigenschaft.</summary>
        <returns>Gibt immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da eine XAML-Direktive ein Umgebungstyp sein kann, gibt diese Implementierung immer `false`. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlDirective" /> stellt ein Ereignis dar.</summary>
        <returns>Gibt immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsReadOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlDirective" /> eine beabsichtigte schreibgeschützte Eigenschaft darstellt.</summary>
        <returns>Gibt immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definitionsgemäß können Direktiven festgelegt werden. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsReadPublic" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlDirective" /> stellt eine Eigenschaft, die einen öffentlichen <see langword="get" /> Accessor.</summary>
        <returns>Gibt immer <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsUnknown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlDirective" /> stellt ein Element, das nicht vom System dahinter liegende aufgelöst werden, die für die Auflösung von Typ- und Memberdaten verwendet wird.</summary>
        <returns>
          <see langword="true" />Wenn diese <see cref="T:System.Xaml.XamlDirective" /> stellt ein Element nicht aufgelöst werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlDirective> Implementierung nur Basisklasse aufruft und mehr wird keine Aktion ausgeführt. Die grundlegende Implementierung gibt die Ergebnisse zurück, in der folgenden Reihenfolge: die Ergebnisse basieren auf internen Reflektion; oder die Ergebnisse basieren auf die Überprüfung auf einen null-Wert von der <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Die <xref:System.Xaml.XamlDirective> Implementierung versiegelt dieses virtuellen Member; daher alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsWriteOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlDirective" /> stellt eine beabsichtigte WriteOnly-Eigenschaft dar.</summary>
        <returns>Gibt immer <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected override sealed bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupIsWritePublic" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dies <see cref="T:System.Xaml.XamlDirective" /> stellt eine Eigenschaft, die einen öffentlichen <see langword="set" /> Accessor.</summary>
        <returns>Gibt immer <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupTargetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Xaml.XamlType" /> des Typs, in dem die <see cref="T:System.Xaml.XamlMember" /> vorhanden sein können. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zieltypen sind nicht relevant für Direktiven; aus diesem Grund diese Implementierung gibt immer `null`. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Xaml.XamlType" /> des Typs, der vom Element verwendet wird.</summary>
        <returns>Die <see cref="T:System.Xaml.XamlType" /> des Typs, der vom Element verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlDirective> Implementierung nur Basisklasse aufruft und mehr wird keine Aktion ausgeführt. Die grundlegende Implementierung gibt Ergebnisse basiert entweder auf interne Reflektion oder die Überprüfung auf einen null-Wert von <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, Verarbeitung in dieser Reihenfolge. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 Finden Sie unter "Hinweise" in <xref:System.Xaml.XamlMember.LookupType%2A?displayProperty=nameWithType> Weitere Informationen darüber, welche Informationen <xref:System.Xaml.XamlMember.Type%2A> führt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected override sealed System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupTypeConverter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Typkonverter-Implementierung, die mit dieser verknüpft ist <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <returns>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> -Zielinstanz mit <see cref="T:System.ComponentModel.TypeConverter" /> Einschränkung oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlDirective> Implementierung nur Basisklasse aufruft und mehr wird keine Aktion ausgeführt. Siehe <xref:System.Xaml.XamlMember.LookupTypeConverter%2A?displayProperty=nameWithType>. <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupUnderlyingGetter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see langword="get" /> Accessor, der mit dieser verknüpft ist <see cref="T:System.Xaml.XamlDirective" />. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupUnderlyingMember" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine CLR-Reflektion <see cref="T:System.Reflection.MemberInfo" /> , die mit dieser verknüpft ist <see cref="T:System.Xaml.XamlDirective" />. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected override sealed System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.LookupUnderlyingSetter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see langword="set" /> Accessor, der mit dieser verknüpft ist <see cref="T:System.Xaml.XamlDirective" />. Diese Implementierung gibt immer <see langword="null" />.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlDirective>versiegelt diesen virtuellen Member; aus diesem Grund alle <xref:System.Xaml.XamlDirective> Typen und alle vordefinierten XAML-Direktiven verwenden, dieses Verhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlDirective.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung dieses <see cref="T:System.Xaml.XamlDirective" />.</summary>
        <returns>Eine Zeichenfolgendarstellung dieses <see cref="T:System.Xaml.XamlDirective" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn XAML-Namespaceinformationen verfügbar ist, gibt diese Implementierung eine Zeichenfolgenkombination aus <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> und <xref:System.Xaml.XamlMember.Name%2A>. Wenn XAML-Namespaceinformationen nicht verfügbar ist, gibt diese Implementierung <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
