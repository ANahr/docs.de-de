<Type Name="SessionAuthenticationModule" FullName="System.IdentityModel.Services.SessionAuthenticationModule">
  <TypeSignature Language="C#" Value="public class SessionAuthenticationModule : System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionAuthenticationModule extends System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.SessionAuthenticationModule" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Services.HttpModuleBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementiert eine ASP.NET-Modul, das verarbeitet Sitzungscookies in WS-Verbund-Szenarien.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn er in der ASP.NET-Pipeline die <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) verarbeitet Sitzungscookies in WS-Verbund-Szenarien. Er verwendet den Cookie-Handler, die gemäß der <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> -Eigenschaft den unformatierten Sitzungscookie aus der HTTP-Anforderung gelesen und in der HTTP-Antwort zu schreiben. Er verwendet die <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> für eine Anwendung die unformatierten Sitzungscookie in deserialisiert konfigurierten <xref:System.IdentityModel.Tokens.SessionSecurityToken> Objekte. Das sitzungssicherheitstoken enthält die Ansprüche (<xref:System.Security.Claims.Claim>) und (<xref:System.Security.Claims.ClaimsPrincipal>) verknüpft sind, mit der Entität, für die die Anforderung verarbeitet wird.  
  
 SAM fügt seiner <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> -Ereignishandler, um die <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> Ereignis in der ASP.NET-Pipeline. Dieser Handler fängt anmeldeanforderungen und, wenn ein Sitzungscookie deserialisiert Sie es in ein Sitzungstoken, und legt sie fest der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> und <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> Eigenschaften, die in das Sitzungstoken enthaltenen anspruchsprinzipal. Sie ruft mehrere der anderen Methoden von SAM während dieses Vorgangs verfügbar gemacht werden.  
  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode kann aufgerufen werden, um den Benutzer von einer Sitzung (z. B. in einem SignOut.aspx.cs Code-Behind-Datei) zu signieren.  
  
 SAM macht mehrere Ereignisse, die Zugriff auf die Pipeline zur anforderungsverarbeitung ermöglichen. Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> und <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> Ereignisse ermöglichen es Ihnen, die Sitzungstoken zu ändern, die Cookies auslesen oder während der Verarbeitung erstellt werden. Dies erfolgt in der Regel um hinzufügen, entfernen oder Transformieren Ansprüche im Token oder der Ablaufzeit anzupassen. Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut>, und <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> Ereignisse und es können Hooks in die Verarbeitung von Anforderungen für einmaliges abmelden. In vielen Szenarien einfach Handler für diese Ereignisse häufig auf die Datei global.asax.cs hinzugefügt wird ausreichend sein.  
  
 Für komplexere Szenarien können Sie ableiten von <xref:System.IdentityModel.Services.SessionAuthenticationModule> um eine benutzerdefinierte SAM zu implementieren. Zu diesem Zweck werden viele der Methoden, die aufgerufen werden, während der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> und <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> werden verfügbar gemacht, sodass Sie benutzerdefinierte Verhalten in bestimmten Phasen des Lebenszyklus des Sitzung-Verarbeitung bereitstellen können.  
  
 Sie können der ASP.NET-Pipeline in einer Konfigurationsdatei SAM hinzufügen, indem HTTP-Module unter entweder hinzugefügt der `<system.webServer>` Element für IIS, Version 7 und höher oder unter dem `<system.web>` -Element für Versionen vor IIS 7. Der Cookie-Handler von SAM verwendeten kann konfiguriert werden, mit der [ &lt;"cookiehandler"&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) Element.  
  
   
  
## Examples  
 [!code-csharp[WifSAM#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#1)]  
  
 Das folgende XML zeigt, wie in der ASP.NET-Pipeline SAM konfigurieren. Viele andere Elemente, die in einer typischen Konfiguration vorhanden sind, werden hier aus Gründen der Übersichtlichkeit weggelassen.  
  
```xml  
<configuration>  
  <system.webServer>  
    <modules>  
      <!--WIF 4.5 modules -->  
      <add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
      <add name="WsFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
  </system.webServer>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionAuthenticationModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IdentityModel.Services.SessionAuthenticationModule" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> -Eigenschaftensatz auf `false` und <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> -Eigenschaft wird mit einer Standardinstanz von initialisiert die <xref:System.IdentityModel.Services.CookieHandlerElement.ChunkedCookieHandler%2A> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateSessionSecurityToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateSessionSecurityToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken(System.IdentityModel.Tokens.SessionSecurityToken,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="writeCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Das sitzungssicherheitstoken zu verwenden, um die eingehende HTTP-Anforderung zu authentifizieren.</param>
        <param name="writeCookie">
          <see langword="true" />das Sitzungscookie schreiben; andernfalls <see langword="false" />.</param>
        <summary>Authentifiziert die eingehende Anforderung überprüft das eingehende Sitzungstoken. Bei einer erfolgreichen Validierung aktualisiert die aktuellen HTTP-Kontext und der Thread Prinzipal mit dem angegebenen <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> Methode wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> Methode. Ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken%2A> Methode zur Überprüfung der eingehenden Token und das Update der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> und <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> Eigenschaften. Wenn die `writeCookie` Parameter ist `true`die <xref:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie%2A> Methode wird aufgerufen, um das Sitzungstoken ein Cookie zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSessionTokenCookie">
      <MemberSignature Language="C#" Value="public bool ContainsSessionTokenCookie (System.Web.HttpCookieCollection httpCookieCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSessionTokenCookie(class System.Web.HttpCookieCollection httpCookieCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ContainsSessionTokenCookie(System.Web.HttpCookieCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpCookieCollection" Type="System.Web.HttpCookieCollection" />
      </Parameters>
      <Docs>
        <param name="httpCookieCollection">Die Auflistung der Cookies, in dem gesucht werden soll.</param>
        <summary>Bestimmt, ob ein Sitzungscookie in der angegebenen Auflistung ist.</summary>
        <returns>
          <see langword="true" />Wenn ein Sitzungscookie gefunden wurde. andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="httpCookieCollection" />ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktiven <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> für den aktuellen <see cref="T:System.Web.HttpContext" />.</summary>
        <value>Das Sicherheitstoken für die aktive Sitzung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieHandler">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Services.CookieHandler CookieHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Services.CookieHandler CookieHandler" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Services.CookieHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Cookie-Handler, der zum Lesen, schreiben und Löschen des Sitzungscookies verwendet wird.</summary>
        <value>Der Cookie-Handler.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Eigenschaft wird initialisiert, indem die <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration%2A> Methode. Diese Methode initialisiert die Eigenschaft der Cookie-Handler angegeben, die auf Grundlage der <xref:System.IdentityModel.Services.Configuration.FederationConfiguration> -Objekt, das auf festgelegt ist die <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> Eigenschaft. Sie können die Cookie-Handler in einer Konfigurationsdatei durch Festlegen der [ &lt;"cookiehandler"&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) Element.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, valuetype System.DateTime validFrom, valuetype System.DateTime validTo, bool isPersistent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.DateTime,System.DateTime,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principal">Der Prinzipal im Token erfasst werden sollen.</param>
        <param name="context">Eine Kontextzeichenfolge anwendungsdefinierte.</param>
        <param name="validFrom">Den ersten Zeitpunkt, in dem das Token gültig ist.</param>
        <param name="validTo">Der letzte Zeitpunkt, in dem das Token gültig ist.</param>
        <param name="isPersistent">
          <see langword="true" />Wenn der Wert durch den Benutzer-Agent beibehalten werden soll; andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> aus den angegebenen Parametern mithilfe den für die Sitzung konfigurierten Tokenhandler.</summary>
        <returns>das Sitzungstoken.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine gültige Sitzungs-Tokenhandler konfiguriert ist nicht vorhanden. (Es ist keine <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> in konfiguriert die <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> Eigenschaft.)</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteSessionTokenCookie">
      <MemberSignature Language="C#" Value="public void DeleteSessionTokenCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSessionTokenCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht das Sitzungscookie und entfernt es aus dem Cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löscht das Sitzungscookie mithilfe des Cookie-Handlers, die gemäß der <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Eigenschaft. Diese Methode wird aufgerufen, während der Abmeldung von der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeModule">
      <MemberSignature Language="C#" Value="protected override void InitializeModule (System.Web.HttpApplication context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializeModule(class System.Web.HttpApplication context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule(System.Web.HttpApplication)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpApplication" />
      </Parameters>
      <Docs>
        <param name="context">Das HTTP-Anwendungsobjekt, das dieses Modul enthält.</param>
        <summary>Initialisiert das Modul und bereitet es zum Behandeln von Ereignissen aus der Moduls [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] Application-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fügt der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> und <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> -Handler die <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> und <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> Ereignisse des Anwendungsobjekts gemäß der `context` Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializePropertiesFromConfiguration">
      <MemberSignature Language="C#" Value="protected override void InitializePropertiesFromConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializePropertiesFromConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert die Moduleigenschaften basierend auf Definitionen in der Konfigurationsdatei an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialisiert die <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Eigenschaft aus der in der Konfiguration von angegebene Handler die <xref:System.IdentityModel.Services.Configuration.FederationConfiguration?displayProperty=nameWithType> -Objekt, das auf festgelegt ist die <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> Eigenschaft. Sie können die Cookie-Ereignishandler in einer Konfigurationsdatei durch Angeben der [ &lt;"cookiehandler"&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) Element.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceMode">
      <MemberSignature Language="C#" Value="public bool IsReferenceMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceMode" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Sitzungsinformationen (Anspruchswerte usw.) gespeichert werden sollen, in das Sitzungscookie oder gibt an, ob der Inhalt der Sitzung auf dem Server, mit das Cookie zum Speichern von nur eines Verweis gespeichert werden sollen.</summary>
        <value>
          <see langword="true" />Wenn ausgestellte Cookies im Verweis-Modus sind andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />, die angibt, die Cookies ausgegeben werden nicht im Verweis-Modus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Modus "Verweis" die <xref:System.IdentityModel.Tokens.SessionSecurityToken> befindet sich in einer serverseitigen Cache (ein Objekt, das von abgeleitet ist <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>). Das ausgestellte Cookie enthält nur eines Kontextbezeichner, der verwendet wird, um das Token aus dem Cache abzurufen.  
  
> [!IMPORTANT]
>  Microsoft empfiehlt, die mit einem Handler für Betrieb im Modus "Verweis" die <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated?displayProperty=nameWithType> Ereignis in die Datei global.asax.cs und die Einstellung der <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> -Eigenschaft im Token übergeben der <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> Eigenschaft. Dadurch wird sichergestellt, dass das Sitzungstoken im Modus "Verweis" für jede Anforderung arbeitet und bevorzugt wird, über das Festlegen von lediglich die <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A?displayProperty=nameWithType> Eigenschaft für die Sitzung Authentifizierungsmodul.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthenticateRequest (object sender, EventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthenticateRequest(object sender, class System.EventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle für das Ereignis. Dies ist ein <see cref="T:System.Web.HttpApplication" /> Objekt.</param>
        <param name="eventArgs">Die Daten für das Ereignis.</param>
        <summary>Behandelt die <see cref="E:System.Web.HttpApplication.AuthenticateRequest" /> Ereignis aus der [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] Pipeline.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt Folgendes aus:  
  
1.  Ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie%2A> -Methode zum Lesen einer <xref:System.IdentityModel.Tokens.SessionSecurityToken> aus dem Sitzungscookie, sofern eins vorhanden ist.  
  
2.  Wenn eine Sitzung werden Sicherheitstoken kann nicht gelesen (wahrscheinlich weil eine Sitzung nicht festgelegt wurde), zurück.  
  
3.  Ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived%2A> Methode zum Auslösen der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> Ereignis. Dies bietet die Möglichkeit, für das Token, das Lesen aus dem Cookie geändert werden oder für die Anforderung abgebrochen wird. Der Handler kann auch angeben, dass das Token soll, durch Festlegen ausgestellt werden der <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> Eigenschaft.  
  
4.  Wenn das Token erneut ausgestellt werden, aus dem Cache entfernt, und ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated%2A> Methode zum Auslösen der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> Ereignis. Dies bietet die Möglichkeit, das Token erneut geändert werden. Wiederholen Sie Verhalten kann auch geändert werden, durch Festlegen der <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> Eigenschaft im Ereignishandler.  
  
5.  Ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> Methode zur Authentifizierung des Benutzers. Wenn erfolgreich, dies die Auswirkung der Einstellung hat die <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaft, die dem Prinzipal, der in enthalten ist die <xref:System.IdentityModel.Tokens.SessionSecurityToken.ClaimsPrincipal%2A?displayProperty=nameWithType> Eigenschaft des eingehenden Tokens.  
  
6.  Wenn die Sitzung abgelaufen ist, ruft der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode.  
  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> -Methode wird hinzugefügt, um die Handler für das <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> Ereignis in der <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine gültige Sitzungs-Tokenhandler konfiguriert ist nicht vorhanden. (Es ist keine <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> in konfiguriert die <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> Eigenschaft.)</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPostAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnPostAuthenticateRequest (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPostAuthenticateRequest(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle für das Ereignis. Dies ist ein <see cref="T:System.Web.HttpApplication" /> Objekt.</param>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Behandelt die <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> Ereignis aus der [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] Pipeline.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung ist leer.  
  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> Handler hinzugefügt, mit der Handler für das <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> Ereignis in der <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenCreated (System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenCreated(class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated(System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Die Daten für das Ereignis.</param>
        <summary>Löst das <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenReceived (System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenReceived(class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived(System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Die Daten für das Ereignis.</param>
        <summary>Löst das <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignedOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSignedOut (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignedOut(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Löst das <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> -Methode auf, nachdem die Abmeldung ausgeführt wurde und das Sitzungscookie gelöscht wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSigningOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSigningOut (System.IdentityModel.Services.SigningOutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSigningOut(class System.IdentityModel.Services.SigningOutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut(System.IdentityModel.Services.SigningOutEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.SigningOutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Löst das <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode, um die Abmeldung ausführen. Er wird aufgerufen, bevor das Sitzungscookie gelöscht wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignOutError">
      <MemberSignature Language="C#" Value="protected virtual void OnSignOutError (System.IdentityModel.Services.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignOutError(class System.IdentityModel.Services.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError(System.IdentityModel.Services.ErrorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Löst das <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode, wenn ein Fehler, während der Abmeldung auftritt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie (byte[] sessionCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie(unsigned int8[] sessionCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionCookie" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="sessionCookie">Das Cookie in unformatierter Form, von denen, der das Sitzungstoken enthält.</param>
        <summary>Liest eine <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> aus der angegebenen Sitzungscookie.</summary>
        <returns>Das Sitzungstoken, aus der das Cookie gelesen wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine gültige Sitzungs-Tokenhandler konfiguriert ist nicht vorhanden. (Es ist keine <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> in konfiguriert die <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> Eigenschaft.)</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein sitzungssicherheitstoken erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis verwenden, das sitzungssicherheitstoken zu ändern, bevor sie auf ein Cookie geschrieben werden.  
  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> Ereignis wird ausgelöst, innerhalb der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> Methode auf, nachdem ein Sitzungstoken (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) erstellt wurde. Dies geschieht beispielsweise, wenn ein Ereignishandler für das <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> Ereignis ändert das Token.  
  
 Sie können dieses Ereignis zum Ändern der Eigenschaften des Sitzungstokens, bevor weitere entlang der Pipeline übergeben wird und dient zur Authentifizierung der Entität vornehmen der Anforderung (Benutzer) verwenden.  
  
 In einem Ereignishandler können Sie das Token über Zugriff auf die <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> Eigenschaft. Nach dem Ändern der Token, können Sie sicherstellen, dass er das Cookie durch Festlegen von zurückgeschrieben wird die <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> Eigenschaft `true`. Im Gegensatz zu, die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> Ereignis <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> ist kein abbrechbares Ereignis.  
  
   
  
## Examples  
 Der folgende Code zeigt einen Handler für das <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> Ereignis in der Datei global.asax.cs einer ASP.NET Web-Anwendung implementiert. Sie müssen auch die Handler an das Ereignis hinzufügen. Ein vollständigeres Beispiel wird gezeigt, der <xref:System.IdentityModel.Services.SessionAuthenticationModule> Übersichtsthema.  
  
 [!code-csharp[WifSAM#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein sitzungssicherheitstoken aus einem Cookie gelesen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> Ereignis wird ausgelöst, innerhalb der <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> Methode auf, nachdem ein Sitzungstoken (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) aus dem Sitzungscookie erfolgreich gelesen wurden.  
  
 Sie können dieses Ereignis zum Ändern der Eigenschaften des Sitzungstokens, bevor weitere entlang der Pipeline übergeben wird und dient zur Authentifizierung der Entität vornehmen der Anforderung (Benutzer) verwenden. Eines der häufigsten Szenarien umfasst die Ablaufzeit für die Sitzung ändern (über die <xref:System.IdentityModel.Tokens.SessionSecurityToken.ValidTo%2A?displayProperty=nameWithType> Eigenschaft) zu überschreiben, die Sitzung Ablaufzeit, die in der Konfiguration durch Festlegen der `lifetime` Attribut des der [ &lt;auf "sessiontokenrequirement"&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) Element. Ändern Sie diese Eigenschaft für jede Anforderung, können Sie eine gleitende Sitzung Implementieren; d. h. eine Sitzung, in denen die Lebensdauer jeder erweitert wird, Zeit greift der Benutzer auf die Website.  
  
 In einem Ereignishandler können Sie das Token über Zugriff auf die <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.SessionToken%2A?displayProperty=nameWithType> Eigenschaft. Nach dem Ändern der Token, können Sie sicherstellen, dass er das Cookie durch Festlegen von zurückgeschrieben wird die <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> auf `true`. Schließlich die <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> Ereignis ist ein abbrechbares Ereignis, und Sie können festlegen, die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs> weitere Verarbeitung der Anforderung abgebrochen.  
  
   
  
## Examples  
 Der folgende Code zeigt einen Handler für das <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> Ereignis in der Datei global.asax.cs einer ASP.NET Web-Anwendung implementiert. Sie müssen auch die Handler an das Ereignis hinzufügen. Ein vollständigeres Beispiel wird gezeigt, der <xref:System.IdentityModel.Services.SessionAuthenticationModule> Übersichtsthema.  
  
 [!code-csharp[WifSAM#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalFromSessionToken">
      <MemberSignature Language="C#" Value="protected virtual void SetPrincipalFromSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetPrincipalFromSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Das Sitzungstoken aus dem Festlegen des Prinzipals.</param>
        <summary>Legt den Prinzipal fest, auf die <see cref="T:System.Web.HttpContext" /> und <see cref="T:System.Threading.Thread" /> , die dem Prinzipal, der in der angegebenen Sitzungstoken enthalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken%2A> -Methode und legt die <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaft und die <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> Eigenschaft auf <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> verwenden die Identitäten, die zurückgegeben werden.  
  
 Diese Methode wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedOut">
      <MemberSignature Language="C#" Value="public event EventHandler SignedOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SignedOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem der Benutzer abgemeldet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ausgelöst von der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode direkt nach der <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> Methode aufgerufen wird.  
  
 Dieses Ereignis wird nicht unbedingt für jede Sitzung aufgerufen werden. Beispielsweise können die Cookies gelöscht werden, auf der Clientseite in diesem Fall werden dieses Ereignis wird nie ausgelöst, da es keine serverseitige-Ereignis ist für das Löschen der Sitzungs.  
  
   
  
## Examples  
 Der folgende Code zeigt einen Handler für das <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut> Ereignis in der Datei global.asax.cs einer ASP.NET Web-Anwendung implementiert. Sie müssen auch die Handler an das Ereignis hinzufügen. Ein vollständigeres Beispiel wird gezeigt, der <xref:System.IdentityModel.Services.SessionAuthenticationModule> Übersichtsthema.  
  
 [!code-csharp[WifSAM#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SigningOut">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt vor dem Löschen der Sitzung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ausgelöst von der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode kurz vor dem Ausführen der <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> Methode aufgerufen wird.  
  
 Dieses Ereignis wird nicht unbedingt für jede Sitzung aufgerufen werden. Beispielsweise können die Cookies gelöscht werden, auf der Clientseite in diesem Fall werden dieses Ereignis wird nie ausgelöst, da es keine serverseitige-Ereignis ist für das Löschen der Sitzungs.  
  
   
  
## Examples  
 Der folgende Code zeigt einen Handler für das <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut> Ereignis in der Datei global.asax.cs einer ASP.NET Web-Anwendung implementiert. Sie müssen auch die Handler an das Ereignis hinzufügen. Ein vollständigeres Beispiel wird gezeigt, der <xref:System.IdentityModel.Services.SessionAuthenticationModule> Übersichtsthema.  
  
 [!code-csharp[WifSAM#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public virtual void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SignOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Meldet den aktuellen Benutzer ab, und die zugehörigen Ereignisse ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut%2A>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>, und <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut%2A> Methoden, um die Abmeldung ausführen. Wenn eine Ausnahme auftritt, die <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError%2A> Methode wird aufgerufen, um das Auslösen der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> Ereignis. Können Sie festlegen, die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.IdentityModel.Services.ErrorEventArgs> -Objekt übergeben, in der Ereignishandler für dieses Ereignis, um die Abmeldung Abbrechen und verhindern, dass die Ausnahme an den Client weitergegeben wird.  
  
 Sie können diese Methode, um anwendungsspezifisches Verhalten hinzufügen, überschreiben.  
  
   
  
## Examples  
 Der folgende Code zeigt den Code zum Aufrufen der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode von einer SignOut.aspx-Seite (SignOut.aspx.cs) in eine ASP.NET-Webanwendung. Ein vollständigeres Beispiel wird gezeigt, der <xref:System.IdentityModel.Services.SessionAuthenticationModule> Übersichtsthema.  
  
 [!code-csharp[WifSAM#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOutError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Fehler aufgetreten, während der Abmeldung ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird ausgelöst, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> Methode, wenn ein Fehler, während der Abmeldung auftritt.  
  
 In einem Ereignishandler, erhalten Sie die Ausnahme, die im Ereignis ausgelöst wird, aus der <xref:System.IdentityModel.Services.ErrorEventArgs.Exception%2A?displayProperty=nameWithType> Eigenschaft. Können Sie Abbrechen, weitere Verarbeitung der Ausnahme, die das Ergebnis der Weitergabe nicht durch Festlegen der Ausnahme an den Client hat die <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Eigenschaft von der <xref:System.IdentityModel.Services.ErrorEventArgs> auf `true`.  
  
 Dieses Ereignis wird nicht unbedingt für jede Sitzung aufgerufen werden. Beispielsweise können die Cookies gelöscht werden, auf der Clientseite in diesem Fall werden dieses Ereignis wird nie ausgelöst, da es keine serverseitige-Ereignis ist für das Löschen der Sitzungs.  
  
   
  
## Examples  
 Der folgende Code zeigt einen Handler für das <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> Ereignis in der Datei global.asax.cs einer ASP.NET Web-Anwendung implementiert. Sie müssen auch die Handler an das Ereignis hinzufügen. Ein vollständigeres Beispiel wird gezeigt, der <xref:System.IdentityModel.Services.SessionAuthenticationModule> Übersichtsthema.  
  
 [!code-csharp[WifSAM#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public bool TryReadSessionTokenFromCookie (out System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadSessionTokenFromCookie([out] class System.IdentityModel.Tokens.SessionSecurityToken&amp; sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Wenn diese Methode zurückgibt, enthält das sitzungssicherheitstoken, das aus dem Sitzungscookie gelesen wurde.</param>
        <summary>Versucht, lesen eine <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> aus ein Sitzungscookie und gibt einen Wert, der angibt, ob das Sitzungscookie erfolgreich gelesen wurde.</summary>
        <returns>
          <see langword="true" />Wenn das Sitzungscookie erfolgreich aus der Anforderung gelesen wurden; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liest das Cookie mithilfe des Cookie-Handlers, der im konfiguriert ist die <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> -Eigenschaft und ruft dann die <xref:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie%2A> Methode, um das Token aus dem Cookie zu lesen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSessionToken">
      <MemberSignature Language="C#" Value="protected System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Das Token zu überprüfen.</param>
        <summary>Überprüft das angegebene <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> und die Identitäten zurückgibt.</summary>
        <returns>Die Auflistung von Identitäten, die im Token enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, aus der <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> Methode. Ruft die <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A?displayProperty=nameWithType> Methode von der für die Sitzung konfigurierten-Tokenhandler das Token zu überprüfen, und extrahieren die Identitäten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Services.FederatedSessionExpiredException">Das Token ist abgelaufen.</exception>
        <exception cref="T:System.IdentityModel.Services.FederationException">Startzeit des Tokens ist noch nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine gültige Sitzungs-Tokenhandler konfiguriert ist nicht vorhanden. (Es ist keine <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> in konfiguriert die <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> Eigenschaft.)</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSessionTokenToCookie">
      <MemberSignature Language="C#" Value="public void WriteSessionTokenToCookie (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSessionTokenToCookie(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Das sitzungssicherheitstoken schreiben.</param>
        <summary>Schreibt das angegebene <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> auf ein Sitzungscookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schreibt das Cookie mithilfe des Cookie-Handlers, der im konfiguriert ist die <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessionToken" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine gültige Sitzungs-Tokenhandler konfiguriert ist nicht vorhanden. (Es ist keine <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> in konfiguriert die <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" /> Eigenschaft.)</exception>
      </Docs>
    </Member>
  </Members>
</Type>
