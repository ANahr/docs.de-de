<Type Name="AsyncFlowControl" FullName="System.Threading.AsyncFlowControl">
  <TypeSignature Language="C#" Value="public struct AsyncFlowControl : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AsyncFlowControl extends System.ValueType implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.AsyncFlowControl" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt die Funktionalität zum Wiederherstellen der Migration oder des Flusses des Ausführungskontexts zwischen Threads bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ausführungskontext enthält alle Informationen, die für einen logischen Thread die Ausführung bezogene. Der Fluss des Ausführungskontexts für andere Threads kann verhindert werden, indem Sie mit der <xref:System.Threading.ExecutionContext.SuppressFlow%2A?displayProperty=nameWithType> -Methode, die gibt eine <xref:System.Threading.AsyncFlowControl> Struktur. Die <xref:System.Threading.AsyncFlowControl.Undo%2A> Methode des zurückgegebenen <xref:System.Threading.AsyncFlowControl> -Struktur kann verwendet werden, die Unterdrückung Fluss rückgängig zu machen. Die <xref:System.Threading.AsyncFlowControl> Struktur muss verwendet werden, auf dem gleichen Thread auf dem es erstellt wurde.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Threading.AsyncFlowControl" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie `Dispose` auf, wenn Sie <xref:System.Threading.AsyncFlowControl> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Threading.AsyncFlowControl> nicht mehr verwendet werden kann. Nach dem Aufruf `Dispose`, müssen Sie alle Verweise auf Freigeben der <xref:System.Threading.AsyncFlowControl> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Threading.AsyncFlowControl> belegt wurde.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Threading.AsyncFlowControl> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Threading.AsyncFlowControl>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.AsyncFlowControl" /> Struktur wird nicht verwendet für den Thread, in dem es erstellt wurde.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.AsyncFlowControl" /> Struktur wurde bereits aufgerufen verwendet <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> oder <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit der aktuellen Struktur verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt gleich dem aktuellen <see cref="T:System.Threading.AsyncFlowControl" /> Struktur.</summary>
        <returns>
          <see langword="true" />Wenn <paramref name="obj" /> ist ein <see cref="T:System.Threading.AsyncFlowControl" /> -Struktur und gleich der aktuellen <see cref="T:System.Threading.AsyncFlowControl" /> Struktur; anderenfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Threading.AsyncFlowControl obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Threading.AsyncFlowControl obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Threading.AsyncFlowControl" />
      </Parameters>
      <Docs>
        <param name="obj">Eine <see cref="T:System.Threading.AsyncFlowControl" /> Struktur, mit der aktuellen Struktur verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Threading.AsyncFlowControl" /> Struktur ist gleich dem aktuellen <see cref="T:System.Threading.AsyncFlowControl" /> Struktur.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> der aktuellen <see cref="T:System.Threading.AsyncFlowControl" />-Struktur entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode für die aktuelle <see cref="T:System.Threading.AsyncFlowControl" /> Struktur.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Threading.AsyncFlowControl" /> Struktur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Threading.AsyncFlowControl a, System.Threading.AsyncFlowControl b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Threading.AsyncFlowControl a, valuetype System.Threading.AsyncFlowControl b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Threading.AsyncFlowControl" />
        <Parameter Name="b" Type="System.Threading.AsyncFlowControl" />
      </Parameters>
      <Docs>
        <param name="a">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
        <param name="b">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
        <summary>Vergleicht zwei <see cref="T:System.Threading.AsyncFlowControl" /> auszugeben, um zu bestimmen, ob sie gleich sind.</summary>
        <returns>
          <see langword="true" />Wenn die beiden Strukturen gleich sind. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die entsprechende Methode für diesen Operator ist <xref:System.Threading.AsyncFlowControl.Equals%28System.Threading.AsyncFlowControl%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Threading.AsyncFlowControl a, System.Threading.AsyncFlowControl b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Threading.AsyncFlowControl a, valuetype System.Threading.AsyncFlowControl b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Threading.AsyncFlowControl" />
        <Parameter Name="b" Type="System.Threading.AsyncFlowControl" />
      </Parameters>
      <Docs>
        <param name="a">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
        <param name="b">Eine <see cref="T:System.Threading.AsyncFlowControl" />-Struktur.</param>
        <summary>Vergleicht zwei <see cref="T:System.Threading.AsyncFlowControl" /> auszugeben, um zu bestimmen, ob diese ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn die Strukturen ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die entsprechende Methode für diesen Operator ist <xref:System.Threading.AsyncFlowControl.Equals%28System.Threading.AsyncFlowControl%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Undo">
      <MemberSignature Language="C#" Value="public void Undo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Undo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.AsyncFlowControl.Undo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt den Fluss des Ausführungskontexts zwischen Threads wieder her.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.ExecutionContext.SuppressFlow%2A?displayProperty=nameWithType> Methode gibt ein <xref:System.Threading.AsyncFlowControl> -Struktur, die zum Wiederherstellen des Flusses verwendet wird.  
  
 Die <xref:System.Threading.AsyncFlowControl.Undo%2A> -Methode muss aufgerufen werden, nur auf die <xref:System.Threading.AsyncFlowControl> Struktur zurückgegeben wird, indem Sie die zugehörigen <xref:System.Threading.ExecutionContext.SuppressFlow%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Threading.AsyncFlowControl" /> Struktur wird nicht verwendet für den Thread, in dem es erstellt wurde.  
  
 - oder -   
  
 Die <see cref="T:System.Threading.AsyncFlowControl" /> Struktur wurde bereits aufgerufen verwendet <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> oder <see cref="M:System.Threading.AsyncFlowControl.Undo" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
