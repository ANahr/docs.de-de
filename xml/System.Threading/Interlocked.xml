<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt atomare Vorgänge für Variablen bereit, die von mehreren Threads gemeinsam genutzt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden dieser Klasse schützen vor Fehlern, die auftreten können, wenn das Zeitplanungsmodul Kontexten wechselt, während ein Thread eine Variable aktualisiert, die von anderen Threads zugegriffen werden kann, oder wenn zwei Threads gleichzeitig auf separaten Prozessoren ausgeführt werden. Die Member dieser Klasse lösen keine Ausnahmen.  
  
 Die <xref:System.Threading.Interlocked.Increment%2A> und <xref:System.Threading.Interlocked.Decrement%2A> Methoden erhöhen oder verringern Sie eine Variable und den resultierenden Wert in einem einzigen Vorgang zu speichern. Bei den meisten Computern ist das Inkrementieren einer Variablen nicht atomare Operation unter erfordern die folgenden Schritte aus:  
  
1.  Laden Sie einen Wert aus einer Instanzvariablen in ein Register.  
  
2.  Erhöhen Sie oder verringern Sie den Wert.  
  
3.  Speichern Sie den Wert in der Instanzvariablen.  
  
 Wenn Sie nicht verwenden <xref:System.Threading.Interlocked.Increment%2A> und <xref:System.Threading.Interlocked.Decrement%2A>, kann ein Thread unterbrochen werden, nach der ersten beiden Schritte ausführen. Ein anderer Thread kann dann alle drei Schritte ausführen. Wenn der erste Thread die Ausführung fortsetzt, wird den Wert in der Instanzvariablen überschrieben und geht verloren, die Auswirkungen der das Inkrement oder Dekrement vom zweiten Thread ausgeführt.  
  
 Die <xref:System.Threading.Interlocked.Exchange%2A> Methode atomar tauscht die Werte der angegebenen Variablen. Die <xref:System.Threading.Interlocked.CompareExchange%2A> -Methode kombiniert zwei Operationen: Vergleichen von zwei Werten, und speichern eine dritte in eine der Variablen, abhängig vom Ergebnis des Vergleichs Wert. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt einen Thread-sichere Ressource Sperrmechanismus.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte befindet sich in <c>location1</c>.</param>
        <param name="value">Der Wert der Ganzzahl an hinzuzufügenden <c>location1</c>.</param>
        <summary>Fügt in einer atomaren Operation zwei 32-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
        <returns>Der neue Wert, der an gespeicherte <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt einen Überlauf durch wrapping: Wenn der Wert an `location1` ist <xref:System.Int32?displayProperty=nameWithType> und `value` 1 ist, ist das Ergebnis <xref:System.Int32?displayProperty=nameWithType>; Wenn `value` gleich 2 ist, ist das Ergebnis (<xref:System.Int32?displayProperty=nameWithType> + 1); und so weiter. Es werden keine Ausnahmen ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte befindet sich in <c>location1</c>.</param>
        <param name="value">Der Wert der Ganzzahl an hinzuzufügenden <c>location1</c>.</param>
        <summary>Fügt in einer atomaren Operation zwei 64-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
        <returns>Der neue Wert, der an gespeicherte <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt einen Überlauf durch wrapping: Wenn der Wert an `location1` ist <xref:System.Int64?displayProperty=nameWithType> und `value` 1 ist, ist das Ergebnis <xref:System.Int64?displayProperty=nameWithType>; Wenn `value` gleich 2 ist, ist das Ergebnis (<xref:System.Int64?displayProperty=nameWithType> + 1); und so weiter. Es werden keine Ausnahmen ausgelöst.  
  
 Die <xref:System.Threading.Interlocked.Read%2A> -Methode und die 64-Bit-Überladungen der <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, und <xref:System.Threading.Interlocked.Add%2A> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <xref:System.IntPtr?displayProperty=nameWithType> 64 Bit lang ist. Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten. Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <xref:System.Threading.Interlocked> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert verglichen mit <c>Comparand</c> und möglicherweise ersetzt.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der verglichen wird, den Wert am <c>location1</c>.</param>
        <summary>Vergleicht zwei Gleitkommazahlen mit doppelter Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert der <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine threadsichere-Methode, die eine laufende Summe akkumuliert <xref:System.Double> Werte. Zwei Threads hinzufügen, eine Reihe von <xref:System.Double> Werte mit der Thread-sichere Methode und dem normalen hinzufügen und beim Beenden der Threads die Ergebnisse werden verglichen. Auf einem Computer mit Dual-Prozessor ist es ein signifikanter Unterschied bei den Gesamtergebnissen.  
  
 In der Thread-sichere Methode, der anfängliche Wert des der laufenden Summe gespeichert wird, und klicken Sie dann die <xref:System.Threading.Interlocked.CompareExchange%2A> Methode wird verwendet, um die neu berechneten insgesamt mit den alten Gesamtwert austauschen. Ist der Rückgabewert nicht gleich dem gespeicherten Wert für die laufende Summe, hat dann einen anderen Thread die Summe in der Zwischenzeit aktualisiert. In diesem Fall muss der Versuch, die laufende Summe aktualisieren wiederholt werden.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert verglichen mit <c>Comparand</c> und möglicherweise ersetzt.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der verglichen wird, den Wert am <c>location1</c>.</param>
        <summary>Vergleicht zwei 32-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert der <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine threadsichere-Methode, die einen laufenden Gesamtbetrag ansammelt. Der Anfangswert von der laufenden Summe gespeichert wird, und klicken Sie dann die <xref:System.Threading.Interlocked.CompareExchange%2A> Methode wird verwendet, um die neu berechneten insgesamt mit den alten Gesamtwert austauschen. Ist der Rückgabewert nicht gleich dem gespeicherten Wert für die laufende Summe, hat dann einen anderen Thread die Summe in der Zwischenzeit aktualisiert. In diesem Fall muss der Versuch, die laufende Summe aktualisieren wiederholt werden.  
  
> [!NOTE]
>  Die <xref:System.Threading.Interlocked.Add%2A> -Methode, eingeführt in Version 2.0 von .NET Framework bietet einen Bequemerer Weg, Thread-sichere laufende Summen für ganze Zahlen zu sammeln.  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert verglichen mit <c>Comparand</c> und möglicherweise ersetzt.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der verglichen wird, den Wert am <c>location1</c>.</param>
        <summary>Vergleicht zwei 64-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert der <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel <see cref="T:System.IntPtr" />, dessen Wert mit dem Wert verglichen wird <c>Comparand</c> und möglicherweise ersetzt durch <c>Wert</c>.</param>
        <param name="value">Die <see cref="T:System.IntPtr" /> , die den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Die <see cref="T:System.IntPtr" /> , im Vergleich zu den Wert am <c>location1</c>.</param>
        <summary>Vergleicht zwei plattformspezifische Handles oder Zeiger hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert dieser Methode wird der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
> [!NOTE]
>  <xref:System.IntPtr>ist ein Plattformspezifischer Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Das Zielobjekt, das mit dem verglichen wird <c>Comparand</c> und möglicherweise ersetzt.</param>
        <param name="value">Das Objekt, das das Zielobjekt ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Das Objekt, das verglichen wird, das Objekt am <c>location1</c>.</param>
        <summary>Vergleicht zwei Objekte hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit das erste Objekt.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und das Objekt im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert der <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
 Ab .NET Framework, Version 2.0, die <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> methodenüberladung bietet eine typsichere Alternative für Verweistypen.  
  
> [!NOTE]
>  Die Objekte für vergleichsgleichheit, verglichen werden und nicht als <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Daher zwei geschachtelte Instanzen des gleichen Werttyp (z. B. die ganze Zahl 3) immer angezeigt werden, und es wird kein Vorgang ausgeführt. Verwenden Sie diese Überladung nicht mit Werttypen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert verglichen mit <c>Comparand</c> und möglicherweise ersetzt.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der verglichen wird, den Wert am <c>location1</c>.</param>
        <summary>Vergleicht zwei Gleitkommazahlen mit einfacher Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert der <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine threadsichere-Methode, die eine laufende Summe akkumuliert <xref:System.Single> Werte. Zwei Threads hinzufügen, eine Reihe von <xref:System.Single> Werte mit der Thread-sichere Methode und dem normalen hinzufügen und beim Beenden der Threads die Ergebnisse werden verglichen. Auf einem Computer mit Dual-Prozessor ist es ein signifikanter Unterschied bei den Gesamtergebnissen.  
  
 In der Thread-sichere Methode, der anfängliche Wert des der laufenden Summe gespeichert wird, und klicken Sie dann die <xref:System.Threading.Interlocked.CompareExchange%2A> Methode wird verwendet, um die neu berechneten insgesamt mit den alten Gesamtwert austauschen. Ist der Rückgabewert nicht gleich dem gespeicherten Wert für die laufende Summe, hat dann einen anderen Thread die Summe in der Zwischenzeit aktualisiert. In diesem Fall muss der Versuch, die laufende Summe aktualisieren wiederholt werden.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ, für die zu verwendende <c>location1</c>, <c>Wert</c>, und <c>Comparand</c>. Dieser Typ muss ein Referenztyp sein.</typeparam>
        <param name="location1">Das Ziel, dessen Wert verglichen mit <c>Comparand</c> und möglicherweise ersetzt. Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der verglichen wird, den Wert am <c>location1</c>.</param>
        <summary>Vergleicht zwei Instanzen des angegebenen Verweistyps <paramref name="T" /> Gleichheit und, wenn sie gleich sind, ersetzt die erste Vorlage.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert im `location1` gleich sind, klicken Sie dann `value` befindet sich in `location1`. Andernfalls wird kein Vorgang ausgeführt. Der Vergleich und die Exchange werden als atomarer Vorgang ausgeführt. Der Rückgabewert dieser Methode wird der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-stattfindet.  
  
 Diese Methode unterstützt nur Verweistypen. Es gibt Überladungen der der <xref:System.Threading.Interlocked.CompareExchange%2A> Methode für die Werttypen <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, und <xref:System.Double>, aber es gibt keine Unterstützung für andere Werttypen.  
  
> [!NOTE]
>  Diese methodenüberladung ist zu bevorzugen die <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> Methode zu überladen, da letztere spät gebundener Zugriff auf das Zielobjekt ist erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert verringert werden.</param>
        <summary>Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der dekrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt einen Überlauf durch wrapping: Wenn `location`  =  <xref:System.Int32?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32?displayProperty=nameWithType>. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgende Beispiel wird bestimmt, wie viele Zufallszahlen, die zwischen 0 und 1000 liegen 1.000 Zufallszahlen mit einem Wert für den Mittelpunkt erforderlich sind. Die Anzahl der Werte für Mittelpunkt, eine Variable des `midpointCount`, ist gleich 1.000 und dekrementiert jedes Mal der Zufallszahlen-Generator einen Wert für den Mittelpunkt gibt. Da drei Threads, die Zufallszahlen generieren die <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> Methode wird aufgerufen, um sicherzustellen, dass mehrere Threads nicht aktualisieren `midpointCount` gleichzeitig. Beachten Sie, dass eine Sperre auch verwendet wird, schützen Sie den Zufallszahlen-Generator und, ein <xref:System.Threading.CountdownEvent> Objekt wird verwendet, um sicherzustellen, dass die `Main` Methode nicht ausführen, bevor der drei Threads abgeschlossen.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 Im folgende Beispiel ähnelt der vorherigen Ansicht identisch, jedoch verwendet die anstelle einer Threadprozedur 50.000 Mittelpunkt zufällige ganze Zahlen zu generieren. In diesem Beispiel wird ein Lambda-Ausdruck ersetzt die `GenerateNumbers` Threadprozedur und der Aufruf an die <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode entfällt die Notwendigkeit für die <xref:System.Threading.CountdownEvent> Objekt.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert verringert werden.</param>
        <summary>Dekrementiert den Wert der angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der dekrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt einen Überlauf durch wrapping: Wenn `location`  =  <xref:System.Int64?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64?displayProperty=nameWithType>. Es werden keine Ausnahmen ausgelöst.  
  
 Die <xref:System.Threading.Interlocked.Read%2A> -Methode und die 64-Bit-Überladungen der <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, und <xref:System.Threading.Interlocked.Add%2A> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <xref:System.IntPtr?displayProperty=nameWithType> 64 Bit lang ist. Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten. Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <xref:System.Threading.Interlocked> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation eine Gleitkommazahl mit doppelter Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt eine 32-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt einen Thread-sichere Ressource Sperrmechanismus.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt eine 64-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation ein plattformspezifisches Handle bzw. einen plattformspezifischen Zeiger auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation ein Objekt auf einen angegebenen Wert fest und gibt einen Verweis auf das ursprüngliche Objekt zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab .NET Framework, Version 2.0, die <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> methodenüberladung bietet eine typsichere Alternative für Verweistypen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Syntax für die Verwendung von `Exchange` bei jedem Verweis Typ-Objekt.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation eine Gleitkommazahl mit einfacher Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ, für die zu verwendende <c>location1</c> und <c>Wert</c>. Dieser Typ muss ein Referenztyp sein.</typeparam>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll. Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
        <param name="value">Der Wert, der <c>location1</c> Parameter festgelegt ist.</param>
        <summary>Legt eine Variable vom angegebenen Typ <paramref name="T" /> in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nur Verweistypen. Es gibt Überladungen der der <xref:System.Threading.Interlocked.Exchange%2A> Methode für die <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, und <xref:System.Double> Werttypen, aber es gibt keine Unterstützung für andere Werttypen.  
  
> [!NOTE]
>  Diese methodenüberladung ist zu bevorzugen die <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> Methode zu überladen, da letztere spät gebundener Zugriff auf das Zielobjekt ist erforderlich.  
  
   
  
## Examples  
 Im folgende Beispiel werden zehn Aufgaben, von die jede 100 zehn Zeichen Teilenummern generiert gestartet. Es wird dann die Teilenummer, das zuerst in alphabetischer Reihenfolge.  
  
 [!code-csharp[System.Threading.Interlocked.Exchange#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/CS/Exchange5.cs#2)]
 [!code-vb[System.Threading.Interlocked.Exchange#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange/VB/Exchange5.vb#2)]  
  
 Im Beispiel wird die `firstWidget` Variable zum Speichern der ID, die zuerst erreicht wird, in der Sortierreihenfolge. Es vergleicht jede ID, die sie mit generiert die `firstWidget` Wert.  Wenn der neue Wert den aktuellen Wert der voransteht `firstWidget` in der Sortierreihenfolge im Beispiel wird die <xref:System.Threading.Interlocked.Exchange%2A> Methode, um den neuen Wert zuzuweisen `firstWidget`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert inkrementiert werden soll.</param>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der inkrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt einen Überlauf durch wrapping: Wenn `location`  =  <xref:System.Int32?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32?displayProperty=nameWithType>. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgende Beispiel wird bestimmt, wie viele Zufallszahlen, die zwischen 0 und 1000 liegen 1.000 Zufallszahlen mit einem Wert für den Mittelpunkt erforderlich sind. Die Anzahl der Werte für Mittelpunkt, eine Variable des `midpointCount`, gleich 0 festgelegt und inkrementiert jedes Mal der Zufallszahlen-Generator einen Wert für den Mittelpunkt gibt bis 10.000 erreicht ist. Da drei Threads, die Zufallszahlen generieren die <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> Methode wird aufgerufen, um sicherzustellen, dass mehrere Threads nicht aktualisieren `midpointCount` gleichzeitig. Beachten Sie, dass eine Sperre auch verwendet wird, schützen Sie den Zufallszahlen-Generator und, ein <xref:System.Threading.CountdownEvent> Objekt wird verwendet, um sicherzustellen, dass die `Main` Methode nicht ausführen, bevor der drei Threads abgeschlossen.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 Im folgende Beispiel ähnelt der vorherigen Ansicht identisch, jedoch verwendet die anstelle einer Threadprozedur 50.000 Mittelpunkt zufällige ganze Zahlen zu generieren. In diesem Beispiel wird ein Lambda-Ausdruck ersetzt die `GenerateNumbers` Threadprozedur und der Aufruf an die <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode entfällt die Notwendigkeit für die <xref:System.Threading.CountdownEvent> Objekt.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert inkrementiert werden soll.</param>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der inkrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt einen Überlauf durch wrapping: Wenn `location`  =  <xref:System.Int64?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64?displayProperty=nameWithType>. Es werden keine Ausnahmen ausgelöst.  
  
 Die <xref:System.Threading.Interlocked.Read%2A> -Methode und die 64-Bit-Überladungen der <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, und <xref:System.Threading.Interlocked.Add%2A> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <xref:System.IntPtr?displayProperty=nameWithType> 64 Bit lang ist. Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten. Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <xref:System.Threading.Interlocked> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronisiert die Speicherzugriff wie folgt: kann nicht in der Prozessor, der den aktuellen Thread ausführt Anweisungen neu anordnen so, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> ausgeführt wird, nachdem die Speicherzugriffe, die dem Aufruf <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wurde hinzugefügt, um die <xref:System.Threading.Interlocked> -Klasse in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] einen Schlüsselverweis; es ist ein Wrapper für die <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> Methode.  
  
 <xref:System.Threading.Interlocked.MemoryBarrier%2A>ist nur auf Systemen mit mehreren Prozessoren erforderlich, die über unsichere Arbeitsspeicher Reihenfolge (z. B. ein System, das verwendet wird. mehrere Intel Itanium-Prozessoren).  
  
 Für die Mehrzahl der Fälle, die C#- `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung oder der <xref:System.Threading.Monitor> Klasse bereitstellen einfachere Möglichkeiten zur Synchronisierung von Daten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Der zu ladende 64-Bit-Wert.</param>
        <summary>Gibt einen 64-Bit-Wert zurück, der in einer atomaren Operation geladen wird.</summary>
        <returns>Der geladene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Interlocked.Read%2A> Methode ist nicht auf 64-Bit-Systemen erforderlich, da 64-Bit-Lesevorgänge bereits atomar sind. Auf 32-Bit-Systemen, 64-Bit-Lesevorgänge sind nicht atomaren, es sei denn, die mit ausgeführt <xref:System.Threading.Interlocked.Read%2A>.  
  
 Die <xref:System.Threading.Interlocked.Read%2A> -Methode und die 64-Bit-Überladungen der <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, und <xref:System.Threading.Interlocked.Add%2A> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <xref:System.IntPtr?displayProperty=nameWithType> 64 Bit lang ist. Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten. Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <xref:System.Threading.Interlocked> Klasse.  
  
> [!NOTE]
>  <xref:System.IntPtr>ist ein Plattformspezifischer Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
