<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementiert die Berkeley-Sockets-Schnittstelle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket> Klasse bietet einen umfangreichen Satz von Methoden und Eigenschaften für die Netzwerkkommunikation. Die <xref:System.Net.Sockets.Socket> Klasse ermöglicht sowohl synchrone und asynchrone Datenübertragung mithilfe der Protokolle für die Kommunikation in der <xref:System.Net.Sockets.ProtocolType> Enumeration.  
  
 Die <xref:System.Net.Sockets.Socket> Klasse folgt das Benennungsmuster von .NET Framework für asynchrone Methoden. Angenommen, die synchrone <xref:System.Net.Sockets.Socket.Receive%2A> Methode entspricht, auf den asynchronen <xref:System.Net.Sockets.Socket.BeginReceive%2A> und <xref:System.Net.Sockets.Socket.EndReceive%2A> Methoden.  
  
 Wenn Ihre Anwendung während der Ausführung nur einen Thread erfordert, verwenden Sie die folgenden Methoden, die für den synchronen Betriebsmodus entworfen werden.  
  
-   Wenn Sie ein verbindungsorientiertes Protokoll wie TCP verwenden, kann der Server für Verbindungen mit dem Lauschen die <xref:System.Net.Sockets.Socket.Listen%2A> Methode. Die <xref:System.Net.Sockets.Socket.Accept%2A> Methode Prozesse eingehende Verbindung anfordert, und gibt eine <xref:System.Net.Sockets.Socket> , dass Sie verwenden können, um Daten mit dem Remotehost kommunizieren. Verwenden Sie diesen zurückgegebenen <xref:System.Net.Sockets.Socket> zum Aufrufen der <xref:System.Net.Sockets.Socket.Send%2A> oder <xref:System.Net.Sockets.Socket.Receive%2A> Methode. Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode vor dem Aufruf der <xref:System.Net.Sockets.Socket.Listen%2A> Methode, wenn Sie die lokale IP-Adresse und Port-Nummer angeben möchten. Verwenden Sie die Portnummer 0 (null), wenn Sie den zugrunde liegenden Dienstanbieter einen freien Anschluss zuweisen möchten. Wenn Sie einen überwachenden Host eine Verbindung herstellen möchten, rufen Sie die <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Um Daten zu kommunizieren, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> oder <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
-   Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht zum Lauschen auf Verbindungen an. Rufen Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode, um eingehende Datagramme zu akzeptieren. Verwenden der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode, um Datagramme mit einem Remotehost senden.  
  
 Verwenden Sie zum Verarbeiten der Kommunikation mit separaten Threads während der Ausführung der folgenden Methoden, die für den asynchronen Vorgang Modus vorgesehen sind.  
  
-   Wenn Sie ein verbindungsorientiertes Protokoll wie TCP verwenden, verwenden Sie die <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, und <xref:System.Net.Sockets.Socket.EndConnect%2A> Methoden für die Verbindung mit einem überwachenden Host. Verwenden der <xref:System.Net.Sockets.Socket.BeginSend%2A> und <xref:System.Net.Sockets.Socket.EndSend%2A> oder <xref:System.Net.Sockets.Socket.BeginReceive%2A> und <xref:System.Net.Sockets.Socket.EndReceive%2A> Methoden, um Daten asynchron kommunizieren. Eingehende verbindungsanforderungen mit verarbeitet <xref:System.Net.Sockets.Socket.BeginAccept%2A> und <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, können Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und <xref:System.Net.Sockets.Socket.EndSendTo%2A> Datagramme senden und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> und <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> um Datagramme zu empfangen.  
  
 Wenn Sie mehrere asynchrone Vorgänge für ein Socket ausführen, sie nicht unbedingt in der Reihenfolge abgeschlossen in denen sie gestartet wurden.  
  
 Wenn Sie nicht mehr benötigen, senden und Empfangen von Daten sind, verwenden Sie die <xref:System.Net.Sockets.Socket.Shutdown%2A> Methode zum Deaktivieren der <xref:System.Net.Sockets.Socket>. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Shutdown%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode, um alle zugeordneten Ressourcen freizugeben. der <xref:System.Net.Sockets.Socket>.  
  
 Die <xref:System.Net.Sockets.Socket> -Klasse ermöglicht es Ihnen so konfigurieren Sie Ihre <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode. Rufen Sie diese Einstellungen über die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie eine relativ einfache Anwendung schreiben und nicht die maximale Leistung benötigen, erwägen Sie <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, und <xref:System.Net.Sockets.UdpClient>. Diese Klassen bieten eine einfachere und benutzerfreundlichere Oberfläche für <xref:System.Net.Sockets.Socket> Kommunikation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht wie die <xref:System.Net.Sockets.Socket> Klasse kann verwendet werden, um Daten an einem HTTP-Server senden und Empfangen der Antwort. In diesem Beispiel wird blockiert, bis die gesamte Seite empfangen wird.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Um eine ausgehende Verbindung herzustellen, oder übernehmen Sie eine eingehende Anforderung.</permission>
    <threadsafe>Instanzen dieser Klasse sind threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Die Socketinformationen zurückgegebenes <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Sockets.Socket" /> -Klasse mithilfe des angegebenen Werts zurückgegebenen aus <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Net.Sockets.Socket.%23ctor%2A> Konstruktor mehrmals mit demselben Bytearray als Argument für jeden Aufruf, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket>mit den gleichen zugrunde liegenden Socket. Dieses Vorgehen wird dringend abgeraten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Sockets.Socket" /> -Klasse mit den angegebenen Sockettyp und im Protokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `socketType` Parameter gibt den Typ des der <xref:System.Net.Sockets.Socket> Klasse und die `protocolType` Parameter gibt an, die vom verwendeten Protokolls <xref:System.Net.Sockets.Socket>. Die beiden Parameter sind nicht voneinander unabhängig. Häufig die <xref:System.Net.Sockets.Socket> Typ ist implizit in das Protokoll. Wenn die Kombination von <xref:System.Net.Sockets.Socket> Typ und im Protokoll geben Ergebnisse in eine ungültige <xref:System.Net.Sockets.Socket>, löst der Konstruktor eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn dieses Konstruktors löst eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Kombination von <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</param>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Net.Sockets.Socket" /> -Klasse mit den angegebenen Adressfamilie, Sockettyp und im Protokoll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `addressFamily` Parameter gibt an, die Adressierung, die Schemas der <xref:System.Net.Sockets.Socket> -Klasse verwendet, die `socketType` Parameter gibt den Typ des der <xref:System.Net.Sockets.Socket> -Klasse, und die `protocolType` Parameter gibt an, die vom verwendeten Protokolls <xref:System.Net.Sockets.Socket>. Die drei Parameter sind nicht voneinander unabhängig. Einige Adressfamilien einschränken, welche Protokolle verwendet werden können, und oft das <xref:System.Net.Sockets.Socket> Typ ist implizit in das Protokoll. Wenn die Kombination aus Adressfamilie, <xref:System.Net.Sockets.Socket> Typ, und geben Sie die Ergebnisse in ein ungültiges Protokoll <xref:System.Net.Sockets.Socket>, löst der Konstruktor eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn dieses Konstruktors löst eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer Instanz von der <xref:System.Net.Sockets.Socket> Klasse.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Kombination von <paramref name="addressFamily" />, <paramref name="socketType" />, und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A>synchron extrahiert das erste ausstehende verbindungsanforderung aus der Warteschlange die empfangsbereiten Sockets und Verbindung erstellt und gibt eine neue <xref:System.Net.Sockets.Socket>. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Sie können jedoch Aufrufen der <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Methode des zurückgegebenen <xref:System.Net.Sockets.Socket> auf dem Remotehost Netzwerk Adresse und Anschlussnummer identifizieren.  
  
 Im blockierenden Modus <xref:System.Net.Sockets.Socket.Accept%2A> blockiert, bis eine eingehende Verbindung in die Warteschlange gestellt wird. Sobald eine Verbindung akzeptiert wird, die ursprüngliche <xref:System.Net.Sockets.Socket> queuing eingehende verbindungsanforderungen bis schließen sie fortgesetzt.  
  
 Wenn Sie diese Methode mit einem nicht blockierenden Aufrufen <xref:System.Net.Sockets.Socket>, und es ist keine Verbindung mit dem Anforderungen sind in der Warteschlange, <xref:System.Net.Sockets.Socket.Accept%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vor dem Aufruf der <xref:System.Net.Sockets.Socket.Accept%2A> -Methode, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.Listen%2A> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird akzeptiert, ein einfaches <xref:System.Net.Sockets.Socket> Verbindung.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht für Verbindungen nicht. Rufen Sie <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> und <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> vor dem Aufruf <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Startet einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Akzeptieren von Verbindungen asynchron bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Vor dem Aufruf der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.  
  
 Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs > delegieren und verknüpfen Sie ihn auf die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer angeben kann, optional eine vorhandene <xref:System.Net.Sockets.Socket> verwenden für die eingehende Verbindung durch Angabe der <xref:System.Net.Sockets.Socket> für die Verwendung mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> -Eigenschaft null ist, ist ein neues <xref:System.Net.Sockets.Socket> wird erstellt, mit dem gleichen <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, und <xref:System.Net.Sockets.Socket.ProtocolType%2A> wie die aktuelle <xref:System.Net.Sockets.Socket> und legen Sie als die <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Optional kann ein Puffer bereitgestellt werden, in dem den erste Block von Daten auf den Socket empfangen die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wird. In diesem Fall die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> -Eigenschaft muss in den Puffer mit den Daten festgelegt werden, zum Empfangen und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft muss auf die maximale Anzahl der Bytes der Daten festgelegt werden, um in den Puffer zu erhalten. Diese Eigenschaften können festgelegt werden, mithilfe der <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> Methode. Teil des übergebenen Puffers wird intern verwendet werden, für die Verwendung durch die zugrunde liegenden Winsock AcceptEx-Aufruf. Dies bedeutet, dass die Menge der zurückgegebenen Daten immer kleiner als der Wert, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Eigenschaft auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> bereitgestellten Instanz. Die Menge des Puffers wird intern verwendet, hängt von der Adressfamilie des Sockets. Die erforderliche minimale Puffergröße ist 288 Byte. Wenn Sie ein größeren Puffer angegeben wird, und klicken Sie dann die <xref:System.Net.Sockets.Socket> erwarten, dass einige zusätzlichen Daten außer den Adressdaten von Winsock AcceptEx empfangene und wartet, bis diese zusätzlichen Daten empfangen werden. Wenn ein Timeout auftritt, wird die Verbindung zurückgesetzt. Also wenn zusätzliche Daten von einem bestimmten Zeitraum erwartet werden, sollten dann die Größe des Puffers an der minimalen Puffergröße plus diese Menge festgelegt werden.  
  
 Die Abschlussrückrufmethode überprüfen sollten die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Eigenschaft, um festzustellen, wo die <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Vorgang war erfolgreich.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis kann in einigen Fällen auftreten, wenn keine Verbindung akzeptiert wurde, und dazu führen, dass die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Eigenschaft festgelegt werden, um <xref:System.Net.Sockets.SocketError.ConnectionReset>. Dies ist möglich durch Scannen von Ports mit einem halb geöffneten SYN-Typ-Scan (SYN-SYN-ACK-> -> RST-Sequenz). Anwendungen, die mithilfe der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode sollten darauf vorbereitet sein, diese Konstellation behandeln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn der bereitgestellte Puffer nicht groß genug ist. Der Puffer muss mindestens 2 * (sizeof(SOCKADDR_STORAGE + 16) Bytes.  
  
 Diese Ausnahme tritt auch auf, wenn mehrere Puffer angegeben werden, die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> -Eigenschaft nicht null ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Argument liegt außerhalb des gültigen Bereichs. Die Ausnahme tritt auf, wenn die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde ein ungültiger Vorgang angefordert. Diese Ausnahme tritt auf, wenn die akzeptieren <see cref="T:System.Net.Sockets.Socket" /> hört nicht für Verbindungen oder die akzeptierte Socket gebunden ist.  
  
 Rufen Sie die <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> und <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> Methode vor dem Aufruf der <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> Methode.  
  
 Diese Ausnahme tritt auch auf, wenn der Socket bereits verbunden ist oder bei einem Socketvorgang war bereits läuft unter Verwendung des angegebenen <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adressfamilie von der <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.AddressFamily> gibt an, die Adressierung von Schemas, die einer Instanz von der <xref:System.Net.Sockets.Socket> Klasse verwenden kann. Diese Eigenschaft ist schreibgeschützt und wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> wird erstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, und <xref:System.Net.Sockets.ProtocolType> an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenmenge ab, die über das Netzwerk empfangen wurde und gelesen werden kann.</summary>
        <value>Die Anzahl der Datenbytes, die vom Netzwerk empfangen wurden und zum Lesen zur Verfügung stehen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie einen nicht blockierenden verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> ist eine gute Möglichkeit, um festzustellen, ob die Daten lesen, vor einem Aufruf in die Warteschlange eingereiht werden <xref:System.Net.Sockets.Socket.Receive%2A>. Die verfügbaren Daten ist die Gesamtmenge der Daten im Netzwerkpuffer zum Lesen in die Warteschlange eingereiht. Wenn keine Daten im Netzwerkpuffer, in der Warteschlange ist <xref:System.Net.Sockets.Socket.Available%2A> gibt 0 zurück.  
  
 Wenn der remote-Host heruntergefahren oder die Verbindung schließt <xref:System.Net.Sockets.Socket.Available%2A> festgehaltenen eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Ergebnisse des Aufrufs von IOControl mit FIONREAD und verfügbare Eigenschaft verglichen.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Startet einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> verweist, die auf den asynchronen <see cref="T:System.Net.Sockets.Socket" /> erstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Akzeptieren von Verbindungen asynchron bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.  
  
 Müssen Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Dazu zumindest müssen Sie übergeben, der überwacht <xref:System.Net.Sockets.Socket> -Objekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über die `state` Parameter. Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wurde. <xref:System.Net.Sockets.Socket.EndAccept%2A>Gibt zurück, ein neues <xref:System.Net.Sockets.Socket> Objekt, das Sie zum Senden und Empfangen von Daten mit dem Remotehost verwenden können. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode auf eine <xref:System.Threading.ManualResetEvent> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.  
  
 Das System kann den aufrufenden Thread auch verwenden, die Rückrufmethode aufgerufen. In diesem Fall die <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft für das zurückgegebene <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> auf dem Remotehost Netzwerk Adresse und Anschlussnummer identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code erhalten haben, finden Sie in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird versucht, eine eingehende Verbindung asynchron zu empfangen.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht für Verbindungen nicht. Rufen Sie <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> und <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> vor dem Aufruf <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
 - oder -   
  
 Der angenommene Socket gebunden ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Die Anzahl der Bytes, die vom Absender zu akzeptieren.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Startet einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen und empfängt die erste von der Clientanwendung gesendeten Datenblock.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> verweist, die auf den asynchronen <see cref="T:System.Net.Sockets.Socket" /> erstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Akzeptieren von Verbindungen asynchron ermöglicht es Ihnen zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Diese Überladung ermöglicht Ihnen die Angabe der Anzahl der Bytes, die in der ersten Übertragung akzeptiert die `receiveSize` Parameter.  
  
 Vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.  
  
 Müssen Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Dazu zumindest müssen Sie übergeben, der überwacht <xref:System.Net.Sockets.Socket> -Objekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über die `state` Parameter. Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wurde.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Gibt eine neue <xref:System.Net.Sockets.Socket> , dass Sie zum Senden und Empfangen von Daten mit dem Remotehost verwenden können. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode auf eine <xref:System.Threading.ManualResetEvent> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.  
  
 Das System kann den aufrufenden Thread auch verwenden, die Rückrufmethode aufgerufen. In diesem Fall die <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft für das zurückgegebene <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>.  Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können mit Aufrufen der <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> Objekt, mit dem Remotehost Netzwerk-Adresse und Port-Nummer angegeben.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert. In diesem Beispiel nimmt der Socket die ersten 10 Bytes der Daten. Die Anzahl der empfangenen Bytes und die Daten werden vom Rückrufdelegaten auf der Konsole angezeigt. Finden Sie unter <xref:System.Net.Sockets.Socket.BeginReceive%2A> eine Beschreibung, wie die übrigen Daten empfangen werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht für Verbindungen nicht. Rufen Sie <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> und <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> vor dem Aufruf <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
 - oder -   
  
 Der angenommene Socket gebunden ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Das angenommene <see cref="T:System.Net.Sockets.Socket" />-Objekt. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="receiveSize">Die maximale Anzahl von Bytes zu erhalten.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Startet einen asynchronen Vorgang, um eine eingehende Verbindung von einem angegebenen Socket anzunehmen und empfängt die erste von der Clientanwendung gesendeten Datenblock.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den asynchronen verweist <see cref="T:System.Net.Sockets.Socket" /> Objekt erstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Akzeptieren von Verbindungen asynchron bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Diese Überladung ermöglicht Ihnen das Festlegen der angenommenen Sockets in der `acceptSocket` Parameter. Wenn dieser Parameter ist `null`, angenommenen Sockets wird erstellt, indem die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Sie können angeben, die Anzahl der Bytes, die in der ersten Übertragung akzeptiert die `receiveSize` Parameter.  
  
 Vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.  
  
 Müssen Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Dazu zumindest müssen Sie übergeben, der überwacht <xref:System.Net.Sockets.Socket> -Objekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über die `state` Parameter. Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wurde.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Gibt eine neue <xref:System.Net.Sockets.Socket> Objekt, das Sie zum Senden und Empfangen von Daten mit dem Remotehost verwenden können. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode auf eine <xref:System.Threading.ManualResetEvent> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.  
  
 Das System kann den aufrufenden Thread auch verwenden, die Rückrufmethode aufgerufen. In diesem Fall die <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft für das zurückgegebene <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> Objekt, mit dem Remotehost Netzwerk-Adresse und Port-Nummer angegeben.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert. In diesem Beispiel wird der Socket akzeptiert die ersten 10 Bytes der Daten und die `acceptSocket` Parameter ist `null`, welche erzwingt, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode, um die angenommenen Sockets erstellen. Die Anzahl der empfangenen Bytes und die Daten werden vom Rückrufdelegaten auf der Konsole angezeigt. Finden Sie unter <xref:System.Net.Sockets.Socket.BeginReceive%2A> eine Beschreibung, wie die übrigen Daten empfangen werden.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht für Verbindungen nicht. Rufen Sie <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> und <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> vor dem Aufruf <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
 - oder -   
  
 Der angenommene Socket gebunden ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="end_point">To be added.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode startet eine asynchrone Anforderung einer Verbindung mit der `remoteEP` Parameter. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.BeginConnect%2A> stellt eine Standard-Remotehost her. Herstellen einer Verbindung oder die Standard-Remotehost asynchron festlegen bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode. Sie müssen zumindest, übergeben die <xref:System.Net.Sockets.Socket> auf <xref:System.Net.Sockets.Socket.BeginConnect%2A> über die `state` Parameter. Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket>, und die anderen erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndConnect%2A> bis der <xref:System.Net.Sockets.Socket> eine Verbindung hergestellt oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode <xref:System.Threading.WaitHandle.WaitOne%2A>. Rufen Sie die Set-Methode auf eine <xref:System.Threading.ManualResetEvent> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.BeginConnect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> für die Kommunikation mit einem Remotehost. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.BeginConnect%2A>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen. Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und legen Sie die Übertragung auf `true`. Wenn Sie nicht möglich, <xref:System.Net.Sockets.Socket.BeginConnect%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll und Sie nicht rufen <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginConnect%2A>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, der Service Provider nicht weist eine lokale Adresse und Anschlussnummer Netzwerknummer erst nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginSend%2A> oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode erneut mit den gewünschten Endpunkt.  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, oder ein asynchroner Vorgang bereits ausgeführt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Die <see cref="T:System.Net.IPAddress" /> des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="callback">To be added.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird zum Übergeben der <c>RequestCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird angegeben, indem ein <see cref="T:System.Net.IPAddress" /> und eine Portnummer an.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `requestCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Connect%2A> -methodenüberladungen, oder <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter. Auch die <xref:System.Net.EndPoint> also verwendet, müssen jedoch verschieden sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Net.Sockets.Socket" /> befindet sich nicht in der Socketfamilie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, oder ein asynchroner Vorgang bereits ausgeführt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">Mindestens ein <see cref="T:System.Net.IPAddress" />, den Remotehost angibt.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="callback">To be added.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird zum Übergeben der <c>RequestCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird angegeben, indem ein <see cref="T:System.Net.IPAddress" /> Array und eine Portnummer an.</summary>
        <returns>Eine <see cref="T:System.IAsyncResult" /> , die auf die asynchronen Verbindungen verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `requestCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Connect%2A> Überladungen der Methode.  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Aufrufen synchroner Methoden asynchron](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter. Auch die <xref:System.Net.EndPoint> also verwendet, müssen jedoch verschieden sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets, <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, oder ein asynchroner Vorgang bereits ausgeführt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">Der Name des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="callback">To be added.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird zum Übergeben der <c>RequestCallback</c> delegieren, wenn der Vorgang abgeschlossen ist.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `requestCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Connect%2A> Überladungen der Methode.  
  
 Einen ausstehenden Aufruf Abbrechen der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode schließen die <xref:System.Net.Sockets.Socket>. Wenn die <xref:System.Net.Sockets.Socket.Close%2A> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter. Auch die <xref:System.Net.EndPoint> also verwendet, müssen jedoch verschieden sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, oder ein asynchroner Vorgang bereits ausgeführt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" />Wenn diesem Socket wiederverwendet werden kann, nachdem die Verbindung geschlossen wird; andernfalls <see langword="false" />.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt eine asynchrone Anforderung zu einem Remoteendpunkt trennen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den asynchronen Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, können Sie rufen die <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Methode, um eine Trennung der Verbindung von einem remote-Endpunkt anzufordern. Wenn `reuseSocket` ist `true`, können Sie den Socket wiederverwenden.  
  
 Die <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Methode verwendet einen eigenen Thread, um die angegebene Rückrufmethode aufzurufen. Die <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Methode blockiert, bis der ausstehende Trennung der Verbindung ist abgeschlossen. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> mit Ausnahme der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und sendet einige Daten mit einem Remotehost. Wenn die Daten gesendet wurden, <xref:System.Net.Sockets.Socket.Shutdown%2A> wird aufgerufen, um das Beenden der Send und receive-Aktivität. Klicken Sie dann <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> wird aufgerufen, um eine Anforderung zum Trennen der beginnen. Klicken Sie nach Abschluss die Anforderung der <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft abgefragt, um zu testen, ob der Socket getrennt ist.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, und diese Methode erfordert Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zu den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Startet asynchron empfangen von Daten aus einer verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Aufrufen synchroner Methoden asynchron](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zu den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Startet asynchron empfangen von Daten aus einer verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Aufrufen synchroner Methoden asynchron](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="offset">Die nullbasierte Position in der <c>Puffer</c> -Parameter, um die empfangenen Daten zu speichern.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zu den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Startet asynchron empfangen von Daten aus einer verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Aufrufen synchroner Methoden asynchron](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird asynchron empfangen von Daten aus einer verbundenen beginnt <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="offset">Die Position im <c>Puffer</c> zum Speichern der empfangenen Daten.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zu den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Startet asynchron empfangen von Daten aus einer verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen werden, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Aufrufen synchroner Methoden asynchron](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="offset">Die nullbasierte Position in der <c>Puffer</c> -Parameter, um die Daten zu speichern.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Startet asynchron empfangen von Daten von einem angegebenen Netzwerkgerät.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode startet verbindungslose Datagramme von einem Remotehost asynchron zu lesen. Aufrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread empfangen.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Hierzu zumindest, Ihre `state` Parameter enthalten, die verbundene oder default muss <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> bis der <xref:System.Net.Sockets.Socket> liest Daten aus, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> -Methode <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, müssen Sie explizit Binden der <xref:System.Net.Sockets.Socket> in einen lokalen Endpunkt mit der <xref:System.Net.Sockets.Socket.Bind%2A> -Methode oder <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Diese Methode liest Daten in den `buffer` Parameter und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet werden. Informationen zum Abrufen von diesem Endpunkt finden Sie unter <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Diese Methode eignet sich am besten, wenn Sie beabsichtigen, verbindungslose Datagramme asynchron von einem unbekannten Host oder mehreren Hosts empfangen werden. In diesen Fällen <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm Sie erhalten größer als die Größe des `buffer`, die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich und löst der Meldung ein <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten. Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode mit einer ausreichend großen Puffer.  
  
 Um sicherzustellen, dass der Endpunkt des remote-Host wird immer zurückgegeben, eine Anwendung sollten explizit Binden der <xref:System.Net.Sockets.Socket> in einen lokalen Endpunkt mit der <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, und rufen Sie dann die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode mit der `optionLevel` Parametersatz auf <xref:System.Net.Sockets.SocketOptionLevel.IP>oder <xref:System.Net.Sockets.SocketOptionLevel.IPv6> nach Bedarf, die `optionName` Parametersatz auf <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, und die `optionValue` Parameter zum Aktivieren dieser Option vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Andernfalls ist es möglich, dass der remote-Host-Endpunkt nicht zurückgegeben werden, wenn der Absender eine Reihe von Datagrammen gesendet hat, bevor der Empfänger aufgerufen hat die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode.  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, oder übernehmen Sie eine eingehende verbindungsanforderung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Beim Aufrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> -Methode vor dem herstellen oder annehmen einer Verbindung erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. In diesen Fällen die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> -Methode ignoriert die `remoteEP` Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.  
  
 Mit verbindungsorientierte Sockets <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> liest so viel verfügbaren Daten bis zur Anzahl der Bytes, die gemäß der `size` Parameter.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird empfängt verbindungslose Datagramme asynchron von einem Remotehost.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="offset">Die nullbasierte Position in der <c>Puffer</c> -Parameter, um die Daten zu speichern.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Eine <see cref="T:System.Net.EndPoint" /> , die die Quelle der Daten darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Startet die angegebene Anzahl von Bytes an Daten asynchron auf der angegebenen Position in der unter Verwendung des angegebenen Datenpuffers empfangen <see cref="T:System.Net.Sockets.SocketFlags" />, und speichert die Endpunkt- und Paketinformationen...</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchronen Empfangsvorgang abgeschlossen werden muss, durch Aufrufen der <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [asynchron aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Diese Methode liest Daten in den `buffer` Parameter, und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet werden, sowie Informationen über das empfangene Paket. Informationen zum Abrufen von diesem Endpunkt finden Sie unter <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Diese Methode eignet sich am besten, wenn Sie beabsichtigen, verbindungslose Datagramme asynchron von einem unbekannten Host oder mehreren Hosts empfangen werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, und diese Methode erfordert Windows XP.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" /> , die die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A>löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu zumindest, Ihre `state` Parameter enthalten, die verbundene oder default muss <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Gedacht für verbindungsorientierte Protokolle <xref:System.Net.Sockets.Socket.BeginSend%2A> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um eine Standard-Remotehost herstellen. Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist angemessen, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" /> , die die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A>löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu zumindest, Ihre `state` Parameter enthalten, die verbundene oder default muss <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode auf eine <xref:System.Threading.ManualResetEvent> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Gedacht für verbindungsorientierte Protokolle <xref:System.Net.Sockets.Socket.BeginSend%2A> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um eine Standard-Remotehost herstellen. Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist angemessen, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> , die die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position in der <c>Puffer</c> -Parameter, um das Senden von Daten beginnen.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A>löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu zumindest, Ihre `state` Parameter enthalten, die verbundene oder default muss <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Gedacht für verbindungsorientierte Protokolle <xref:System.Net.Sockets.Socket.BeginSend%2A> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um eine Standard-Remotehost herstellen. Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist angemessen, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird startet das asynchrone Senden von Daten mit einem Remotehost.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" />ist kleiner als die Länge des <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> , die die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position in der <c>Puffer</c> -Parameter, um das Senden von Daten beginnen.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A>löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu zumindest, Ihre `state` Parameter enthalten, die verbundene oder default muss <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Gedacht für verbindungsorientierte Protokolle <xref:System.Net.Sockets.Socket.BeginSend%2A> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um eine Standard-Remotehost herstellen. Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist angemessen, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state`ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" />ist kleiner als die Länge des <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> an einen verbundenen <see cref="T:System.Net.Sockets.Socket" /> -Objekt unter Verwendung der <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> Flag.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> Objekt, das den asynchronen Sendevorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet die Datei `fileName` an den verbundenen Socket. Wenn `fileName` wird in das lokale Verzeichnis es mit nur der Name der Datei identifiziert werden kann; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst wird.  
  
 Diese Methode verwendet die `TransmitFile` -Funktion, die in der Windows Sockets-API 2 gefunden. Weitere Informationen zu den `TransmitFile` -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 Die <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methoden. <xref:System.Net.Sockets.Socket.BeginSendFile%2A>löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode können Sie eine Datei in einem separaten Ausführungsthread senden.  
  
 Zum Abschließen des Vorgangs können Sie eine Rückrufmethode, die aufgerufen wird, indem Sie erstellen die <xref:System.AsyncCallback> Parameter zu delegieren. Hierzu zumindest, die `state` Parameter muss enthalten die <xref:System.Net.Sockets.Socket> Objekt für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieses benutzerdefinierten Objekts in der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen muss die <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSendFile%2A> bis der <xref:System.Net.Sockets.Socket> sendet die gesamte Datei oder eine Ausnahme auslöst. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Gedacht für verbindungsorientierte Protokolle <xref:System.Net.Sockets.Socket.BeginSendFile%2A> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um eine Standard-Remotehost herstellen. Mit verbindungslose Protokolle müssen Sie Sie sicher, dass sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> mit Ausnahme der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation. Zunächst wird die Datei "text.txt" asynchron mit dem Remotehost gesendet. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> um die Übertragung abzuschließen.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Zeichenfolge, die den Pfad und Name der zu sendenden Datei enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="preBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="postBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="flags">Eine bitweise Kombination von <see cref="T:System.Net.Sockets.TransmitFileOptions" /> Werte.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" /> nach Abschluss dieses Vorgangs aufzurufende Delegat. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Zustandsinformationen für diese Anforderung enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Sendet eine Datei und Datenpuffer asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" /> Objekt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> -Objekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung muss der Name der Datei, die Sie senden möchten und eine bitweise Kombination von <xref:System.Net.Sockets.TransmitFileOptions> Werte. Die `preBuffer` Parameter enthält alle Daten, die vor der Datei gesendet werden sollen. `postBuffer`enthält Daten, die Sie die Datei folgen soll. Wenn `fileName` wird in das lokale Verzeichnis es mit nur der Name der Datei identifiziert werden kann; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst wird.  
  
 Die `flags` Parameter stellt die Fenster Sockets-Dienstanbieter mit zusätzlichen Informationen über die Übertragung von Dateien bereit. Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Diese Methode verwendet die `TransmitFile` -Funktion, die in der Windows Sockets-API 2 gefunden. Weitere Informationen zu den `TransmitFile` -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 Die <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methoden. <xref:System.Net.Sockets.Socket.BeginSendFile%2A>löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> -Methode erhalten Sie die Möglichkeit, eine Datei in einem separaten Ausführungsthread senden.  
  
 Zum Abschließen des Vorgangs können Sie eine Rückrufmethode, die aufgerufen wird, indem Sie erstellen die <xref:System.AsyncCallback> Parameter zu delegieren. Hierzu zumindest, die `state` Parameter muss enthalten die <xref:System.Net.Sockets.Socket> Objekt für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und andere erforderliche Informationen. Übergeben Sie eine Instanz dieses benutzerdefinierten Objekts in der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen muss die <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSendFile%2A> bis der <xref:System.Net.Sockets.Socket> sendet die gesamte Datei oder eine Ausnahme auslöst. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Gedacht für verbindungsorientierte Protokolle <xref:System.Net.Sockets.Socket.BeginSendFile%2A> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um eine Standard-Remotehost herstellen. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> mit Ausnahme der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation und beginnt damit, senden die Datei "text.txt" asynchron mit dem Remotehost. In diesem Beispiel wird eine `preBuffer` und ein `postBuffer` der Daten erstellt, um mit der Datei und der standardmäßige senden <xref:System.Net.Sockets.TransmitFileOptions> Wert wird verwendet. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> um die Übertragung abzuschließen.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist nicht Windows NT oder höher.  
  
 \- oder –  
  
 Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> , die die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position in <c>Puffer</c> ab dem Senden von Daten.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet asynchron Daten an einen angegebenen Remotehost.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" /> , das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode startet einen asynchronen Sendevorgang mit dem Remotehost, angegeben der `remoteEP` Parameter. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden. Obwohl für verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.BeginSendTo%2A> arbeitet mit Verbindungs- und verbindungsorientierte Protokolle.  
  
 Können Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren, und übergeben Sie den Namen in der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode. Hierzu zumindest, Ihre `state` Parameter enthalten, die verbundene oder default muss <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket>, und die anderen erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode. Wenn die Anwendung aufruft, <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSendTo%2A> bis der <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode oder <xref:System.Net.Sockets.Socket.BeginSendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A>ignoriert die `remoteEP` Parameter und sendet Daten an die <xref:System.Net.EndPoint> hergestellt, die der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>. Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>, die `remoteEP` Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang. Sind Sie auch nicht aufrufen erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. In diesem Fall wird der zugrunde liegende Dienstanbieter die am besten geeignete LAN-Adresse und Anschlussnummer Anzahl zuweisen. Verwenden Sie die Portnummer 0 (null), wenn die zugrunde liegenden Service-Anbieter einen Port frei auswählen soll. Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. -Sie müssen auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.EndSendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> -Methode, die einen bestimmten <xref:System.Net.Sockets.Socket> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet Daten asynchron mit dem angegebenen Remotehost.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Die lokale <see cref="T:System.Net.EndPoint" /> zum Zuordnen der <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Ordnet eine <see cref="T:System.Net.Sockets.Socket" /> mit einem lokalen Endpunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden müssen. Rufen Sie <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf können die <xref:System.Net.Sockets.Socket.Listen%2A> Methode. Sie müssen nicht aufrufen <xref:System.Net.Sockets.Socket.Bind%2A> vor der Verwendung der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden müssen. Sie können die <xref:System.Net.Sockets.Socket.Bind%2A> Methode Verbindungs- und verbindungsorientierte Protokolle.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.Bind%2A>, müssen Sie zunächst die lokale erstellen <xref:System.Net.IPEndPoint> aus dem Sie Daten kommuniziert werden soll. Wenn unwichtig ist, welche lokale Adresse zugewiesen wird, können Sie erstellen eine <xref:System.Net.IPEndPoint> mit <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adressenparameter und der zugrunde liegende Dienst Anbieter die am besten geeignete Netzwerkadresse zugewiesen wird. Das kann hilfreich sein, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn unwichtig ist, welche lokaler Port verwendet wird, können Sie erstellen eine <xref:System.Net.IPEndPoint> mit dem Wert 0 für die Portnummer an. In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000.  
  
 Wenn Sie die oben beschriebene Ansatz verwenden, können Sie ermitteln, welche LAN-Adresse und Anschlussnummer Anzahl durch den Aufruf zugewiesen wurde die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> die lokal zugewiesene Netzwerkadresse erst nicht zurückgegeben, nachdem Sie einen Aufruf vorgenommen haben die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, werden Sie keinen Zugriff auf diese Informationen, bis einen Sendevorgang abgeschlossen haben oder erhalten.  
  
 Wenn ein UDP-Socket Schnittstelleninformationen auf empfangene Pakete empfangen möchte die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode sollte explizit aufgerufen werden, mit der Socketoption auf <xref:System.Net.Sockets.SocketOptionName.PacketInformation> unmittelbar nach dem Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie Multicastdatagramme empfangen möchten, müssen Sie Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> Methode mit einer multicast-Anschlussnummer.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode, wenn Sie beabsichtigen, verbindungslose Datagramme mit empfangen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> beim Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, mit der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel bindet einen <xref:System.Net.Sockets.Socket> mit den angegebenen lokalen Endpunkt.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen vom Host durch definierten <paramref name="localEP" />. Zugeordnete Enumeration:<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die <see cref="T:System.Net.Sockets.Socket" /> im blockierenden Modus befindet.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> blockiert; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft gibt an, ob eine <xref:System.Net.Sockets.Socket> im blockierenden Modus befindet.  
  
 Wenn Sie in Blockierungsmodus befinden, und Sie stellen eine Methode aufrufen, die nicht sofort abgeschlossen wird, wird Ihre Anwendung Ausführung blockiert, bis der angeforderte Vorgang abgeschlossen ist. Wenn die Ausführung fortgesetzt werden, obwohl der angeforderte Vorgang nicht abgeschlossen ist, ändern soll, die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false`. Die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft wirkt sich nicht auf asynchrone Methoden. Wenn Sie senden und Empfangen von Daten asynchron und die Ausführung blockieren möchten, verwenden Sie die <xref:System.Threading.ManualResetEvent> Klasse.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> verwendet, um die Verbindung mit dem Remotehost anzufordern, durch den Aufruf eines Objekts die <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> Methoden.</param>
        <summary>Bricht eine asynchrone Anforderung einer Remotehostverbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> -Methode bricht eine asynchrone Anforderung einer Remotehostverbindung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="e" /> Parameter darf nicht null sein und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht null sein.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" /> Verbindungs- und alle zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Close%2A> Methode schließt die Remotehostverbindung und Releases alle verwalteten und nicht verwaltete Ressourcen für die <xref:System.Net.Sockets.Socket>. Nach Abschluss der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaftensatz auf `false`.  
  
 Für verbindungsorientierte Protokolle wird empfohlen, die Sie aufrufen <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufruf der <xref:System.Net.Sockets.Socket.Close%2A> Methode. Dadurch wird sichergestellt, dass alle Daten gesendet und empfangen auf dem verbundenen Socket, bevor er geschlossen wurde.  
  
 Wenn Sie aufrufen müssen <xref:System.Net.Sockets.Socket.Close%2A> erst nach Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragung festlegen, indem gesendet werden die <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> option `false` und ein Timeoutintervall ungleich NULL angeben. <xref:System.Net.Sockets.Socket.Close%2A>wird dann blockieren, bis die Daten gesendet werden oder das angegebene Timeout abläuft. Wenn Sie festlegen, <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf `false` , und geben Sie ein Timeoutintervall NULL <xref:System.Net.Sockets.Socket.Close%2A> gibt die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.  
  
> [!NOTE]
>  Festlegen der <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf `false`, erstellen eine <xref:System.Net.Sockets.LingerOption>, legen Sie die enabled-Eigenschaft auf `true`, und legen Sie die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft, um das gewünschte Zeitlimit. Verwenden Sie diese <xref:System.Net.Sockets.LingerOption> zusammen mit den <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption zum Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel schließt eine <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Warten Sie bis zu <c>Timeout</c> Sekunden, um alle verbleibenden Daten zu senden, schließen Sie dann den Socket.</param>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen mit einem angegebenen Timeout frei, damit in der Warteschlange befindliche Daten gesendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Close%2A> Methode schließt die Remotehostverbindung und Releases alle verwalteten und nicht verwaltete Ressourcen für die <xref:System.Net.Sockets.Socket>. Nach Abschluss der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaftensatz auf `false`.  
  
 Für verbindungsorientierte Protokolle wird empfohlen, die Sie aufrufen <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Close%2A>. Dadurch wird sichergestellt, dass alle Daten gesendet und empfangen auf dem verbundenen Socket, bevor er geschlossen wurde.  
  
 Wenn Sie aufrufen müssen <xref:System.Net.Sockets.Socket.Close%2A> erst nach Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragung festlegen, indem gesendet werden die <xref:System.Net.Sockets.SocketOptionName.DontLinger> option `false` und ein Timeoutintervall ungleich NULL angeben. <xref:System.Net.Sockets.Socket.Close%2A>wird dann blockieren, bis die Daten gesendet werden oder das angegebene Timeout abläuft. Wenn Sie festlegen, <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf `false` , und geben Sie ein Timeoutintervall NULL <xref:System.Net.Sockets.Socket.Close%2A> gibt die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.  
  
> [!NOTE]
>  Festlegen der <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf `false`, erstellen eine <xref:System.Net.Sockets.LingerOption>, legen Sie die enabled-Eigenschaft auf `true`, und legen Sie die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft, um den gewünschten Timeoutzeitraum. Verwenden Sie diese <xref:System.Net.Sockets.LingerOption> zusammen mit den <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption zum Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Schließen einer <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> -Methode synchron richtet eine Verbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und der angegebenen Remoteendpunkt. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.Connect%2A> stellt eine Standard-Remotehost her. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, Senden von Daten an das Remotegerät mit dem <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen. Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 Die <xref:System.Net.Sockets.Socket.Connect%2A> Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> abgeschlossen ist eine Verbindung herstellen.  
  
> [!NOTE]
>  Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Herstellen einer Verbindung mit dem Remotehost. Zugeordnete Enumeration:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Die IP-Adresse des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird mit einer IP-Adresse und einer Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> -Methode synchron richtet eine Verbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und der angegebenen Remoteendpunkt. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.Connect%2A> stellt eine Standard-Remotehost her. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> Senden von Daten an das Remotegerät mit dem <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , die über eine andere Adresse als der angegebene Standardwert eingehen Datagramme werden verworfen. Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> abgeschlossen ist eine Verbindung herstellen.  
  
> [!NOTE]
>  Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Die IP-Adressen des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird durch ein Array von IP-Adressen und eine Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel verwendet, sofort nach einem Aufruf von <xref:System.Net.Dns.GetHostAddresses%2A>, dem können mehrere IP-Adressen für einen einzelnen Host zurückgeben. Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> -Methode synchron richtet eine Verbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und der angegebenen Remoteendpunkt. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.Connect%2A> stellt eine Standard-Remotehost her. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> Senden von Daten an das Remotegerät mit dem <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , die über eine andere Adresse als der angegebene Standardwert eingehen Datagramme werden verworfen. Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> abgeschlossen ist eine Verbindung herstellen.  
  
> [!NOTE]
>  Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Der Name des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> -Methode synchron richtet eine Verbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remotehost. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.Connect%2A> stellt eine Standard-Remotehost her. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> Senden von Daten an das Remotegerät mit dem <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , die über eine andere Adresse als der angegebene Standardwert eingehen Datagramme werden verworfen. Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> abgeschlossen ist eine Verbindung herstellen.  
  
 Wenn IPv6 aktiviert ist und die <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> Methode wird aufgerufen, um eine Verbindung zu einem Host herzustellen, der sowohl IPv6-aufgelöst wird und IPv4-Adressen, die Verbindung mit der IPv6-Adresse versucht zuerst, bevor Sie die IPv4-Adresse. Dies kann wirken sich die Zeit zum Herstellen der Verbindung, wenn der Host nicht auf die IPv6-Adresse lauscht verzögern.  
  
> [!NOTE]
>  Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, die Verbindung wiederherzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf in einem Wartezustand platziert <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Beginnt eine asynchrone Anforderung für eine Verbindung mit einem Remotehost.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode startet eine asynchrone Anforderung für eine Verbindung mit dem Remotehost. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.ConnectAsync%2A> stellt eine Standard-Remotehost her.  
  
 Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs > delegieren, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, für die Verbindung.  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> für die Kommunikation mit einem Remotehost. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erneut mit den gewünschten Endpunkt.  
  
 Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und legen Sie die Übertragung auf `true`. Wenn dies nicht erfolgt, die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Optional ein Puffer kann angegeben werden die auf den Socket atomar gesendet werden die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wird. In diesem Fall die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> -Eigenschaft muss in den Puffer mit den Daten festgelegt werden, um zu senden und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft muss auf die Anzahl der Bytes der Daten festgelegt werden, um aus dem Puffer zu senden. Sobald eine Verbindung hergestellt ist, wird dieser Puffer von Daten gesendet.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll und Sie nicht rufen <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, der Service Provider nicht weist eine LAN-IP-Adresse und Anschlussnummer Zahl erst nach dem Aufruf der <xref:System.Net.Sockets.Socket.SendAsync%2A> oder <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methoden.  
  
 Die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode löst <xref:System.NotSupportedException> Wenn die Adressfamilie von der <xref:System.Net.Sockets.Socket> und <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> sind nicht die gleiche Adressfamilie.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> verwenden Sie beim Aufrufen dieser Methode die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden, die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> -Eigenschaft nicht null ist.</exception>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="e" /> Parameter darf nicht null sein und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht null sein.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> ist überwacht oder bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode. Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> sind nicht die gleiche Adressfamilie.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Beginnt eine asynchrone Anforderung für eine Verbindung mit einem Remotehost.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, beginnt die m:System.NET.Sockets.Socket.ConnectAsync(System.NET.Sockets.SocketType,System.NET.Sockets.ProtocolType,System.NET.Sockets.SocketAsyncEventArgs)-Methode eine asynchrone Anforderung einer Verbindung mit dem Remotehost. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.ConnectAsync%2A> richtet einen Standard-Remotehost gemäß der `socketType` und `protocolType` Parameter.  
  
 Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs > delegieren, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, für die Verbindung.  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> für die Kommunikation mit einem Remotehost. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erneut mit den gewünschten Endpunkt.  
  
 Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und legen Sie die Übertragung auf `true`. Wenn dies nicht erfolgt, die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Optional ein Puffer kann angegeben werden die auf den Socket atomar gesendet werden die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wird. In diesem Fall die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> -Eigenschaft muss in den Puffer mit den Daten festgelegt werden, um zu senden und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft muss auf die Anzahl der Bytes der Daten festgelegt werden, um aus dem Puffer zu senden. Sobald eine Verbindung hergestellt ist, wird dieser Puffer von Daten gesendet.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll und Sie nicht rufen <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, der Service Provider nicht weist eine LAN-IP-Adresse und Anschlussnummer Zahl erst nach dem Aufruf der <xref:System.Net.Sockets.Socket.SendAsync%2A> oder <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methoden.  
  
 Die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode löst <xref:System.NotSupportedException> Wenn die Adressfamilie von der <xref:System.Net.Sockets.Socket> und <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> sind nicht die gleiche Adressfamilie.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> verwenden Sie beim Aufrufen dieser Methode die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden, die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> -Eigenschaft nicht null ist.</exception>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="e" /> Parameter darf nicht null sein und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht null sein.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Net.Sockets.Socket" /> ist überwacht oder bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode. Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> sind nicht die gleiche Adressfamilie.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob ein <see cref="T:System.Net.Sockets.Socket" /> verbunden ist, mit einem Remotehost zum Zeitpunkt der letzten <see cref="Overload:System.Net.Sockets.Socket.Send" /> oder <see cref="Overload:System.Net.Sockets.Socket.Receive" /> Vorgang.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> wurde mit einer Remoteressource zuletzt ausgeführten Vorgangs verbunden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Connected` Eigenschaft ruft den Verbindungsstatus des der <xref:System.Net.Sockets.Socket> zum Zeitpunkt der letzten e/a-Vorgang. Bei der Rückgabe `false`der <xref:System.Net.Sockets.Socket> wurde entweder nie verbunden, oder ist nicht mehr verbunden.  
  
 Der Wert, der die <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft gibt den Status der Verbindung zum Zeitpunkt des letzten Vorgangs wieder. Wenn Sie den aktuellen Zustand der Verbindung bestimmen müssen, stellen Sie einen nicht blockierenden, 0 Byte senden, aufrufen. Wenn der Aufruf erfolgreich zurückgegeben oder einen Fehlercode WAEWOULDBLOCK (10035 aufgeführt löst), wird der Socket noch verbunden. Andernfalls wird der Socket nicht mehr verbunden.  
  
 Beim Aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> für ein Socket User Datagram Protocol (UDP) der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaft gibt immer `true`, aber diese Aktion ändert sich nicht auf den inhärenten verbindungslosen Charakter UDP.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt, überprüft der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaft, und überprüft den aktuellen Zustand der Verbindung.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" />Wenn diesem Socket wiederverwendet werden kann, nachdem die aktuelle Verbindung geschlossen wurde; andernfalls <see langword="false" />.</param>
        <summary>Schließt die Socketverbindung und ermöglicht die Wiederverwendung des Sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, können Sie diese Methode, um den Socket schließen. Diese Methode beendet die Verbindung und stellt die <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft `false`. Jedoch wenn `reuseSocket` ist `true`, können Sie den Socket wiederverwenden.  
  
 Um sicherzustellen, dass alle Daten gesendet und empfangen, bevor der Socket geschlossen ist, rufen Sie <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufruf der <xref:System.Net.Sockets.Socket.Disconnect%2A> Methode.  
  
 Wenn Sie aufrufen müssen <xref:System.Net.Sockets.Socket.Disconnect%2A> erst nach Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>, können Sie festlegen, die <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> option `false` , und geben Sie einen Wert ungleich NULL Timeoutintervall um sicherzustellen, dass die Daten in der Warteschlange für ausgehende Übertragung gesendet wird. <xref:System.Net.Sockets.Socket.Disconnect%2A>Klicken Sie dann blockiert, bis die Daten gesendet werden oder das angegebene Timeout abläuft. Wenn Sie festlegen, <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf `false` , und geben Sie ein Timeoutintervall NULL <xref:System.Net.Sockets.Socket.Close%2A> gibt die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die synchrone Kommunikation erstellt und sendet einige Daten mit einem Remotehost. Er ruft dann <xref:System.Net.Sockets.Socket.Shutdown%2A>beenden Senden und empfangen-Aktivität, und <xref:System.Net.Sockets.Socket.Disconnect%2A>, um die Socketverbindung zu schließen.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Diese Methode erfordert Windows 2000 oder früher, oder die Ausnahme wird ausgelöst.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Beginnt eine asynchrone Anforderung zu einem Remoteendpunkt trennen.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden zu können, Aufrufen der <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> -Methode fordert eine Trennung der Verbindung mit einem Remoteendpunkt. Wenn Sie festlegen, <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> auf `true` in der `e` -Parameter, der Socket wiederverwendet werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <paramref name="e" /> Parameter darf nicht null sein.</exception>
        <exception cref="T:System.InvalidOperationException">Bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie `Dispose` auf, wenn Sie <xref:System.Net.Sockets.Socket> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Net.Sockets.Socket> nicht mehr verwendet werden kann. Nach dem Aufruf `Dispose`, müssen Sie alle Verweise auf Freigeben der <xref:System.Net.Sockets.Socket> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Net.Sockets.Socket> belegt wurde.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Net.Sockets.Socket> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
        <summary>Gibt die vom <see cref="T:System.Net.Sockets.Socket" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.Socket> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ihn fest ein <see cref="T:System.Boolean" /> Wert, der angibt, ob die <see cref="T:System.Net.Sockets.Socket" /> IP (Internet Protocol)-Datagramme fragmentiert werden können.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> Datagrammfragmentierung zulässt, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramme erfordern eine Fragmentierung, wenn ihre Größe das Maximum Transfer Unit (MTU) des Übertragungsmediums übersteigt. Datagramme können vom sendenden Host (alle Versionen für Internet Protocol) oder einen zwischengeschalteten Router (nur Internet Protocol Version 4) fragmentiert. Wenn ein Datagramm fragmentiert werden muss, und die <xref:System.Net.Sockets.Socket.DontFragment%2A> Option festgelegt ist, das Datagramm verworfen und Internet Control Message Protocol (ICMP) folgende Fehlermeldung zurück an den Absender der das Datagramm gesendet wird.  
  
 Durch Festlegen dieser Eigenschaft für ein Socket Protokoll TCP (Transmission Control) werden keine Auswirkungen haben.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.DontFragment%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann festgelegt werden, nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> Familien.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> ein für IPv4 und IPv6 verwendeter Dualmodussocket ist, oder legt ihn fest.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ein Dualmodussocket ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Die ID des Zielprozesses, wo ein Duplikat des Socketverweises erstellt wird.</param>
        <summary>Den Socketverweis für den Zielprozess dupliziert und schließt den Socket für diesen Prozess.</summary>
        <returns>Der Socketverweis an den Zielprozess übergeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zielprozess die zu verwendende <xref:System.Net.Sockets.Socket.%23ctor%2A> auf die doppelte Socketinstanz zu erstellen.  
  
 Beim Aufrufen der <xref:System.Net.Sockets.Socket.%23ctor%2A> Konstruktor mehrmals mit demselben Bytearray als Argument für jeden Aufruf, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket> Instanzen mit dem gleichen zugrunde liegenden Socket. Dieses Vorgehen wird dringend abgeraten.  
  
 Wenn der Prozess zum Erstellen des Sockets asynchrone Methoden verwendet (<xref:System.Net.Sockets.Socket.BeginReceive%2A> oder <xref:System.Net.Sockets.Socket.BeginSend%2A>), muss zunächst Festlegen der <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> Eigenschaft auf "true" ist, andernfalls wird der Socket an den Abschlussport des erstellen-Prozesses, was eine bewirkenkanngebunden<xref:System.ArgumentNullException> auf den Zielprozess ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" />ist keine gültige Prozess-Id.  
  
 - oder -   
  
 Fehler bei der Duplizierung des Socketverweises.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ihn fest ein <see cref="T:System.Boolean" /> Wert, der angibt, ob die <see cref="T:System.Net.Sockets.Socket" /> senden / empfangen Broadcastpakete kann.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete zulässt, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Übertragung muss auf ein bestimmtes Subnetz beschränkt, und User Datagram-Protokolls (UDP). Internetprotokoll Version 4 können Sie Ihrem lokalen Subnetz durch Senden eines Pakets 255.255.255.255 übertragen. oder Sie können die gesteuerte Broadcastadresse, die der Netzwerkteil einer Adresse Internetprotokoll (IP), mit der alle Bits in den Hostteil festgelegt ist. Angenommen, Ihre IP-Adresse 192.168.1.40 ist (eine Adresse der Klasse C mit einer 255.255.255.0--der Netzwerkteil gibt die ersten drei Oktette und der Hostteil ist das letzte Oktett), die gesteuerte Broadcastadresse ist 192.168.1.255.  
  
 Durch Festlegen dieser Eigenschaft für ein Socket Protokoll TCP (Transmission Control) werden keine Auswirkungen haben.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Diese Option gilt für nur einen Datagrammsocket.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Nimmt eine eingehende Verbindung asynchron an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" /> Remotehostkommunikation zu behandeln.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> zum Verarbeiten der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginAccept%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode zurückkehrt. Es zustimmen der `asyncResult` Parameter zurückgegeben, aus der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode.  
  
 In der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der `asyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf der der Verbindungsversuch erfolgt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode blockiert, bis eine Verbindung ausstehend ist in der Warteschlange für eingehende Verbindungen. Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode akzeptiert die eingehende Verbindung, und gibt eine neue <xref:System.Net.Sockets.Socket> , die verwendet werden kann, um Daten zu senden und Empfangen von Daten vom Remotehost aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet eine asynchrone Anforderung und erstellt einen neuen <xref:System.Net.Sockets.Socket> eine eingehende verbindungsanforderung zu akzeptieren. Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Socket-Codebeispiele](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde zuvor aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> , enthält der übertragenen Bytes.</param>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> Objekt, das Informationen zum Status für diesen asynchronen Vorgang als auch für alle Benutzer speichert benutzerdefinierte Daten.</param>
        <summary>Nimmt eine eingehende Verbindung asynchron an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" /> Objekt Remotehostkommunikation zu behandeln. Diese Methode gibt einen Puffer mit den anfänglichen Daten übertragen.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> Objekt zum Verarbeiten der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginAccept%2A>, müssen Sie eine Rückrufmethode erstellen, die aufgerufen wird, indem Sie die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode zurückkehrt.  
  
 In der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der `asyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf der der Verbindungsversuch erfolgt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen. Die `buffer` Parameter dieser Überladung enthält Daten, die im Aufruf empfangen wurde <xref:System.Net.Sockets.Socket.BeginAccept%2A> und `bytesTransferred` Parameter enthält die Anzahl der Bytes, die im Aufruf übertragen wurden.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode blockiert, bis eine Verbindung ausstehend ist in der Warteschlange für eingehende Verbindungen. Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode akzeptiert die eingehende Verbindung, und gibt eine neue <xref:System.Net.Sockets.Socket> , die verwendet werden kann, um Daten zu senden und Empfangen von Daten vom Remotehost aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.Socket.BeginAccept%2A> zum Erstellen und Verbinden eines Sockets und akzeptieren die ersten 10 Bytes der Daten. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> , die asynchrone Anforderung zu beenden. Die Anzahl der übertragenen Bytes und die Daten werden zurückgegeben, der `buffer` und `bytesTransferred` Parameter dieser Methode und in der Konsole angezeigt werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf die<see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> , enthält der übertragenen Bytes.</param>
        <param name="bytesTransferred">Die Anzahl der übertragenen Bytes.</param>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> Objekt, das Informationen zum Status für diesen asynchronen Vorgang als auch für alle Benutzer speichert benutzerdefinierte Daten.</param>
        <summary>Nimmt eine eingehende Verbindung asynchron an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" /> Objekt Remotehostkommunikation zu behandeln. Diese Methode gibt einen Puffer, der die Anfangsdaten und die Anzahl der übertragenen Bytes enthält.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> Objekt zum Verarbeiten der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginAccept%2A>, müssen Sie eine Rückrufmethode erstellen, die aufgerufen wird, indem Sie die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode zurückkehrt. Es zustimmen der `asyncResult` Parameter zurückgegeben, aus der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode.  
  
 In der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der `asyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf der der Verbindungsversuch erfolgt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen. Die `buffer` Parameter dieser Überladung enthält Daten, die im Aufruf empfangen wurde <xref:System.Net.Sockets.Socket.BeginAccept%2A> und `bytesTransferred` Parameter enthält die Anzahl der Bytes, die im Aufruf übertragen wurden.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode blockiert, bis eine Verbindung ausstehend ist in der Warteschlange für eingehende Verbindungen. Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode akzeptiert die eingehende Verbindung, und gibt eine neue <xref:System.Net.Sockets.Socket> , die verwendet werden kann, um Daten zu senden und Empfangen von Daten vom Remotehost aus.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.Socket.BeginAccept%2A> zum Erstellen und Verbinden eines Sockets und akzeptieren die ersten 10 Bytes der Daten. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> , die asynchrone Anforderung zu beenden. Die Anzahl der übertragenen Bytes und die Daten werden zurückgegeben, der `buffer` und `bytesTransferred` Parameter dieser Methode und in der Konsole angezeigt werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />wurde nicht durch einen Aufruf erstellt <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf die <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Beendet eine ausstehende asynchrone Verbindung-Anforderung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A>ist eine blockierende Methode, die die verbindungsanforderung asynchrone Remotehost abgeschlossen wird gestartet wurde, der <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginConnect%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginConnect%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode als Parameter.  
  
 In der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf der der Verbindungsversuch erfolgt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der asynchronen Verbindungsversuch beendet. Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Socket-Codebeispiele](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />wurde bereits für die asynchrone Verbindung aufgerufen werden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> -Objekt, das Zustandsinformationen und benutzerdefinierte Daten für diesen asynchronen Vorgang speichert.</param>
        <summary>Beendet eine ausstehende asynchrone Disconnect-Anforderung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. Die <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Methode blockiert, bis der Vorgang abgeschlossen ist. Informationen zu asynchronen Vorgängen finden Sie unter der asynchronen Programmierung Übersichtsthema in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und sendet einige Daten mit einem Remotehost. Wenn die Daten gesendet wurden, <xref:System.Net.Sockets.Socket.Shutdown%2A> wird aufgerufen, um das Beenden der Send und receive-Aktivität. Klicken Sie dann <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> wird aufgerufen, um eine Anforderung zum Trennen der beginnen. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndDisconnect%2A> , die asynchrone Anforderung zu beenden. Klicken Sie nach Abschluss die Anforderung der <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft abgefragt, um zu testen, ob der Socket getrennt ist.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, und diese Methode erfordert Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />wurde bereits für die asynchrone Verbindung aufgerufen werden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.Net.WebException">Die Disconnect-Anforderung wurde überschritten.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode schließt den asynchronen Lesevorgang gestartet werden, der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceive%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> übergebene, um das Zustandsobjekt, das Abrufen der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.Socket> aus dieses Zustandsobjekt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndReceive%2A> liest das erste Datagramm im eingehenden Netzwerkpuffer verfügbar. Wenn Sie ein verbindungsorientiertes Protokoll verwenden der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode wird bis zur Anzahl von Bytes verfügbar ist, in angegebenen, Daten Lesen der `size` Parameter von der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Aufrufen, um die empfangenen Daten zu erhalten, die <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult>, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer.  
  
 Auf "Abbrechen" eine ausstehende <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen ausstehenden asynchronen Lesevorgang beendet. Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Socket-Codebeispiele](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> zur Speicherung der Zustandsinformationen und benutzerdefinierte Daten für diesen asynchronen Vorgang.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode schließt den asynchronen Lesevorgang gestartet werden, der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceive%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> übergebene, um das Zustandsobjekt, das Abrufen der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.Socket> aus dieses Zustandsobjekt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndReceive%2A> liest das erste Datagramm im eingehenden Netzwerkpuffer verfügbar. Wenn Sie ein verbindungsorientiertes Protokoll verwenden der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode wird bis zur Anzahl von Bytes verfügbar ist, in angegebenen, Daten Lesen der `size` Parameter von der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Aufrufen, um die empfangenen Daten zu erhalten, die <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult>, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</summary>
        <returns>Bei Erfolg, empfangen die Anzahl der Bytes an. Wenn Fehler auftreten, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode schließt den asynchronen Lesevorgang gestartet werden, der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> übergebene, um das Zustandsobjekt, das Abrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.Socket> aus dieses Zustandsobjekt. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> liest das erste Datagramm im eingehenden Netzwerkpuffer verfügbar. Wenn Sie ein verbindungsorientiertes Protokoll verwenden der <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode wird bis zur Anzahl von Bytes verfügbar ist, in angegebenen, Daten Lesen der `size` Parameter von der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück. Aufrufen, um die empfangenen Daten zu erhalten, die <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Objekt, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer. Um den Ausgangshost zu identifizieren, extrahieren Sie die <xref:System.Net.EndPoint> und wandeln Sie sie in einer <xref:System.Net.IPEndPoint>. Verwenden der <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Methode, um die IP-Adresse abzurufen und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode, um die Portnummer abzurufen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> zur Speicherung der Zustandsinformationen und benutzerdefinierte Daten für diesen asynchronen Vorgang.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" /> Werte für das empfangene Paket.</param>
        <param name="endPoint">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">Die <see cref="T:System.Net.IPAddress" /> und die Schnittstelle des empfangenen Pakets.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt. Diese Methode stellt außerdem Informationen über das Paket als <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Bei Erfolg, empfangen die Anzahl der Bytes an. Wenn Fehler auftreten, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden Sie die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.  
  
 Untersuchen Sie `ipPacketInformation` Wenn müssen Sie wissen, ob das Datagramm mit einer Unicast-, Multicast- oder Broadcastnetzwerkverkehr gesendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist gleich <see langword="null" />.  
  
 - oder -   
  
 <paramref name="endPoint" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang an.</summary>
        <returns>Wenn erfolgreich, die Anzahl der Bytes an gesendet der <see cref="T:System.Net.Sockets.Socket" />ist, andernfalls eine ungültige <see cref="T:System.Net.Sockets.Socket" /> Fehler.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>Schließt den asynchronen Sendevorgang in gestartet <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSend%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Parameter zum Abrufen der Versand <xref:System.Net.Sockets.Socket>. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis einige des Puffers gesendet wurde. Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> gibt an, dass der Puffer nicht vollständig gesendet wurde, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erneut, den Puffer zum Speichern von nicht gesendeten Daten zu ändern.  
  
 Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen ausstehenden asynchronen Sendevorgang beendet.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> zur Speicherung der Informationen zum Status für diesen asynchronen Vorgang.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang an.</summary>
        <returns>Wenn erfolgreich, die Anzahl der Bytes an gesendet der <see cref="T:System.Net.Sockets.Socket" />ist, andernfalls eine ungültige <see cref="T:System.Net.Sockets.Socket" /> Fehler.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>Schließt den asynchronen Sendevorgang in gestartet <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSend%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Parameter zum Abrufen der Versand <xref:System.Net.Sockets.Socket>. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis einige des Puffers gesendet wurde. Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> gibt an, dass der Puffer nicht vollständig gesendet wurde, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erneut, den Puffer zum Speichern von nicht gesendeten Daten zu ändern.  
  
 Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" /> Objekt, das Informationen zum Status für diesen asynchronen Vorgang speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang einer Datei an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A>Schließt den asynchronen Sendevorgang in gestartet <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, müssen Sie eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes Objekt die <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Parameter zum Abrufen der Versand <xref:System.Net.Sockets.Socket>. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, können Sie rufen die <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode, um den Sendevorgang erfolgreich abgeschlossen.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSendFile%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSendFile%2A> blockiert, bis die gesamte Datei gesendet wird. Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation und beginnt damit, senden die Datei "text.txt" asynchron mit dem Remotehost. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> um die Übertragung abzuschließen.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />vorher hieß die für den asynchronen <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang an einem bestimmten Speicherort.</summary>
        <returns>Wenn erfolgreich, die Anzahl der Bytes gesendet. andernfalls eine ungültige <see cref="T:System.Net.Sockets.Socket" /> Fehler.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A>Schließt den asynchronen Sendevorgang in gestartet <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes die <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode als Parameter.  
  
 Innerhalb der Rückrufmethode Aufrufen der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Parameter zum Abrufen der Versand <xref:System.Net.Sockets.Socket>. Nach dem Erhalt der <xref:System.Net.Sockets.Socket>, Sie erreichen die <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.EndSendTo%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet werden. Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen asynchronen Sendevorgang an einem bestimmten Speicherort beendet.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" />nicht durch einen Aufruf zurückgegeben wurde die <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> Methode.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ihn fest ein <see cref="T:System.Boolean" /> Wert, der angibt, ob die <see cref="T:System.Net.Sockets.Socket" /> kann nur ein Prozess zum Binden an einen Port.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> nur ein Socket zum Binden an einen bestimmten Port; zulässt, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" /> für Windows Server 2003 und Windows XP Service Pack 2 und <see langword="false" /> für alle anderen Versionen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> ist `false`, mehrere Sockets können die <xref:System.Net.Sockets.Socket.Bind%2A> Methode zum Binden an einen bestimmten Port, jedoch nur eine der Sockets Vorgänge für den Netzwerkdatenverkehr an den Port gesendete ausführen kann. Wenn mehr als ein Socket versucht, verwenden die <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> Methode an einen bestimmten Port gebunden werden soll, und klicken Sie dann das Laufwerk mit die spezifische IP-Adresse den Netzwerkdatenverkehr, die an diesen Port gesendet behandelt.  
  
 Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> ist `true`, der ersten Verwendung von der <xref:System.Net.Sockets.Socket.Bind%2A> Methode versucht, binden an einen bestimmten Port, unabhängig von der Adresse Internetprotokoll (IP), wird erfolgreich ausgeführt werden; alle nachfolgenden Verwendungen von der <xref:System.Net.Sockets.Socket.Bind%2A> Methode versucht, die an diesen Port gebunden wird fehl, bis der ursprüngliche gebundene Socket zerstört wird.  
  
 Diese Eigenschaft muss festgelegt werden, bevor <xref:System.Net.Sockets.Socket.Bind%2A> aufgerufen; andernfalls wird eine <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />für diesen aufgerufen wurde <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt von der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendete Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket> -Klasse Finalizer Ruft die <xref:System.Net.Sockets.Socket.Close%2A> Methode zum Schließen der <xref:System.Net.Sockets.Socket> und zugeordneten Ressourcen frei der <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <summary>Gibt den Wert eines angegebenen <see cref="T:System.Net.Sockets.Socket" /> Option, die als Objekt dargestellt.</summary>
        <returns>Ein Objekt, das den Wert der Option darstellt. Wenn die <paramref name="optionName" /> Parameter auf festgelegt ist <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> der Rückgabewert ist eine Instanz von der <see cref="T:System.Net.Sockets.LingerOption" /> Klasse. Wenn <paramref name="optionName" /> festgelegt ist, um <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> oder <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, der Rückgabewert ist eine Instanz von der <see cref="T:System.Net.Sockets.MulticastOption" /> Klasse. Wenn <paramref name="optionName" /> ein anderer Wert ist der Rückgabewert ist eine ganze Zahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung zum Abrufen der <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, und <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> Optionen. Für die <xref:System.Net.Sockets.SocketOptionName.Linger> mit <xref:System.Net.Sockets.Socket> für die `optionLevel` Parameter. Für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership>, verwenden Sie <xref:System.Net.Sockets.SocketOptionLevel.IP>. Wenn Sie verwenden möchten, legen Sie den Wert aller oben aufgeführten Optionen, verwenden die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Der folgende code Beispiel ruft die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte und zeigt sie an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
 - oder -   
  
 <paramref name="optionName" />auf den nicht unterstützten Wert festgelegt wurde <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Array vom Typ <see cref="T:System.Byte" /> , ist die Einstellung der Option empfangen.</param>
        <summary>Gibt das angegebene <see cref="T:System.Net.Sockets.Socket" /> option festlegen, dargestellt als Bytearray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Nach erfolgreichem Abschluss dieser Methode ein Array gemäß der `optionValue` Parameter enthält den Wert des angegebenen <xref:System.Net.Sockets.Socket> Option.  
  
 Wenn die Länge des der `optionValue` Array ist kleiner als die erforderliche Anzahl von Bytes zum Speichern des Werts des angegebenen <xref:System.Net.Sockets.Socket> Option <xref:System.Net.Sockets.Socket.GetSocketOption%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers. Verwenden Sie diese Überladung für Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Der folgende code Beispiel ruft die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte und zeigt sie an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
 \- oder –  
  
 In .NET Compact Framework-Anwendungen wird die Windows CE-Standardspeicherplatz Puffer auf 32768 Byte festgelegt. Sie können ändern, die pro Socket Pufferspeicher durch Aufrufen von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionLength">Die Länge in Bytes, der von der erwartete Rückgabewert.</param>
        <summary>Gibt den Wert des angegebenen <see cref="T:System.Net.Sockets.Socket" /> Option in einem Array.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" /> , den Wert der Option "Socket" enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `optionLength` Parameter legt die maximale Größe des zurückgegebenen Bytearrays. Wenn der Optionswert weniger Bytes erforderlich ist, wird das Array enthalten nur die Anzahl an Bytes. Wenn der Optionswert mehr Bytes erfordert <xref:System.Net.Sockets.Socket.GetSocketOption%2A> löst eine <xref:System.Net.Sockets.SocketException>. Verwenden Sie diese Überladung für Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Der folgende code Beispiel ruft die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte und zeigt sie an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
 \- oder –  
  
 In .NET Compact Framework-Anwendungen wird die Windows CE-Standardspeicherplatz Puffer auf 32768 Byte festgelegt. Sie können ändern, die pro Socket Pufferspeicher durch Aufrufen von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Betriebssystemhandle für die <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Ein <see cref="T:System.IntPtr" /> , das das Betriebssystemhandle für darstellt. die <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Ein <see cref="T:System.Int32" /> Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</param>
        <param name="optionInValue">Ein <see cref="T:System.Byte" /> Array, die durch den Vorgang erforderlichen Eingabedaten enthält.</param>
        <param name="optionOutValue">Ein <see cref="T:System.Byte" /> Array, das die vom Vorgang zurückgegebenen Ausgabedaten enthält.</param>
        <summary>Legt die Low-Level Betriebsmodi für die <see cref="T:System.Net.Sockets.Socket" /> mit numerischen Steuerungscodes.</summary>
        <returns>Die Anzahl der Bytes in der <paramref name="optionOutValue" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.IOControl%2A> -Methode bietet auf niedriger Ebene Zugriff auf das Betriebssystem <xref:System.Net.Sockets.Socket> zugrunde liegenden der aktuellen Instanz der dem <xref:System.Net.Sockets.Socket> Klasse. Weitere Informationen finden Sie in der WSAIoctl-Dokumentation in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Ergebnisse von FIONREAD und verfügbare Eigenschaft verglichen.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, so ändern Sie den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" /> Eigenschaft.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ausführen von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Ein <see cref="T:System.Net.Sockets.IOControlCode" /> Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</param>
        <param name="optionInValue">Ein Array vom Typ <see cref="T:System.Byte" /> , die durch den Vorgang erforderlichen Eingabedaten enthält.</param>
        <param name="optionOutValue">Ein Array vom Typ <see cref="T:System.Byte" /> , enthält die Ausgabedaten, die vom Vorgang zurückgegeben wird.</param>
        <summary>Legt die Low-Level Betriebsmodi für die <see cref="T:System.Net.Sockets.Socket" /> mithilfe der <see cref="T:System.Net.Sockets.IOControlCode" /> Enumeration Steuerungscodes angeben.</summary>
        <returns>Die Anzahl der Bytes in der <paramref name="optionOutValue" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet auf niedriger Ebene Zugriff auf das Betriebssystem <xref:System.Net.Sockets.Socket> zugrunde liegenden der aktuellen Instanz der dem <xref:System.Net.Sockets.Socket> Klasse. Weitere finden Sie in der WSAIoctl-Dokumentation in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Ergebnisse des Aufrufs verglichen <xref:System.Net.Sockets.Socket.IOControl%2A> mit <xref:System.Net.Sockets.IOControlCode.DataToRead> und <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, so ändern Sie den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" /> Eigenschaft.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Ausführen von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die <see cref="T:System.Net.Sockets.Socket" /> an einen bestimmten lokalen Port gebunden ist.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> an einen lokalen Port gebunden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Socket wird als gebunden an einen lokalen Port angesehen, wenn sie explizit durch Aufrufen von gebunden ist die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode oder implizit durch Aufrufen von Membern wie gebundene <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, welche verwenden einen kurzlebigen lokalen Anschluss (eine frei größer als 1024, vom Betriebssystem ausgewählt.) Server verwenden die <xref:System.Net.Sockets.Socket.Bind%2A> Methode, um an einem bekannten Port binden, damit Clients eine Verbindung damit herstellen können.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.IsBound%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die <see cref="T:System.Net.Sockets.Socket" /> wird verzögert, einen Socket schließen, in dem Versuch, alle ausstehenden Daten zu senden.</summary>
        <value>Ein <see cref="T:System.Net.Sockets.LingerOption" /> , wie beim Schließen eines Sockets linger angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.LingerState%2A> -Eigenschaft ändert das <xref:System.Net.Sockets.Socket.Close%2A> Methode verhält sich. Diese Eigenschaft wird beim Festlegen der Bedingungen ändert, unter denen die Verbindung durch Winsock zurückgesetzt werden kann. Verbindungszurücksetzungen können weiterhin basierend auf dem IP-Protokoll-Verhalten auftreten.  
  
 Diese Eigenschaft steuert die Zeitspanne, die eine Verbindung mit einem verbindungsorientierten geöffnet, nach einem Aufruf von gehalten wird <xref:System.Net.Sockets.Socket.Close%2A> bleibt, wenn noch weitere Daten gesendet werden.  
  
 Beim Aufrufen von Methoden zum Senden von Daten für einen Peer werden diese Daten im ausgehenden Netzwerkpuffer platziert. Diese Eigenschaft kann verwendet werden, um sicherzustellen, dass diese Daten mit dem Remotehost, bevor Sie gesendet werden die <xref:System.Net.Sockets.TcpClient.Close%2A> Methode löscht die Verbindung.  
  
 Erstellen Sie aktivieren, indem eine <xref:System.Net.Sockets.LingerOption> -Instanz, die die gewünschten Werte enthält, und legen Sie die <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft dieser Instanz.  
  
 Die folgende Tabelle beschreibt das Verhalten des der <xref:System.Net.Sockets.Socket.Close%2A> Methode für die möglichen Werte für die <xref:System.Net.Sockets.LingerOption.Enabled%2A> Eigenschaft und die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft gespeichert, der <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft.  
  
|LingerState.Enabled|LingerState.LingerTime|Verhalten|  
|-------------------------|----------------------------|--------------|  
|`false`(deaktiviert), den Standardwert|Das Timeout ist nicht anwendbar (Standard).|Versucht, ausstehende Daten zu senden, bis das Zeitlimit für IP-Protokoll abläuft.|  
|`true`(aktiviert)|Ein Wert ungleich NULL Timeout|Versucht, ausstehende Daten senden, bis das angegebene Timeout abläuft, und wenn der Versuch fehlschlägt, klicken Sie dann Winsock setzt die Verbindung zurück.|  
|`true`(aktiviert)|0 (null) ein Timeout.|Verwirft alle ausstehenden Daten. Für verbindungsorientierte Sockets (z. B. TCP) und setzt Winsock die Verbindung zurück.|  
  
 Der IP-Stapel berechnet die Timeoutzeitspanne standardmäßig IP-Protokoll verwenden, basierend auf die Roundtripzeit der Verbindung. In den meisten Fällen ist das Timeout berechnet, indem der Stapel relevanter als ein von einer Anwendung definiert. Dies ist das Standardverhalten für ein Socket bei der <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft nicht festgelegt ist.  
  
 Wenn die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft gespeichert, der <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft größer als das Standardtimeout für IP-Protokoll festgelegt ist, das Standardtimeout für IP-Protokoll wird weiterhin gelten, und überschreiben.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</param>
        <summary>Stellen ein <see cref="T:System.Net.Sockets.Socket" /> in einem Wartezustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A>bewirkt, dass eine verbindungsorientierten <xref:System.Net.Sockets.Socket> zum Abhören von eingehenden Verbindungsversuche. Die `backlog` Parameter gibt die Anzahl der eingehenden Verbindungen, die für seine Annahme abgefragt werden können. Um die maximale Anzahl von Verbindungen zu ermitteln, können Sie angeben, Abrufen der <xref:System.Net.Sockets.SocketOptionName.MaxConnections> Wert. <xref:System.Net.Sockets.Socket.Listen%2A>wird nicht blockiert.  
  
 Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers. Verwendung <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> annehmen eine Verbindung aus der Warteschlange.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.Listen%2A>, oder <xref:System.Net.Sockets.Socket.Listen%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Backlog-Parameter ist beschränkt auf verschiedene Werte je nach Betriebssystem. Sie können einen höheren Wert angeben, aber der Rückstand ist beschränkt, basierend auf dem Betriebssystem.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.Socket> zum Lauschen auf eingehende Verbindungen.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen Endpunkt ab.</summary>
        <value>Die <see cref="T:System.Net.EndPoint" /> , die die <see cref="T:System.Net.Sockets.Socket" /> für die Kommunikation verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft ruft eine <xref:System.Net.EndPoint> , enthält die lokale IP-Adresse und Anschlussnummer Zahl an, die <xref:System.Net.Sockets.Socket> gebunden ist. Müssen Sie eine Umwandlung dies <xref:System.Net.EndPoint> auf eine <xref:System.Net.IPEndPoint> vor dem Abrufen von Informationen. Rufen Sie dann die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Methode zum Abrufen des lokalen <xref:System.Net.IPAddress>, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode, um die lokalen Portnummer abzurufen.  
  
 Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft wird normalerweise festgelegt, nachdem Sie einen Aufruf zum Ausführen der <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie zulassen, dass das System Zuweisen des Sockets lokale IP-Adresse und Portnummer an, dass die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft wird festgelegt, nach dem ersten e/a-Vorgang. Für verbindungsorientierte Protokolle, wäre der erste e/a-Vorgang ein Aufruf der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Für verbindungslose Protokolle würde der erste e/a-Vorgang werden für das Senden oder Empfangen von Aufrufe.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgerufen, und die lokalen und Remoteendpunkte angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob ausgehende Multicastpakete an die sendende Anwendung übermittelt werden.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> ausgehende Multicastpakete; empfängt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multicast ist eine skalierbare Methode für die m: n-Kommunikation über das Internet. Ein Prozess abonniert eine Multicastadresse; Alle Pakete von einem abonnierte Prozess gesendet werden anschließend von jedem anderen Prozess abonniert die Multicastadresse empfangen.  
  
 Durch Festlegen dieser Eigenschaft für ein Socket Protokoll TCP (Transmission Control) werden keine Auswirkungen haben.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ihn fest ein <see cref="T:System.Boolean" /> Wert, der angibt, ob der Stream <see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet.</summary>
        <value>
          <see langword="false" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, andernfalls <see langword="true" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nagle-Algorithmus wurde entwickelt, um den Netzwerkverkehr zu reduzieren, den Socket kleine Pakete und kombinieren, und senden Sie diese in einem Paket unter bestimmten Umständen zu verursachen. Ein TCP-Paket besteht aus 40 Byte der Header und der Daten, die gesendet werden. Wenn kleine Datenpakete mit TCP gesendet werden, kann der Mehraufwand des TCP-Headers ein wesentlicher Teil des Netzwerkdatenverkehrs werden. In stark ausgelasteten Netzwerken kann die Überlastung, die aus diesen zusätzlichen Aufwand stammenden verloren Datagramme und-Pakete voneinander trennt sowie eine übermäßige Weitergabe Zeit aufgrund von Überlastung führen. Der Nagle-Algorithmus wird verhindert, dass das Senden von neuen TCP Segmentswhen neue ausgehende Daten des Benutzers eintrifft werden, wenn alle zuvor übertragene Daten für die Verbindung nicht bestätigte bleibt.  
  
 Die meisten netzwerkanwendungen sollte den Nagle-Algorithmus verwenden.  
  
 Durch Festlegen dieser Eigenschaft für ein Socket User Datagram Protocol (UDP), wird keine Auswirkungen haben.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.NoDelay%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf die <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten Internetprotokoll Version 4 (IPv4) unterstützt.</summary>
        <value>
          <see langword="true" />Wenn das Betriebssystem und die Netzwerkkarten das IPv4-Protokoll unterstützen andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten Internetprotokoll Version 6 (IPv6) unterstützen.</summary>
        <value>
          <see langword="true" />Wenn das Betriebssystem und die Netzwerkadapter die IPv6-Protokoll unterstützen andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Die Zeit zum Warten auf eine Antwort in Mikrosekunden.</param>
        <param name="mode">Einer der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</param>
        <summary>Bestimmt den Status der <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Den Status der <see cref="T:System.Net.Sockets.Socket" /> basierend auf der übergebenen Werts für den Abruf der <paramref name="mode" /> Parameter.  
  
 <list type="table"><listheader><term>Modus  
  
 </term><description>Rückgabewert  
  
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />Wenn <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> aufgerufen wurde und eine Verbindung aussteht.  
  
 - oder -   
  
 <see langword="true" />Wenn Daten zum Lesen verfügbar sind.  
  
 - oder -   
  
 <see langword="true" />Wenn die Verbindung wurde geschlossen, zurücksetzen, oder beendet.  
  
 Andernfalls gibt <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, wenn die Verarbeitung einer <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, und die Verbindung erfolgreich war.  
  
 - oder -   
  
 <see langword="true" />Wenn Daten gesendet werden können.  
  
 Andernfalls gibt <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />Bei der Verarbeitung einer <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> , die nicht blockiert, und die Verbindung fehlgeschlagen ist.  
  
 - oder -   
  
 <see langword="true" />Wenn <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nicht festgelegt ist und Out-of-Band-Daten verfügbar ist.  
  
 Andernfalls gibt <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Poll%2A> Methode überprüft den Status der <xref:System.Net.Sockets.Socket>. Geben Sie <xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType> für die `selectMode` Parameter, um festzustellen, wo die <xref:System.Net.Sockets.Socket> lesbar ist. Geben Sie <xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType> zum bestimmen, ob die <xref:System.Net.Sockets.Socket> geschrieben werden kann. Verwendung <xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType> eine fehlerbedingung erkannt. <xref:System.Net.Sockets.Socket.Poll%2A>blockiert die Ausführung bis zum angegebenen Zeitraum, gemessen in `microseconds`, verstrichen ist. Legen Sie die `microSeconds` Parameter, um eine negative ganze Zahl, wenn Sie, um unbegrenzt zu warten, bis eine Antwort möchten. Wenn Sie den Status mehrerer Sockets überprüfen möchten, Sie möchten möglicherweise verwenden Sie die <xref:System.Net.Sockets.Socket.Select%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Diese Methode nicht erkannt werden bestimmte Arten von Verbindungsproblemen, z. B. eine fehlerhafte Netzwerkkabel oder, die der Remotehost nicht ordnungsgemäß heruntergefahren wurde. Sie müssen versuchen zum Senden oder Empfangen von Daten, um diese Arten von Fehlern zu erkennen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket erstellt, eine Verbindung mit einem Server her und verwendet <xref:System.Net.Sockets.Socket.Poll%2A> zum Überprüfen des Status des Sockets.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die <paramref name="mode" /> Parameter ist nicht die <see cref="T:System.Net.Sockets.SelectMode" /> Werte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie weiter unten im Abschnitt "Hinweise".</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Protokolltyp der <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ProtocolType%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> erstellt wird, und gibt das Protokoll verwendet wird, <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, und <xref:System.Net.Sockets.ProtocolType> an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <summary>Empfängt Daten von einer Grenze <see cref="T:System.Net.Sockets.Socket" /> in einen Empfangspuffer.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können Aufrufen <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierten und verbindungslose Sockets.  
  
 Diese Überladung müssen nur einen Empfangspuffer bereitstellen. Der Pufferoffset hat den Standardwert 0, die Größe der Standardwert ist die Länge des Pufferparameters und der <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von den Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird empfängt Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste der <see cref="T:System.ArraySegment`1" />vom Typ s <see cref="T:System.Byte" /> die empfangenen Daten enthält.</param>
        <summary>Empfängt Daten von einer Grenze <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den Puffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können aus einem verbindungsorientierten und verbindungslose Sockets aufrufen.  
  
 Diese Überladung erfordert, dass Sie zur Verfügung stellen oder Empfangspuffer.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von der Verbindung die remote-Host in Eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben das erste Datagramm Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffers` Parameter `buffers` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
 **Hinweis** dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt Daten von einer Grenze <see cref="T:System.Net.Sockets.Socket" /> in einen Puffer Receive mithilfe des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können Aufrufen <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierten und verbindungslose Sockets.  
  
 Diese Überladung erfordert nur einen Empfangspuffer und die erforderlichen bereitstellen <xref:System.Net.Sockets.SocketFlags>. Der Pufferoffset hat den Standardwert 0, und die Größe wird standardmäßig auf die Länge des Byteparameters.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von den Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie in nicht blockierenden Modus, und es keine Daten in der Protokoll-Stack-Puffer sind der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie Ihre Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben das erste Datagramm Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt einen Datenpuffer und <xref:System.Net.Sockets.SocketFlags> für den Empfang von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste der <see cref="T:System.ArraySegment`1" />vom Typ s <see cref="T:System.Byte" /> die empfangenen Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt Daten von einer Grenze <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den `buffers` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Sie können aus einem verbindungsorientierten und verbindungslose Sockets aufrufen.  
  
 Diese Überladung erfordert, dass Sie zur Verfügung stellen oder Empfangspuffer. Die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von der Verbindung die remote-Host in Eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> löst das Aufrufen einer <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben das erste Datagramm Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffers` Parameter `buffers` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Empfangen von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="buffers" />. Count ist 0 (null).</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt die angegebene Anzahl von Bytes an Daten aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einen Puffer Receive mithilfe des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den `buffer` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Sie können Aufrufen <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierten und verbindungslose Sockets.  
  
 Diese Überladung nur mus eine Empfangspuffer, die Anzahl der Bytes, die Sie erhalten möchten, und die erforderlichen <xref:System.Net.Sockets.SocketFlags>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von den Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie Ihre Empfangsvorgang.  
  
 Bei einem verbindungsorientierten Verwendung <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten wie bis zur Anzahl der vom angegebenen Bytes verfügbar ist, liest die `size` Parameter. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Die nachfolgenden Empfänge, die Daten in den `buffer`, und gibt <xref:System.Net.Sockets.SocketFlags.None> für <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" />überschreitet die Größe des <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste der <see cref="T:System.ArraySegment`1" />vom Typ s <see cref="T:System.Byte" /> die empfangenen Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <summary>Empfängt Daten von einer Grenze <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den `buffers` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Sie können aus einem verbindungsorientierten und verbindungslose Sockets aufrufen.  
  
 Diese Überladung erfordert, dass Sie zur Verfügung stellen oder Empfangspuffer. Die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von der Verbindung die remote-Host in Eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> löst das Aufrufen einer <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffers` Parameter `buffers` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="buffers" />. Count ist 0 (null).</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <c>Puffer</c> zum Speichern der empfangenen Daten.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt die angegebene Anzahl von Bytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der angegebenen Offsetposition des Empfangspuffers, unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können Aufrufen <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierten und verbindungslose Sockets.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von den Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie unter "Hinweise" weiter unten. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest so viele Daten wie verfügbar ist, bis zur Anzahl der Bytes, die Size-Parameter angegeben wird. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt einen Datenpuffer, ein Offset, Größe und ein Socket-Flag vor dem Empfangen von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="offset">Die Position in der <c>Puffer</c> Parameter zum Speichern der empfangenen Daten.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <summary>Empfängt Daten von einer Grenze <see cref="T:System.Net.Sockets.Socket" /> in einen Puffer Receive mithilfe des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können Aufrufen <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierten und verbindungslose Sockets.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit remote-Host oder <xref:System.Net.Sockets.Socket.Accept%2A> auf eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest nur Daten, die von den Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>können Sie Daten von jedem Host zu erhalten.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie unter "Hinweise" weiter unten. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Wenn Sie einen verbindungsorientierten verwenden <xref:System.Net.Sockets.Socket>, die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest so viele Daten wie verfügbar ist, bis zur Anzahl der Bytes, die Size-Parameter angegeben wird. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm Sie erhalten größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft ist nicht festgelegt.  
  
 - oder -   
  
 Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Beginnt eine asynchrone Anforderung zum Empfangen von Daten aus einer verbundenen <see cref="T:System.Net.Sockets.Socket" /> Objekt.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methode wird verwendet, für verbundene Sockets oder gebundene Sockets ohne Verbindung und wird verwendet, um eingehende Daten gelesen. Der lokale Socketadresse muss bekannt sein.  
  
 Für gebundene Sockets ohne Verbindung schränkt diese Funktion die Adressen aus dem empfangene Nachrichten akzeptiert werden. Die Funktion gibt nur Nachrichten aus der in der Verbindung angegebenen Remoteadresse. Nachrichten von anderen Adressen werden automatisch verworfen.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Eigenschaft auf die `e` Parameter enthält das Fenster Sockets Dienstanbieter mit zusätzlichen Informationen über die leseanforderung. Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Für Sockets Byte im Stream-Format verwenden werden der eingehende Daten in den Puffer eingefügt, bis der Puffer voll ist, die Verbindung geschlossen wird oder die intern gepufferten Daten erschöpft ist.  
  
 Für nachrichtenorientierter Sockets wird eine eingehende Nachricht in den Puffer bis zu der Gesamtgröße des Puffers zugeordnet platziert die `e` Parameter. Wenn die Nachricht größer als der Puffer ist, wird der Puffer mit dem ersten Teil der Nachricht gefüllt.  
  
 Für verbindungsorientierte Sockets die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methode kann ein ordnungsgemäße Beenden der virtuellen Verbindung in einer von zwei Methoden, die abhängig, ob der Socket Bytestream oder dienstorientierten Nachricht ist angeben. Bei Bytestreams gibt 0 (null) Bytes gelesen ordnungsgemäß geschlossen werden, sodass keine weiteren Bytes mehr gelesen werden. Für nachrichtenorientierter Sockets, in dem eine 0 (null) Bytes Nachricht häufig zulässige ist, eine <xref:System.Net.Sockets.SocketException> mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den systemeigenen WSAEDISCON Winsock-Fehlercode (10101) wird verwendet, um ordnungsgemäß geschlossen anzugeben. In jedem Fall eine <xref:System.Net.Sockets.SocketException> mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> der systemeigenen Winsock WSAECONNRESET Fehlercode (10054) zeigt an einem abbrechenden schließen aufgetreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument war ungültig. Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> Eigenschaften auf der <paramref name="e" /> -Parameter muss gültige Puffer verweisen. Eines dieser Zuordnungsverfahren dieser Eigenschaften kann festlegen, aber nicht beides gleichzeitig sein.</exception>
        <exception cref="T:System.InvalidOperationException">Bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, die Größe des Empfangspuffers von der <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Eine <see cref="T:System.Int32" /> , die die Größe des Empfangspuffers in Bytes enthält. Der Standard ist 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein größeren Puffer potenziell reduziert die Anzahl der leeren Bestätigungen (TCP-Paketen mit keine Datenteil), aber möglicherweise auch dann verzögern, die Erkennung von Problemen bei der Verbindung. Erhöhen Sie die Größe des Puffers, wenn Sie große Dateien übertragen, oder Sie verwenden eine hohe Bandbreite, die hohe Latenz der Verbindung (z. B. ein Satellit Breitband-Anbieter.)  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Für einen Set-Vorgang angegebene Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt ein Datagramm im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.  
  
 Diese Überladung erfordert nur eine Receive-Anweisung bereitstellen `buffer`, und ein <xref:System.Net.EndPoint> , der den Remotehost darstellt. Der Pufferoffset hat den Standardwert 0. Die Standardgröße der Länge der `buffer` Parameter und die `socketFlags` -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit Binden der <xref:System.Net.Sockets.Socket> in einen lokalen Endpunkt mit der <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm Sie erhalten größer als die Größe des `buffer`, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich und löst der Meldung ein <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten. Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einer ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In diesen Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode ignoriert die `remoteEP` Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.  
  
 Mit verbindungsorientierte Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten bis zur Größe des verfügbaren `buffer`. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss übereinstimmen der <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" /> d. h. den Speicherort für die empfangenen Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt ein Datagramm im Datenpuffer unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />, und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.  
  
 Diese Überladung erfordert nur einen Empfangspuffer, die erforderlichen bereitstellen <xref:System.Net.Sockets.SocketFlags>, und ein <xref:System.Net.EndPoint> , der den Remotehost darstellt. Der Offset der Standardwert ist 0 und der Größe der Standardwert ist die Länge des Pufferparameters.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit Binden der <xref:System.Net.Sockets.Socket> in einen lokalen Endpunkt mit der <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm Sie erhalten größer als die Größe des `buffer`, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich und löst der Meldung ein <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten. Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einer ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In diesen Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode ignoriert die `remoteEP` Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.  
  
 Mit verbindungsorientierte Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten bis zur Größe des verfügbaren `buffer`. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss übereinstimmen der <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen. <xref:System.Net.Sockets.SocketFlags>zum Übergeben der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt die angegebene Anzahl von Bytes im Datenpuffer unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />, und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.  
  
 Diese Überladung erfordert nur einen Empfangspuffer, die Anzahl der Bytes Geben Sie erhalten möchten, die erforderlichen <xref:System.Net.Sockets.SocketFlags>, und ein <xref:System.Net.EndPoint> , der den Remotehost darstellt. Der Pufferoffset hat den Standardwert 0.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm Sie erhalten größer als die Größe des `buffer`, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich und löst der Meldung ein <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten. Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einer ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In diesen Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode ignoriert die `remoteEP` Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.  
  
 Mit verbindungsorientierte Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viel verfügbaren Daten bis zur Anzahl der Bytes, die gemäß der `size` Parameter. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit Binden der <xref:System.Net.Sockets.Socket> in einen lokalen Endpunkt mit der <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss übereinstimmen der <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen. Die Größe des Puffers und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position in der <c>Puffer</c> Parameter zum Speichern der empfangenen Daten.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm Sie erhalten größer als die Größe des `buffer`, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich und löst der Meldung ein <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten. Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einer ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, ist die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis Daten verfügbar sind. Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In diesen Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode ignoriert die `remoteEP` Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.  
  
 Mit verbindungsorientierte Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viel verfügbaren Daten bis zu die Anzahl der Bytes, die gemäß der `size` Parameter. Wenn der remote-Host heruntergefahren der <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit Binden der <xref:System.Net.Sockets.Socket> in einen lokalen Endpunkt mit der <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss übereinstimmen der <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen. Der Offset, die Puffergröße und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Startet asynchron empfangen von Daten von einem angegebenen Netzwerkgerät.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Methode wird in erster Linie zum Empfangen von Daten auf einem verbindungslosen Socket verwendet. Der lokale Socketadresse muss bekannt sein.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, aus dem die Daten empfangen werden soll.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Eigenschaft auf die `e` Parameter enthält das Fenster Sockets Dienstanbieter mit zusätzlichen Informationen über die leseanforderung. Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Für nachrichtenorientierter Sockets wird eine eingehende Nachricht in den Puffer bis zu der Gesamtgröße des Puffers eingefügt. Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.  
  
 Für Byte-Datenstrom Stil Sockets werden der eingehende Daten in den Puffer eingefügt, bis der Puffer voll ist, die Verbindung geschlossen wird oder die intern gepufferten Daten erschöpft ist. Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht null sein.</exception>
        <exception cref="T:System.InvalidOperationException">Bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position in der <c>Puffer</c> Parameter zum Speichern der empfangenen Daten.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <param name="ipPacketInformation">Ein <see cref="T:System.Net.Sockets.IPPacketInformation" />-Objekt, das Adress- und Schnittstelleninformationen enthält.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> -Methode liest Daten in den `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten, sowie Informationen über das empfangene Paket gesendet wurden.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode wird in erster Linie zum Empfangen von Nachrichtendaten auf einem verbindungslosen Socket verwendet. Der lokale Socketadresse muss bekannt sein. Diese Methode kann nur mit Datagramm und raw-Sockets verwendet werden. Der Socket muss initialisiert werden, mit der Socket <xref:System.Net.Sockets.SocketType.Dgram> oder <xref:System.Net.Sockets.SocketType.Raw> vor dem Aufrufen dieser Methode. Dies ist möglich, wenn der Socket erstellt wurde, mit <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Für Sockets nachrichtenorientierter befindet sich eine eingehende Nachricht in die `buffer` Parameter bis zu der Gesamtgröße angegeben, der `size` Parameter. Die `offset` Parameter bestimmt, wo in der `buffer` Daten befindet. Die tatsächliche Datenmenge platziert, in der `buffer` wird zurückgegeben, durch die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.  
  
 Der <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> -Methode legt automatisch die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf `true` beim ersten für Aufruf eine angegebene <xref:System.Net.Sockets.Socket>. Allerdings das zurückgegebene <xref:System.Net.Sockets.IPPacketInformation> Objekt ist nur für Pakete, die auf dem lokalen Computer ankommen, nachdem die Socketoption festgelegt wurde ungültig wird. Wenn ein Socket Pakete zwischen gesendet wird, wenn es an einen lokalen Endpunkt gebunden ist (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch einen der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, oder <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methoden) und dem ersten Aufruf der <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methodenaufrufe <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> wird Methodenrückgabewert ungültige <xref:System.Net.Sockets.IPPacketInformation> Objekte für diese Pakete.  
  
 Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation> Objekte gültig sind, sollte eine Anwendung festlegen, die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf `true` , bevor sie an einen lokalen Endpunkt gebunden ist die <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> Methode.  
  
 Eine Anwendung kann Untersuchen der `ipPacketInformation` Parameter an, wenn sie wissen muss, ob das Datagramm mit einer Unicast-, Multicast- oder Broadcastnetzwerkverkehr gesendet wurde.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss übereinstimmen der <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 \-oder -  
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 .NET Framework wird auf ein AMD-64-Bit-Prozessor ausgeführt.  
  
 - oder -   
  
 Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, und diese Methode erfordert Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">zum Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Startet die angegebene Anzahl von Bytes an Daten in der angegebenen Position in der unter Verwendung des angegebenen Datenpuffers asynchron empfangen <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode wird in erster Linie zum Empfangen von Nachrichtendaten auf einem verbindungslosen Socket verwendet. Der lokale Socketadresse muss bekannt sein. Diese Methode kann nur mit Datagramm und raw-Sockets verwendet werden. Der Socket muss initialisiert werden, mit der Socket <xref:System.Net.Sockets.SocketType.Dgram> oder <xref:System.Net.Sockets.SocketType.Raw> vor dem Aufrufen dieser Methode. Dies ist möglich, wenn der Socket erstellt wurde, mit <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, aus dem die Daten empfangen werden soll.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Für nachrichtenorientierter Sockets wird eine eingehende Nachricht in den Puffer bis zu der Gesamtgröße des Puffers eingefügt. Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> -Methode legt automatisch die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf `true` zum ersten Mal er, für aufgerufen wird einen angegebenen <xref:System.Net.Sockets.Socket>. Allerdings die <xref:System.Net.Sockets.IPPacketInformation> Objekt ist nur für Pakete, die auf dem lokalen Computer ankommen, nachdem die Socketoption festgelegt wurde ungültig wird. Wenn ein Socket Pakete zwischen gesendet wird, wenn der Socket an einen lokalen Endpunkt gebunden ist (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine von der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, oder <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methoden) und der erste Aufruf der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>Methodenaufrufe <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode führt dazu, Invalid <xref:System.Net.Sockets.IPPacketInformation> Objekte für diese Pakete.  
  
 Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation> Objekte gültig sind, sollte eine Anwendung festlegen, die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf`true` , bevor sie an einen lokalen Endpunkt gebunden ist die <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> Methode.  
  
 Eine Anwendung kann die resultierende untersuchen <xref:System.Net.Sockets.IPPacketInformation> Objekten zurück, wenn sie wissen muss, ob das Datagramm mit einer Unicast-, Multicast- oder Broadcastnetzwerkverkehr gesendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht null sein.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, die Zeitdauer nach dem synchronen <see cref="Overload:System.Net.Sockets.Socket.Receive" /> Aufruf durch einen Timeout beendet.</summary>
        <value>Der Timeoutwert in Millisekunden. Der Standardwert ist 0, womit ein unendliches Timeout an. Wenn-1 angegeben gibt auch ein unendliches Timeout an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Option gilt für synchrone <xref:System.Net.Sockets.Socket.Receive%2A> nur aufruft. Wenn das Timeoutintervall überschritten wird, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Für einen Set-Vorgang angegebene Wert ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Remoteendpunkt ab.</summary>
        <value>Die <see cref="T:System.Net.EndPoint" /> mit dem der <see cref="T:System.Net.Sockets.Socket" /> kommuniziert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft ruft die <xref:System.Net.EndPoint> , enthält die remote-IP-Adresse und Anschlussnummer Zahl an, die <xref:System.Net.Sockets.Socket> verbunden ist. Wenn Sie ein verbindungsloses Protokoll verwenden <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> enthält die standardmäßige remote IP-Adresse und Port-Nummer, mit denen die <xref:System.Net.Sockets.Socket> kommuniziert. Müssen Sie eine Umwandlung dies <xref:System.Net.EndPoint> auf eine <xref:System.Net.IPEndPoint> vor dem Abrufen von Informationen. Rufen Sie dann die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Methode zum Abrufen der entfernten <xref:System.Net.IPAddress>, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode, um die Nummer des Remoteports abzurufen.  
  
 Die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> festgelegt ist, nach einem Aufruf von entweder <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie versuchen, Zugriff auf diese Eigenschaft zuvor <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgerufen, und die lokalen und Remoteendpunkte angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob sie gelesen werden können.</param>
        <param name="checkWrite">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob in sie geschrieben werden kann.</param>
        <param name="checkError">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, die auf Fehler überprüft werden sollen.</param>
        <param name="microSeconds">Der Timeoutwert in Mikrosekunden. Ein Wert von -1 gibt ein unendliches Timeout an.</param>
        <summary>Bestimmt den Status von einem oder mehreren Sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A>ist eine statische Methode, die den Status einer oder mehrerer bestimmt <xref:System.Net.Sockets.Socket> Instanzen. Richten Sie eine oder mehrere Sockets in einer <xref:System.Collections.IList> vor der Verwendung der <xref:System.Net.Sockets.Socket.Select%2A> Methode. Überprüfen Sie zur besseren Lesbarkeit durch Aufrufen von <xref:System.Net.Sockets.Socket.Select%2A> mit der <xref:System.Collections.IList> als die `checkRead` Parameter. Verwenden Sie zum Überprüfen Ihrer Sockets können die `checkWrite` Parameter. Verwenden Sie Fehlerzustände zu erkennen, `checkError`. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Select%2A>die <xref:System.Collections.IList> ausgefüllt mit nur diese Sockets, die die Bedingung erfüllen.  
  
 Wenn Sie in einem Wartezustand befinden, Lesbarkeit bedeutet, dass einen Aufruf von <xref:System.Net.Sockets.Socket.Accept%2A> wird erfolgreich ausgeführt, ohne zu blockieren. Wenn Sie die Verbindung bereits akzeptiert haben, bedeutet die Lesbarkeit, dass Daten zum Lesen verfügbar sind. In diesen Fällen werden alle Empfangsvorgänge wird erfolgreich ausgeführt, ohne zu blockieren. Lesbarkeit kann auch darauf hinweisen, ob die Remote <xref:System.Net.Sockets.Socket> wurde die Verbindung; in diesem Fall heruntergefahren einen Aufruf von <xref:System.Net.Sockets.Socket.Receive%2A> wird sofort zurückgegeben werden, und 0 (null) Bytes zurückgegeben.  
  
 <xref:System.Net.Sockets.Socket.Select%2A>Gibt zurück, wenn mindestens eines der Sockets von Interesse sind (die Sockets in der `checkRead`, `checkWrite`, und `checkError` aufgeführt) die angegebenen Kriterien erfüllt oder `microSeconds` Parameter überschritten wird, welcher Fall zuerst eintritt. Festlegen von `microSeconds` auf-1 gibt ein unbegrenztes Timeout.  
  
 Wenn Sie einen nicht blockierenden Aufruf vornehmen <xref:System.Net.Sockets.Socket.Connect%2A>, Schreibberechtigung bedeutet, dass Sie erfolgreich eine Verbindung hergestellt haben. Wenn Sie bereits eine Verbindung hergestellt haben, also können alle senden, ohne Blockierung Vorgänge werden zwar erfolgreich ausgeführt werden.  
  
 Wenn Sie einen nicht blockierenden Aufruf vorgenommen haben <xref:System.Net.Sockets.Socket.Connect%2A>die `checkerror` Parameter identifiziert Sockets, die nicht verbunden.  
  
> [!NOTE]
>  Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, wenn Sie nur den Status einer einzelnen bestimmen möchten <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Diese Methode nicht erkannt werden bestimmte Arten von Verbindungsproblemen, z. B. eine fehlerhafte Netzwerkkabel oder, die der Remotehost nicht ordnungsgemäß heruntergefahren wurde. Sie müssen versuchen zum Senden oder Empfangen von Daten, um diese Arten von Fehlern zu erkennen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.Socket.Select%2A> um zu bestimmen, welche empfangsbereiten Sockets eine verbindungsanforderung haben.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="checkRead" />-Parameter ist <see langword="null" /> oder leer.  
  
 - und -  
  
 Der <paramref name="checkWrite" />-Parameter ist <see langword="null" /> oder leer.  
  
 - und -  
  
 Der <paramref name="checkError" />-Parameter ist <see langword="null" /> oder leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>sendet Daten synchron mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A>kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss es sich um einen Puffer, der die Daten enthält, die Sie senden möchten. Die <xref:System.Net.Sockets.SocketFlags> Wert hat den Standardwert 0, der Pufferoffset hat den Standardwert 0, und die Anzahl der Bytes, die Standardwerte auf die Größe des Puffers zu senden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, sendende von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste der <see cref="T:System.ArraySegment`1" />vom Typ s <see cref="T:System.Byte" /> enthält die Daten gesendet werden.</param>
        <summary>Sendet den Satz von Puffern in der Liste an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung erfordert mindestens einen Puffer mit den Daten, die Sie senden möchten.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Finden Sie im Abschnitt "Hinweise" weiter unten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" /> unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>sendet Daten synchron an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. Die <xref:System.Net.Sockets.Socket.Send%2A> Methode kann bei einem verbindungsorientierten und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss ein Puffer mit den Daten gesendet werden soll und eine bitweise Kombination von <xref:System.Net.Sockets.SocketFlags>. Der Pufferoffset hat den Standardwert 0, und die Anzahl der Bytes, die Standardwerte auf die Größe des Puffers zu senden. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameterwert, der die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, müssen Sie rufen die <xref:System.Net.Sockets.Socket.Connect%2A> vor jeder Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter[Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, sendende von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste der <see cref="T:System.ArraySegment`1" />vom Typ s <see cref="T:System.Byte" /> enthält die Daten gesendet werden.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet den Satz von Puffern in der Liste an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erfordert mindestens einen Puffer mit den Daten, die Sie senden möchten. Die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig auf 0. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketFlags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Im Modus nicht blockierend <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>sendet Daten synchron an den Remotehost, der der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A>kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss ein Puffer mit den Daten zu senden, die Anzahl der Bytes, die Sie senden möchten, und eine bitweise Kombination von <xref:System.Net.Sockets.SocketFlags>. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, müssen Sie rufen die <xref:System.Net.Sockets.Socket.Connect%2A> vor jeder Aufruf von der <xref:System.Net.Sockets.Socket.Send%2A> Methode. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Mit einem verbindungsorientiertes Protokoll <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet die Daten in Puffer und gibt <xref:System.Net.Sockets.SocketFlags.None> für <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" />ist kleiner als 0 oder überschreitet die Größe des Puffers.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Ein Betriebssystem-Fehler tritt beim Zugriff auf den Socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste der <see cref="T:System.ArraySegment`1" />vom Typ s <see cref="T:System.Byte" /> enthält die Daten gesendet werden.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <summary>Sendet den Satz von Puffern in der Liste an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung erfordert mindestens einen Puffer mit den Daten, die Sie senden möchten. Die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig auf 0. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketFlags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. Im Modus nicht blockierend <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, beginnend bei einem angegebenen Offset und unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>sendet Daten synchron mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A>kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 In dieser Überladung, wenn Sie angeben, die <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <xref:System.Net.Sockets.Socket.SendTo%2A>. Wenn Sie nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A>, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Es ist angemessen, verwenden Sie <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Sie müssen auch sicher sein, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel gibt an, den Datenpuffer, ein Offset, Größe und <xref:System.Net.Sockets.SocketFlags> zum Senden von Daten an einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" /> -Objekt, den Socketfehler speichert.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, beginnend am angegebenen Offset begonnen und unter Verwendung des angegebenen<see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>sendet Daten synchron mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A>kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 In dieser Überladung, wenn Sie angeben, die <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <xref:System.Net.Sockets.Socket.SendTo%2A>. Wenn Sie nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A>, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Es ist angemessen, verwenden Sie <xref:System.Net.Sockets.Socket.SendTo%2A> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch vor dem Aufruf der Standard-Remotehost ändern <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Sie müssen auch sicher sein, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Send%2A> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> Aufruf löst eine <xref:System.Net.Sockets.SocketException>. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter[Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel gibt an, den Datenpuffer, ein Offset, Größe und <xref:System.Net.Sockets.SocketFlags> zum Senden von Daten an einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" /> Objekt.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode wird verwendet, um ausgehende Daten aus einem oder mehreren Puffern für einen verbindungsorientierten Socket zu schreiben. Diese Methode kann auch, allerdings auf verbindungslosen Sockets verwendet werden, die einen Remotehost auf ein Verbindungsvorgang angegeben haben.  
  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.SendAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Aufrufen der <xref:System.Net.Sockets.Socket.SendAsync%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.  
  
 Überschreiten Sie für nachrichtenorientierter Sockets Sie die maximale Nachrichtengröße des zugrunde liegenden Windows Sockets-Dienstanbieters nicht. Wenn die Daten der zugrunde liegenden Dienstanbieter atomar passieren zu lang sind, werden keine Daten übertragen und die <xref:System.Net.Sockets.Socket.SendAsync%2A> -Methode löst eine <xref:System.Net.Sockets.SocketException> mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den systemeigenen WSAEMSGSIZE Winsock-Fehlercode (10040) festgelegt.  
  
 Beachten Sie, dass beim erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode nicht, dass die Daten erfolgreich übermittelt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> Eigenschaften auf der <paramref name="e" /> -Parameter muss gültige Puffer verweisen. Eines dieser Zuordnungsverfahren dieser Eigenschaften kann festlegen, aber nicht beides gleichzeitig sein.</exception>
        <exception cref="T:System.InvalidOperationException">Bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Die <see cref="T:System.Net.Sockets.Socket" /> ist noch nicht verbunden oder abgerufen wurde nicht über eine <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, oder <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, die Größe des Sendepuffers von der <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Eine <see cref="T:System.Int32" /> , die die Größe des Sendepuffers in Bytes enthält. Der Standard ist 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Erkennung von Problemen bei der Verbindung ein größeren Puffers möglicherweise verzögert werden. Erhöhen Sie die Größe des Puffers, wenn Sie große Dateien übertragen, oder Sie verwenden eine hohe Bandbreite, die hohe Latenz der Verbindung (z. B. ein Satellit Breitband-Anbieter.)  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.SendBufferSize%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Für einen Set-Vorgang angegebene Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> an einen verbundenen <see cref="T:System.Net.Sockets.Socket" /> -Objekt mit den <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> Flag zu übertragen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet die Datei `fileName` an den verbundenen Socket. Die `flags` Parameter hat den Standardwert <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), und die `preBuffer` und `postBuffer` Parameter standardmäßig `null`. Wenn `fileName` wird in das lokale Verzeichnis es mit nur der Name der Datei identifiziert werden kann; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst wird.  
  
 Diese Methode verwendet die `TransmitFile` -Funktion, die in der Windows Sockets-API 2 gefunden. Weitere Informationen zu den `TransmitFile` -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>sendet synchron eine Datei mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. <xref:System.Net.Sockets.Socket.SendFile%2A>kann für beide verbindungsorientierten und verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode andernfalls <xref:System.Net.Sockets.Socket.SendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> eine Remotehostverbindung oder mit <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die Datei gesendet wird. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.SendFile%2A> möglicherweise erfolgreich abgeschlossen, bevor die gesamte Datei gesendet wurde. Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.SendFile%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und einen Socket verbunden und sendet dann eine Datei mit dem Remotehost. Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="preBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="postBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="flags">Mindestens ein <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> und puffert Daten mit dem angegebenen <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert in einem verbundenen <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung muss der Name der Datei, die Sie senden möchten und eine bitweise Kombination von <xref:System.Net.Sockets.TransmitFileOptions> Werte. Die `preBuffer` Parameter enthält alle Daten, die vor der Datei gesendet werden sollen. `postBuffer`enthält Daten, die Sie die Datei folgen soll. Wenn `fileName` ist im aktuellen Arbeitsverzeichnis, es mit nur der Name der Datei identifiziert werden kann; andernfalls den vollständigen Pfad und Name der Datei müssen angegeben werden. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt.  
  
 Die `flags` Parameter stellt die Fenster Sockets-Dienstanbieter mit zusätzlichen Informationen über die Übertragung von Dateien bereit. Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Diese Methode verwendet die `TransmitFile` -Funktion, die in der Windows Sockets-API 2 gefunden. Weitere Informationen zu den `TransmitFile` -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>sendet synchron eine Datei mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. <xref:System.Net.Sockets.Socket.SendFile%2A>kann für beide verbindungsorientierten und verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode; andernfalls <xref:System.Net.Sockets.Socket.SendFile%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptiert.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die gesamte Datei gesendet wird. In nicht blockierenden Modus <xref:System.Net.Sockets.Socket.SendFile%2A> möglicherweise erfolgreich abgeschlossen, bevor die gesamte Datei gesendet wurde. Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.SendFile%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und einen Socket verbunden. Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers. In diesem Beispiel werden eine Prebuffer und Postbuffer von Daten erstellen und senden sie mit der Datei mit dem Remotehost. Die Standardeinstellung <xref:System.Net.Sockets.TransmitFileOptions> verwendet werden.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist nicht Windows NT oder höher.  
  
 \- oder –  
  
 Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Sendet eine Auflistung von Dateien oder im Arbeitsspeicher Datenpuffer asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" /> Objekt.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode wird verwendet, um eine Auflistung von Dateien oder im Arbeitsspeicher Datenpuffer an remote-Host zu senden. Die <xref:System.Net.Sockets.Socket> muss bereits mit dem Remotehost verbunden sein.  
  
 Wenn eine <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> Verweise auf eine Datei in das Arbeitsverzeichnis, können Sie den Namen der Datei identifiziert werden; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden. Platzhalter und UNC-Freigabenamen werden unterstützt. Wenn die Datei nicht gefunden wird, <xref:System.IO.FileNotFoundException> ausgelöst wird.  
  
 Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs > delegieren, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Eigenschaft auf die `e` Parameter stellt die Fenster Sockets-Dienstanbieter mit zusätzlichen Informationen über die Übertragung von Dateien bereit. Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Diese Methode verwendet die vorhandene TransmitPackets-Funktion in der Windows Sockets-API 2 an. Weitere Informationen zu TransmitPackets-Funktion und den Flags finden Sie unter der Windows Sockets-Dokumentation in der MSDN Library.  
  
 Gedacht für verbindungsorientierte Protokolle der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode, um eine Standard-Remotehost herstellen. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet. Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme.  
  
 Die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode optimiert, nach dem Betriebssystem, auf denen es verwendet wird. Auf Windows Server-Editionen die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode ist für hohe Leistung optimiert.  
  
 Für Editionen von Windows-Client die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode ist für die minimale Arbeitsspeicher und der ressourcennutzung optimiert.  
  
 Verwenden der <xref:System.Net.Sockets.TransmitFileOptions?displayProperty=nameWithType> -flag in der <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Eigenschaft auf die `e` Parameter kann beachtliche Leistungsvorteile bieten. Wenn der Thread initiiert die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methodenaufruf für umfangreiche Berechnungen verwendet wird, es ist möglich, obwohl unwahrscheinlich, dass APCs starten verhindert werden können. Beachten Sie, dass es ein Unterschied zwischen Kernel und im Benutzermodus APCs. Kernel-APCs starten, wenn ein Thread in einen Wartezustand versetzt ist. Im Benutzermodus APCs starten, wenn ein Thread in einem warnpflichtigen Wartezustand ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei der <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode. Diese Ausnahme tritt auch auf, wenn die <see cref="T:System.Net.Sockets.Socket" /> nicht mit einem Remotehost verbunden ist.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ein verbindungsloses <see cref="T:System.Net.Sockets.Socket" /> verwendet wird und die Datei gesendet wird überschreitet die maximale Paketgröße des zugrunde liegenden Transports.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, die Zeitdauer nach dem synchronen <see cref="Overload:System.Net.Sockets.Socket.Send" /> Aufruf durch einen Timeout beendet.</summary>
        <value>Der Timeoutwert in Millisekunden. Wenn Sie die Eigenschaft mit einem Wert zwischen 1 und 499 festlegen, wird der Wert 500 geändert werden. Der Standardwert ist 0, womit ein unendliches Timeout an. Wenn-1 angegeben gibt auch ein unendliches Timeout an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Option gilt für synchrone <xref:System.Net.Sockets.Socket.Send%2A> nur aufruft. Wenn das Timeoutintervall überschritten wird, die <xref:System.Net.Sockets.Socket.Send%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.SendTimeout%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Für einen Set-Vorgang angegebene Wert ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="remoteEP">Die <see cref="T:System.Net.EndPoint" /> , die das Ziel für die Daten darstellt.</param>
        <summary>Sendet Daten an den angegebenen Endpunkt.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung der Pufferoffset hat den Standardwert 0, die Anzahl der Bytes die Größe des Standards an die `buffer` Parameter, und die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig auf 0.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>. Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>, die `remoteEP` Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang. Sind Sie auch nicht aufrufen erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In diesen Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.  
  
 Blockierende Sockets blockiert, bis alle Bytes im Puffer gesendet werden. Da ein nicht blockierenden <xref:System.Net.Sockets.Socket> abgeschlossen ist, es möglicherweise nicht umgehend aller Bytes in der `buffer`. Es liegt in Ihrer Anwendung Verantwortung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung alle Bytes in sendet der `buffer`. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Sie müssen auch sicher sein, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Die <see cref="T:System.Net.EndPoint" /> , das den Zielspeicherort für die Daten darstellt.</param>
        <summary>Sendet Daten an einen bestimmten Endpunkt unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung der Pufferoffset hat den Standardwert 0, und die Anzahl der Bytes die Größe des Standards an die `buffer`. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>. Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>, die `remoteEP` Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang. Sind Sie auch nicht aufrufen erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In diesen Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.  
  
 Blockierende Sockets blockieren, bis die angeforderte aller Bytes in den `buffer` gesendet werden. Da ein nicht blockierenden <xref:System.Net.Sockets.Socket> abgeschlossen ist, es möglicherweise nicht umgehend aller Bytes in der `buffer`. Es liegt in Ihrer Anwendung Verantwortung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung alle Bytes in sendet der `buffer`. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis eine erhebliche Menge an ausgehenden Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Sie müssen auch sicher sein, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost. <xref:System.Net.Sockets.SocketFlags>zum Übergeben der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Die <see cref="T:System.Net.EndPoint" /> , das den Zielspeicherort für die Daten darstellt.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung der Pufferoffset hat den Standardwert 0. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> als flag die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>. Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>, die `remoteEP` Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang. Sind Sie auch nicht aufrufen erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In diesen Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.  
  
 Blockierende Sockets wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden. Da eine nicht blockierende <xref:System.Net.Sockets.Socket> abgeschlossen ist, es möglicherweise nicht umgehend alle Bytes in einem einzigen Vorgang angefordert. Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis eine erhebliche Menge an ausgehenden Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Sie müssen auch sicher sein, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost. Die Größe und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Das angegebene <paramref name="size" /> überschreitet die Größe des <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Die <see cref="T:System.Net.EndPoint" /> , das den Zielspeicherort für die Daten darstellt.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt, an der angegebenen Position im Puffer starten, und unter Verwendung des angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung, wenn Sie angeben, die <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` Parameter, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>. Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendTo%2A>, die `remoteEP` Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang. Sind Sie auch nicht aufrufen erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In diesen Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.  
  
 Blockierende Sockets wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden. Da ein nicht blockierender <xref:System.Net.Sockets.Socket> abgeschlossen ist, es möglicherweise nicht umgehend alle Bytes in einem einzigen Vorgang angefordert. Es liegt in Ihrer Verantwortung Anwendungen zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet. Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden. Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis eine erhebliche Menge an ausgehenden Daten gesammelt werden. Ein erfolgreicher Abschluss des der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <xref:System.Net.Sockets.Socket.SendTo%2A> blockiert, bis das Datagramm gesendet wird. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Sie müssen auch sicher sein, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost. Der Offset, Größe und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
 - oder -   
  
 <paramref name="size" /> ist kleiner als 0.  
  
 - oder -   
  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
 - oder -   
  
 Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste besitzt nicht die erforderlichen Berechtigungen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> Objekt, das für diesen asynchronen Socketvorgang verwendet.</param>
        <summary>Sendet asynchron Daten an einen angegebenen Remotehost.</summary>
        <returns>Gibt <see langword="true" /> , wenn der e/a-Vorgang aussteht. Die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter nach dem Abschluss des Vorgangs ausgelöst werden soll.  
  
 Gibt <see langword="false" /> , wenn der e/a-Vorgang synchron abgeschlossen wurde. In diesem Fall die <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> Ereignis auf der <paramref name="e" /> Parameter werden nicht ausgelöst, und die <paramref name="e" /> -Objekt übergeben, wie ein Parameter überprüft werden kann, unmittelbar nach dem Aufruf der Methode zurückgegeben wird, um das Ergebnis des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode startet einen asynchronen Sendevorgang mit dem Remotehost, angegeben der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft von der `e` Parameter. Aufrufen der <xref:System.Net.Sockets.Socket.SendToAsync%2A> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden. Obwohl diese Methode für verbindungslose Protokolle bestimmt ist <xref:System.Net.Sockets.Socket.SendToAsync%2A> arbeitet mit Verbindungs- und verbindungsorientierte Protokolle.  
  
 Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs > delegieren, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <xref:System.Net.Sockets.Socket.SendToAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode. Andernfalls <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer verbindungsorientiertes Protokoll der <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode ignoriert die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft und sendet Daten an die <xref:System.Net.EndPoint?displayProperty=nameWithType> in vielen Branchen der <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> oder <xref:System.Net.Sockets.Socket.SendAsync%2A> Methoden. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.SendToAsync%2A>, die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Überschreiben der Eigenschaft die angegebene Standard-Remotehost, der nur für Sendevorgang. Sind Sie auch nicht aufrufen erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. In diesem Fall wird der zugrunde liegende Dienstanbieter die am besten geeignete lokale IP-Adresse und Anschlussnummer Netzwerknummer zuweisen. Verwenden Sie die Portnummer 0 (null), wenn die zugrunde liegenden Service-Anbieter einen Port frei auswählen soll. Wenn Sie die zugewiesenen LAN-IP-Adresse und Portnummer Anzahl identifizieren müssen, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis signalisiert wurde und die entsprechenden Delegaten aufgerufen werden.  
  
 Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption option <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType> auf "true". Sie müssen auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird. Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Wenn Sie angeben, dass das DontRoute-Flag in der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> -Eigenschaft, die Daten, die Sie senden nicht weitergeleitet werden.  
  
 Für Sockets nachrichtenorientierter muss darauf geachtet werden, nicht zu überschreiten die maximale Nachrichtengröße des zugrunde liegenden Transports. Wenn die Größe des Puffers die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>. Beim erfolgreichen Abschluss einer <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode nicht, dass die Daten erfolgreich übermittelt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht null sein.</exception>
        <exception cref="T:System.InvalidOperationException">Bei einem Socketvorgang war schon Status mithilfe der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> im angegebenen Objekt der <paramref name="e" /> Parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP oder höher ist erforderlich, damit diese Methode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Das angegebene Protokoll ist einem verbindungsorientierten, aber die <see cref="T:System.Net.Sockets.Socket" /> ist noch nicht verbunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">Die IP-Schutzebene auf dieser Ebene festlegen.</param>
        <summary>Legen Sie die Schutzebene für die IP-Socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> -Methode ermöglicht die Einschränkung einen eine IPv6- oder IP-Sockets auf einen angegebenen Bereich, zu überwachen, wie z. B. Adressen mit demselben linklokalen oder standortlokalen Präfix. Diese Socketoption kann Anwendungen zugriffseinschränkungen für IPv6- oder IP-Sockets zu platzieren. Mit solchen Einschränkungen kann sich eine im privaten LAN ausgeführte Anwendung selbst einfach und stabil vor externen Angriffen schützen. Diese Socketoption kann auch verwendet werden, um zugriffsbeschränkungen zu entfernen, wenn die `level` Parametersatz auf <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Diese Socketoption erweitert oder beschränkt den Bereich eines empfangsbereiten Sockets und ermöglicht so bei Bedarf den uneingeschränkten Zugriff von öffentlichen und privaten Benutzern oder beschränkt den Zugriff nur auf denselben Standort.  
  
 Für diese Socketoption sind in der <xref:System.Net.Sockets.IPProtectionLevel>-Enumeration angegebene Schutzebenen definiert.  
  
 Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Methode dient zum Aktivieren oder deaktivieren (Network Address Traversal, NAT) für eine <xref:System.Net.Sockets.Socket> Instanz. NAT-Durchlauf kann mit Teredo, 6to4 oder einen ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn die `level` Parameter auf festgelegt ist <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, oder <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, dies explizit deaktiviert NAT-Durchlauf für eine <xref:System.Net.Sockets.Socket> Instanz.  
  
 Wenn die `level` Parameter auf festgelegt ist <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, kann dieser NAT-Durchlauf für eine <xref:System.Net.Sockets.Socket> abhängig von Firewallregeln auf dem System vorhanden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="level" />-Parameter darf nicht <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> sein. Die IP-Schutzebene kann nicht angegeben festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Net.Sockets.AddressFamily" /> des Sockets muss entweder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Der Wert der Option, dargestellt als eine <see cref="T:System.Boolean" />.</param>
        <summary>Setzt den angegebenen <see cref="T:System.Net.Sockets.Socket" /> Option aus, um den angegebenen <see cref="T:System.Boolean" /> Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Legen Sie `optionValue` auf `true` So aktivieren Sie die Option oder `false` zum Deaktivieren der Option.  
  
 <xref:System.Net.Sockets.Socket>Optionen werden nach Maß an Unterstützung für das Protokoll gruppiert.  
  
 Unten sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen, die mit dieser Überladung festgelegt werden können. Diese Optionen werden von der entsprechenden gruppiert <xref:System.Net.Sockets.SocketOptionLevel> Wert. Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, den entsprechenden verwenden <xref:System.Net.Sockets.SocketOptionLevel> Wert für die `optionLevel` Parameter. Die Option wählen, dass einrichten muss angegeben werden, der `optionName` Parameter. Wenn Sie den aktuellen Wert eines der aufgeführten Optionen abzurufen, verwenden Sie möchten die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Weitere Informationen zu diesen Optionen finden Sie in der <xref:System.Net.Sockets.SocketOptionName> Enumeration.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> mit Ausnahme der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und ermöglicht die `DontLinger` und `OutOfBandInline` Socketoptionen.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Array vom Typ <see cref="T:System.Byte" /> , die den Wert der Option darstellt.</param>
        <summary>Setzt den angegebenen <see cref="T:System.Net.Sockets.Socket" /> Option aus, um den angegebenen Wert als ein Byte-Array dargestellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung, die festzulegende <xref:System.Net.Sockets.Socket> Optionen, die ein Bytearray als Optionswert erfordern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeoutwerte.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Wert der Option.</param>
        <summary>Setzt den angegebenen <see cref="T:System.Net.Sockets.Socket" /> Option aus, um den angegebenen ganzzahligen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Für eine Option mit einem <xref:System.Boolean> -Datentyp, geben Sie einen Wert ungleich NULL, um die Option zu aktivieren und einen Wert von 0 zum Deaktivieren der Option. Geben Sie für eine Option mit einem Integer-Datentyp den entsprechenden Wert ein. <xref:System.Net.Sockets.Socket>Optionen werden nach Maß an Unterstützung für das Protokoll gruppiert.  
  
 Unten sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen, die mit dieser Überladung festgelegt werden können. Diese Optionen werden von der entsprechenden gruppiert <xref:System.Net.Sockets.SocketOptionLevel>. Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, den entsprechenden verwenden <xref:System.Net.Sockets.SocketOptionLevel> für die `optionLevel` Parameter. Die Option wählen, dass einrichten muss angegeben werden, der `optionName` Parameter. Wenn Sie den aktuellen Wert eines der aufgeführten Optionen abzurufen, verwenden Sie möchten die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Weitere Informationen zu diesen Optionen finden Sie in der <xref:System.Net.Sockets.SocketOptionName> Enumeration.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeoutwerte.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein <see cref="T:System.Net.Sockets.LingerOption" /> oder <see cref="T:System.Net.Sockets.MulticastOption" /> , den Wert der Option "" enthält.</param>
        <summary>Setzt den angegebenen <see cref="T:System.Net.Sockets.Socket" /> Option aus, um den angegebenen Wert als ein Objekt dargestellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung zum Festlegen der <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, und <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> Optionen. Für die <xref:System.Net.Sockets.SocketOptionName.Linger> mit <xref:System.Net.Sockets.Socket> für die `optionLevel` Parameter. Für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership>, verwenden Sie <xref:System.Net.Sockets.SocketOptionLevel.IP>. Wenn Sie den aktuellen Wert eines der oben aufgeführten Optionen abzurufen, verwenden Sie möchten die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeoutwerte.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Eines der <see cref="T:System.Net.Sockets.SocketShutdown" /> Werte, der den Vorgang angibt, die nicht mehr möglich ist.</param>
        <summary>Deaktiviert die sendet und empfängt, die auf eine <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung einer verbindungsorientierten <xref:System.Net.Sockets.Socket>, rufen Sie immer die <xref:System.Net.Sockets.Socket.Shutdown%2A> Methode vor dem Schließen der <xref:System.Net.Sockets.Socket>. Dadurch wird sichergestellt, dass alle Daten gesendet und empfangen auf dem verbundenen Socket, bevor er geschlossen wurde.  
  
 Rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode, um alle freizugeben verwaltete und nicht verwaltete Ressourcen, die zugeordneten der <xref:System.Net.Sockets.Socket>. Versuchen Sie nicht, Wiederverwenden der <xref:System.Net.Sockets.Socket> nach dem Schließen.  
  
 Die folgende Tabelle zeigt die <xref:System.Net.Sockets.SocketShutdown> gültige Enumerationswerte für die `how` Parameter.  
  
|Wert|Beschreibung|  
|-----------|-----------------|  
|Senden|Deaktiviert das Senden für dieses <xref:System.Net.Sockets.Socket>.|  
|Empfangen|Deaktiviert das Empfangen für dieses <xref:System.Net.Sockets.Socket>.|  
|Beides|Deaktiviert das Senden und empfangen auf diese <xref:System.Net.Sockets.Socket>.|  
  
 Festlegen von `how` auf <xref:System.Net.Sockets.SocketShutdown.Send> gibt an, dass bei nachfolgenden Aufrufe von <xref:System.Net.Sockets.Socket.Send%2A> sind nicht zulässig. Bei einem verbindungslosen <xref:System.Net.Sockets.Socket>, wobei <xref:System.Net.Sockets.SocketShutdown.Send> hat keine Auswirkungen.  
  
 Festlegen von `how` auf <xref:System.Net.Sockets.SocketShutdown.Receive> gibt an, dass bei nachfolgenden Aufrufe von <xref:System.Net.Sockets.Socket.Receive%2A> sind nicht zulässig. Dies wirkt sich nicht auf niedrigeren Protokollebenen. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wird die Verbindung beendet, wenn eine der folgenden Bedingungen, nach einem Aufruf von vorhanden <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Daten sind in der eingehenden Netzwerkpuffer darauf warten, empfangen werden.  
  
-   Mehr Daten empfangen hat.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, sind Datagramme akzeptiert und in die Warteschlange eingereiht. Wenn kein Pufferplatz für weitere eingehende Datagramme verfügbar ist, werden sie verworfen und wird kein Fehler an den Absender zurückgegeben werden. Mit <xref:System.Net.Sockets.Socket.Shutdown%2A> auf einem verbindungslosen <xref:System.Net.Sockets.Socket> wird nicht empfohlen.  
  
 Festlegen von `how` auf <xref:System.Net.Sockets.SocketShutdown.Both> deaktiviert sowohl senden und empfangen, wie oben beschrieben.  
  
> [!NOTE]
>  Erhalten Sie eine <xref:System.Net.Sockets.SocketException> beim Aufrufen der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, mit der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit <xref:System.Net.Sockets.Socket.Shutdown%2A> zum Deaktivieren der <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A>ist schreibgeschützt und wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> wird erstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, und <xref:System.Net.Sockets.ProtocolType> an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob IPv4-Unterstützung verfügbar und auf dem aktuellen Host aktiviert ist.</summary>
        <value>
          <see langword="true" />Wenn der aktuelle Host das IPv4-Protokoll unterstützt. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob das Framework IPv6 für bestimmte veraltete unterstützt <see cref="T:System.Net.Dns" /> Elemente.</summary>
        <value>
          <see langword="true" />Wenn das Framework IPv6 unterstützt, die für bestimmte veraltete <see cref="T:System.Net.Dns" /> Methoden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der die Gültigkeitsdauer (TTL) der Internetprotokoll (IP)-Pakete, die per angibt, der <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Der TTL-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der TTL-Wert gibt die maximale Anzahl von Routern, die das Paket durchlaufen kann, bevor der Router verwirft das Paket und eine Internet ICMP Control Message Protocol () "Gültigkeitsdauer überschritten" Fehlermeldung an den Absender zurückgegeben.  
  
 Der TTL-Wert kann auf einen Wert von 0 bis 255 festgelegt werden. Wenn diese Eigenschaft nicht festgelegt ist, ist der Standardwert für die Gültigkeitsdauer (TTL) für ein Socket 32.  
  
 Durch Festlegen dieser Eigenschaft für ein Protokoll TCP (Transmission Control)-Socket wird vom TCP/IP-Stapel ignoriert, wenn eine erfolgreiche Verbindung mit dem Socket hergestellt wurde.  
  
 Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.Socket.Ttl%2A> Eigenschaft.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der TTL-Wert kann nicht auf eine negative Zahl festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann festgelegt werden, nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> Familien.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Dieser Fehler wird auch zurückgegeben, bei dem Versuch Gültigkeitsdauer (TTL) auf einen höheren Wert als 255 festgelegt wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Socket nur überlappenden e/a-Modus verwenden möchten.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Net.Sockets.Socket" /> verwendet nur überlappende e/a ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` für eine <xref:System.Net.Sockets.Socket> Sie aufrufen möchten <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Ordnen Sie andernfalls das Framework kann ein Abschlussport an den Socket, die die Verwendung von verhindern würden <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Socket wurde an ein Completion Port gebunden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
