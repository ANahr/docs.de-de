<Type Name="ServiceController" FullName="System.ServiceProcess.ServiceController">
  <TypeSignature Language="C#" Value="public class ServiceController : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceController extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceController" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.ServiceProcess.Design.ServiceControllerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ServiceProcess.ServiceProcessDescription("ServiceControllerDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Windows-Dienst dar und ermöglicht es, eine Verbindung mit einem ausgeführten oder beendeten Dienst herzustellen, ihn zu verändern oder Informationen über ihn abzurufen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.ServiceProcess.ServiceController> Klasse eine Verbindung herstellen und das Verhalten vorhandener Dienste zu steuern. Beim Erstellen einer Instanz von der <xref:System.ServiceProcess.ServiceController> -Klasse, damit er mit einem bestimmten Windowsdienst interagiert, Festlegen ihrer Eigenschaften. Sie können dann mithilfe der Klasse starten, beenden und den Dienst auf andere Weise bearbeiten.  
  
 Verwenden Sie wahrscheinlich die <xref:System.ServiceProcess.ServiceController> Verwaltungsebene Komponente. Beispielsweise konnte, erstellen Sie eine Windows oder Web-Anwendung, die benutzerdefinierte sendet Befehle an einen Dienst über die <xref:System.ServiceProcess.ServiceController> Instanz. Dies wäre hilfreich, da das Service Control Manager (SCM) Microsoft Management Console-Snap-in benutzerdefinierte Befehle nicht unterstützt.  
  
 Nach der Erstellung einer Instanz von <xref:System.ServiceProcess.ServiceController>, müssen Sie zwei Eigenschaften festlegen, wird, um den Dienst zu identifizieren, mit denen er interagiert: den Computernamen und den Namen des Diensts, die Sie steuern möchten.  
  
> [!NOTE]
>  Standardmäßig <xref:System.ServiceProcess.ServiceController.MachineName%2A> auf dem lokalen Computer festgelegt ist, damit Sie nicht benötigen, um ihn zu ändern, es sei denn, Sie die Instanz, zeigen Sie auf einen anderen Computer festlegen möchten.  
  
 Im Allgemeinen schreibt dienstautor Code, der die Aktion, die einen bestimmten Befehl zugeordnet passt. Ein Dienst kann z. B. Code zum Reagieren auf enthalten eine <xref:System.ServiceProcess.ServiceBase.OnPause%2A?displayProperty=nameWithType> Befehl. In diesem Fall wird die benutzerdefinierte Verarbeitung für die <xref:System.ServiceProcess.ServiceController.Pause%2A> Task ausgeführt wird, bevor das System den Dienst anhält.  
  
 Der Satz von Befehlen, die ein Dienst verarbeitet werden kann, hängt von dessen Eigenschaften ab. Sie können z. B. Festlegen der <xref:System.ServiceProcess.ServiceController.CanStop%2A> Eigenschaft für einen Dienst zum `false`. Diese Einstellung rendert die `Stop` Befehls auf diesen Dienst nicht verfügbar; es verhindert, dass Sie den Dienst aus dem SCM beenden, deaktivieren Sie die Schaltfläche "erforderlich". Wenn Sie versuchen, den Dienst aus dem Code zu beenden, wird das System löst einen Fehler aus und zeigt die Fehlermeldung "Fehler beim Beenden des `servicename`."  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController> Klasse steuern die `SimpleService` Service-Beispiel.  
  
 [!code-csharp[ServiceControllerClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#1)]
 [!code-vb[ServiceControllerClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceController ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ServiceProcess.ServiceController" /> -Klasse, die einen bestimmten Dienst zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceController (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der den Dienst für das System identifiziert. Dies kann auch der Anzeigename für den Dienst sein.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ServiceProcess.ServiceController" /> -Klasse, die einen vorhandenen Dienst auf dem lokalen Computer zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.%23ctor%28System.String%29?displayProperty=nameWithType> Konstruktor zur Erstellung einer <xref:System.ServiceProcess.ServiceController> -Objekt, das verwendet wird, um ein Beispieldienst zu steuern. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#2](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#2)]
 [!code-vb[ServiceControllerClass#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceController (string name, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.#ctor(System.String,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der den Dienst für das System identifiziert. Dies kann auch der Anzeigename für den Dienst sein.</param>
        <param name="machineName">Der Computer, auf dem der Dienst befindet.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ServiceProcess.ServiceController" /> -Klasse, die einen vorhandenen Dienst auf dem angegebenen Computer zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die `machineName` -Parameter, die Sie verwenden "." auf den lokalen Computer darzustellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist ungültig.  
  
 - oder -   
  
 <paramref name="machineName" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPCanPauseAndContinue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst angehalten und fortgesetzt werden kann.</summary>
        <value>
          <see langword="true" />Wenn der Dienst angehalten werden kann; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.CanPauseAndContinue%2A> Eigenschaft, um zu bestimmen, ob ein Dienst angehalten und fortgesetzt werden kann. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#2](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#2)]
 [!code-vb[ServiceControllerClass#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPCanShutdown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst beim Herunterfahren des Systems benachrichtigt werden soll.</summary>
        <value>
          <see langword="true" />Wenn der Dienst benachrichtigt werden soll, wenn das System heruntergefahren wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.CanShutdown%2A> Eigenschaft, um zu bestimmen, ob ein Dienst einen Handler für ein Shutdown-Ereignis bereitstellt. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#2](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#2)]
 [!code-vb[ServiceControllerClass#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPCanStop")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Dienst nach dem Starten angehalten werden kann.</summary>
        <value>
          <see langword="true" />Wenn der Dienst beendet werden kann und die <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> Methode aufgerufen wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.CanStop%2A> Eigenschaft, um zu bestimmen, ob ein Dienst einen Handler für eine Stop-Ereignis bereitstellt. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#2](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#2)]
 [!code-vb[ServiceControllerClass#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Trennt diese <see cref="T:System.ServiceProcess.ServiceController" /> Instanz aus dem Dienst, und alle der Instanz zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceController.Close%2A>Gibt alle zugeordneten Handles frei der <xref:System.ServiceProcess.ServiceController> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public void Continue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Continue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Continue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt einen Dienst fort, nachdem dieser angehalten wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.ServiceProcess.ServiceController.Continue%2A> für einen Dienst ist zuerst dessen Status auf geändert `ContinuePending` und klicken Sie dann, wenn die <xref:System.ServiceProcess.ServiceController.Continue%2A> Methode zurückgegeben wird, wird er in geändert `Running`.  
  
 Sie können nicht aufrufen <xref:System.ServiceProcess.ServiceController.Continue%2A> für den Dienst, bis der Status des Controllers ist `Paused`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.Continue%2A> Methode, um einen angehaltenen Dienst fortzusetzen. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#5](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#5)]
 [!code-vb[ServiceControllerClass#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">zum Steuern der Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Control" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den uneingeschränkten Zugriff auf Dienstinformationen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DependentServices">
      <MemberSignature Language="C#" Value="public System.ServiceProcess.ServiceController[] DependentServices { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceProcess.ServiceController[] DependentServices" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.DependentServices" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPDependentServices")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceController[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Satz von Diensten, die von dem Dienst zugeordnete abhängt <see cref="T:System.ServiceProcess.ServiceController" /> Instanz.</summary>
        <value>Ein Array von <see cref="T:System.ServiceProcess.ServiceController" /> Instanzen, von denen jede bezieht sich auf einen Dienst, von denen dieser Dienst abhängt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceController.DependentServices%2A> Array darstellt, die Dienste, die vom System angehalten, wenn die Anwendung aufruft <xref:System.ServiceProcess.ServiceController.Stop%2A> für diesen Dienst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um die Gruppe von Diensten angezeigt, die dem Ereignisprotokolldienst abhängig sind.  
  
 [!code-cpp[ServiceController#3](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#3)]
 [!code-csharp[ServiceController#3](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#3)]
 [!code-vb[ServiceController#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">für die Verbindung mit vorhandenen Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Browse" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisplayName">
      <MemberSignature Language="C#" Value="public string DisplayName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.DisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPDisplayName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen angezeigten Namen für den Dienst ab oder richtet ihn ein.</summary>
        <value>Der angezeigte Name des Diensts, der zu dessen Identifizierung verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können festlegen, die <xref:System.ServiceProcess.ServiceController.DisplayName%2A> auf eine leere Zeichenfolge (""), aber das Festlegen von `null` löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um die Gruppe von Diensten angezeigt, die dem Ereignisprotokolldienst abhängig sind.  
  
 [!code-cpp[ServiceController#3](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#3)]
 [!code-csharp[ServiceController#3](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#3)]
 [!code-vb[ServiceController#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.ServiceProcess.ServiceController.DisplayName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.ServiceProcess.ServiceController" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A>Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn die `disposing` Parameter ist "true", gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte, die von diesem <xref:System.ServiceProcess.ServiceController> Verweise. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Zum Überschreiben <see langword="Dispose(Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see langword="Dispose" />. Weitere Informationen zum Implementieren <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public void ExecuteCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.ExecuteCommand(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Ein von der Anwendung definiertes Befehlsflag, das angibt, welcher benutzerdefinierte Befehl ausgeführt werden soll. Der Wert muss zwischen 128 und einschließlich 256 liegen.</param>
        <summary>Führt einen benutzerdefinierten Befehl für den Dienst aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>, der Status des Diensts ändert sich nicht. Wenn der Dienst gestartet wurde, bleibt der Status `Running`. Wenn der Dienst beendet wurde, bleibt der Status `Stopped`und so weiter. Um den benutzerdefinierten Befehl zu verarbeiten, muss der Dienst überschreiben die <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> Methode, und geben Sie einen Handler für den Befehl durch identifiziert die `command` Parameter.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.ExecuteCommand%28System.Int32%29?displayProperty=nameWithType> Methode zum Ausführen von benutzerdefinierten Befehlen in der `SimpleService` Service-Beispiel.  
  
 [!code-csharp[ServiceContoller_ExecuteCommand#1](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceContoller_ExecuteCommand/CS/program.cs#1)]
 [!code-vb[ServiceContoller_ExecuteCommand#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceContoller_ExecuteCommand/VB/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">zum Steuern der Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Control" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den uneingeschränkten Zugriff auf Dienstinformationen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDevices">
      <MemberSignature Language="C#" Value="public static System.ServiceProcess.ServiceController[] GetDevices ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceProcess.ServiceController[] GetDevices() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.GetDevices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceController[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Gerätetreiberdienste auf dem lokalen Computer ab.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.ServiceProcess.ServiceController" /> in dem jedes Element mit einem Gerät Treiber-Dienst auf dem lokalen Computer zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceController.GetDevices%2A>Gibt den Treiberdienste nur das Gerät aus dem lokalen Computer zurück. Rufen Sie zum Abrufen der Gerätetreiberdienste Dienste oder Dienste, die keine Treiber sind die <xref:System.ServiceProcess.ServiceController.GetServices%2A> Methode. Zusammen ermöglichen die beiden Methoden Zugriff auf alle Dienste auf einem Computer an.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um die Gerätetreiberdienste auf dem lokalen Computer anzuzeigen.  
  
 [!code-cpp[ServiceController#5](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#5)]
 [!code-csharp[ServiceController#5](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#5)]
 [!code-vb[ServiceController#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDevices">
      <MemberSignature Language="C#" Value="public static System.ServiceProcess.ServiceController[] GetDevices (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceProcess.ServiceController[] GetDevices(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.GetDevices(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceController[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, von dem die Gerätetreiberdienste abgerufen werden soll.</param>
        <summary>Ruft die Gerätetreiberdienste auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.ServiceProcess.ServiceController" /> in dem jedes Element mit einem Gerät Treiber-Dienst auf dem angegebenen Computer zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceController.GetDevices%2A>Gibt den Treiberdienste nur das Gerät aus dem angegebenen Computer zurück. Rufen Sie zum Abrufen der Gerätetreiberdienste Dienste oder Dienste, die keine Treiber sind die <xref:System.ServiceProcess.ServiceController.GetServices%2A> Methode. Zusammen ermöglichen die beiden Methoden Zugriff auf alle Dienste auf einem Computer an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter hat eine ungültige Syntax.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetServices">
      <MemberSignature Language="C#" Value="public static System.ServiceProcess.ServiceController[] GetServices ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceProcess.ServiceController[] GetServices() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.GetServices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceController[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle Dienste auf dem lokalen Computer mit Ausnahme der Gerätetreiberdienste ab.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.ServiceProcess.ServiceController" /> in dem jedes Element mit einem Dienst auf dem lokalen Computer zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceController.GetServices%2A>Gibt nur die Gerätetreiberdienste und die Dienste, die Treiber auf dem lokalen Computer nicht sind. Um Gerätetreiberdienste abzurufen, rufen Sie die <xref:System.ServiceProcess.ServiceController.GetDevices%2A> Methode. Zusammen ermöglichen die beiden Methoden Zugriff auf alle Dienste auf einem Computer an.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um die Dienste angezeigt, die auf dem lokalen Computer ausgeführt werden.  
  
 [!code-cpp[ServiceController#6](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#6)]
 [!code-csharp[ServiceController#6](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#6)]
 [!code-vb[ServiceController#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetServices">
      <MemberSignature Language="C#" Value="public static System.ServiceProcess.ServiceController[] GetServices (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceProcess.ServiceController[] GetServices(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.GetServices(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceController[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, von dem Dienste abgerufen werden soll.</param>
        <summary>Ruft alle Dienste auf dem angegebenen Computer mit Ausnahme der Gerätetreiberdienste ab.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.ServiceProcess.ServiceController" /> in dem jedes Element mit einem Dienst auf dem angegebenen Computer zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceController.GetServices%2A>Gibt nur die Gerätetreiberdienste und die Dienste, die nicht-Treiber aus dem angegebenen Computer sind. Um Gerätetreiberdienste abzurufen, rufen Sie die <xref:System.ServiceProcess.ServiceController.GetDevices%2A> Methode. Zusammen ermöglichen die beiden Methoden Zugriff auf alle Dienste auf einem Computer an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter hat eine ungültige Syntax.</exception>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem sich dieser Dienst befindet, oder legt diesen fest.</summary>
        <value>Der Name des Computers, der den mit diesem verknüpften Dienst ausgeführt wird <see cref="T:System.ServiceProcess.ServiceController" /> Instanz. Der Standardwert ist der lokale Computer (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Computername ist der Name des Servers, der diesen Dienst, ohne die vorherigen umgekehrte Schrägstriche ausgeführt wird (\\\\).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.ServiceProcess.ServiceController.MachineName" /> Syntax ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Pause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht die Ausführung eines Diensts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können nicht aufrufen <xref:System.ServiceProcess.ServiceController.Continue%2A> für den Dienst, bis der Status des Controllers ist `Paused`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.Pause%2A> Methode, um einen Dienst anzuhalten. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#4](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#4)]
 [!code-vb[ServiceControllerClass#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">zum Steuern der Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Control" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den uneingeschränkten Zugriff auf Dienstinformationen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert Eigenschaftswerte durch Zurücksetzen der Eigenschaften auf ihre aktuellen Werte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceController.Refresh%2A> -Methode nimmt die <xref:System.ServiceProcess.ServiceController.ServicesDependedOn%2A>, <xref:System.ServiceProcess.ServiceController.DependentServices%2A>, und <xref:System.ServiceProcess.ServiceController.Status%2A> Eigenschaften auf ihre aktuellen Werte zurückgesetzt werden soll, wenn sie als Nächstes referenziert werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.ServiceProcess.ServiceController.Refresh%2A> Methode, um den Status eines Diensts abzurufen. Der Code weist einen Dienst anhalten und dann wartet, bis der Status der Änderung zu übernehmen. In diesem Beispiel ist Teil eines umfangreicheren Beispiels, die aus Gründen der <xref:System.ServiceProcess.ServiceController> Klasse.  
  
 [!code-csharp[ServiceControllerClass#4](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceControllerClass/CS/program.cs#4)]
 [!code-vb[ServiceControllerClass#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceControllerClass/VB/program.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.SafeHandle ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.SafeHandle ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.SafeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für den Dienst ab.</summary>
        <value>Ein <see cref="T:System.Runtime.InteropServices.SafeHandle" /> , die das Handle für den Dienst enthält.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceProcess.Design.ServiceNameConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen ab, der den Dienst identifiziert, auf den diese Instanz verweist, oder richtet diesen Namen ein.</summary>
        <value>Der Name, der den Dienst identifiziert, die von diesem <see cref="T:System.ServiceProcess.ServiceController" /> Instanzenverweis. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceProcess.ServiceController.ServiceName%2A> identifiziert den Dienst mit dem Dienststeuerungs-Manager. Das Ändern dieser Eigenschaft bewirkt, dass die <xref:System.ServiceProcess.ServiceController> Instanz zum Binden an einen anderen Dienst wird nicht welche der Dienstkontroll-Manager des Microsoft Management Console-Snap-in zeigt geändert.  
  
 Wenn Sie einen benutzerdefinierten Dienst implementieren, muss der Wert dieser Eigenschaft identisch mit dem Namen für den Dienst in aufgezeichnet werden die <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> -Eigenschaft des entsprechenden <xref:System.ServiceProcess.ServiceInstaller> Klasse. Im Code der <xref:System.ServiceProcess.ServiceController.ServiceName%2A> ist in der Regel legen Sie der `main()` Funktion der ausführbaren Datei.  
  
 Wenn Sie zurücksetzen, um die <xref:System.ServiceProcess.ServiceController.ServiceName%2A> Eigenschaftensätze, die Methode, die die Eigenschaft festlegt dieser Instanz <xref:System.ServiceProcess.ServiceController.DisplayName%2A> auf eine leere Zeichenfolge ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.ServiceProcess.ServiceController.ServiceName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax der <see cref="P:System.ServiceProcess.ServiceController.ServiceName" /> Eigenschaft ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServicesDependedOn">
      <MemberSignature Language="C#" Value="public System.ServiceProcess.ServiceController[] ServicesDependedOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceProcess.ServiceController[] ServicesDependedOn" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.ServicesDependedOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPServicesDependedOn")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceController[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Gruppe von Diensten, von denen dieser Dienst abhängig ist.</summary>
        <value>Ein Array von <see cref="T:System.ServiceProcess.ServiceController" /> Instanzen, von denen jede bezieht sich auf ein Dienst, der für diesen Dienst zur Ausführung ausgeführt werden muss.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Dienst die <xref:System.ServiceProcess.ServiceController.ServicesDependedOn%2A> Array wird nicht ausgeführt, Sie werden nicht in der Lage sind, diesen Dienst zu starten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> zum Anzeigen der der Satz von Diensten, die der Messenger-Dienst abhängig ist.  
  
 [!code-cpp[ServiceController#4](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#4)]
 [!code-csharp[ServiceController#4](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#4)]
 [!code-vb[ServiceController#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">für die Verbindung mit vorhandenen Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Browse" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceType">
      <MemberSignature Language="C#" Value="public System.ServiceProcess.ServiceType ServiceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceProcess.ServiceType ServiceType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.ServiceType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPServiceType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Diensts ab, auf den dieses Objekt verweist.</summary>
        <value>Eines der <see cref="T:System.ServiceProcess.ServiceType" /> Werte, mit dem den Typ der anzugeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Diensttyp gibt an, wie der Dienst vom System verwendet wird. Der Wert, der die <xref:System.ServiceProcess.ServiceController.ServiceType%2A> Eigenschaft stellt einen Satz von Flags, die mit dem bitweisen OR-Operator kombiniert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um die Gerätetreiberdienste auf dem lokalen Computer anzuzeigen.  
  
 [!code-cpp[ServiceController#5](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#5)]
 [!code-csharp[ServiceController#5](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#5)]
 [!code-vb[ServiceController#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Dienst und übergibt dabei keine Argumente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können nicht aufrufen <xref:System.ServiceProcess.ServiceController.Stop%2A> für den Dienst, bis der Status des Controllers ist `Running`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse zu überprüfen, ob der Warndienst beendet wird. Wenn der Dienst beendet wird, wird im Beispiel wird der Dienst gestartet und wartet, bis der Status des Diensts festgelegt ist, um <xref:System.ServiceProcess.ServiceControllerStatus.Running>.  
  
 [!code-cpp[ServiceController#1](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#1)]
 [!code-csharp[ServiceController#1](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#1)]
 [!code-vb[ServiceController#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">zum Steuern der Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Control" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den uneingeschränkten Zugriff auf Dienstinformationen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Start(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Argumenten, die an den Dienst übergeben wird, wenn er gestartet wird.</param>
        <summary>Startet einen Dienst und übergibt dabei die angegebenen Argumente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können nicht aufrufen <xref:System.ServiceProcess.ServiceController.Stop%2A> für den Dienst, bis der Status des Controllers ist `Running`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst kann nicht gestartet werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> ist <see langword="null" />.  
  
 - oder -   
  
 Ein Member des Arrays ist <see langword="null" />.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">zum Steuern der Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Control" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den uneingeschränkten Zugriff auf Dienstinformationen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="StartType">
      <MemberSignature Language="C#" Value="public System.ServiceProcess.ServiceStartMode StartType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceProcess.ServiceStartMode StartType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.StartType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPStartType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceStartMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie der vom <see cref="T:System.ServiceProcess.ServiceController" />-Objekt angegebene Dienst gestartet wird.</summary>
        <value>Ein Wert, der angibt, wie der Dienst gestartet wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">für das Durchsuchen von Diensten auf dem Computer. Zugeordnete Enumeration: <see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Browse" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.ServiceProcess.ServiceControllerStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceProcess.ServiceControllerStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceController.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SPStatus")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceProcess.ServiceControllerStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand des Diensts ab, auf den diese Instanz verweist.</summary>
        <value>Eines der <see cref="T:System.ServiceProcess.ServiceControllerStatus" /> Werte, der angibt, ob der Dienst ausgeführt wird, beendet oder angehalten wurde, oder gibt an, ob eine starten, beenden, Anhalten oder Fortsetzen der Befehl zur Verfügung steht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Status gibt den aktuellen Status des Diensts an. Der Satz möglicher Werte umfassen mehrere, die angeben, ob ein Befehl ändern mit dem Status Ausstehend ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um den aktuellen Status des Diensts Telnet überprüfen. Wenn der Dienst beendet wird, wird die den Dienst gestartet. Wenn der Dienst ausgeführt wird, wird im Beispiel wird der Dienst beendet.  
  
 [!code-cpp[ServiceController#2](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#2)]
 [!code-csharp[ServiceController#2](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#2)]
 [!code-vb[ServiceController#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.Stop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet diesen Dienst sowie alle Dienste, die von diesem Dienst abhängig sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn alle Dienste auf diesen Dienst für den Vorgang abhängig sind, werden sie beendet werden, bevor dieser Dienst beendet wird. Die <xref:System.ServiceProcess.ServiceController.DependentServices%2A> Eigenschaft enthält den Satz von Diensten, die von dieser abhängen.  
  
 Wenn Sie einen Dienst, von denen dieser Dienst abhängt beenden, rufen Sie die <xref:System.ServiceProcess.ServiceController.Stop%2A> Methode für diesen Dienst innerhalb der <xref:System.ServiceProcess.ServiceController.Stop%2A> Methode des übergeordneten Diensts. Die <xref:System.ServiceProcess.ServiceController.ServicesDependedOn%2A> Eigenschaft enthält die Dienste, von denen dieser Dienst abhängt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse, um den aktuellen Status des Diensts Telnet überprüfen. Wenn der Dienst beendet wird, wird die den Dienst gestartet. Wenn der Dienst ausgeführt wird, wird im Beispiel wird der Dienst beendet.  
  
 [!code-cpp[ServiceController#2](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#2)]
 [!code-csharp[ServiceController#2](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#2)]
 [!code-vb[ServiceController#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugreifen auf eine System-API ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Der Dienst wurde nicht gefunden.</exception>
        <permission cref="T:System.ServiceProcess.ServiceControllerPermission">zum Steuern der Dienste auf dem Computer. Zugeordnete Enumeration:<see cref="F:System.ServiceProcess.ServiceControllerPermissionAccess.Control" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den uneingeschränkten Zugriff auf Dienstinformationen. Zugeordnete Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForStatus">
      <MemberSignature Language="C#" Value="public void WaitForStatus (System.ServiceProcess.ServiceControllerStatus desiredStatus);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForStatus(valuetype System.ServiceProcess.ServiceControllerStatus desiredStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.WaitForStatus(System.ServiceProcess.ServiceControllerStatus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="desiredStatus" Type="System.ServiceProcess.ServiceControllerStatus" />
      </Parameters>
      <Docs>
        <param name="desiredStatus">Der Status, auf den gewartet werden soll.</param>
        <summary>Wartet unbegrenzt, bis der Dienst den angegebenen Zustand annimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceController.WaitForStatus%2A> eine Anwendung Anhalten des verarbeiten, bis der Dienst den erforderlichen Status erreicht hat.  
  
> [!NOTE]
>  Die <xref:System.ServiceProcess.ServiceController.WaitForStatus%2A> Methode wartet ungefähr 250 Millisekunden zwischen jeder Status überprüfen.  <xref:System.ServiceProcess.ServiceController.WaitForStatus%2A>der beobachteten Dienst zum Ändern die Groß-/Kleinschreibung nicht erkennen die `desiredStatus` und dann sofort auf einen anderen Status in diesem Intervall.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.ServiceProcess.ServiceController> Klasse zu überprüfen, ob der Warndienst beendet wird. Wenn der Dienst beendet wird, wird im Beispiel wird der Dienst gestartet und wartet, bis der Status des Diensts festgelegt ist, um <xref:System.ServiceProcess.ServiceControllerStatus.Running>.  
  
 [!code-cpp[ServiceController#1](~/samples/snippets/cpp/VS_Snippets_CLR/ServiceController/CPP/servicecontroller.cpp#1)]
 [!code-csharp[ServiceController#1](~/samples/snippets/csharp/VS_Snippets_CLR/ServiceController/CS/servicecontroller.cs#1)]
 [!code-vb[ServiceController#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ServiceController/VB/servicecontroller.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="desiredStatus" />-Parameter ist keiner der in der <see cref="T:System.ServiceProcess.ServiceControllerStatus" />-Enumeration definierten Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForStatus">
      <MemberSignature Language="C#" Value="public void WaitForStatus (System.ServiceProcess.ServiceControllerStatus desiredStatus, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForStatus(valuetype System.ServiceProcess.ServiceControllerStatus desiredStatus, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceController.WaitForStatus(System.ServiceProcess.ServiceControllerStatus,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="desiredStatus" Type="System.ServiceProcess.ServiceControllerStatus" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="desiredStatus">Der Status, auf den gewartet werden soll.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />-Objekt, das die Zeitspanne angibt, die gewartet werden soll, bis der Dienst den angegebenen Status erreicht.</param>
        <summary>Wartet, bis der Dienst den angegebenen Status annimmt oder bis das angegebene Timeout abläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.ServiceProcess.ServiceController.WaitForStatus%2A> eine Anwendung Anhalten des verarbeiten, bis der Dienst den erforderlichen Status erreicht hat.  
  
> [!NOTE]
>  Die <xref:System.ServiceProcess.ServiceController.WaitForStatus%2A> Methode wartet ungefähr 250 Millisekunden zwischen jeder Status überprüfen.  <xref:System.ServiceProcess.ServiceController.WaitForStatus%2A>der beobachteten Dienst zum Ändern die Groß-/Kleinschreibung nicht erkennen die `desiredStatus` und dann sofort auf einen anderen Status in diesem Intervall.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="desiredStatus" />-Parameter ist keiner der in der <see cref="T:System.ServiceProcess.ServiceControllerStatus" />-Enumeration definierten Werte.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Der für den <paramref name="timeout" />-Parameter angegebene Wert läuft ab.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
