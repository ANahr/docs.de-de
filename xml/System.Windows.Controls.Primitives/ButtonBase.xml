<Type Name="ButtonBase" FullName="System.Windows.Controls.Primitives.ButtonBase">
  <TypeSignature Language="C#" Value="public abstract class ButtonBase : System.Windows.Controls.ContentControl, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ButtonBase extends System.Windows.Controls.ContentControl implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ButtonBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Button)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die Basisklasse für alle <see cref="T:System.Windows.Controls.Button" /> Steuerelemente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Behandeln der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis reagiert, wenn der Benutzer klickt auf eine <xref:System.Windows.Controls.Primitives.ButtonBase>. Der Benutzer kann Auslösen der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis mithilfe einer <xref:System.Windows.Controls.AccessText> oder durch Drücken von EINGABETASTE oder die LEERTASTE, wenn das Steuerelement den Fokus besitzt.  Wenn der Benutzer drückt die LEERTASTE, das Steuerelement legt <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> auf `true` und die Maus erfasst.  Daher das Steuerelement löst Mausereignisse wie z. B. <xref:System.Windows.UIElement.MouseEnter> und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Beachten Sie, dass die Verwendung der <xref:System.Windows.Controls.AccessText> oder EINGABETASTE ändert sich nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder die Maus erfassen, aber es löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase> legt die <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> angefügten Eigenschaft, um `true`.  
  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase> legt die <xref:System.Windows.UIElement.IsInputMethodEnabled%2A> Eigenschaft `false`.  
  
 Ein <xref:System.Windows.Controls.Primitives.ButtonBase> ist eine <xref:System.Windows.Controls.ContentControl>, was bedeutet, dass es ein einzelnes Objekt eines beliebigen Typs (z. B. eine Zeichenfolge, ein Bild oder ein Bereich) enthalten kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Windows.Controls.ContentControl>-Klasse.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ButtonBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ButtonBase.Click" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine <see cref="T:System.Windows.Controls.Button" /> geklickt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer kann Auslösen der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis mithilfe einer <xref:System.Windows.Controls.AccessText> oder durch Drücken von EINGABETASTE oder die LEERTASTE, wenn das Steuerelement den Fokus besitzt.  Wenn der Benutzer drückt die LEERTASTE, das Steuerelement legt <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> auf `true` und die Maus erfasst.  Daher das Steuerelement löst Mausereignisse wie z. B. <xref:System.Windows.UIElement.MouseEnter> und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Beachten Sie, dass die Verwendung der <xref:System.Windows.Controls.AccessText> oder EINGABETASTE ändert sich nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder die Maus erfassen, aber es löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase> markiert die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis als behandelt, in der <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> -Methode auf und löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis. Daher wird die <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> Ereignis treten nie für ein Steuerelement, das von erbt <xref:System.Windows.Controls.Primitives.ButtonBase>. Fügen Sie stattdessen einen Ereignishandler an das <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> Ereignis an, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
<a name="routedEventInfo_Click"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt drei Schaltflächen, die auf Klicks auf drei verschiedene Arten reagieren.  
  
-   Hover - ändert die erste Schaltfläche Farben, wenn der Benutzer mit der Maus auf die Schaltfläche gezeigt wird  
  
-   Drücken Sie - erfordert die zweite Schaltfläche mit der Maus geklickt werden, während der Mauszeiger auf die Schaltfläche befindet.  
  
-   Release - ist das dritte erst zurückgesetzt, die Hintergrundfarbe der Schaltflächen die Maustaste gedrückt und losgelassen wird, in der Schaltfläche.  
  
 [!code-xaml[ClickModes_snip#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml#1)]  
  
 [!code-csharp[ClickModes_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ClickModes_snip#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClickModes_snip/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis entspricht einem linken Mausklick.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ClickMode ClickMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ClickMode ClickMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ClickMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, wann die <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" /> Ereignis auftritt.</summary>
        <value>Wenn die <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" /> Ereignis auftritt. Der Standardwert ist <see cref="F:System.Windows.Controls.ClickMode.Release" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ClickMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClickModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClickModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, der Befehl aufgerufen wird, wenn diese Schaltfläche aufgerufen werden.</summary>
        <value>Ein Befehl, der aufgerufen wird, wenn diese Schaltfläche aufgerufen werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird verwendet, eine bestimmte Schaltfläche einen Befehl zugeordnet.  
  
 In [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], diese Eigenschaft wird am häufigsten festgelegt, um einen statischen Befehlswert aus einer vorhandenen Befehlsbibliotheken, wie z. B. werden <xref:System.Windows.Input.ApplicationCommands> oder <xref:System.Windows.Input.NavigationCommands>. Weitere Informationen finden Sie unter [Befehle (Übersicht)](~/docs/framework/wpf/advanced/commanding-overview.md) oder <xref:System.Windows.Input.ICommand>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Command="commandName"/>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *commandName*  
 Der Befehl, der aufgerufen wird, wenn diese Schaltfläche aufgerufen werden.  
  
<a name="dependencyPropertyInfo_Command"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Parameter an übergeben der <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" /> Eigenschaft.</summary>
        <value>Parameter, der zum Übergeben der <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" /> Eigenschaft.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten vorhandenen Befehle aus den Bibliotheken verwenden einen Befehlsparameter. Der Befehle, die einen Parameter verwenden, übernehmen die meisten dieser einen Parameter mit einem bestimmten Grundtyp-Wert, z. B. eine ganze Zahl oder eine Zeichenfolge. Es ist jedoch möglich, einen benutzerdefinierten Befehl zu erstellen, in dem dieser Befehl einen nicht primitiven Typ als Befehlsparameter erwartet. Für einen benutzerdefinierten Befehl Fall wie folgt, Festlegen von <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> im Code eine neue oder vorhandene Objektinstanz erforderlich. Festlegen von <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> im Markup Eigenschaftenelementsyntax, in dem das Ausfüllen der Eigenschaftenelementsyntax Object-Element ein neues Element des Typs, die vom Befehl erwarteten ist erfordern. Alternativ können Sie möglicherweise festlegen im Markup erfordern einen Verweis durch eine Markuperweiterung auf ein vorhandenes Objekt (in der Regel werden diese Verweise mit [Markuperweiterung binden](~/docs/framework/wpf/advanced/binding-markup-extension.md) oder [StaticResource-Markuperweiterung ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)).  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object CommandParameter="commandParameter" />  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *commandParameter*  
 Ein Wert des gleichen Typs wie der bestimmten Befehl angegeben, der <xref:System.Windows.Controls.Primitives.ButtonBase.Command%2A> Eigenschaft erwartet. Wenn Sie einen vorhandene Bibliothek-Befehl verwenden, finden Sie in dieser Befehlsbibliothek Dokumentation [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Verwendungsinformationen an, welche Art von einschließlich <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> erwartet, dass der Befehl. Wenn Sie einen benutzerdefinierten Befehl verwenden, finden Sie unter "Hinweise".  
  
<a name="dependencyPropertyInfo_CommandParameter"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die weitergeleitete <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" /> Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt das Element, für das den angegebenen Befehl ausgelöst werden soll.</summary>
        <value>Element auf dem einen Befehl ausgelöst werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> Eigenschaft kann nicht verwendet werden, definieren eine <xref:System.Windows.UIElement>. Die <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> Eigenschaft stellt einen Verweis auf ein Element, das bereits an anderer Stelle in der Anwendung definiert ist.  
  
<a name="xamlAttributeUsage_Target"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<ButtonBase CommandTarget="{Binding ElementName= elementName }"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *elementName*  
 Der Name des <xref:System.Windows.IInputElement> , der den Befehl empfängt.  
  
<a name="dependencyPropertyInfo_CommandTarget"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der <see cref="P:System.Windows.ContentElement.IsEnabled" /> Eigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Steuerelement aktiviert ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Implementierung überschreiben, stellen Sie sicher, dass Sie die Basismethode aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressed">
      <MemberSignature Language="C#" Value="public bool IsPressed { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPressed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob eine <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> ist zurzeit aktiviert.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> aktiviert ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A>ist der Zustand einer Schaltfläche, der die linke Maustaste gedrückt angibt, oder LEERTASTE gedrückt wird, auf die Schaltfläche. Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist `true`, zeichnet die Maus auf das Steuerelement.  Daher das Steuerelement löst Mausereignisse wie z. B. <xref:System.Windows.UIElement.MouseEnter> und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Beachten Sie, dass die Verwendung der <xref:System.Windows.Controls.AccessText> oder EINGABETASTE ändert sich nicht <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> oder die Maus erfassen, jedoch wird wird ausgelöst der <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Ab .NET Framework Version 3.0 Servicepack 1, <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> verfügt über einen geschützten Setter. Zur Verwendung dieser Funktionen sollte die Anwendung .NET Framework, Version 3.5 abzielen.  Weitere Informationen finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
<a name="dependencyPropertyInfo_IsPressed"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Dieses Beispiel zeigt, wie die <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> Eigenschaft in einem Trigger-Stil.  
  
 [!code-xaml[BtnColor#9](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnColor/CSharp/Pane1.xaml#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsPressedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsPressedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected override void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für die <see cref="E:System.Windows.Input.AccessKeyManager.AccessKeyPressed" /> Ereignis.</param>
        <summary>Reagiert, wenn die <see cref="P:System.Windows.Controls.AccessText.AccessKey" /> für dieses Steuerelement aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Input.AccessKeyEventArgs.IsMultiple%2A> ist `true`, ruft diese Methode die basisimplementierung, wodurch dieses den Steuerelementfokus erhalten.  Andernfalls löst diese Methode die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" /> Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das Steuerelement die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis durch Aufrufen von <xref:System.Windows.UIElement.RaiseEvent%2A>. Weitere Informationen finden Sie unter [Ereignisübersicht weitergeleitet](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> Methode, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsPressedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsPressedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsPressedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnIsPressedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</param>
        <summary>Wird aufgerufen, wenn die <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" /> -Eigenschaft ändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyDown" /> Routingereignis, das auftritt, wenn der Benutzer eine Taste drückt, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.KeyDown> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nicht auf festgelegt ist <xref:System.Windows.Controls.ClickMode.Hover> und einer der folgenden Fälle zutrifft:  
  
-   Der Benutzer drückt die LEERTASTE.  
  
-   Der Benutzer die EINGABETASTE drückt und <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> ist `true` für dieses Steuerelement.  
  
 In allen anderen Fällen wird diese Implementierung zum behandelten Zustand nicht geändert (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.KeyDown> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für die <see cref="E:System.Windows.UIElement.KeyUp" /> Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.KeyUp" /> Routingereignis, das auftritt, wenn der Benutzer eine Taste loslässt, während dieses Steuerelement den Fokus besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.KeyUp> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` Wenn der Benutzer die LEERTASTE loslässt. Diese Implementierung ändert, andernfalls nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.KeyUp> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für die <see cref="E:System.Windows.IInputElement.LostKeyboardFocus" /> Ereignis.</param>
        <summary>Wird aufgerufen, wenn ein Element den Tastaturfokus verliert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für die <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.LostMouseCapture" /> Routingereignis, das auftritt, wenn dieses Steuerelement nicht mehr Maus-Ereignisnachrichten empfangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung ändert nicht zum behandelten Zustand (die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft) von der <xref:System.Windows.UIElement.LostMouseCapture> Ereignisdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für die <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" /> Routingereignis, das auftritt, wenn die Maus des Steuerelements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> auf festgelegt ist <xref:System.Windows.Controls.ClickMode.Hover>, diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseEnter> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` und löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten für die <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> Ereignis.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeave" /> Routingereignis, das auftritt, wenn der Mauszeiger über ein Element verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseLeave> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> auf festgelegt ist <xref:System.Windows.Controls.ClickMode.Hover>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> Routingereignis, das auftritt, wenn die linke Maustaste gedrückt wird, während der Mauszeiger über diesem Steuerelement befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nicht festgelegt ist, um <xref:System.Windows.Controls.ClickMode.Hover>. So reagieren Sie auf die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis, fügen Sie einen Ereignishandler an das <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> Ereignis an, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> festgelegt ist, um <xref:System.Windows.Controls.ClickMode.Press>, löst diese Methode die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> Routingereignis, das auftritt, wenn die linke Maustaste losgelassen wird, während sich der Mauszeiger über diesem Steuerelement befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft der Ereignisdaten zu `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nicht festgelegt ist, um <xref:System.Windows.Controls.ClickMode.Hover>. So reagieren Sie auf die <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignis, fügen Sie einen Ereignishandler an das <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> Ereignis an, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
 Wenn <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> festgelegt ist, um <xref:System.Windows.Controls.ClickMode.Release> ist <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist `true`, löst diese Methode die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.MouseMove" /> Routingereignis, das auftritt, wenn der Mauszeiger bewegt wird, während er sich über diesem Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung kennzeichnet die <xref:System.Windows.UIElement.MouseMove> Ereignis als behandelt, indem die <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft, der die Ereignisdaten an `true` beim <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> nicht festgelegt ist, um <xref:System.Windows.Controls.ClickMode.Hover> und <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> ist `true`. So reagieren Sie auf die <xref:System.Windows.UIElement.MouseMove> Ereignis, fügen Sie einen Ereignishandler an das <xref:System.Windows.ContentElement.PreviewMouseMove> Ereignis an, oder rufen <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` festgelegt `true`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie außer Kraft setzen <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />, rufen Sie immer die grundlegende Implementierung Ihrer <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" /> Implementierung. Die basisimplementierung aufgerufen wird verhindert, dass Basisklassen Behandlung des Ereignisses mit einem Klassenhandler, der das Laufzeitverhalten der endgültigen Klasse ändern kann. Sie können die grundlegende Implementierung entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufrufen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Gibt die Fenstergröße ändert.</param>
        <summary>Wird aufgerufen, wenn die gerenderte Größe eines Steuerelements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreibt die <xref:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged%2A> Methode der <xref:System.Windows.UIElement>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
