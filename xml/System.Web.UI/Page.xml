<Type Name="Page" FullName="System.Web.UI.Page">
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine ASPX-Datei dar, auch bekannt als Web Forms-Seite, die von einem Server angefordert wird, der eine ASP.NET-Webanwendung hostet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page> Klasse bezieht sich auf Dateien, die eine ASPX-Erweiterung aufweisen. Diese Dateien werden zur Laufzeit als kompiliert <xref:System.Web.UI.Page> Objekte und im Arbeitsspeicher des Servers zwischengespeichert.  
  
 Wenn Sie eine Web Forms-Seite mit dem Code-Behind-Verfahren erstellen möchten, leiten Sie von dieser Klasse. Rapid Application Development, (RAD)-Designer, z. B. Microsoft Visual Studio, verwenden Sie dieses Modell automatisch, um Web Forms-Seiten zu erstellen.  
  
 Die <xref:System.Web.UI.Page> Objekt dient als Namenscontainer für alle Steuerelemente auf einer Seite, mit Ausnahme derjenigen, die implementieren die <xref:System.Web.UI.INamingContainer> -Schnittstelle oder sind untergeordnete Steuerelemente von Steuerelementen, die diese Schnittstelle implementieren.  
  
 Die <xref:System.Web.UI.Page> Klasse ist ein Steuerelement, das als Benutzeroberfläche für Ihre Web-Anwendung fungiert, und sollte daher geprüft werden, um Stellen Sie sicher, dass bewährte Methoden Schreiben von sicherem Code, und Sichern von Clientanwendungen eingehalten werden. Allgemeine Informationen zu diesen Themen finden Sie unter [Overview of Web Application Security Threats](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: Security Policy Best Practices](http://msdn.microsoft.com/en-us/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), und [Key Security Concepts](~/docs/standard/security/key-security-concepts.md). Weitere Informationen finden Sie unter [Standardsteuerelemente schützen](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [wie: sichere Fehlermeldungen anzeigen](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [wie: schützen gegen Script Exploits in einer Web-Anwendung durch Anwenden von HTML Codierung in Zeichenfolgen](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), und [Einführung in die Validierungssteuerelemente](http://msdn.microsoft.com/en-us/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 Ist ein Visual Studio Web Site-Projekt mit Quellcode zu diesem Thema steht verfügbar: [herunterladen](http://go.microsoft.com/fwlink/?LinkId=192425).  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.Page> Klasse wird im Code-Behind-Seitenmodell verwendet. Beachten Sie, dass der Code-Behind-Quelldatei eine partielle Klasse deklariert, die von einer Basisklasse Page-Klasse erbt. Die Basisseite-Klasse kann Folgendes sein <xref:System.Web.UI.Page>, oder es kann eine andere Klasse, abgeleitet wird <xref:System.Web.UI.Page>. Beachten Sie darüber hinaus, dass die Teilklasse die CodeBehind-Datei, mit der Steuerelemente auf der Seite ohne definiert diese als Feldmember definieren kann.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 Das folgende Codebeispiel zeigt die ASPX-Datei, die den vorangehenden Code-Behind-Quelldatei entspricht.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 Verwenden Sie die Richtlinie und verwenden Sie die `Inherits` und `CodeFile` Attribute, die Code-Behind-Datei mit der ASPX-Datei zu verknüpfen. In diesem Beispiel wird die `Inherits` -Attribut gibt an, die `MyCodeBehind` Klasse und die `CodeFile` Attribut gibt den Pfad zu den sprachspezifischen-Datei, die die Klasse enthält.  
  
 Im folgenden Codebeispiel wird veranschaulicht, das Modell Einzeldateiseite und Zugriff auf die <xref:System.Web.UI.Page.IsPostBack%2A> Eigenschaft und die <xref:System.Web.UI.Page.Response%2A> Eigenschaft von der <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.UI.Page" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardkonstruktor initialisiert alle Felder mit ihren Standardwerten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">Der Name, der den Inhalt der Vorlage hinzugefügt werden soll.</param>
        <param name="template">Den Inhalt der Vorlage</param>
        <summary>Wird aufgerufen, während der Initialisierung der Seite erstellen Sie eine Sammlung von Inhalten (Content-Steuerelemente), die auf einer Masterseite übergeben wird, wenn die aktuelle Seite oder die Masterseite auf einer Masterseite verweist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Eine Inhaltsvorlage mit dem gleichen Namen ist bereits vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Der Delegat für die <see cref="T:System.Web.BeginEventHandler" /> Methode.</param>
        <param name="endHandler">Der Delegat für die <see cref="T:System.Web.EndEventHandler" /> Methode.</param>
        <summary>Registriert die Anfangs- und Enddatumsangaben Ereignishandlerdelegaten, die keine Zustandsinformationen für eine asynchrone Seite erfordern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> Methode, um eine asynchrone Webseite hinzufügen.  
  
 Sie können mehrere asynchrone Handler registriert werden; Allerdings führt nur einen Ereignishandler zu einem Zeitpunkt. Wenn Sie mehrere asynchrone Methoden gleichzeitig verarbeiten möchten, verwenden Sie ein einzelnes <xref:System.Web.BeginEventHandler> Methode, und starten Sie mehrere asynchrone Vorgänge aus dieser Handler.  
  
 Die asynchrone Ereignishandler werden aufgerufen, zwischen den <xref:System.Web.UI.Control.PreRender> und <xref:System.Web.UI.Page.PreRenderComplete> Ereignisse.  
  
 Zuerst alle <xref:System.Web.UI.Page> Ereignisse (über die <xref:System.Web.UI.Control.PreRender> Ereignis) ausführen, und klicken Sie dann jedes registriert sind <xref:System.Web.BeginEventHandler> -Methode aufgerufen wird. Wenn der Handler abgeschlossen wird, den entsprechenden <xref:System.Web.EndEventHandler> -Methode aufgerufen wird. Wenn mehrere asynchrone Handler vorhanden sind, wird der nächste Handler aufgerufen.  
  
 Nachdem die registrierten asynchronen Ereignishandler aufgerufen wurden, der Rest der Seitenereignisse werden aufgerufen, beginnend mit der <xref:System.Web.UI.Page.PreRenderComplete> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet eine asynchrone Anforderung zum Anzeigen der HTML-Quellcode der Standardseite für den lokalen Webserver in einem <xref:System.Web.UI.WebControls.TextBox> Steuerelement.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="&lt;async&gt;" /> Seitendirektive ist nicht festgelegt, um <see langword="true" />.  
  
 \- oder –  
  
 Die <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> Methode wird aufgerufen, nachdem die <see cref="E:System.Web.UI.Control.PreRender" /> Ereignis.</exception>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> oder <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Der Delegat für die <see cref="T:System.Web.BeginEventHandler" /> Methode.</param>
        <param name="endHandler">Der Delegat für die <see cref="T:System.Web.EndEventHandler" /> Methode.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für die Ereignishandler.</param>
        <summary>Register öffnend und schließend Ereignishandlerdelegaten für eine asynchrone Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> Methode, um Handler hinzuzufügen, die Statusinformationen zu einer asynchronen Webseite erfordern. Das Objekt übergeben, der `state` Parameter kann jedes Objekt, das die Anwendung zur Übertragung von Informationen zwischen Ereignishandlerdelegaten erfordert in angegeben sein der `beginHandler` und die `endHandler` Parameter.  
  
 Sie können mehrere asynchrone Handler registriert werden; Allerdings führt nur einen Ereignishandler zu einem Zeitpunkt. Wenn Sie mehrere asynchrone Methoden gleichzeitig verarbeiten möchten, verwenden Sie ein einzelnes <xref:System.Web.BeginEventHandler> Methode, und starten Sie mehrere asynchrone Vorgänge aus dieser Handler.  
  
 Die asynchrone Ereignishandler werden aufgerufen, zwischen den <xref:System.Web.UI.Control.PreRender> und <xref:System.Web.UI.Page.PreRenderComplete> Ereignisse.  
  
 Zuerst alle <xref:System.Web.UI.Page> Ereignisse (über die <xref:System.Web.UI.Control.PreRender> Ereignis) ausführen, und klicken Sie dann jedes registriert sind <xref:System.Web.BeginEventHandler> -Methode aufgerufen wird. Wenn der Handler abgeschlossen wird, den entsprechenden <xref:System.Web.EndEventHandler> -Methode aufgerufen wird. Wenn mehrere asynchrone Handler vorhanden sind, wird der nächste Handler aufgerufen.  
  
 Nachdem die registrierten asynchronen Ereignishandler aufgerufen wurden, der Rest der Seitenereignisse werden aufgerufen, beginnend mit der <xref:System.Web.UI.Page.PreRenderComplete> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet eine asynchrone Anforderung zum Anzeigen der HTML-Quellcode der Standardseite für den lokalen Webserver in einem <xref:System.Web.UI.WebControls.TextBox> Steuerelement.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="&lt;async&gt;" /> Seitendirektive ist nicht festgelegt, um <see langword="true" />.  
  
 \- oder –  
  
 Die <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> Methode wird aufgerufen, nachdem die <see cref="E:System.Web.UI.Control.PreRender" /> Ereignis.</exception>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> oder <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Ein <see cref="T:System.Object" /> , enthält die Liste der Dateinamen.</param>
        <summary>Fügt eine Liste der abhängigen Dateien, aus denen die aktuelle Seite besteht. Diese Methode wird durch das ASP.NET-Seitenframework intern verwendet und sollte nicht direkt aus Ihrem Code verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> Methode fügt eine Liste der Dateien, z. B. Benutzersteuerelement-Dateien, aus denen die aktuelle Seite besteht. Wenn eine dieser Seiten geändert wird, wird die gesamte Seite das nächste Mal kompiliert, wenn, das es angefordert wird. Diese Methode unterstützt die .NET Framework-Infrastruktur und ist nicht für eine direkte Verwendung im Code vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpApplicationState" />-Objekt für die aktuelle Webanforderung ab.</summary>
        <value>Die aktuellen Daten in der <see cref="T:System.Web.HttpApplicationState" /> Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Ein <see cref="T:System.Web.HttpContext" /> mit Informationen über die aktuelle Anforderung.</param>
        <param name="cb">Die Rückrufmethode.</param>
        <param name="extraData">Alle zusätzlichen unbekannten Daten, die zum Verarbeiten der Anforderung auf die gleiche Weise wie eine ASP-Anforderung erforderlich sind.</param>
        <summary>Initiiert eine Anforderung für Active Server Page (ASP)-Ressourcen. Diese Methode wird für die Kompatibilität mit älteren ASP-Anwendungen bereitgestellt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Die ASP-Seite, die von der Anforderung generiert.</param>
        <summary>Beendet eine Anforderung für Active Server Page (ASP)-Ressourcen. Diese Methode wird für die Kompatibilität mit älteren ASP-Anwendungen bereitgestellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Wert, der angibt, ob die Seite in einem Singlethread-Apartment (STA)-Thread ausgeführt werden kann.</summary>
        <value>
          <see langword="true" />Wenn die Seite "Active Server Pages (ASP) Code unterstützt. andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Festlegung auf `true`, dieser Eigenschaft können Sie die Seite in einem Singlethread-Apartment (STA)-Thread ausgeführt werden. Dadurch wird die Seite STA-Komponenten, wie entwickelt, die mit Visual Basic 6.0-Komponenten aufrufen. Wenn diese Eigenschaft auf `true` können auch auf die Seite, um die COM+-Komponenten aufrufen, die Zugriff auf die nicht verwalteten integriertes ASP-Objekte erfordern. Dies sind über die ASP `ObjectContext` Objekt oder die `OnStartPage` Methode.  
  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `aspcompat` -Attribut `true` mit der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Wert, der angibt, ob die Seite synchron oder asynchron verarbeitet wird.</summary>
        <value>
          <see langword="true" />Wenn die Seite asynchron verarbeitet wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.AsyncMode%2A> Eigenschaft wird festgelegt, indem die <xref:System.Web.UI.Page> Parser Wenn Code für die Seite generiert wird. Verwenden der `Async` -Attribut in der Richtlinie, um diesen Wert festzulegen.  
  
 Asynchrone Seiten können nicht ausgeführt, wenn die `AspCompat` -Attributsatz zur `true` oder `Transaction` Attribut auf einen Wert festgelegt ist als `Disabled` in der Direktive.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Die <see cref="T:System.Web.HttpContext" /> für die Anforderung.</param>
        <param name="callback">Die Rückrufmethode zu benachrichtigen, wenn der Vorgang abgeschlossen ist.</param>
        <param name="extraData">Statusdaten für die asynchrone Methode.</param>
        <summary>Beginnt mit der Verarbeitung einer Anforderung für asynchrone Seite.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Anforderung verweist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein <see cref="T:System.IAsyncResult" /> auf eine ausstehende asynchrone Anforderung verweist.</param>
        <summary>Beendet die Verarbeitung einer Anforderung für asynchrone Seite.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, des Timeoutintervalls beim Verarbeiten von asynchroner Aufgaben verwendet.</summary>
        <value>Ein <see cref="T:System.TimeSpan" /> , die das zulässige Zeitintervall für den Abschluss des asynchronen Vorgangs enthält. Das Standardintervall beträgt 45 Sekunden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das asynchrone Timeout der Seite stellt die Zeitspanne, die die Seite gewartet wird, um asynchrone Aufgaben ausführen. Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die Seite asynchrone Timeoutwert Intervall, indem die von der Konfigurationsdatei oder in der Direktive. In den Seitenkonfigurationsabschnitt festgelegten Werte werden von der Seitendirektive überschrieben.  
  
 Definieren Sie asynchrone Aufgabe mithilfe der <xref:System.Web.UI.PageAsyncTask> Klasse, und registrieren Sie eine Start-, End- und einen Timeouthandler. Wenn die asynchrone Aufgabe nicht innerhalb des angegebenen Zeitintervalls abgeschlossen wird, wird der Timeouthandler aufgerufen werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft mit dem <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> und <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Methoden. Beachten Sie die Verwendung der Start-, End- und Timeout-Handler. Im Beispiel eine künstliche Verzögerung zur Veranschaulichung der Situation einer asynchronen Aufgabe, die für den Task entsprechend den Angaben in die vorgesehenen Zeit überschreitet, wird die <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft. In einem realen Szenario konnte eine asynchrone Aufgabe auszuführenden Datenbankaufrufe oder imagegenerierung, z. B. und dienen der Timeouthandler stellt maßvolle Leistungseinbußen, wenn die Aufgabe in einem angegebenen Zeitraum nicht ausgeführt wird. Beachten Sie, dass die <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft in der Seitendirektive festgelegt ist.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wurde ein negativer Wert festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt das Steuerelement auf der Seite, die zum Ausführen von Postbacks verwendet wird.</summary>
        <value>Das Steuerelement, das zum Ausführen von Postbacks verwendet wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Wert, der angibt, ob die Seitenausgabe gepuffert wird.</summary>
        <value>
          <see langword="true" />Wenn die Seitenausgabe gepuffert wird. andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die <xref:System.Web.UI.Page.Buffer%2A> -Attribut `true` mit der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.Page.Buffer%2A> Eigenschaft legt fest, und ruft die <xref:System.Web.HttpResponse.BufferOutput%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Web.Caching.Cache" /> Objekt zugewiesen ist, mit der Anwendung, in dem sich die Seite befindet.</summary>
        <value>Die <see cref="T:System.Web.Caching.Cache" /> der Page-Anwendung zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einer Anwendungsverzeichnis <xref:System.Web.Caching.Cache> Objekts können Sie beliebige Daten bei nachfolgenden Anforderungen speichern und abrufen. Der Cache ist nicht speziell auf einer Seite oder einem Benutzersteuerelement-Clientsitzung zugeordnet. Es wird hauptsächlich zum Verbessern der Leistung der Anwendung verwendet. Weitere Informationen finden Sie unter [Anwendungsdaten Caching](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d). Weitere Informationen zu den Unterschieden zwischen Zwischenspeicherung von Anwendungsdaten und Seitenausgabe-caching finden Sie unter [Übersicht über das Zwischenspeichern von ASP.NET](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Summe von zwei ganzen Zahlen eingefügt die <xref:System.Web.Caching.Cache?displayProperty=nameWithType> -Objekt unter Verwendung der <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> Eigenschaft. Dann werden den Wert mit der <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> Methode und schreibt ihn auf eine <xref:System.Web.UI.WebControls.Label> -Webserversteuerelement.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Eine Instanz von <see cref="T:System.Web.Caching.Cache" /> wird nicht erstellt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeichenfolge Abfrageteil der angeforderten URL ab.</summary>
        <value>Die Zeichenfolge Abfrageteil der angeforderten URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.ClientQueryString%2A> Eigenschaft enthält die Zeichenfolge Abfrageteil der vom Browser angeforderten URL. Wenn die angeforderte URL "http://www.contoso.com/default.aspx?id=100", ist beispielsweise die <xref:System.Web.UI.Page.ClientQueryString%2A> Eigenschaft enthält "Id = 100". Die <xref:System.Web.UI.Page.ClientQueryString%2A> Eigenschaft verschlüsselt wird; verwenden Sie die <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> Methode, um die Abfragezeichenfolge zu decodieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Web.UI.ClientScriptManager" /> zu verwalten, registrieren und Hinzufügen von Skripts auf der Seite "verwendete Objekt.</summary>
        <value>Ein <see cref="T:System.Web.UI.ClientScriptManager" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.ClientScript%2A> Eigenschaft, um eine <xref:System.Web.UI.ClientScriptManager> -Objekt, das zum Verwalten, registrieren und Hinzufügen von Skripts zu einer Webseite verwendet werden kann. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Web.UI.ClientScriptManager>-Klasse.  
  
 Die <xref:System.Web.UI.ClientScriptManager> Klasse ist neu in [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] und ersetzt <xref:System.Web.UI.Page> -Klasse Methoden zum Verwalten von Skripts, die jetzt veraltet sind.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter der <xref:System.Web.UI.ClientScriptManager> Übersichtsthema.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, mit dem Sie die automatischen Erkennung von Browserfunktionen überschreiben und angeben, wie eine Seite für bestimmte Browserclients gerendert wird.</summary>
        <value>Ein <see cref="T:System.String" /> , angibt, dass der Webbrowser-Funktionen, die Sie überschreiben möchten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht Festlegen der <xref:System.Web.UI.Page.ClientTarget%2A> -Eigenschaft, die <xref:System.Web.HttpBrowserCapabilities> zugeordnete Objekt der <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> Eigenschaft spiegelt die Funktionen des Clientbrowsers. Wenn Sie diese Eigenschaft festlegen, Client-Browser-Erkennung ist deaktiviert, und mithilfe der Seite Browserfunktionen, die Verbindung mit dem Wert (Alias), den Sie bereitstellen.  
  
 Die Stammdatei für die Konfiguration von "Web.config" auf dem Webservercomputer definiert die folgenden Standardaliase, die Sie als Kurzform für allgemeine Benutzer-Agent-Zeichenfolgen verwenden können:  
  
-   `uplevel`, gibt die Browserfunktionen ist gleichbedeutend mit Internet Explorer 6.0.  
  
-   `downlevel`, gibt Browserfunktionen gleichbedeutend mit älteren Browsern, die keine Clientskripts unterstützen. Dieser Alias können Sie bestimmen, wie Webseiten in einem Browser erfolgen kann, die Clientskripts deaktiviert wurde.  
  
 Sie können den Alias, der mit dieser Eigenschaft programmgesteuert festlegen, oder Sie können festlegen, deklarativ mithilfe der `ClientTarget` Attribut der Richtlinie.  
  
 Sie können zusätzliche Aliase im Definieren der `clientTarget` Abschnitt der Datei "Web.config" auf Anwendungsebene. Weitere Informationen finden Sie unter [ClientTarget Element ((ASP.NET Settings Schema)](http://msdn.microsoft.com/en-us/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine `ie302` Alias enthält Abschnitte, die zum Konfigurieren Ihrer Anwendung in der Datei "Web.config" erforderlich. Mit diesem Alias an, Sie können festlegen, die <xref:System.Web.UI.Page.ClientTarget%2A> Eigenschaft `ie302` Seiten speziell für Internet Explorer 3.02 und anpassen.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Codepage-Bezeichner für die aktuelle <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Eine ganze Zahl, die der Codepage-Bezeichner für die aktuelle darstellt <see cref="T:System.Web.UI.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `CodePage` -Attributs auf den Wert, der mit der Direktive in der ASPX-Datei enthalten sein sollen. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den HTTP-MIME-Typ für die <see cref="T:System.Web.HttpResponse" /> Objekt, das mit der Seite zugeordnet.</summary>
        <value>Der HTTP-MIME-Typ der aktuellen Seite zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `ContentType` -Attribut mit der Richtlinie in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Web.HttpContext" /> Objekt, das mit der Seite zugeordnet.</summary>
        <value>Ein <see cref="T:System.Web.HttpContext" /> -Objekt, das der aktuellen Seite zugeordnete Informationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den programmgesteuerten Zugriff auf den Kontext, in den die Seite, ausgeführt wird, einschließlich Informationen über die Anforderung, Response, Session und Anwendung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.Context%2A> aufzurufende Eigenschaft der <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> und <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> Methoden und die <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> Eigenschaft. Das Beispiel erstellt drei benutzerdefinierte Ausnahmen mithilfe der <xref:System.Web.HttpContext.AddError%2A> -Methode und verwendet die <xref:System.Web.HttpContext.AllErrors%2A> Eigenschaft, um diese Ausnahmen in ein Array zu laden. Klicken Sie dann das Array auf der Seite schreibt und verwendet die <xref:System.Web.HttpContext.ClearError%2A> Methode so löschen Sie alle Fehler aus der <xref:System.Web.UI.Page.Context%2A> Eigenschaft.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">Der <see cref="T:System.IO.TextWriter" />, der zum Erstellen des <see cref="T:System.Web.UI.HtmlTextWriter" />s verwendet wurde.</param>
        <summary>Erstellt ein <see cref="T:System.Web.UI.HtmlTextWriter" /> Objekt, das der Inhalt der Seite gerendert.</summary>
        <returns>Ein <see cref="T:System.Web.UI.HtmlTextWriter" /> oder <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Methode erstellt eine <xref:System.IO.TextWriter> über die <xref:System.Web.HttpRequest.Browser%2A> Eigenschaft von der <xref:System.Web.HttpContext.Request%2A> Objekt, auf der Seite "-Anforderung zugeordnet. Sie können einen Verweis auf Hinzufügen einer <xref:System.Web.UI.HtmlTextWriter> in die `browserCaps` Konfigurationsabschnitt. Überschreiben Sie die <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Methode, um benutzerdefinierte Suche auszuführen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> Methode zum Erstellen einer Instanz eines benutzerdefinierten <xref:System.Web.UI.HtmlTextWriter> Objekt mit dem Namen `MyHtmlTextWriter`. Die <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> -Methode überschrieben wird, der `MyPage` -Klasse, die abgeleitet ist <xref:System.Web.UI.Page>, sodass `MyHtmlTextWriter` ASP.NET-Serversteuerelemente rendert, wenn die Seite angefordert wird. Beachten Sie, dass in diesem Beispiel wird verhindert, Adapter dass <xref:System.IO.TextWriter> Verhalten.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">Der <see cref="T:System.IO.TextWriter" />, der zum Erstellen des <see cref="T:System.Web.UI.HtmlTextWriter" />s verwendet wurde.</param>
        <param name="writerType">Der Typ des Textwriters zu erstellen.</param>
        <summary>Erstellt ein angegebenes <see cref="T:System.Web.UI.HtmlTextWriter" /> Objekt, das der Inhalt der Seite gerendert.</summary>
        <returns>Ein <see cref="T:System.Web.UI.HtmlTextWriter" /> , rendert den Inhalt der Seite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern in Seitenadaptern verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <paramref name="writerType" /> Parameter auf einen ungültigen Typ festgelegt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Kultur-ID für die <see cref="T:System.Threading.Thread" /> Objekt, das mit der Seite zugeordnet.</summary>
        <value>Eine gültige Kultur-ID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die `Culture` Attribut in der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse den Wert dieser Eigenschaft fest. Darüber hinaus können Sie auch explizit den Wert der Festlegen der <xref:System.Web.UI.Page.Culture%2A> Eigenschaft programmgesteuert oder in das Element der Datei Web.config-Datei.  
  
 Die <xref:System.Web.UI.Page.Culture%2A> Eigenschaft wird zum Lokalisieren von Seiteninhalt verwendet. Sie können es auf eine beliebige gültige Kultur-ID festlegen. Z. B. die `en-us` Kultur-ID wird die Seite auf amerikanisches Englisch und die `fr` Kultur-ID der Seite auf Französisch festgelegt. Sie können auch den Wert festlegen, um `auto` bevorzugte Sprache und legen sie die automatischen Erkennung des Browsers ausgeführt wird. Die automatische Spracherkennung kann z. B. mit einem Standardwert qualifiziert werden `auto:en-us`.  
  
 Weitere Informationen finden Sie unter der <xref:System.Globalization.CultureInfo> -Klassenübersicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt alle Initialisierungsschritte für die Instanz von der <see cref="T:System.Web.UI.Page" /> -Klasse, die RAD-Designer erforderlich ist. Diese Methode wird nur zur Entwurfszeit verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Collections.Specialized.NameValueCollection" /> von Daten an die Seite mit einer POST oder GET-Befehl zurückgesendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Specialized.NameValueCollection" /> Objekt, das die Formulardaten enthält. Wenn das Postback der POST-Befehl verwendet wird, wird die Formularinformationen zurückgegeben, aus der <see cref="P:System.Web.UI.Page.Context" /> Objekt. Wenn das Postback der GET-Befehl verwendet, wird die Abfragezeichenfolgen-Informationen zurückgegeben. Wenn die Seite zum ersten Mal angefordert wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.DeterminePostBackMode%2A> Methode gibt ein <xref:System.Collections.Specialized.NameValueCollection> Objekt, das die Daten enthält, die an der Seite zurückgesendet. Das Vorhandensein der Seite ausgeblendete Felder "ViewState" Speichern und EVENTTARGET wird verwendet, um zu ermitteln, ob ein Postbackereignis aufgetreten ist. Die <xref:System.Web.UI.Page.IsPostBack%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Web.UI.Page.DeterminePostBackMode%2A> -Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Name-Wert-Auflistung von Daten, die zurückgesendet wurde auf der Seite mit einer POST oder GET-Befehl ohne Ausführen von ASP.NET anforderungsüberprüfung für die Anforderung zurück.</summary>
        <returns>Ein Objekt, das nicht überprüfte Daten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Web.UnvalidatedRequestValues>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Seite Postback und Rückrufereignisse überprüft.</summary>
        <value>
          <see langword="true" />Wenn die Seite Postback und Rückrufereignisse überprüft; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Web.UI.Page.EnableEventValidation%2A> -Eigenschaftensatz auf `true`, ASP.NET überprüft, dass über die Benutzeroberfläche, die von diesem Steuerelement gerendert wurde, eine Steuerelementereignis ausgelöst wurde. Ein Steuerelement seine Ereignisse während des Renderings registriert und überprüft dann, ob die Ereignisse während der Behandlung von Postback oder der Rückruffunktion. Beispielsweise enthält ein Listenfeld-Steuerelement Optionen 1, 2 oder 3 nummeriert, wenn die Seite gerendert wird und eine postback Anforderung empfangen wird, Angeben von Optionsnummer 4, ASP.NET eine Ausnahme auslöst. Alle Steuerelemente, die in ASP.NET die ereignisgesteuerte dieses Feature wird standardmäßig verwendet.  
  
 Wenn Sie Clientskripts, die ein Steuerelement auf dem Client zur Laufzeit ändert schreiben, müssen Sie möglicherweise verwenden Sie die <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode, um "false" Ereignis-Validierungsfehler zu vermeiden.  
  
> [!IMPORTANT]
>  Diese Funktion reduziert das Risiko von nicht autorisierten oder böswilligen postback Anforderungen und Rückrufe. Es wird dringend empfohlen, dass Sie die Validierung nicht deaktivieren.  
  
 Festlegen der <xref:System.Web.UI.Page.EnableEventValidation%2A> Eigenschaft durch Festlegen der `enableEventValidation` Attribut der Anweisung oder der `enableEventValidation` Attribut des Elements in der Datei "Web.config". Wenn Sie diese Eigenschaft im Code festlegen, müssen Sie es vor der Initialisierung der Seite "festlegen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Web.UI.Page.EnableEventValidation" /> -Eigenschaft wurde festgelegt, nachdem die Seite initialisiert wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt enthält ein Wert, der angibt, ob die Seite seinen Ansichtszustand verwaltet und das Anzeigen des Status von einem beliebigen Server jedoch kontrolliert, wenn die aktuelle Seitenanforderung endet.</summary>
        <value>
          <see langword="true" />Wenn die Seite seinen Ansichtszustand beibehält; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen dazu, warum Sie möglicherweise Ansichtszustand deaktivieren möchten, finden Sie unter <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Auch wenn <xref:System.Web.UI.Page.EnableViewState%2A> ist `false`, die Seite möglicherweise ein ausgeblendetes Feld für den Status, die von ASP.NET verwendet wird, um ein Postback zu erkennen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.UI.Page.EnableViewState%2A> Eigenschaft `false` beim Laden der Seite. Dadurch werden deaktiviert, Anzeigen des Status für die <xref:System.Web.UI.Page> Objekt, d. h., dass weder Informationen zum Ansichtszustand für die Seite noch über die Steuerelemente der Seite gespeichert werden.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, oder legt Sie einen Wert, der angibt, ob ASP.NET Nachrichtenauthentifizierungscodes (MAC) überprüft werden soll im Anzeigezustand der Seite fest, wenn die Seite vom Client zurückgesendet wird.</summary>
        <value>
          <see langword="true" />Wenn der Ansichtszustand MAC überprüft und codiert werden soll; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein MAC Ansichtszustand ist eine verschlüsselte Version der ausgeblendeten Variablen, die eine Seite Ansichtszustand zu beibehalten wird, wenn die Seite an den Browser gesendet wird. Wenn diese Eigenschaft festgelegt wird, um `true`, der verschlüsselten Ansichtszustand wird überprüft, um sicherzustellen, dass es nicht auf dem Client manipuliert wurde.  
  
 Legen Sie diese Eigenschaft nicht im Code. Legen Sie die `EnableViewStateMac` -Attribut mit der Richtlinie in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
> [!IMPORTANT]
>  Dieses Attribut sollte nicht festgelegt werden, um `false` in einer Produktions-Website, selbst wenn der Ansichtszustand nicht von der Anwendung oder die Seite verwendet wird. Der Ansichtszustand MAC hilft damit die Sicherheit anderer ASP.NET-Funktionen, die zusätzlich zu den Ansichtszustand.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Fehlerseite an der anfordernde Browser im Falle einer Seitenausnahme nicht behandelte umgeleitet wird.</summary>
        <value>Die Fehlerseite, zu der der Browser umgeleitet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die Ausführung einer asynchronen Aufgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definieren Sie eine asynchrone Aufgabe mit der <xref:System.Web.UI.PageAsyncTask> Klasse. Nachdem die Aufgabe definiert ist und für die Seite, indem registriert ist die <xref:System.Web.UI.Page.RegisterAsyncTask%2A> -Methode, die <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Methode kann aufgerufen werden, um die asynchrone Aufgabe zu starten.  
  
 Die <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Methode wird automatisch aufgerufen, an dem Punkt in der Verarbeitung der Seite ", wenn alle asynchronen Vorgänge registriert, wenn sie vorhanden sind, werden für eine Seite nicht asynchron aufgerufen. Diese automatischen Aufruf von <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> tritt direkt vor der <xref:System.Web.UI.Page.PreRenderComplete> Ereignis. Rufen Sie die <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Methode für Aufgaben, die Zeiten als den automatischen Aufruf dieser Methode aufgerufen werden soll. Beachten Sie, dass asynchrone Vorgänge werden nur einmal, obwohl ausgeführt <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> möglicherweise mehr als einmal aufgerufen werden.  
  
 Die <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft wird bei jedem Aufruf von Zurücksetzen der <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Methode. Der letzte Wert der <xref:System.Web.UI.Page.AsyncTimeout%2A> vor dem Aufrufen der <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Methode hat Vorrang vor. Wenn eine asynchrone Aufgabe nimmt mehr als die <xref:System.Web.UI.Page.AsyncTimeout%2A>, nachfolgenden Tasks aufgerufen, die während der <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Aufruf sofort Timeout.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft mit dem <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> und <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Methoden. Beachten Sie die Verwendung der Start-, End- und Timeout-Handler. Im Beispiel eine künstliche Verzögerung zur Veranschaulichung der Situation einer asynchronen Aufgabe, die für den Task entsprechend den Angaben in die vorgesehenen Zeit überschreitet, wird die <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft. In einem realen Szenario konnte eine asynchrone Aufgabe auszuführenden Datenbankaufrufe oder imagegenerierung, z. B. und dienen der Timeouthandler stellt maßvolle Leistungseinbußen, wenn die Aufgabe in einem angegebenen Zeitraum nicht ausgeführt wird.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Es ist eine Ausnahme in der asynchronen Aufgabe.</exception>
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt ein Array von Dateien, die das aktuelle <see cref="T:System.Web.HttpResponse" /> Objekt abhängig ist.</summary>
        <value>Das Array von Dateien, die das aktuelle <see cref="T:System.Web.HttpResponse" /> Objekt abhängig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist veraltet. Verwenden der <xref:System.Web.HttpResponse.AddFileDependencies%2A> Methode oder die <xref:System.Web.HttpResponse.AddFileDependency%2A> Methode der <xref:System.Web.HttpResponse> stattdessen.  
  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `FileDependencies` -Attribut `true` mit der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Der Bezeichner für das Steuerelement gefunden werden.</param>
        <summary>Durchsucht die Seite Benennungscontainer nach einem Serversteuerelement mit dem angegebenen Bezeichner.</summary>
        <returns>Das angegebene Steuerelement oder <see langword="null" /> ist das angegebene Steuerelement ist nicht vorhanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.FindControl%2A> Methode kann verwendet werden, um ein Steuerelement zuzugreifen, dessen <xref:System.Web.UI.Control.ID%2A> zur Entwurfszeit nicht verfügbar ist. Die Methode sucht nur die Seite sofort oder auf der obersten Ebene, Container. Es ist nicht rekursiv nach Steuerelementen in Benennen von Containern enthalten, die auf der Seite. Um Steuerelemente in einem untergeordneten Benennungscontainer zuzugreifen, rufen die `FindControl` Methode des Containers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.Page.FindControl%2A> Methode zum Suchen von Steuerelementen in Vorlagen. In diesem Beispiel zwei <xref:System.Web.UI.WebControls.Repeater> Steuerelemente definiert sind; jedes zeigt eine andere Möglichkeit zum Abfangen der <xref:System.Web.UI.WebControls.LinkButton.Click> -Ereignis für eine <xref:System.Web.UI.WebControls.LinkButton> innerhalb der Repeater-Elementvorlage.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das HTML-Formular für die Seite ab.</summary>
        <value>Die <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> Objekt, das mit der Seite zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.Form%2A> Eigenschaft Zugriff auf die Methoden und Eigenschaften der <xref:System.Web.UI.HtmlControls.HtmlForm> -Objekt, das die Basis der Steuerelementhierarchie auf der Seite ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert die Struktur des Steuerelements während der Generierung von Seite basierend auf den deklarative Charakter der Seite an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.FrameworkInitialize%2A> Methode initialisiert die <xref:System.Web.UI.Page> Objekt, und die Struktur des Steuerelements basierend auf den deklarative Charakter der Seite "erstellt. Die <xref:System.Web.UI.Page.FrameworkInitialize%2A> Methode wird überschrieben, indem Sie die Seite analysieren und die codegenerierung für die <xref:System.Web.UI.Page> Klasse für eine deklarative Seite. Normalerweise ist es nicht erforderlich, diese Methode überschreiben. Wenn außer Kraft gesetzt, werden der Basisklasse aufrufen <xref:System.Web.UI.Page.FrameworkInitialize%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das Datenelement am oberen Rand dem Datenbindung Kontextstapel ab.</summary>
        <returns>Das Objekt am Anfang des bindungsstapels Kontext Daten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Es ist kein Kontext die Datenbindung für die Seite.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das das Postback zum Clientereignis empfängt.</param>
        <param name="argument">Eine <see cref="T:System.String" />, die an <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" /> übergeben wird.</param>
        <summary>Ruft einen Verweis ab, der in einem Clientereignis für Postbacks an den Server für das angegebene Steuerelement und mit den angegebenen Ereignisargumenten verwendet kann.</summary>
        <returns>Die Zeichenfolge, die das Clientereignis darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter der <xref:System.Web.UI.ClientScriptManager> Alternativen zu dieser veralteten Member-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das Postback verarbeitet werden soll.</param>
        <param name="argument">Der Parameter übergeben, der dem Serversteuerelement.</param>
        <summary>Ruft einen Verweis mit <see langword="javascript:" /> am Anfang davon aus, die in einem Clientereignis zum Zurücksenden an den Server für das angegebene Steuerelement und mit der angegebenen Argumente verwendet werden kann.</summary>
        <returns>Eine Zeichenfolge, die einen JavaScript-Aufruf an die postback-Funktion, die das Zielsteuerelement-ID und der Ereignisargumente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter der <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> Methode für eine Alternative zu diesem veralteten Member.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das Postback auf dem Server verarbeitet werden soll.</param>
        <summary>Gibt eine Zeichenfolge, die verwendet werden kann in einem Clientereignis, um Postback an den Server zurück. Die Verweiszeichenfolge wird definiert durch das angegebene <see cref="T:System.Web.UI.Control" /> Objekt.</summary>
        <returns>Eine Zeichenfolge, die als Skript auf dem Client behandelt das Postback initiiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> stattdessen.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das Postback verarbeitet werden soll.</param>
        <param name="argument">Der Parameter übergeben, der dem Serversteuerelement.</param>
        <summary>Gibt eine Zeichenfolge, die verwendet werden kann in einem Clientereignis, um Postback an den Server zurück. Die Verweiszeichenfolge wird durch das angegebene Steuerelement definiert, die das Postback und ein Zeichenfolgenargument an zusätzliche Ereignisinformationen behandelt.</summary>
        <returns>Eine Zeichenfolge, die als Skript auf dem Client behandelt das Postback initiiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> stattdessen.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode, der vom generierten <see cref="T:System.Web.UI.Page" /> Objekten, die generiert werden, zur Laufzeit. Dieser Hash wird nur für die <see cref="T:System.Web.UI.Page" /> Steuerelementhierarchie des Objekts.</summary>
        <returns>Der Hashcode, der zur Laufzeit generiert wird. Der Standard ist 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Der Validierungsgruppe zurückgegeben oder <see langword="null" /> zurückzugebenden die Standardgruppe für die Überprüfung.</param>
        <summary>Gibt eine Auflistung von Steuerelement-Validierungssteuerelementen für eine der angegebenen Validierungsgruppe zurück.</summary>
        <returns>Ein <see cref="T:System.Web.UI.ValidatorCollection" /> , die Validierungssteuerelemente Steuerelement für die angegebene Validierungsgruppe enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.GetValidators%2A> Methodenrückgabe alle Überprüfung-Objekte, die eine bestimmte Gruppe zugeordnet. Sie können die Standardgruppe für die Validierung zurückgeben (alle Validierungssteuerelemente Steuerelemente ohne zugeordnete der `ValidationGroup` Eigenschaftensatz) durch Festlegen der `validationGroup` Parameter `null`.  
  
 Um die Mitglieder der Gruppe "Überprüfung" zu überprüfen, Sie können Aufzählen von Daten für die Sammlung, und rufen die <xref:System.Web.UI.IValidator.Validate%2A> jeder Bestätigung von der Methode zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.GetValidators%2A> Methode, um die Überprüfung Standardgruppe zurückzugeben.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Ein Zeichenfolgenarray virtueller Speicherorte.</param>
        <summary>Gibt eine Liste der physischen Dateinamen entsprechen, die auf eine Liste von virtuellen Dateispeicherorte zurück.</summary>
        <returns>Ein Objekt, das eine Liste der physischen Speicherorte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> Methode ruft eine Liste der Dateien, z. B. Benutzersteuerelement-Dateien, aus denen die aktuelle Seite besteht. Wenn eine dieser Seiten geändert werden, wird die gesamte Seite das nächste Mal kompiliert, wenn, das es angefordert wird. Überschreiben Sie diese Methode nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Dokument-Header für die Seite ab, wenn die <see langword="head" /> Element definiert ist, mit einem <see langword="runat=server" /> in der Seitendeklaration.</summary>
        <value>Ein <see cref="T:System.Web.UI.HtmlControls.HtmlHead" /> , das den Seitenkopf enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.Header%2A> -Eigenschaft ruft einen Verweis auf ein <xref:System.Web.UI.HtmlControls.HtmlHead> Objekt, mit der Dokument-Headerinformationen für die Seite festgelegt werden können. Die <xref:System.Web.UI.HtmlControls.HtmlHead> können Sie Informationen wie z. B. Stylesheets, Stilregeln, einen Titel und Metadaten zum Hinzufügen der `head` Element.  
  
> [!NOTE]
>  Hinzufügen von Stilen programmgesteuert mithilfe der Methoden von der <xref:System.Web.UI.IStyleSheet> Schnittstelle bei asynchronen Postbacks wird nicht unterstützt. Wenn Sie die AJAX-Funktionen zu einer Webseite hinzufügen, aktualisieren asynchrone Postbacks Bereiche der Seite, ohne die ganze Seite zu aktualisieren. Weitere Informationen finden Sie unter [Microsoft Ajax-Übersicht](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Zugriff auf die <xref:System.Web.UI.HtmlControls.HtmlHead> steuern, programmgesteuert mithilfe der <xref:System.Web.UI.Page.Header%2A> Eigenschaft. Ein `title` Element und `style` Element hinzugefügt werden die `head` -Element der Seite.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Bezeichner für eine bestimmte Instanz der <see cref="T:System.Web.UI.Page" /> Klasse.</summary>
        <value>Der Bezeichner für die Instanz von der <see cref="T:System.Web.UI.Page" /> Klasse. Der Standardwert ist '_Page'.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zeichen verwendet, um das Steuerelement-IDs zu trennen, wenn Sie eine eindeutige ID für ein Steuerelement auf einer Seite zu erstellen.</summary>
        <value>Das Zeichen zum Trennen der Steuerelement-IDs verwendet. Die Standardeinstellung wird festgelegt, indem die <see cref="T:System.Web.UI.Adapters.PageAdapter" /> -Instanz, die die Seite rendert. Die <see cref="P:System.Web.UI.Page.IdSeparator" /> ist ein Feld für die serverseitige und sollte nicht geändert werden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, sobald die seiteninitialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.InitComplete> Ereignis wird am Ende der Seite Initialisierungsphase aufgerufen. In dieser Phase des Lebenszyklus der Seite alle deklarierten Steuerelemente auf der Seite werden initialisiert, aber die Seite Status ist noch nicht aufgefüllt. Sie können Steuerelemente zugreifen, aber nicht noch enthalten sie Informationen, die vom Benutzer zurückgegeben.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [NIB: Behandeln von Ereignissen](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die <see cref="P:System.Web.UI.Page.Culture" /> und <see cref="P:System.Web.UI.Page.UICulture" /> für den aktuellen Thread der Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.InitializeCulture%2A> Methode enthält keine Logik Schreiben von Code. Steuerelemententwickler Erweitern der Funktionalität eines der <xref:System.Web.UI.Page> -Klasse überschreiben die <xref:System.Web.UI.Page.InitializeCulture%2A> Methode zum Initialisieren der <xref:System.Web.UI.Page.Culture%2A> und <xref:System.Web.UI.Page.UICulture%2A> Informationen für die Seite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert den Ausgabecache für die aktuelle Seitenanforderung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht für die direkte Verwendung im Code vorgesehen. Zum Aktivieren und Zwischenspeichern der Ausgabe für eine Seite zu bearbeiten, verwenden Sie einen der folgenden Ansätze:  
  
-   Legen Sie Optionen deklarativ in der ASPX-Datei mit der Direktive.  
  
-   Verwenden Sie die Methoden und Eigenschaften der <xref:System.Web.HttpCachePolicy> -Klasse, die von verfügbar gemacht wird die `Response.Cache` Objekt im Code der Seite.  
  
 Weitere Informationen finden Sie unter [Zwischenspeichern von ASP.NET-Seiten](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">Ein <see cref="T:System.Web.UI.OutputCacheParameters" /> , das die cacheeinstellungen enthält.</param>
        <summary>Initialisiert des Ausgabecaches für die aktuelle Seitenanforderung anhand ein <see cref="T:System.Web.UI.OutputCacheParameters" /> Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode nicht aufrufen. Zum Aktivieren und Zwischenspeichern der Ausgabe für eine Seite zu bearbeiten, verwenden Sie entweder die Direktive in der ASPX-Datei oder die Methoden und Eigenschaften der der <xref:System.Web.HttpCachePolicy> Klasse. Letztere werden über `Response.Cache` Syntax in der Seite Code Deklaration Block oder Code-Behind-Datei. Weitere Informationen finden Sie unter [Zwischenspeichern von ASP.NET-Seiten](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das Cacheprofil wurde nicht gefunden.  
  
 \- oder –  
  
 Profil für einen fehlenden Richtlinie oder Konfigurationseinstellungen Attribut erstellt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Speicherort des Ausgabecaches Einstellungen ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Die Zeitspanne, die Objekte im Ausgabecache gespeichert gültig sind.</param>
        <param name="varyByHeader">Eine durch Semikolons getrennte Liste von Headern, die aus dem Ausgabecache Inhalte variieren je nach.</param>
        <param name="varyByCustom">Die <see langword="Vary" /> HTTP-Header.</param>
        <param name="location">Einer der <see cref="T:System.Web.UI.OutputCacheLocation" />-Werte.</param>
        <param name="varyByParam">Eine durch Semikolons getrennte Liste von Parametern, die durch eine Get- oder POST-Methode, der von Inhalt aus dem Ausgabecache variiert wird empfangen.</param>
        <summary>Initialisiert den Ausgabecache für die aktuelle Seitenanforderung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode nicht aufrufen. Zum Aktivieren und Zwischenspeichern der Ausgabe für eine Seite zu bearbeiten, verwenden Sie entweder die Direktive in der ASPX-Datei oder die Methoden und Eigenschaften der der <xref:System.Web.HttpCachePolicy> Klasse. Letztere werden über `Response.Cache` Syntax im Code der Seite. Weitere Informationen finden Sie unter [Zwischenspeichern von ASP.NET-Seiten](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein ungültiger Wert angegeben wird, für die <paramref name="location" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Die Zeitspanne, die Objekte im Ausgabecache gespeichert gültig sind.</param>
        <param name="varyByContentEncoding">Eine durch Semikolons getrennte Liste von Zeichensätzen (inhaltscodierungen), die aus dem Ausgabecache Inhalte variieren je nach.</param>
        <param name="varyByHeader">Eine durch Semikolons getrennte Liste von Headern, die aus dem Ausgabecache Inhalte variieren je nach.</param>
        <param name="varyByCustom">Die <see langword="Vary" /> HTTP-Header.</param>
        <param name="location">Einer der <see cref="T:System.Web.UI.OutputCacheLocation" />-Werte.</param>
        <param name="varyByParam">Eine durch Semikolons getrennte Liste von Parametern, die durch eine Get- oder POST-Methode, der von Inhalt aus dem Ausgabecache variiert wird empfangen.</param>
        <summary>Initialisiert den Ausgabecache für die aktuelle Seitenanforderung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode nicht aufrufen. Zum Aktivieren und Zwischenspeichern der Ausgabe für eine Seite zu bearbeiten, verwenden Sie entweder die Richtlinie in der ASPX-Datei, oder Methoden und Eigenschaften von der <xref:System.Web.HttpCachePolicy> Klasse. Letztere werden über `Response.Cache` Syntax im Code der Seite. Weitere Informationen finden Sie unter [Zwischenspeichern von ASP.NET-Seiten](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein ungültiger Wert angegeben wird, für die <paramref name="location" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Seite asynchron verarbeitet wird.</summary>
        <value>
          <see langword="true" />Wenn die Seite im asynchronen Modus ausgeführt wird; andernfalls <see langword="false" />;</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.IsAsync%2A> Eigenschaft, um zu bestimmen, ob die Webseite im asynchronen Modus ausgeführt wird. Diese Informationen sind hilfreich, wenn Steuerelemente oder Code auf der Seite zum Ändern des Verhaltens, je nachdem, ob die Seite asynchrone benötigen. Weitere Informationen zur asynchronen Programmierung finden Sie unter [asynchrone Vorgänge](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Seitenanforderung das Ergebnis eines Rückrufs ist.</summary>
        <value>
          <see langword="true" />Wenn die Seitenanforderung das Ergebnis eines Rückrufs; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Implementing Client Rückrufe ohne Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Clientskripts.</param>
        <summary>Bestimmt, ob das den Clientskriptblock mit dem angegebenen Schlüssel mit der Seite registriert ist.</summary>
        <returns>
          <see langword="true" />Wenn der Skriptblock registriert ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> vermeiden unnötiges Assemblieren der Skriptdatei auf Clientseite. Dies ist besonders wichtig, wenn das Skript eine große Menge an Serverressourcen zum Erstellen erforderlich ist.  
  
 Die <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> Methode in Verbindung mit der <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> Methode. Wenn in der Deklaration Codeblock geschriebene ECMAScript noch nicht registriert wurde, wie durch die bestimmt, <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, und klicken Sie dann eine <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Seite ein Postback seitenübergreifend einbezogen ist.</summary>
        <value>
          <see langword="true" />Wenn die Seite in einer Anforderung Cross-Seite ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET verfügt über zwei Mechanismen zur Steuerung von einer Seite zu einem anderen übertragen. Können Sie die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode zum Übertragen von Verarbeitung zwischen Seiten, oder Sie können anfordern seitenübergreifend durch Zuweisen einer Seiten-URL der <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> Eigenschaft des einem Schaltflächen-Steuerelement, das implementiert die <xref:System.Web.UI.WebControls.IButtonControl> Schnittstelle.  
  
 In beiden Fällen die <xref:System.Web.UI.Page.PreviousPage%2A> (Eigenschaft) enthält ein Objekt, das die vorherige oder Absender Seite darstellt. Wenn Sie z. B. Page A an Seite B, A Page zurückgesendet <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> Eigenschaft (über die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft) werden `true` und Seite-B <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft müssen den Namen des Page A.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Seite zum ersten Mal gerendert wird oder als Antwort auf ein Postback geladen wird.</summary>
        <value>
          <see langword="true" />Wenn die Seite als Antwort auf ein Postback des Clients geladen wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Erläuterung des Unterschieds zwischen Postbacks und Rückrufe, finden Sie unter [Implementing Client Rückrufe ohne Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Testen des Werts der <xref:System.Web.UI.Page.IsPostBack%2A> Eigenschaft, wenn die Seite geladen wird, um festzustellen, ob die Seite zum ersten Mal gerendert wird oder auf ein Postback reagiert wird. Wenn die Seite zum ersten Mal gerendert wird, ruft der Code die <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> Methode.  
  
 Enthält die Seitenmarkup (nicht dargestellt) <xref:System.Web.UI.WebControls.RequiredFieldValidator> Steuerelemente zur Anzeige von Sternchen, wenn kein Eintrag für ein Pflichtfeld Eingabe erfolgt. Aufrufen von <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> bewirkt, dass das Sternchen angezeigt werden, sofort anstatt zu warten, bis der Benutzer die Schaltfläche "Absenden" klickt, wenn die Seite gerendert wird. Nach einem Postback Sie keine Aufrufen <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, da diese Methode, als Teil aufgerufen wird der <xref:System.Web.UI.Page> Lebenszyklus.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob das Steuerelement auf der Seite, die von der Postbacks registriert wurde.</summary>
        <value>
          <see langword="true" />Wenn das Steuerelement besitzt wurde registriert. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die <see cref="T:System.Web.UI.Page" /> Objekt wiederverwendet werden kann.</summary>
        <value>
          <see langword="false" /> in allen Fällen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Startskripts.</param>
        <summary>Bestimmt, ob der Clientstartskript registriert wird die <see cref="T:System.Web.UI.Page" /> Objekt.</summary>
        <returns>
          <see langword="true" />Wenn das Startskript registriert ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> vermeiden unnötiges Assemblieren der Skriptdatei auf Clientseite. Dies ist besonders wichtig, wenn das Skript eine große Menge an Serverressourcen zum Erstellen erforderlich ist.  
  
 Die <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.RegisterStartupScript%2A> Methode in Verbindung mit der <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> Methode. Wenn in der Deklaration Codeblock geschriebene ECMAScript noch nicht registriert wurde, wie durch die bestimmt, <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, und klicken Sie dann eine <xref:System.Web.UI.Page.RegisterStartupScript%2A> aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Validierung erfolgreich war.</summary>
        <value>
          <see langword="true" />Bei erfolgreicher Überprüfung der Seite " andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für diese Eigenschaft zurückzugebenden `true`, alle Server Validierungssteuerelemente in der aktuellen Validierungsgruppe müssen erfolgreich überprüft wurde. Nur, nachdem Sie aufgerufen haben, überprüfen Sie diese Eigenschaft sollte die <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> -Methode oder eine Gruppe die `CausesValidation` Eigenschaft `true` in der `OnServerClick` -Ereignishandler für ein ASP.NET-Serversteuerelement, der die Form Verarbeitung initiiert. Diese Steuerelemente umfassen die <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, und <xref:System.Web.UI.WebControls.LinkButton> Klassen.  
  
 Wenn Sie erzwingen, dass die Überprüfung einer Überprüfung mit der <xref:System.Web.UI.Page.Validate%2A> -Methode, und klicken Sie dann auf alle Validierungssteuerelemente in der angegebenen Validierungsgruppe müssen ebenfalls erfolgreich überprüft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.Page.IsValid%2A> Eigenschaft zum Einrichten einer bedingten Anweisung. Wenn die Eigenschaft zurückgibt `true`, `Text` Eigenschaft von der `lblOutput` Steuerelement auf "gilt Seite!" festgelegt ist Legen Sie andernfalls ist es auf "sind einige der erforderlichen Felder leer."  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see cref="P:System.Web.UI.Page.IsValid" /> Eigenschaft wird aufgerufen, bevor der Validierung aufgetreten ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste von Objekten, die im Seitenkontext gespeichert.</summary>
        <value>Ein Verweis auf eine <see cref="T:System.Collections.IDictionary" /> , die im Seitenkontext gespeicherten Objekte enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.Items%2A> Eigenschaft zum Speichern von Objekten mit der gleichen Lebensdauer als der Seitenanforderung. Diese Eigenschaft ist schreibgeschützt. Sie können jedoch Objekte zum Hinzufügen der <xref:System.Collections.IDictionary> -Objekt wird zurückgegeben.  
  
 Hinzugefügte Objekte die <xref:System.Web.UI.Page.Items%2A> Eigenschaft während der gesamten Lebensdauer der Seite verfügbar sind, damit Sie Objekte hinzufügen können die <xref:System.Web.UI.Page.Items%2A> Eigenschaft in den Ereignissen früh in der Lebensdauer der Seite der Reihe nach und den Zugriff auf diese Objekte höher Ereignisse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Gebietsschemabezeichner für die <see cref="T:System.Threading.Thread" /> Objekt, das mit der Seite zugeordnet.</summary>
        <value>Der Gebietsschemabezeichner für die Übergabe an die <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Die `LCID` Attribut kann in der Direktive der ASPX-Datei festgelegt werden, allerdings ist die bevorzugte Methode zum Festlegen der Gebietsschema-ID mithilfe des der <xref:System.Web.UI.Page.Culture%2A> und <xref:System.Web.UI.Page.UICulture%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt am Ende der Ladephase der Lebenszyklus der Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.LoadComplete> Ereignis tritt auf, nachdem alle Postbackdaten und Ansichtszustand Daten werden geladen, in die Seite und nach der <xref:System.Web.UI.Control.OnLoad%2A> -Methode für alle Steuerelemente auf der Seite aufgerufen wurde.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [NIB: Behandeln von Ereignissen](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lädt alle gespeicherten Ansichtszustand Informationen zu den <see cref="T:System.Web.UI.Page" /> Objekt.</summary>
        <returns>Der gespeicherte Ansichtszustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> -Methode verwendet die <xref:System.Web.UI.PageStatePersister.Load%2A> Methode der <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> Objekt verweist die <xref:System.Web.UI.Page.PageStatePersister%2A> Ansichtszustandsinformationen für die Eigenschaft zu laden gespeichert die <xref:System.Web.UI.Page> Objekt.  
  
 ASP.NET umfasst zwei Nachfolger des der <xref:System.Web.UI.PageStatePersister> -Klasse, die <xref:System.Web.UI.HiddenFieldPageStatePersister> -Klasse, die Zustandsinformationen in einem ausgeblendeten Feld auf der ASP.NET-Seite speichert und die <xref:System.Web.UI.SessionPageStatePersister> -Klasse, die den Zustand im speichert die <xref:System.Web.UI.Page.Session%2A> Objekt zugeordnet der Anforderung.  
  
 Um den Zustand in den Speicherort Ihrer Wahl zu speichern, erstellen Sie eine neue untergeordnete der <xref:System.Web.UI.PageStatePersister> -Klasse, speichert und lädt den Zustand auf dem Dauerhaftigkeitsmedium Ihrer Wahl. Ein Beispiel für die Erstellung einer neuen <xref:System.Web.UI.PageStatePersister> Objekt, finden Sie unter der <xref:System.Web.UI.PageStatePersister> Klasse.  
  
 Bei Verwendung von .NET Framework, Version 1.0 oder 1.1, die diese Methode überschreiben, wenn Sie laden möchten die <xref:System.Web.UI.Page> Zustand etwas anderes als ein ausgeblendetes Feld. Wenn Sie dies auswählen, müssen Sie auch überschreiben die <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der anzeigt, ob der Benutzer nach dem Postback im Clientbrowser an dieselbe Position zurückkehren soll. Diese Eigenschaft ersetzt die veraltete <see cref="P:System.Web.UI.Page.SmartNavigation" /> Eigenschaft.</summary>
        <value>
          <see langword="true" />Wenn die Clientposition beibehalten werden soll; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Webseiten an den Server zurückgesendet werden, wird der Benutzer am oberen Rand der Seite "zurückgegeben. Bei umfangreichen Webseiten bedeutet dies, dass der Benutzer hat die Seite an die letzte Position auf der Seite einen Bildlauf durchführen.  
  
 Wenn die <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> -Eigenschaftensatz auf `true`, der Benutzer wird stattdessen zurückgegeben bis zum letzten Position auf der Seite.  
  
 Sie legen die <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> Eigenschaft in der [@ Page](http://msdn.microsoft.com/en-us/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) Richtlinie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ein <see cref="T:System.String" /> , die den virtuellen Pfad darstellt.</param>
        <summary>Ruft den physischen Pfad, dem ein virtueller Pfad absolut oder relativ ist, oder ein relativer Pfad zugeordnet wird.</summary>
        <returns>Der physische Pfad, der den virtuellen Pfad oder ein relativer Pfad zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Die <xref:System.Web.UI.Page.MapPath%2A> Eigenschaft kann potenziell vertrauliche Informationen über die hostumgebung enthalten. Der Rückgabewert sollte nicht für Benutzer angezeigt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.UI.Page.MapPath%2A> Methode, um den physischen Pfad der Unterordner abzurufen. Anschließend fügt der Dateiname, der gelesen wird die <xref:System.Web.UI.WebControls.TextBox.Text%2A> Eigenschaft ein <xref:System.Web.UI.WebControls.TextBox> Steuerelement. Das Ergebnis ist der absolute physische Pfad zu der Datei.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gestaltungsvorlage, die bestimmt, die allgemeine Darstellung der Seite ab.</summary>
        <value>Die <see cref="T:System.Web.UI.MasterPage" /> dieser Seite ggf. zugeordnet ist, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.Master%2A> -Eigenschaft gibt die <xref:System.Web.UI.MasterPage> Objekt, das mit dieser Seite zugeordnet. Diese Eigenschaft ist schreibgeschützt. Sie können jedoch Eigenschaften festlegen, auf die <xref:System.Web.UI.MasterPage> -Objekt wird zurückgegeben.  
  
 Die <xref:System.Web.UI.Page.Master%2A> Eigenschaft gilt nur für Seiten, die auf eine Masterseite in verweisen die <xref:System.Web.UI.Page.MasterPageFile%2A> Eigenschaft. Wenn Sie Zugriff auf die <xref:System.Web.UI.Page.Master%2A> Eigenschaft auf einer Seite, die nicht auf eine Masterseite verweist `null` zurückgegeben wird. Der Inhalt einer Masterseite sind nicht erst verfügbar, nachdem die <xref:System.Web.UI.Page.PreInit> Ereignis ausgelöst wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den virtuellen Pfad der Masterseite.</summary>
        <value>Der virtuelle Pfad der Masterseite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.MasterPageFile%2A> Eigenschaft ist ein virtueller Pfad (ausgehend vom Stamm der Anwendung), der die Masterseite-Datei, die auf dieser Seite zugeordnet. Die <xref:System.Web.UI.Page.MasterPageFile%2A> Eigenschaft kann festgelegt werden, nur in der <xref:System.Web.UI.Page.PreInit> Ereignis; beim Festlegen der <xref:System.Web.UI.Page.MasterPageFile%2A> Eigenschaft nach der <xref:System.Web.UI.Page.PreInit> Ereignis wird ausgelöst ein <xref:System.InvalidOperationException> Ausnahme. Wenn die <xref:System.Web.UI.Page.MasterPageFile%2A> Eigenschaft ist nicht gültig ist, eine Ausnahme vom Typ <xref:System.Web.HttpException> später im Lebenszyklus Seite ausgelöst wird, aber es wird keine Ausnahme ausgelöst, wenn die Eigenschaft, in festgelegt wird der <xref:System.Web.UI.Page.PreInit> Ereignis.  
  
 Seiten, die über die <xref:System.Web.UI.Page.MasterPageFile%2A> Eigenschaftensatz Inhaltsseiten sind und daher dürfen nur auf oberster Ebene Steuerelemente, die <xref:System.Web.UI.WebControls.Content> Steuerelemente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Web.UI.Page.MasterPageFile" /> Eigenschaft wird festgelegt, nachdem die <see cref="E:System.Web.UI.Page.PreInit" /> Ereignis ist abgeschlossen.</exception>
        <exception cref="T:System.Web.HttpException">Die angegebene Datei der <see cref="P:System.Web.UI.Page.MasterPageFile" /> Eigenschaft ist nicht vorhanden.  
  
 \- oder –  
  
 Die Seite verfügt nicht über eine <see cref="T:System.Web.UI.WebControls.Content" /> Steuerelement als Steuerelement der obersten Ebene.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die maximale Länge für den Anzeigezustand der Seite Statusfeld.</summary>
        <value>Die maximale Länge in Bytes, der für die Seite Statusfeld. Der Standard ist -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> Eigenschaft in eine positive Zahl festgelegt ist, der Ansichtszustand, der an den Clientbrowser gesendet wird in mehrere ausgeblendete Felder aufgeteilt und jedes Feld Wert ist kleiner als die Größe, die im angegebenen die <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> Eigenschaft.  
  
 Festlegen der <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> Eigenschaft auf eine negative Zahl (Standard) gibt an, dass das Feld Ansichtszustand nicht sollte, in Blöcke unterteilt getrennt werden. Festlegen der <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> auf eine kleine Zahl kann zu schlechter Leistung führen.  
  
 Legen Sie den Wert, der die <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> Eigenschaft in der die Datei "Web.config".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> Eigenschaft ist nicht gleich-1 oder eine positive Zahl.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> -Eigenschaft wurde festgelegt, nachdem die Seite initialisiert wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Inhalt der "Description" <see langword="meta" /> Element.</summary>
        <value>Der Inhalt der "Description" <see langword="meta" /> Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` -Elemente können verwendet werden, um Suchmaschinen zu verbessern. Der "Description" `meta` Element wird von einigen Suchmaschinen zum Angebot Previews zu verbessern.  
  
 Wenn es ist keine "Beschreibung" `meta` Element in der `head` Element im Markup Seite, die `meta` Element wird auf der Seite hinzugefügt, wenn die Seite gerendert wird. Wenn Markup der Seite bereits eine "Beschreibung" `meta` Element, diese Eigenschaft ruft ab oder legt ihn fest der `content` Attribut von der `meta` Element.  
  
 Sie können diese Eigenschaft auch in der Direktive festlegen.  
  
   
  
## Examples  
 Wenn Sie festlegen, die <xref:System.Web.UI.Page.MetaDescription%2A> Eigenschaft einer Seite "Übersicht über ASP.NET", erscheint das folgende Element im gerenderten HTML-Code:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Seite verfügt nicht über einem Headersteuerelement (eine <see langword="head" /> Element mit der <see langword="runat" /> -Attributsatz zur "Server").</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Inhalt der "Schlüsselwörter" <see langword="meta" /> Element.</summary>
        <value>Der Inhalt der "Schlüsselwörter" <see langword="meta" /> Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` -Elemente können verwendet werden, um Suchmaschinen zu verbessern. Die "Schlüsselwörter" `meta` Element ist entweder überhaupt nicht verwendet werden oder kaum Gewichtung von der wichtigsten Suchmaschinen erhält.  
  
 Es ist keine "Schlüsselwörter" `meta` Element in der `head` Element im Markup Seite, die `meta` Element wird auf der Seite hinzugefügt, wenn die Seite gerendert wird. Wenn Markup der Seite bereits eine "Schlüsselwörter" `meta` Element, diese Eigenschaft ruft ab oder legt ihn fest der `content` Attribut von der `meta` Element.  
  
 Sie können diese Eigenschaft auch in der Direktive festlegen.  
  
   
  
## Examples  
 Wenn Sie festlegen, die <xref:System.Web.UI.Page.MetaKeywords%2A> Eigenschaft einer Seite auf "HTML, CSS, XML, JavaScript", erscheint das folgende Element im gerenderten HTML-Code:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Seite verfügt nicht über einem Headersteuerelement (eine <see langword="head" /> Element mit der <see langword="runat" /> -Attributsatz zur "Server").</exception>
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, der modellbindungs-Ausführungskontext.</summary>
        <value>Der modellbindungs-Ausführungskontext. Ist der modellbindungs-Ausführungskontext <see langword="null" />, ein neuer Schlüssel erstellt und zurückgegeben wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modell Zustand Dictionary-Objekt, das den Zustand des Modells und der modellbindungs-Validierung enthält.</summary>
        <value>Das Modell Zustand Dictionary-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Control.Init" /> Ereignis, um die Seite zu initialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnInit%2A> -Methode führt die Initialisierung und Setup erforderlichen Schritte zum Erstellen einer <xref:System.Web.UI.Page> Instanz. In dieser Phase des Lebenszyklus der Seite werden die deklarierten Serversteuerelemente auf der Seite auf ihren Standardzustand zurückgesetzt initialisiert; der Ansichtszustand für jedes Steuerelement ist jedoch noch nicht aufgefüllt. Ein Steuerelement auf der Seite kann nicht zugegriffen andere Serversteuerelemente auf der Seite während der `Page_Init` Phase, unabhängig davon, ob die anderen Steuerelemente untergeordnete oder übergeordnete Steuerelemente sind. Andere Steuerelemente sind nicht unbedingt erstellt und für den Zugriff bereit.  
  
 Die <xref:System.Web.UI.Page.OnInit%2A> Methode wird aufgerufen, nachdem die <xref:System.Web.UI.Page.OnPreInit%2A> Methode und vor der <xref:System.Web.UI.Page.OnInitComplete%2A> Methode.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Web.UI.Page.OnInit%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Page.InitComplete" /> Ereignis nach der seiteninitialisierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnInitComplete%2A> Methode wird aufgerufen, nachdem die seiteninitialisierung abgeschlossen ist. In dieser Phase des Lebenszyklus der Seite alle deklarierten Steuerelemente auf der Seite werden initialisiert, aber Anzeigezustand der Seite wird noch nicht aufgefüllt. Sie können Steuerelemente zugreifen, aber nicht noch enthalten sie Informationen, die vom Benutzer zurückgegeben.  
  
 Die <xref:System.Web.UI.Page.OnInitComplete%2A> Methode tritt am Ende der <xref:System.Web.UI.Page> Initialisierungsphase und vor der Ladephase.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Web.UI.Page.OnInitComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Page.LoadComplete" /> Ereignis am Ende der Ladephase der Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnLoadComplete%2A> Methode am Ende der Ladephase der Seite aufgerufen wird. Zu diesem Zeitpunkt im Lebenszyklus Seite alle Postbackdaten und Ansichtszustandsdaten wird geladen Steuerelemente auf der Seite.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [NIB: durch das Auslösen eines Ereignisses](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 Mit der <xref:System.Web.UI.Page.OnLoadComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Page.PreInit" /> Ereignis am Anfang der seiteninitialisierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnPreInit%2A> Methode am Anfang des Initialisierungsphase der Seite aufgerufen wird.  
  
 Nach der <xref:System.Web.UI.Page.OnPreInit%2A> Methode wird aufgerufen, Personalisierungsinformationen geladen, und Seitendesigns, sofern vorhanden, wird initialisiert. Dies ist auch die bevorzugte Phase dynamisch definieren eine <xref:System.Web.UI.PageTheme> oder <xref:System.Web.UI.MasterPage> für die Seite.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Web.UI.Page.OnPreInit%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Page.PreLoad" /> Ereignis nach Postbackdaten in die Steuerelemente für die Server, jedoch bevor geladen werden die <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnPreLoad%2A> Methode wird aufgerufen, nachdem alle vom Benutzer zurückgegebene Postbackdaten geladen werden. In dieser Phase im Lebenszyklus der Seite deklariert Ansichtszustandsinformationen und Postbackdaten für Steuerelemente und Steuerelemente, die während der Initialisierungsphase erstellt, in die Steuerelemente der Seite geladen werden.  
  
 Steuerelemente, die erstellt werden, der <xref:System.Web.UI.Page.OnPreLoad%2A> Methode wird auch mit Ansichtszustand und Postbacks Daten geladen werden.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Web.UI.Page.OnPreLoad%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Page.PreRenderComplete" /> Ereignis nach der <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> Ereignis und bevor die Seite gerendert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnPreRenderComplete%2A> Methode wird aufgerufen, wenn es sich bei die Wiedergabe Phase des Lebenszyklus der Seite abgeschlossen ist. In dieser Phase des Lebenszyklus der Seite alle Steuerelemente erstellt, und die Seite ist bereit, um die Ausgabe zu rendern.  
  
 Dies ist das letzte Ereignis aufgerufen wird, bevor die Seite Ansichtszustand gespeichert wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Web.UI.Page.OnPreRenderComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" /> Objekt, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Page.SaveStateComplete" /> Ereignis nach der Seite Status auf dem Medium Persistenz gespeichert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.OnSaveStateComplete%2A> Methode wird aufgerufen, wenn die Statusinformationen für das Steuerelement die Persistenz "Mittel" für die Seite geschrieben wurde. Zustandsinformationen bezieht sich auf das Medium Persistenz durch Aufrufen der <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> Methode.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Mit der <xref:System.Web.UI.Page.OnSaveStateComplete%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Adapter, der die Seite für den anfordernden Browser rendert.</summary>
        <value>Die <see cref="T:System.Web.UI.Adapters.PageAdapter" /> , rendert die Seite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.PageAdapter%2A> Eigenschaft gibt die spezifische <xref:System.Web.UI.Adapters.PageAdapter> -Objekt, das das Verhalten ändert die <xref:System.Web.UI.Page> Objekt für den anfordernden Browser.  
  
 Die spezifische <xref:System.Web.UI.Adapters.PageAdapter> Objekt wird bestimmt durch Überprüfen der Merkmale des eingehenden <xref:System.Web.UI.Page.Request%2A> Objekt. Wenn ein Adapter für die Anforderung Lebenszyklusereignisse auf ausgewählt ist die <xref:System.Web.UI.Adapters.PageAdapter> Objekt überschreiben die entsprechenden Ereignissen auf der <xref:System.Web.UI.Page> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Web.UI.PageStatePersister" /> Objekt, das mit der Seite zugeordnet.</summary>
        <value>Ein <see cref="T:System.Web.UI.PageStatePersister" /> mit der Seite verknüpft sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP-Anforderungen und Antworten sind grundsätzlich keinen Zustand. Um den Status zwischen den HTTP-Anforderungen zu beizubehalten, ASP.NET-Seiten für Server speichern können <xref:System.Web.UI.Page> Zustand. Dieser Status, als Ansichtszustand bezeichnet besteht aus Seiten- und steuerelementeinstellungen und Daten, die die Seiten und Steuerelemente, die angezeigt werden, als ob sie identisch sind, die der Benutzer gesehen haben, und auf ihren letzten Roundtrip zur Seite Interaktion. Mehrere Mechanismen vorhanden sein, damit um zwischen aufeinander folgende Anforderungen zur selben Seite Ansichtszustand zu speichern. Die abstrakte <xref:System.Web.UI.PageStatePersister> Klasse stellt die Basisklasse für diesen Zustand Speichermechanismen dar.  
  
 Entwickler von Seiten in der Regel nicht verwenden müssen die <xref:System.Web.UI.Page.PageStatePersister%2A> Eigenschaft. Die <xref:System.Web.UI.Page.PageStatePersister%2A> Eigenschaft wird hauptsächlich von Steuerelemententwicklern zum Erweitern der Funktionalität des verwendet die <xref:System.Web.UI.Page> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Zeichenfolge, die das ausgeblendete EVENTARGUMENT-Feld in der gerenderten Seite definiert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Zeichenfolge, die das ausgeblendete EVENTTARGET-Feld in der gerenderten Seite definiert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, vor der seiteninitialisierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis können Sie überprüfen von Bedingungen für die Seitenanforderung, z. B., ob die Seite als Antwort auf ein Postback geladen wird. Sie können auch die Werte der Profileigenschaften überprüfen.  
  
 Das Ereignis können Sie Werte festlegen, die später im Lebenszyklus Seite verwendet werden. Sie können dynamisch eine Gestaltungsvorlage oder ein Design für die angeforderte Seite festgelegt und dynamische Steuerelemente erstellen.  
  
 Weitere Informationen darüber, wie die <xref:System.Web.UI.Page.PreInit> Ereignis in den Lebenszyklus von ASP.NET passt, finden Sie unter [ASP.NET Seite Übersicht über den Lebenszyklus](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, bevor die Seite <see cref="E:System.Web.UI.Control.Load" /> Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.PreLoad> Ereignis wird ausgelöst, nachdem die Verarbeitung aller Postbackdaten und vor dem <xref:System.Web.UI.Control.Load> Ereignis. Es wird ein zweiter Versuch Postbackdaten vor dem Laden der <xref:System.Web.UI.Page.OnLoadComplete%2A> Ereignis. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [NIB: Behandeln von Ereignissen](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, bevor der Seiteninhalt gerendert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.PreRenderComplete> Ereignis wird ausgelöst, wenn die vorab rendernde-Phase des Lebenszyklus der Seite abgeschlossen ist. In dieser Phase des Lebenszyklus der Seite werden alle Steuerelemente erstellt, ggf. erforderliche Paginierung abgeschlossen ist und die Seite wird zum Rendern der Ausgabe bereit.  
  
 Dies ist das letzte Ereignis ausgelöst, bevor die Seite Ansichtszustand gespeichert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [NIB: Behandeln von Ereignissen](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Seite, die die Steuerung der aktuellen Seite ab.</summary>
        <value>Die <see cref="T:System.Web.UI.Page" /> die Seite, die die Steuerung auf die aktuelle Seite darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung der <xref:System.Web.HttpServerUtility.Transfer%2A> -Methode, oder verwenden seitenübergreifend buchen, um die Verarbeitung von einer ASP.NET-Seite in einen anderen zu übertragen, enthält die ursprüngliche Seite Anforderungsinformationen, die für die Seite "Ziel" erforderlich sind. Sie können die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft auf die Informationen zugreifen.  
  
 Wenn die aktuelle Seite gerendert wird als Ergebnis einer direkten Anforderung (keine Übertragung oder Cross-Post aus einer anderen Seite), die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft enthält `null`.  
  
   
  
## Examples  
 Im folgende Beispiel wird in zwei Teilen. Die erste ist eine ASP.NET-Seite auf, die verwendet die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode, die verfügbar gemacht werden, in das Modell als `Server.Transfer("path")`. Der zweite Teil ist der Zielseite verwendet die <xref:System.Web.UI.Page.PreviousPage%2A> Eigenschaft, um den Titel der ersten Seite abzurufen.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Benutzer ist nicht zulässig, die vorherige Seite aufzurufen.  
  
 - oder -   
  
 ASP.NET-Routing wird verwendet, und der vorherigen Seite URL ist eine URL weitergeleitet. Wenn ASP.NET Zugriffsberechtigungen überprüft, es wird vorausgesetzt, die URL einer tatsächlichen Pfad zu einer Datei. Da dies nicht der Fall bei einer weitergeleiteten URL ist, schlägt der Test fehl.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Ein <see cref="T:System.Web.HttpContext" /> -Objekt, das Verweise auf die systeminternen Serverobjekte bereitstellt (z. B. <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" />, und <see cref="P:System.Web.HttpContext.Session" />) verwendet, um HTTP-Anforderungen.</param>
        <summary>Legt die systeminternen Serverobjekte von der <see cref="T:System.Web.UI.Page" /> Objekt, wie die <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" />, und <see cref="P:System.Web.UI.Page.Application" /> Eigenschaften.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode nicht aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">Die ASP.NET-Serversteuerelement, das das Postback verursacht hat. Dieses Steuerelement muss implementieren die <see cref="T:System.Web.UI.IPostBackEventHandler" /> Schnittstelle.</param>
        <param name="eventArgument">Das postback Argument.</param>
        <summary>Benachrichtigt das Serversteuerelement, das dem Postback, die verursacht ein eingehendes Postbackereignis behandelt werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page> -Objekt ruft die <xref:System.Web.UI.Page.RaisePostBackEvent%2A> Methode, wenn ein Postback erfolgt. Dieser Aufruf erfolgt im Lebenszyklus Seite nach dem Laden und die Änderung Benachrichtigung abgeschlossen sind, aber bevor Prerendering auftritt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.UI.Page.RaisePostBackEvent%2A> Methode, um ASP.NET zu benachrichtigen, dass ein Postbackereignis ausgelöst wird, wenn eine benutzerdefinierte `userButton` -Steuerelement geklickt wird.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Der Name des Arrays, in dem den Wert zu deklarieren.</param>
        <param name="arrayValue">Der Wert im Array platziert.</param>
        <summary>Deklariert einen Wert, der als ECMAScript-Arraydeklaration deklariert wird, wenn die Seite gerendert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann vom Skript-basierte Steuerelemente verwendet werden, selbst in einem Array deklarieren, sodass eine Clientbibliothek für das Skript mit allen Steuerelementen desselben Typs arbeiten kann.  
  
 Die <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> Methode, um ein Array zu deklarieren `myArray`, enthält drei Objekte, die mit dem Namen `x`, `y`, und `z`. Im Beispiel definiert und registriert eine Start-Skript mithilfe der <xref:System.Web.UI.Page.RegisterStartupScript%2A> Methode. Wenn die ECMAScript `doClick` Funktion wird aufgerufen, auf der Seite, die diesen Code enthält, das Array und seine Objekte initialisiert werden.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">Ein <see cref="T:System.Web.UI.PageAsyncTask" /> , die die asynchrone Aufgabe definiert.</param>
        <summary>Registriert eine neue asynchrone Aufgabe mit der Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definieren Sie eine asynchrone Aufgabe mit der <xref:System.Web.UI.PageAsyncTask> Klasse. Wenn die Aufgabe definiert ist, verwenden Sie die <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Methode, um den Vorgang mit der Seite zu registrieren. Rufen Sie nach dem Registrieren der Aufgabe, die <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> Methode, um die asynchrone Aufgabe zu starten.  
  
 Die <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Methode kann mit synchronen und asynchronen Seiten verwendet werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft mit dem <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> und <xref:System.Web.UI.Page.RegisterAsyncTask%2A> Methoden. Beachten Sie die Verwendung der Start-, End- und Timeout-Handler. Im Beispiel eine künstliche Verzögerung zur Veranschaulichung der Situation einer asynchronen Aufgabe, die für den Task entsprechend den Angaben in die vorgesehenen Zeit überschreitet, wird die <xref:System.Web.UI.Page.AsyncTimeout%2A> Eigenschaft. In einem realen Szenario konnte eine asynchrone Aufgabe auszuführenden Datenbankaufrufe oder imagegenerierung, z. B. und dienen der Timeouthandler stellt maßvolle Leistungseinbußen, wenn die Aufgabe in einem angegebenen Zeitraum nicht ausgeführt wird.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der asynchrone Vorgang ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Eindeutige Schlüssel, der einen Skriptblock identifiziert.</param>
        <param name="script">Der Inhalt des Skripts, die an den Client gesendet wird.</param>
        <summary>Gibt die clientseitige Skriptblöcke in die Antwort an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Skriptdatei auf Clientseite wird ausgegeben, direkt hinter dem Starttag des der <xref:System.Web.UI.Page> des Objekts `<form runat= server>` Element. Schließen Sie unbedingt öffnende und schließende `<script>` Elemente, um das Skript blockieren angegebenen Zeichenfolge in der `script` Parameter.  
  
 Da diese Methode einen Schlüssel verwendet, um den Skriptblock zu identifizieren, muss der Skriptblock nicht jedes Mal in den Ausgabedatenstrom ausgegeben werden, wenn es von einer anderen Serverinstanz Steuerelement angefordert wird. Mithilfe eines Schlüssels verringert auch die Wahrscheinlichkeit, dass verschiedene Steuerelemente Skriptblöcke einander beeinträchtigen.  
  
 Alle Skriptblöcke mit dem gleichen `key` Parameterwerte werden als Duplikate angesehen.  
  
> [!NOTE]
>  Denken Sie daran, HTML-Kommentartags Ihr Skript einschließen, damit es nicht gerendert wird, wenn der anfordernde Browser keine Skripts unterstützt.  
  
 Die <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> stattdessen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> Methode in Verbindung mit der <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> Methode. Wenn ECMAScript im Codeblock Deklaration noch nicht registriert wurde, wie durch die bestimmt, <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>die <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Der eindeutige Name des ausgeblendeten Felds gerendert werden soll.</param>
        <param name="hiddenFieldInitialValue">Der Wert in der verborgenen Form ausgegeben werden.</param>
        <summary>Ermöglicht Serversteuerelemente, um ein ausgeblendetes Feld im Formular automatisch zu registrieren. Das Feld an gesendet werden die <see cref="T:System.Web.UI.Page" /> Objekt bei der <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> -Steuerelement gerendert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.RegisterHiddenField%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.RegisterHiddenField%2A> Methode zu erleichtern, ECMAScript-Code erstellen, die an den anfordernden Browser übergeben wird. Der Name des ausgeblendeten Felds wird festgelegt, um `myHiddenField` und sein Wert auf "Welcome to Microsoft!" festgelegt wird Die <xref:System.Web.UI.Page.RegisterStartupScript%2A> Methodenaufrufe der `myHiddenField` Wert, wenn der Benutzer auf eine Schaltfläche auf der Seite klickt.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein ausgeblendetes Feld, das ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig sollten Sie den Wert eines ausgeblendeten Felds überprüfen, wie Sie den Wert eines Textfelds. ASP.NET Web Pages überprüfen, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Eindeutige Schlüssel, der einen Skriptblock identifiziert.</param>
        <param name="script">Die Skriptdatei auf Clientseite an den Client gesendet werden.</param>
        <summary>Ermöglicht eine Seite, um den Clientzugriff <see langword="OnSubmit" /> Ereignis. Das Skript sollte einen Funktionsaufruf an den Clientcode, die an anderer Stelle registriert sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> ein Skript, auf dem reagiert, wenn ein Client-Side-Schaltfläche "Absenden" geklickt wird. Wenn dieses Ereignis tritt auf, wird der registrierte ECMAScript-Code auf dem Client ausgeführt.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein ausgeblendetes Feld, das ein potenzielles darstellen Sicherheitsrisiko. Standardmäßig sollten Sie den Wert eines ausgeblendeten Felds überprüfen, wie Sie den Wert eines Textfelds. ASP.NET Web Pages überprüfen, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement zu registrieren.</param>
        <summary>Registriert ein Steuerelement als ein Feld, dessen Steuerelementzustand beibehalten werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzerdefinierte Serversteuerelemente, die Steuerelementzustand verwenden müssen Aufrufen der <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> -Methode für jede Anforderung da-Registrierung für Steuerelementzustand nicht während der ein Postbackereignis Anforderung übertragen werden. Es wird empfohlen, die Registrierung erfolgen, in der <xref:System.Web.UI.Control.Init> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt einen Aufruf der benutzerdefinierten Steuerelement die <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> Methode.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das zu registrierende Steuerelement ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> Methode kann aufgerufen werden, nur vor oder während der <see cref="E:System.Web.UI.Control.PreRender" /> Ereignis.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement registriert werden.</param>
        <summary>Registriert ein Steuerelement als ein, die erforderlich sind, postback Verarbeitung, wenn die Seite an den Server zurückgesendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Steuerelement zu registrierenden implementieren muss die <xref:System.Web.UI.IPostBackDataHandler> Schnittstelle oder eine <xref:System.Web.HttpException> ausgelöst wird. Bei der Implementierung durch ein Steuerelement die <xref:System.Web.UI.IPostBackDataHandler> Schnittstelle ermöglicht von Postbackdaten behandeln und Auslösen von Beiträge sichern Datenereignisse geändert. Weitere Informationen zu den Ereignismodell, finden Sie unter [ASP.NET Web Forms-Steuerelement Ereignis Servermodell](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Registrieren Sie Steuerelemente für die Seite am oder vor dem `Page_PreRender` Ereignis des Lebenszyklus der Seite.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> Methode, um ein Textfeld-Steuerelement, erfordern `myTextBox`zurückgesendet werden, bevor das Textfeld zugeordneter Code ausgeführt werden kann. <xref:System.Web.UI.WebControls.TextBox>Steuerelemente implementieren die <xref:System.Web.UI.IPostBackDataHandler> Schnittstelle.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das zu registrierende Steuerelement implementiert nicht die <see cref="T:System.Web.UI.IPostBackDataHandler" /> Schnittstelle.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement zu registrieren.</param>
        <summary>Registriert ein ASP.NET-Serversteuerelement als ein Ereignis ausgelöst werden, wenn das Steuerelement verarbeitet wird, auf die <see cref="T:System.Web.UI.Page" /> Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pro Seite kann nur ein Serversteuerelement registriert werden. Die <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> muss verwendet werden, wenn das Steuerelement nicht die Steuerelement-ID in das Formular post-Daten enthalten. Außerdem muss das Steuerelement, das registriert wird implementieren die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> Methode zum Registrieren einer <xref:System.Web.UI.WebControls.Button> -Webserversteuerelement erfordern, ein Ereignis ausgelöst werden soll. Nach der ersten Registrierung <xref:System.Web.UI.WebControls.Button> -Steuerelement, Sie können dazu führen, dass die zweite <xref:System.Web.UI.WebControls.Button> Steuerelement im Code die Ergebnisse der ersten Schaltfläche deklarierte click-Ereignis auf der Seite.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Registriert ein Steuerelement mit der Seite als ein erfordern Ansichtszustand Verschlüsselung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein benutzerdefiniertes Steuerelement, der potenziell vertrauliche Informationen behandelt entwickeln, rufen Sie die <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> -Methode registrieren das Steuerelement für die Seite, und gewährleisten Ansichtszustand für das Steuerelement verschlüsselt ist.  
  
 Der Status für die gesamte Seite wird verschlüsselt, wenn die <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> festgelegt ist, um <xref:System.Web.UI.ViewStateEncryptionMode.Auto> oder <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen der Ansichtszustand Verschlüsselungsmodus für eine <xref:System.Web.UI.Page> -Objekt und das Anfordern der Verschlüsselung des Ansichtszustands über <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. In diesem Beispiel wird der Ansichtszustand verschlüsselt werden, wenn Kundeninformationen aus einer Datenbank abgerufen werden.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> -Methode muss aufgerufen werden, bevor oder während Sie die Seite <see langword="PreRender" /> phase im Lebenszyklus Seite.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Eindeutige Schlüssel, der einen Skriptblock identifiziert.</param>
        <param name="script">Der Inhalt des Skripts, die an den Client gesendet werden sollen.</param>
        <summary>Gibt einen clientseitigen Skriptblock in die Seite "-Antwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ähnlich wie die <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> -Methode, die <xref:System.Web.UI.Page.RegisterStartupScript%2A> Methode ausgibt, das Skript direkt vor dem Endtag des der <xref:System.Web.UI.Page> des Objekts `<form runat= server>` Element. Schließen Sie unbedingt öffnende und schließende `<script>` Elemente, um das Skript blockieren angegebenen Zeichenfolge in der `script` Parameter.  
  
 Da diese Methode einen Schlüssel verwendet, um den Skriptblock zu identifizieren, muss der Skriptblock nicht jedes Mal in den Ausgabedatenstrom ausgegeben werden, wenn es von einer anderen Serverinstanz Steuerelement angefordert wird  
  
 Alle Skriptblöcke mit dem gleichen `key` Parameterwerte werden als Duplikate angesehen.  
  
> [!NOTE]
>  Denken Sie daran, HTML-Kommentartags Ihr Skript einschließen, damit es nicht gerendert wird, wenn der anfordernde Browser keine Skripts unterstützt.  
  
 Die <xref:System.Web.UI.Page.RegisterStartupScript%2A>-Methode ist veraltet. Verwenden der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode in der <xref:System.Web.UI.ClientScriptManager> stattdessen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.Page.RegisterStartupScript%2A> Methode in Verbindung mit der <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> Methode. Wenn in der Deklaration Codeblock geschriebene ECMAScript noch nicht registriert wurde, wie durch die bestimmt, die <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> -Methode, und klicken Sie dann eine <xref:System.Web.UI.Page.RegisterStartupScript%2A> aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass Seite Ansichtszustand beibehalten werden, wenn Sie aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> Methode wird automatisch aufgerufen, durch die <xref:System.Web.UI.HtmlControls.HtmlForm> Serversteuerelement. Wenn diese Methode nicht aufgerufen wird, wird die Seite Ansichtszustand nicht beibehalten werden.  
  
> [!NOTE]
>  In der Regel nur die <xref:System.Web.UI.HtmlControls.HtmlForm> -Steuerelement für die Seite ruft diese Methode auf.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Die <see cref="T:System.Web.UI.HtmlTextWriter" /> , empfängt den Seiteninhalt.</param>
        <summary>Initialisiert die <see cref="T:System.Web.UI.HtmlTextWriter" /> -Objekt und ruft die untergeordneten Steuerelemente von der <see cref="T:System.Web.UI.Page" /> zum Rendern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.Render%2A> Methode ist verantwortlich für das Erstellen von Text und Markup, das an den Clientbrowser gesendet wird. Die Standardeinstellung <xref:System.Web.UI.Page.Render%2A> Methodenaufrufe <xref:System.Web.UI.Control.RenderChildren%2A> zum Schreiben von Text und Markup für die Steuerelemente auf der Seite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpRequest" />-Objekt für die angefragte Seite ab.</summary>
        <value>Die aktuelle <see cref="T:System.Web.HttpRequest" /> der Seite "zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Web.HttpRequest>-Objekt enthält Informationen zur aktuellen HTTP-Anforderung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der <xref:System.Web.HttpRequest.Headers%2A> Auflistung aus der <xref:System.Web.HttpRequest> Objekt, und es zu einer ASP.NET-Seite zu schreiben.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Tritt auf, wenn die <see cref="T:System.Web.HttpRequest" /> Objekt ist nicht verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Die <see cref="T:System.Web.UI.Control" /> zu suchende Steuerelement Status erforderlich.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Web.UI.Control" /> -Objekt ist für die Einbeziehung in die Verwaltung registriert.</summary>
        <returns>
          <see langword="true" />Wenn das angegebene <see cref="T:System.Web.UI.Control" /> erforderliche Zustand befindet, andernfalls<see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelementzustand ist ein Objekt, das wichtige Webserversteuerelemente-Funktion müssen Ansichtszustand-Daten besteht. Es ist in ein separates Objekt aus dem normalen Ansichtszustand enthalten.  
  
 Benutzerdefinierte Steuerelemente, die mithilfe der Steuerelementzustand aufrufen, müssen die <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> Methode vor dem Speichern der Steuerelementzustand. Verwenden der <xref:System.Web.UI.Page.RequiresControlState%2A> Methode, um Steuerelemente zu überprüfen, die mit der Seite erfordern, Steuerelementzustand registriert sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.HttpResponse" />-Objekt ab, das dem <see cref="T:System.Web.UI.Page" />-Objekt zugeordnet ist. Mit diesem Objekt können Sie HTTP-Antwortdaten an einen Client senden. Es enthält außerdem Informationen über diese Antwort.</summary>
        <value>Die aktuelle <see cref="T:System.Web.HttpResponse" /> der Seite "zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, ein Cookie erstellt und Hinzufügen von HTTP-Ausgabe der Seite mithilfe der <xref:System.Web.HttpResponse> Objekt.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see cref="T:System.Web.HttpResponse" /> Objekt ist nicht verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Hiermit wird die Codierung Sprache für die aktuelle <see cref="T:System.Web.HttpResponse" /> Objekt.</summary>
        <value>Eine Zeichenfolge, die Codierungssprache für die aktuelle enthält <see cref="T:System.Web.HttpResponse" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `ResponseEncoding` -Attributs auf den Wert, der mit der Direktive in der ASPX-Datei enthalten sein sollen. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="P:System.Web.Routing.RequestContext.RouteData" /> Wert des aktuellen <see cref="T:System.Web.Routing.RequestContext" /> Instanz.</summary>
        <value>Die <see cref="P:System.Web.Routing.RequestContext.RouteData" /> Wert des aktuellen <see cref="T:System.Web.Routing.RequestContext" /> Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Seite als Antwort auf eine Anforderung durch das ASP.NET-Routing ausgeführt wird, enthält diese Eigenschaft den Zugriff auf die URL-Parameterwerte, die als Routendaten übergeben wurden. Wenn die Seite als Antwort auf eine physische URL statt einer Routen-URL ausgeführt wird, wird diese Eigenschaft ist `null`. Im folgende Beispiel wird gezeigt, wie zum Extrahieren des Werts von URL-Parameter mit dem Namen `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Wenn die Route definiert ist, mithilfe der URL-Muster `{locale}/{year}` für die Domäne `contoso.com`, und wenn die angeforderte URL ist `contoso.com/US/2010`, `year` enthält den Wert "2010", wenn dieser Code ausgeführt wird.  
  
 Weitere Informationen zu ASP.NET-Routing finden Sie unter [ASP.NET-Routing](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Object" /> in dem Sie die Ansichtszustandsinformationen zu speichern.</param>
        <summary>Speichert alle Ansichtszustand und Steuerelementzustand Informationen für die Seite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> -Methode verwendet die <xref:System.Web.UI.PageStatePersister.Save%2A> Methode der <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> Objekt verweist die <xref:System.Web.UI.Page.PageStatePersister%2A> Eigenschaft zum Speichern von Ansichtszustand und Steuerelementzustand Informationen für die Seite.  
  
 ASP.NET umfasst zwei Nachfolger des der <xref:System.Web.UI.PageStatePersister> -Klasse, die <xref:System.Web.UI.HiddenFieldPageStatePersister> -Klasse, die Zustandsinformationen in einem ausgeblendeten Feld auf der ASP.NET-Seite speichert und die <xref:System.Web.UI.SessionPageStatePersister> -Klasse, die den Zustand im speichert die <xref:System.Web.UI.Page.Session%2A> Objekt zugeordnet der Anforderung. Beachten Sie, dass bei Verwendung der <xref:System.Web.UI.SessionPageStatePersister> Klasse ausgeblendeten Felds "ViewState" speichern, noch gerendert wird, da diese verwendet werden, um zu bestimmen, Postback.  
  
 Um den Zustand in den Speicherort Ihrer Wahl zu speichern, erstellen Sie eine neue untergeordnete der <xref:System.Web.UI.PageStatePersister> -Klasse, speichert und lädt den Zustand auf dem Dauerhaftigkeitsmedium Ihrer Wahl. Ein Beispiel für die Erstellung einer neuen <xref:System.Web.UI.PageStatePersister> Objekt, finden Sie unter der <xref:System.Web.UI.PageStatePersister> Klasse.  
  
 Bei Verwendung von .NET Framework, Version 1.0 oder 1.1, die diese Methode überschreiben, wenn Sie speichern möchten die <xref:System.Web.UI.Page> State in etwas anderes als ein ausgeblendetes Feld. Wenn Sie dies auswählen, müssen Sie auch überschreiben die <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem die Seite abgeschlossen wurde, speichern alle Status und Steuerung Ansichtszustandsinformationen für die Seite, und klicken Sie auf der Seite "steuert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach der gespeicherten Zustandsinformationen für Steuerelemente auf der Webseite der <xref:System.Web.UI.Page.PreRenderComplete> Ereignis. Die <xref:System.Web.UI.Page.SaveStateComplete> Ereignis wird ausgelöst, nachdem der Ansichtszustand und Steuerelementzustand der Seite und die Steuerelemente auf der Seite auf das Medium Persistenz gespeichert wurden.  
  
 Dies ist das letzte Ereignis ausgelöst, bevor die Seite an den anfordernden Browser gerendert wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [Ereignisse](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see langword="Server" /> -Objekt, das eine Instanz von der <see cref="T:System.Web.HttpServerUtility" /> Klasse.</summary>
        <value>Die aktuelle <see langword="Server" /> Objekt, das mit der Seite zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf die häufig verwendete <xref:System.Web.HttpServerUtility.HtmlEncode%2A> und <xref:System.Web.HttpServerUtility.MapPath%2A> Methoden o. ä.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Fehlerinformationen vom Server mit den Zugriff auf die `Server` Objekt. Insbesondere im Beispiel ruft die angeforderte URL aus der `Request` -Objekt, das neueste Fehlerprotokoll aus der `Server` Objekt (mit der <xref:System.Web.HttpServerUtility.GetLastError%2A> Methode) und konvertiert sie beide in Zeichenfolgen, die vom Client angezeigt werden können. Sobald der `message` Variable an den Client geschrieben wird der Fehler wird gelöscht, mit der <xref:System.Web.HttpServerUtility.ClearError%2A> Methode.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuellen <see langword="Session" /> von ASP.NET bereitgestellte Objekt.</summary>
        <value>Die aktuellen Sitzungszustandsdaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet Informationen über die aktuelle Anforderung Sitzung. Ein `Session` Objekt bleibt für jeden Benutzer, die eine Seite oder ein Dokument von einer ASP.NET-Anwendung anfordert. Variablen gespeichert, der `Session` Objekt sind nicht verworfen werden, wenn der Benutzer die Seite in der Anwendung bewegt; stattdessen diese Variablen beibehalten, solange der Benutzer Seiten in der Anwendung zugreift. Weitere Informationen über den Sitzungszustand finden Sie unter [ASP.NET Session State Overview](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine `GetStyle` -Funktion, die in den Sitzungszustand des Web Forms-Seite gespeicherten Schlüssel abruft und seinen Wert in eine Zeichenfolge konvertiert.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Tritt auf, wenn die Sitzungsinformationen, um festgelegt ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">Die ID des Steuerelements auf den Fokus festgelegt werden soll.</param>
        <summary>Legt den Browserfokus auf das Steuerelement mit dem angegebenen Bezeichner fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.SetFocus%2A> string-Methode, um das Steuerelement mit der angegebenen ID, das zum aktive Steuerelement auf der Webseite, die vom Browser angezeigt. Die <xref:System.Web.UI.Page.SetFocus%2A> -Methode muss aufgerufen werden, bevor die Seite für das Rendering an den Client in vorbereitet wird die <xref:System.Web.UI.Control.PreRender> Ereignis.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.Page.SetFocus%2A> Methode funktioniert nur in Browsern mit Unterstützung von ECMAScript-Version 1.3 oder höher.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Fokus auf das zweite Textfeld auf einer Webseite fest.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.String)" />wird aufgerufen, wenn das Steuerelement nicht Teil einer Web Forms-Seite ist.  
  
 \- oder –  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.String)" />wird aufgerufen, nachdem die <see cref="E:System.Web.UI.Control.PreRender" /> Ereignis.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Das Steuerelement, das den Fokus erhalten soll.</param>
        <summary>Legt den Browserfokus auf das angegebene Steuerelement fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.SetFocus%2A> Methode zum Erstellen von des angegebenen Steuerelements des aktiven Steuerelements auf der Webseite, die vom Browser angezeigt. Die <xref:System.Web.UI.Page.SetFocus%2A> -Methode muss aufgerufen werden, bevor die Seite für das Rendering an den Client in vorbereitet wird die <xref:System.Web.UI.Control.PreRender> Ereignis.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.Page.SetFocus%2A> Methode funktioniert nur in Browsern mit Unterstützung von ECMAScript-Version 1.3 oder höher.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Fokus auf das zweite Textfeld auf einer Webseite fest.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />wird aufgerufen, wenn das Steuerelement nicht Teil einer Web Forms-Seite ist.  
  
 \- oder –  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />wird aufgerufen, nachdem die <see cref="E:System.Web.UI.Control.PreRender" /> Ereignis.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob der Wert der Abfragezeichenfolge überprüft wird.</summary>
        <value>
          <see langword="true" />Wenn die Überprüfung der Zeichenfolge übersprungen werden soll (die Abfragezeichenfolge nicht überprüft werden soll); andernfalls <see langword="false" /> Überprüfung der Zeichenfolge werden soll, platzieren Sie wie gewohnt. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die intelligente Navigation aktiviert ist, oder legt diesen fest. Diese Eigenschaft ist veraltet.</summary>
        <value>
          <see langword="true" />, wenn die intelligente Navigation aktiviert ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `SmartNavigation` -Attribut `true` in der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse diese Eigenschaft fest.  
  
> [!NOTE]
>  In ASP.NET 2.0 sind die <xref:System.Web.UI.Page.SmartNavigation%2A> Eigenschaft ist veraltet. Verwenden der <xref:System.Web.UI.Page.SetFocus%2A> Methode und die <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> Eigenschaft stattdessen.  
  
 Wenn eine Seite von Microsoft Internet Explorer 5.5-Browser oder höher, intelligente Navigation angefordert wird verbessert die benutzerfreundlichkeit der Seite durch Ausführen der folgenden:  
  
-   Entfernen Sie die Flash Navigation zurückzuführen.  
  
-   Die Bildlaufposition beibehalten, wenn von einer Seite auf Seite verschieben.  
  
-   Beibehalten von den Elementfokus zwischen Navigationsvorgängen.  
  
-   Nur der letzte Seitenzustand im Verlauf des Browsers werden beibehalten.  
  
 Intelligente Navigation wird am besten verwendet werden, mit ASP.NET-Seiten, die häufig Postbacks erfordert jedoch mit visuellen Inhalt, der bei der Rückgabe nicht erheblich geändert wird. Berücksichtigen Sie dies bei der Entscheidung, ob diese Eigenschaft festgelegt wird, um `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namen des Designs, die auf der Seite einem frühen Zeitpunkt im Lebenszyklus Seite angewendet wird.</summary>
        <value>Der Name des Designs, die auf der Seite einem frühen Zeitpunkt im Lebenszyklus Seite angewendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verweist nicht direkt auf ein cascading Stylesheet (CSS). Die Eigenschaft enthält den Namen eines ASP.NET-Designs, die CSS-Dateien darin enthalten kann.  
  
 Die <xref:System.Web.UI.Page.StyleSheetTheme%2A> Eigenschaft gibt den Namen des ein Design, das auf einer Seite einem frühen Zeitpunkt im Lebenszyklus Seite angewendet wird, während die <xref:System.Web.UI.Page.Theme%2A> Eigenschaft gibt den Namen des ein Design, das auf einer Seite, die später im Lebenszyklus Seite angewendet wird. Dies bedeutet, dass Einstellungen auf der Seite gegenüber den Einstellungen in das Stylesheet-Design Vorrang. Weitere Informationen finden Sie unter [ASP.NET-Designs und Skins](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Sie können einen Wert für diese Eigenschaft in der Regel festlegen, in der Seitendirektive oder durch Überschreiben der Eigenschaft. Informationen finden Sie unter den folgenden Themen:  
  
-   [Vorgehensweise: Anwenden von ASP.NET-Designs](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [Vorgehensweise: Programmgesteuertes Anwenden von ASP.NET-Designs](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, Festlegen der <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> Eigenschaft nach der <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> Methode wurde aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" />wird auf eine ungültige Designnamen festgelegt. Diese Ausnahme wird ausgelöst, wenn die <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> -Methode aufgerufen wird, nicht durch den Eigenschaftensetter.</exception>
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namen des Seitendesigns.</summary>
        <value>Der Name des Seitendesigns.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.Theme%2A> Eigenschaft legt den Namen des Designs für die Seite verwendet. Wenn Sie die Einstellungen auf der Seite, die Vorrang vor der Einstellungen im Design möchten, verwenden die <xref:System.Web.UI.Page.StyleSheetTheme%2A> Eigenschaft. Weitere Informationen finden Sie unter [ASP.NET-Designs und Skins](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Die <xref:System.Web.UI.Page.Theme%2A> Eigenschaft muss festgelegt werden, vor der <xref:System.Web.UI.Page.PreInit> Ereignis; die Einrichtung der <xref:System.Web.UI.Page.Theme%2A> Eigenschaft nach der <xref:System.Web.UI.Page.PreInit> Ereignis führt dazu, dass ein <xref:System.InvalidOperationException> Ausnahme.  
  
 Das angegebene Design muss als eine Anwendung oder ein globales Design vorhanden sein. Wenn das Design nicht vorhanden ist, eine <xref:System.Web.HttpException> Ausnahme wird ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Web.UI.Page.Theme%2A> Eigenschaft, um einen Namen in der Abfragezeichenfolge übergeben.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, festzulegende <see cref="P:System.Web.UI.Page.Theme" /> nach der <see cref="E:System.Web.UI.Page.PreInit" /> Ereignis ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" />wird auf eine ungültige Designnamen festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Titel für die Seite.</summary>
        <value>Der Titel der Seite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Web.UI.Page.Title%2A> -Eigenschaft zum Festlegen des Seitentitel im HTML-Header an den Browser gesendet.  
  
> [!NOTE]
>  Die Seite enthalten, muss eine `head` Element mit dem Attribut `runat="server"`, andernfalls wird der Titel nicht dargestellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Web.UI.Page.Title" /> Eigenschaft erfordert ein Headersteuerelement auf der Seite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Web.TraceContext" />-Objekt für die aktuelle Webanforderung ab.</summary>
        <value>Daten aus der <see cref="T:System.Web.TraceContext" /> Objekt der aktuellen webanforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ablaufverfolgung verfolgt und zeigt die Ausführungsdetails zu einer webanforderung. Für die Ablaufverfolgungsdaten in einer gerenderten Seite angezeigt werden müssen Sie die Ablaufverfolgung auf der Seite oder Anwendungsebene aktivieren.  
  
 Die Ablaufverfolgung auf einer Seite ist standardmäßig deaktiviert. Verwenden Sie zum Aktivieren der Ablaufverfolgung für eine Seite die Direktive `<% @ Page trace="true" %>`. Zum Aktivieren der Ablaufverfolgung für eine gesamte Anwendung, müssen Sie sie in der Konfigurationsdatei "Web.config", die Anwendung aktivieren, die sich im Stammverzeichnis der Anwendung befinden. Weitere Informationen finden Sie unter [ASP.NET Tracing Overview](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht den Zugriff auf die <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> Eigenschaft und die <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> Methode über die <xref:System.Web.UI.Page.Trace%2A> Eigenschaft. Dieser Code Ruft die <xref:System.Diagnostics.Trace.Write%2A> Methode, nur, wenn Ablaufverfolgung aktiviert ist, für die <xref:System.Web.UI.Page> Objekt. Wenn es nicht aktiviert ist, wird dieser Code nicht ausgeführt, hilft der Aufwand für die Anwendung zu reduzieren.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Wert, der angibt, ob Ablaufverfolgung, für aktiviert ist die <see cref="T:System.Web.UI.Page" /> Objekt.</summary>
        <value>
          <see langword="true" />Wenn die Ablaufverfolgung für die Seite aktiviert ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `Trace` -Attribut `true` in der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Modus, in der die, den Ablaufverfolgungsinformationen Anweisungen auf der Seite angezeigt werden.</summary>
        <value>Eines der <see cref="T:System.Web.TraceMode" /> Enumerationsmember.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `TraceMode` Attribut in der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Ebene der Transaktion für die Seite unterstützt wird.</summary>
        <value>Eine ganze Zahl, die eine der darstellt der <see cref="T:System.EnterpriseServices.TransactionOption" /> Enumerationsmember.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft nicht im Code, in den meisten Fällen. Legen Sie die `Transaction` Attribut in der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse die Eigenschaft fest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert die angegebene Modellinstanz mit Werten von einem Wertanbieter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Der Typ des Modells.</typeparam>
        <param name="model">Das Modell.</param>
        <summary>Aktualisiert die angegebene Modellinstanz mit Werten aus dem datengebundenen Steuerelement.</summary>
        <returns>
          <see langword="true" />Wenn die modellbindung erfolgreich ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur aufgerufen werden, von einer Methode, die von einem datengebundenen Steuerelement angegeben wird `UpdateMethod` oder `InsertMethod` Eigenschaft.  
  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Der Typ des Modells.</typeparam>
        <param name="model">Das Modell.</param>
        <param name="valueProvider">Der Wertanbieter.</param>
        <summary>Aktualisiert die Modellinstanz mit Werten aus den angegebenen Wertanbieter.</summary>
        <returns>
          <see langword="true" />Wenn die modellbindung erfolgreich ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die ID für die Benutzeroberfläche (UI) für die <see cref="T:System.Threading.Thread" /> Objekt, das mit der Seite zugeordnet.</summary>
        <value>Die UI-ID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Kurzform für die <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft. Die Kultur ist eine Eigenschaft des ausgeführten Threads  
  
 Legen Sie die `UICulture` Attribut in der Direktive in der ASPX-Datei. Wenn die Seite angefordert wird, legt die dynamisch generierte Klasse den Wert dieser Eigenschaft fest. Darüber hinaus können Sie auch explizit den Wert der Festlegen der <xref:System.Web.UI.Page.UICulture%2A> Eigenschaft in der die Datei "Web.config".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein eindeutiges Suffix, um den Dateipfad für caching Browser angefügt werden soll.</summary>
        <value>Ein eindeutiges Suffix an den Dateipfad angefügt. Die Standardeinstellung ist "__ufps =" und eine eindeutige Zahl von 6 Ziffern.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> Eigenschaft gibt eine Zeichenfolge, die am Ende einen Dateipfad im Bedarfsfall zum Zwischenspeichern von Browsern angefügt wird. Diese Zeichenfolge wird verwendet, zum Identifizieren des Dateipfad, der einer bestimmten Anforderung zugeordnet ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob unaufdringliches JavaScript für die clientseitige Validierung verwendet wird.</summary>
        <value>
          <see langword="true" />Wenn unaufdringliches JavaScript verwendet wird. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Die <see cref="T:System.Web.UI.Control" /> für die Dauerhaftigkeit des Steuerelementzustands zu beenden.</param>
        <summary>Beendet die Dauerhaftigkeit des Steuerelementzustands für das angegebene Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzerdefinierte Serversteuerelemente, die Steuerelementzustand verwenden müssen Aufrufen der <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> bei jeder Anforderung während der vor dem Ausführen der Zustand beibehalten wird. Registrierung für Steuerelementzustand wird nicht aus der Anforderung auf Anforderung während eines Postbacks übernommen. Verwenden der <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> Methode, um sicherzustellen, dass Steuerelementzustand für Steuerelemente, die nicht mehr für Postback beibehalten werden müssen, nicht permanent ist.  
  
 Intern die <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> Methode wird aufgerufen, wenn mithilfe der <xref:System.Web.UI.Control.RemovedControl%2A> Methode, um ein Steuerelement aus einer steuerelementeauflistung zu entfernen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert die angegebene Modellinstanz mit Werten von einem Wertanbieter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Der Typ des Modells.</typeparam>
        <param name="model">Das Modell.</param>
        <summary>Aktualisiert die angegebene Modellinstanz mit Werten aus dem datengebundenen Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur aufgerufen werden, von einer Methode, die von einem datengebundenen Steuerelement angegeben wird `UpdateMethod` oder `InsertMethod` Eigenschaft.  
  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Der Typ des Modells.</typeparam>
        <param name="model">Das Modell.</param>
        <param name="valueProvider">Der Wertanbieter.</param>
        <summary>Aktualisiert die angegebene Modellinstanz mit Werten von einem angegebenen Wertanbieter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Reihe von Lernprogrammen bei Verwendung von modellbindung für Webformulare, finden Sie unter [wurden die Modellbindung und Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen über die Seite anfordernde Benutzer ab.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IPrincipal" /> , der die Seite anfordernde Benutzer darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Security.Principal.IPrincipal> Objekt stellt den Sicherheitskontext des Benutzers in dessen Auftrag der Code ausgeführt wird, einschließlich der Identität des Benutzers und keine Rollen, zu denen sie gehören.  
  
 Diese Eigenschaft verwendet die <xref:System.Web.HttpContext> des Objekts <xref:System.Web.HttpContext.User%2A> -Eigenschaft können Sie bestimmen, in dem die Anforderung stammt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Web.UI.Page.User%2A> Eigenschaft, um Authentifizierung und Identität Zugriffsinformationen für den aktuellen Benutzer. Wenn der Benutzer nicht authentifiziert ist, wird er zu einer Anmeldeseite umgeleitet.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist alle Validierungssteuerelemente, die auf der Seite, um die zugewiesenen Informationen zu überprüfen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Benutzer ASP.NET-Serversteuerelement klickt, wurde die `CausesValidation` -Eigenschaftensatz auf `true`, dies ist die Standardeinstellung. Dazu gehören die <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, und <xref:System.Web.UI.WebControls.LinkButton> Webserver-Steuerelemente, die <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, und <xref:System.Web.UI.HtmlControls.HtmlButton> HTML-Serversteuerelemente und Steuerelemente, die automatisch an den Server, z. B. die zurücksendenkönnen<xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, und <xref:System.Web.UI.WebControls.BulletedList> Steuerelemente.  
  
 Legen Sie zum Deaktivieren der Validierung für alle Schaltflächen-Steuerelement auf der Seite "des Schaltflächen-Steuerelements `CausesValidation` Eigenschaft `false`.  
  
 Wenn diese Methode aufgerufen wird, durchläuft es die Validierungssteuerelemente, die der <xref:System.Web.UI.ValidatorCollection> zugeordnete Objekt der <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> Eigenschaft und ruft die Validierungslogik für die einzelnen Validierungssteuerelemente in der aktuellen Gruppe der Validierung. Die Validierungsgruppe wird vom Steuerelement bestimmt, die die Seite an den Server zurückgesendet. Wenn keine Überprüfung Gruppe angegeben wird, wird keine Validierungsgruppe verwendet.  
  
> [!NOTE]
>  Das Verhalten der seitenüberprüfung wurde geändert. In [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], rufen Steuerelemente nicht mehr die <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> Methode, die sie verwenden die <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> Methode stattdessen. Bei Verwendung der <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> Methode auf eine [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] Seite Überprüfung Gruppen werden ignoriert, und alle Steuerelemente werden überprüft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die <xref:System.Web.UI.Page.Validate%2A> Methode auf einer Seite in einem Szenario mit mehreren anderen Überprüfung Gruppen definiert.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die <see cref="M:System.Web.UI.Page.Validate" /> Methode wird nicht verwendet [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]. Beim Verwenden [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], überschreiben die <see cref="M:System.Web.UI.Page.Validate(System.String)" /> Methode, um die Seite Überprüfungsverhalten zu ändern.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Der Validierungsgruppenname der Steuerelemente zu überprüfen.</param>
        <summary>Weist die Validierungssteuerelemente in der angegebenen Überprüfung Gruppe um die zugewiesenen Informationen zu überprüfen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Benutzer ASP.NET-Serversteuerelement klickt, wurde die `CausesValidation` -Eigenschaftensatz auf `true`, dies ist die Standardeinstellung. Dazu gehören die <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, und <xref:System.Web.UI.WebControls.LinkButton> Webserver-Steuerelemente, die <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, und <xref:System.Web.UI.HtmlControls.HtmlButton> HTML-Serversteuerelemente und Steuerelemente, die automatisch an den Server, z. B. die zurücksendenkönnen<xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, und <xref:System.Web.UI.WebControls.BulletedList> Steuerelemente.  
  
 Legen Sie zum Deaktivieren der Validierung für alle Schaltflächen-Steuerelement auf der Seite "des Schaltflächen-Steuerelements `CausesValidation` Eigenschaft `false`.  
  
 Die <xref:System.Web.UI.Page.Validate%2A> Methode überprüft, ob die angegebene Validierungsgruppe. Nach dem Aufruf der <xref:System.Web.UI.Page.Validate%2A> Methode für eine Gruppe Überprüfung der <xref:System.Web.UI.Page.IsValid%2A> Methode zurück `true` nur, wenn die angegebene Validierungsgruppe und der Gruppe der Validierung des Steuerelements, das die Seite an den Server zurückgesendet werden gültig sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die <xref:System.Web.UI.Page.Validate%2A> Methode auf einer Seite in einem Szenario mit mehreren anderen Überprüfung Gruppen definiert.  
  
> [!IMPORTANT]
>  Dieses Beispiel umfasst ein Textfeld, das Benutzereingaben akzeptiert, die ein potenzielles Sicherheitsrisiko darstellen. Standardmäßig stellen ASP.NET-Webseiten sicher, dass Benutzereingaben keine Skript- oder HTML-Elemente enthalten. Weitere Informationen finden Sie unter [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Seite Clienteingaben vom Browser für potenziell gefährlichen Werte überprüft.</summary>
        <value>Ein Wert, der angibt, ob die Seite Clienteingabe überprüft. Die Standardeinstellung ist <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert <xref:System.Web.UI.ValidateRequestMode.Inherit> werden nicht in der <xref:System.Web.UI.Page> Klasse, da es nichts zum Vererben ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von alle Validierungssteuerelemente, die auf die angeforderte Seite enthalten sind.</summary>
        <value>Die Auflistung der Validierungssteuerelemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um die Methoden und Eigenschaften zu bearbeiten der <xref:System.Web.UI.ValidatorCollection> Objekt zugewiesen ist, mit dem aktuellen <xref:System.Web.UI.Page> Instanz. Diese Auflistung enthält alle Überprüfung-Serversteuerelemente, die auf einer Seite befinden.  
  
 Aufrufen der <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> Methode bewirkt, dass die Validierungslogik für die einzelnen Validierungssteuerelemente für die Server in der aktuellen Gruppe für die Validierung ausgeführt werden. Wenn eines dieser Steuerelemente nicht übergeben, die <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> -Eigenschaft gibt `false`.  
  
 Weitere Informationen über Validierungssteuerelemente finden Sie unter [ASP.NET-Validierungssteuerelementen](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Die ASP.NET-Serversteuerelement, die erforderlich ist, in der <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> Steuerelement.</param>
        <summary>Bestätigt, dass ein <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> Steuerelement für das angegebene Serversteuerelement von ASP.NET zur Laufzeit gerendert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelemente, die erforderlich sind, innerhalb `<form runat=server>` Tags können diese Methode aufrufen, bevor sie gerendert werden, sodass eine Fehlermeldung angezeigt werden, wenn sie außerhalb der Tags eingefügt werden. Steuerelemente, die registrierten Skriptblöcke abhängig sind oder zurücksenden sollten diese Methode in einer Überschreibung von Aufrufen der <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> Methode. Seiten, die eine andere Art der Server Form-Elements gerendert haben, können diese Methode zum Auslösen einer Ausnahme unter verschiedenen Bedingungen überschreiben.  
  
 Serversteuerelemente, die Postback oder Verwenden von clientseitigem Skript können nicht ausgeführt werden, wenn sie nicht, in eingeschlossen sind der <xref:System.Web.UI.HtmlControls.HtmlForm> Webserversteuerelement (<`form runat="server">`) Tags. Diese Steuerelemente können diese Methode aufrufen, wenn sie rendern eine klare Fehlermeldung bereitstellen, wenn sie nicht in eingeschlossen sind die <xref:System.Web.UI.HtmlControls.HtmlForm> Steuerelement.  
  
 Wenn Sie ein benutzerdefiniertes Steuerelement entwickeln, es ist üblich, diese Methode aufrufen, wenn Sie überschreiben die `Render` Methode für jede Art von Eingabetag. Dies ist besonders wichtig, wenn das Eingabesteuerelement ruft <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, oder wenn sie Clientskripts ausgibt. Ein zusammengesetztes Serversteuerelement muss nicht zum Ausführen dieses Aufrufs.  
  
   
  
## Examples  
 Das folgende Codebeispiel setzt die <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> Methode eines benutzerdefinierten Steuerelements. Wenn dieses Steuerelement seinen Inhalt zu einer Seite schreibt, verwendet der <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> Methode, um sicherzustellen, dass zwischen dem Start- und Endtag des Steuerelements angezeigt wird ein <xref:System.Web.UI.HtmlControls.HtmlForm> Steuerelement.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Das angegebene Serversteuerelement wird nicht zwischen dem Start- und Endtag des enthalten die <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> -Steuerelement zur Laufzeit.</exception>
        <exception cref="T:System.ArgumentNullException">Das zu überprüfende Steuerelement ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Verschlüsselungsmodus des Ansichtszustands.</summary>
        <value>Einer der <see cref="T:System.Web.UI.ViewStateEncryptionMode" />-Werte. Der Standardwert ist <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> Eigenschaft kann nicht im Code festgelegt werden. Er kann nur festgelegt werden, in der Anweisung oder in der < Element der Konfigurationsdatei. Werte festlegen in der Richtlinie überschreiben alle Werte in der Konfigurationsdatei festgelegt.  
  
 Die Syntax zum Festlegen dieser Eigenschaft in der Direktive lautet wie folgt:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 Die Syntax zum Festlegen dieser Eigenschaft in der Konfigurationsdatei lautet wie folgt:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Entwickler von benutzerdefinierten Steuerelementen möchten möglicherweise den Wert dieser Eigenschaft im Code zu überprüfen, vor dem Speichern der potenziell vertraulicher Daten im Steuerelement Ansichtszustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte Wert ist nicht Mitglied der <see cref="T:System.Web.UI.ViewStateEncryptionMode" /> Enumeration.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> Eigenschaft kann festgelegt werden, nur in oder vor der Seite <see langword="PreRender" /> phase im Lebenszyklus Seite.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Weist einen Bezeichner zu einem einzelnen Benutzer in der Ansichtszustand-Variablen, die mit der aktuellen Seite verknüpft ist.</summary>
        <value>Der Bezeichner für die einzelnen Benutzer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der <xref:System.Web.UI.Page.ViewStateUserKey%2A> Eigenschaft können Sie die für die Anwendung von böswilligen Benutzern-Angriffe zu verhindern. Hierzu können Sie einen Bezeichner mit der Variablen Ansichtszustand für einzelne Benutzer zuweisen, damit sie die Variable nicht verwenden können, um einen Angriff zu generieren. Weitere Informationen über Web-Angriffe und was Sie tun können, um Hilfe zu verhindern, dass finden Sie unter [dauern Vorteil von ASP.NET integrierte Funktionen zum Webangriffen](http://go.microsoft.com/fwlink/?LinkId=163557).  
  
 Diese Eigenschaft kann auf jeden Zeichenfolgenwert festgelegt werden, z. B. dem authentifizierten Namen des Benutzers oder der <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> Wert.  
  
> [!NOTE]
>  Sie müssen diese Eigenschaft beim Festlegen der `Page_Init` Phase der Verarbeitung der Seite. Durch Festlegen dieser Eigenschaft während der `Page_Load` Phase löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Die <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> Eigenschaft während der Verarbeitung der Seite zu spät zugegriffen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die <see cref="T:System.Web.UI.Page" /> Objekt gerendert wird.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Web.UI.Page" /> werden gerendert; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Web.UI.Page.Visible%2A> Eigenschaft `false` um den gerenderten Inhalt einer Seite auszublenden. Wenn diese Seite zuerst angefordert wird, wird eine Datenquelle aufgefüllt, auf der Seite angezeigt. Wenn ein Benutzer die Schaltfläche klickt der `HideButton_Click` Ereignishandler Blendet den gesamten Inhalt der Seite gerendert.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
