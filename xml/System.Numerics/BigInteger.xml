<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>2.3.98.1</AssemblyVersion>
    <AssemblyVersion>3.98.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine beliebig große ganze Zahl mit Vorzeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger> Typ ist ein unveränderlicher Typ, der eine beliebig große ganze Zahl darstellt, dessen Wert theoretisch keine oberen und unteren Grenzen hat. Die Mitglieder der <xref:System.Numerics.BigInteger> -Typs ähneln im Wesentlichen denen der anderen ganzzahligen Typen (die <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, und <xref:System.UInt64> Typen). Dieser Typ unterscheidet sich von der anderen ganzzahligen Typen in der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], wofür einen Bereich von ihren `MinValue` und `MaxValue` Eigenschaften.  
  
> [!NOTE]
>  Da die <xref:System.Numerics.BigInteger> Typ ist unveränderlich (finden Sie unter [Veränderlichkeit und BigInteger-Struktur](#mutability)) und da er keine oberen und unteren Grenzen hat ein <xref:System.OutOfMemoryException> ausgelöst werden kann, für jeden Vorgang, der bewirkt, dass ein <xref:System.Numerics.BigInteger> Wert zu vergrößern. große.  
  
## <a name="instantiating-a-biginteger-object"></a>Instanziieren eines BigInteger-Objekts  
 Instanziieren Sie ein <xref:System.Numerics.BigInteger> Objekt auf verschiedene Weise:  
  
-   Sie können die `new` Schlüsselwort, und geben Sie einen beliebigen ganzzahligen oder Gleitkomma-Wert als Parameter an die <xref:System.Numerics.BigInteger> Konstruktor. (Gleitkommawerte werden abgeschnitten, bevor sie zugewiesen sind die <xref:System.Numerics.BigInteger>.) Das folgende Beispiel zeigt, wie die `new` Schlüsselwort instanziieren <xref:System.Numerics.BigInteger> Werte.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Sie können Deklarieren einer <xref:System.Numerics.BigInteger> Variable und weisen Sie ein Wert an, wie Sie würden alle numerischen Typen, solange dieser Wert einen ganzzahligen Typ ist. Im folgenden Beispiel wird die Zuordnung zum Erstellen einer <xref:System.Numerics.BigInteger> Wert aus einer <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Sie können einen Wert decimal "oder" Gleitkomma Zuweisen einer <xref:System.Numerics.BigInteger> Objekt, wenn Sie den Wert wandelt, oder konvertieren Sie ihn zuerst. Im folgenden Beispiel explizit umgewandelt (in c#) oder (in Visual Basic) konvertiert eine <xref:System.Double> und ein <xref:System.Decimal> -Wert in einen <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Diese Methoden ermöglichen es Ihnen, beim Instanziieren einer <xref:System.Numerics.BigInteger> Objekt, dessen Wert im Bereich eines der vorhandenen numerischen nur Typen. Instanziieren Sie ein <xref:System.Numerics.BigInteger> Objekt, dessen Wert den Bereich der vorhandenen numerischen Typen in einer von drei Methoden überschreiten kann:  
  
-   Können Sie die `new` Schlüsselwort, und geben Sie ein Bytearray von beliebiger Größe für den <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> Konstruktor. Zum Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Sie erreichen die <xref:System.Numerics.BigInteger.Parse%2A> oder <xref:System.Numerics.BigInteger.TryParse%2A> Methoden konvertiert die Zeichenfolgendarstellung einer Zahl in eine <xref:System.Numerics.BigInteger>. Zum Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Sie erreichen eine `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> Methode, die einen Vorgang für einen numerischen Ausdruck ausführt, und gibt einen berechneten <xref:System.Numerics.BigInteger> Ergebnis. Im folgende Beispiel wird dies durch cuberstellung <xref:System.UInt64.MaxValue?displayProperty=nameWithType> und erneute Zuordnen des Ergebnisses an eine <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Der nicht initialisierte Wert, der eine <xref:System.Numerics.BigInteger> ist <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Ausführen von Vorgängen für BigInteger-Werte  
 Sie können eine <xref:System.Numerics.BigInteger> Instanz wie alle anderen ganzzahligen Typs verwenden. <xref:System.Numerics.BigInteger>Überladungen die standardmäßigen numerischen Operatoren, damit Sie grundlegende mathematische Operationen wie Addition, Subtraktion, Division, Multiplikation, Subtraktion, Negation und unäre Negation ausführen können. Sie können auch die standardmäßigen numerischen Operatoren Vergleichen zweier <xref:System.Numerics.BigInteger> Werte miteinander. Wie die anderen ganzzahligen Typen <xref:System.Numerics.BigInteger> unterstützt auch das bitweise `And`, `Or`, `XOr`, linke UMSCHALTTASTE und right Shift-Operatoren. Für Sprachen, die keine benutzerdefinierte Operatoren unterstützen die <xref:System.Numerics.BigInteger> Struktur bietet auch entsprechende Funktionen zur Durchführung von mathematischer Operations. Dazu gehören <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, und einigen weiteren Bildschirmen.  
  
 Viele Elemente der der <xref:System.Numerics.BigInteger> Struktur entsprechen direkt Membern der anderen ganzzahligen Typen. Darüber hinaus <xref:System.Numerics.BigInteger> fügt z. B. die folgenden Elemente:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, einen Wert, der das Vorzeichen des gibt an, womit eine <xref:System.Numerics.BigInteger> Wert.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, womit der Absolute Wert des einem <xref:System.Numerics.BigInteger> Wert.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, die den Quotienten und den Rest einer Division zurückgibt.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, womit den größten gemeinsamen Teiler zweier <xref:System.Numerics.BigInteger> Werte.  
  
 Viele dieser zusätzlichen Member entsprechen den Elementen von der <xref:System.Math> Klasse, die die Funktionen zum Arbeiten mit den primitiven numerischen Typen bereitstellt.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Veränderlichkeit und BigInteger-Struktur  
 Das folgende Beispiel instanziiert einen <xref:System.Numerics.BigInteger> Objekt, und klicken Sie dann seinen Wert um eins erhöht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Obwohl in diesem Beispiel wird zum Ändern des Werts des vorhandenen Objekts angezeigt werden, ist dies nicht der Fall. <xref:System.Numerics.BigInteger>-Objekte sind unveränderlich, d. h., intern, die common Language Runtime tatsächlich erstellt ein neues <xref:System.Numerics.BigInteger> Objekt, und weist ihr den Wert eins größer als der vorherige Wert. Dieses neue Objekt wird dann an den Aufrufer zurückgegeben.  
  
> [!NOTE]
>  Die numerischen Typen in .NET Framework sind auch unveränderlich. Jedoch, da die <xref:System.Numerics.BigInteger> Typ verfügt über keine oberen und unteren Grenzen, dessen Werte sehr groß und messbaren Auswirkungen auf die Leistung haben können.  
  
 Obwohl dieser Prozess an den Aufrufer transparent ist, es eine Leistungseinbußen. In einigen Fällen, insbesondere wenn wiederholte Vorgänge ausgeführt werden in einer Schleife sehr große <xref:System.Numerics.BigInteger> Werte, diese Leistungseinbußen kann sehr erheblich sein. Z. B. im folgenden Beispiel ein Vorgang wird wiederholt bis zu eine Millionen Mal ausgeführt, und ein <xref:System.Numerics.BigInteger> Wert wird um eins erhöht, jedes Mal, wenn der Vorgang erfolgreich ist.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 In diesem Fall können Sie die Leistung verbessern, indem ausführen alle intermediate Zuweisungen zu einer <xref:System.Int32> Variable. Kann der endgültige Wert der Variable dann zugewiesen werden die <xref:System.Numerics.BigInteger> Objekt, wenn die Schleife beendet wird. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Arbeiten mit Bytearrays und Hexadezimalzeichenfolgen  
 Konvertieren von <xref:System.Numerics.BigInteger> Werte auf Bytearrays oder Byte-Arrays zum Konvertieren von <xref:System.Numerics.BigInteger> Werte, berücksichtigen Sie die Reihenfolge der Bytes. Die <xref:System.Numerics.BigInteger> Struktur erwartet, dass die einzelnen Bytes in einem Bytearray in little-Endian-Reihenfolge angezeigt werden (d. h. die niederwertigen Bytes des Wertes vor stehen die höherwertigen Bytes). Sie können einen Roundtrip eine <xref:System.Numerics.BigInteger> -Wert durch Aufrufen der <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode und übergeben das resultierende Byte-array an die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Instanziiert eine <xref:System.Numerics.BigInteger> Wert aus einem Bytearray, das einen Wert eines anderen ganzzahligen Typs darstellt, können Sie den ganzzahligen Wert zu übergeben der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> Methode, und klicken Sie dann das resultierende Bytearray, übergeben die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor. Das folgende Beispiel instanziiert einen <xref:System.Numerics.BigInteger> Wert aus einem Bytearray, das darstellt ein <xref:System.Int16> Wert.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger> Struktur wird davon ausgegangen, dass negative Werte gespeichert werden, mithilfe der zwei Komplement Darstellung. Da die <xref:System.Numerics.BigInteger> Struktur stellt einen numerischen Wert ohne feste Länge der <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor immer das höchstwertige Bit des letzten Bytes im Array als Vorzeichenbit interpretiert. Um zu verhindern, dass die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor aus verwirrend erscheinen die beiden Komplement Darstellung eines negativen Werts durch die Zeichen und Größe Darstellung des einen positiven Wert positive Werte in der die meisten niederwertigste Bit des letzten Bytes im Bytearray wäre normalerweise sollte eine zusätzliche Byte, dessen Wert 0 ist, enthalten. Beispielsweise 0xC0 0xBD 0xF0 0xFF ist die hexadezimale Darstellung der little-Endian--1,000,000 oder 4,293,967,296. Da das höchstwertige Bit des letzten Bytes im Array auf ist, würde der Wert des Bytearrays von interpretiert werden die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor als-1.000.000. Beim Instanziieren einer <xref:System.Numerics.BigInteger> , dessen Wert positiv ist, wird ein Byte-Array, dessen Elemente 0xC0, 0xBD 0xF0 0xFF 0x00 muss an den Konstruktor übergeben werden. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Bytearrays erstellt, indem die <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode von positive Werte enthalten, diese Byte zusätzlichen NULL-Wert. Aus diesem Grund die <xref:System.Numerics.BigInteger> Struktur können erfolgreich in Werte, indem sie zum zuweisen, und klicken Sie dann wiederhergestellt werden diese Bytearrays, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Allerdings müssen Bytearrays dieses zusätzliche Byte mit dem Wert 0 (null) hinzugefügt werden, die dynamisch vom Entwickler erstellt werden oder durch Methoden, die ganze Zahlen ohne Vorzeichen in Bytearrays konvertieren zurückgegeben werden (z. B. <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, und <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Bei der Analyse einer hexadezimalen Zeichenfolge, die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> und <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methoden angenommen, wenn das höchstwertige Bit des ersten Bytes in der Zeichenfolge festgelegt ist, oder wenn die erste hexadezimale Ziffer der Zeichenfolge die unteren vier Bits eines Bytewerts darstellt, der Wert ist Mithilfe der zwei Komplement-Darstellung dargestellt. Zum Beispiel darstellen "FF01" und "F01" den Dezimalwert-255 dar. Um positive von negativen Werten zu unterscheiden, sollte positive Werte eine führende 0 (null) enthalten. Die entsprechenden Überladungen der <xref:System.Numerics.BigInteger.ToString%2A> Methode, wenn sie die Formatzeichenfolge "X" übergeben werden, fügen eine führende 0 auf die zurückgegebenen hexadezimale Zeichenfolge für positive Werte zulässig sind. Auf diese Weise für den roundtripvorgang <xref:System.Numerics.BigInteger> Werte mithilfe der <xref:System.Numerics.BigInteger.ToString%2A> und <xref:System.Numerics.BigInteger.Parse%2A> Methoden, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Jedoch die Hexadezimalzeichenfolgen erstellt durch Aufrufen der `ToString` der anderen ganzzahligen Typen oder Überladungen der Methoden der <xref:System.Convert.ToString%2A> Methode, die implizit enthalten eine `toBase` Parameter nicht angegeben wird, die Vorzeichen des Werts oder der Quelldatentyp aus dem die hexadezimale Zeichenfolge abgeleitet wurde. Instanziieren erfolgreich eine <xref:System.Numerics.BigInteger> Wert von solch eine Zeichenfolge erfordert zusätzliche Logik. Das folgende Beispiel veranschaulicht eine mögliche Implementierung.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array der Bytewerte in Little-Endian-Reihenfolge.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur mit den Werten in einem Bytearray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes in den `value` Array sollte in der little-Endian-Reihenfolge, Byte der niedrigsten zum höchsten Byte sein. Der numerische Wert 1.000.000.000.000 wird beispielsweise dargestellt, wie in der folgenden Tabelle dargestellt:  
  
|||  
|-|-|  
|Hexadezimale Zeichenfolge|E8D4A51000|  
|Byte-Array (niedrigste zuerst index)|00 10 A5 D4 E8 00|  
  
 Die meisten Methoden, die numerische Werte in Bytearrays, z. B. konvertieren <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> und <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, Bytearrays in little-Endian-Reihenfolge zurück.  
  
 Der Konstruktor erwartet positive Werte zulässig sind, in der das Bytearray, das Vorzeichen-Wert-Darstellung und negative Werte verwenden, um zwei des Komplement Darstellung verwenden. Das heißt, wenn es sich bei der das höchstwertige Byte in der höchsten bit `value` festgelegt ist, wird das resultierende <xref:System.Numerics.BigInteger> Wert ist negativ. Abhängig von der Quelle des Bytearrays kann dies dazu führen, dass einen positiven Wert als einen negativen Wert fehlinterpretiert werden. Bytearrays werden i. d. r. folgendermaßen generiert:  
  
-   Durch Aufrufen der <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> Methode. Da diese Methode ein Bytearray mit dem höchsten Bit das höchstwertige Byte im Array Satz auf 0 für positive Werte zurückgibt, ist gibt es keine Chance Formatelementen einen positiven Wert als negativ. Unverändert bleiben sollen Bytearrays erstellt, indem die <xref:System.Numerics.BigInteger.ToByteArray%2A> Methode immer erfolgreich zurückkonvertiert, wenn es sich bei der Übergabe an die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und eine Ganzzahl mit Vorzeichen als Parameter übergeben. Da Ganzzahlen mit Vorzeichen Vorzeichen-Wert-Darstellung und zwei der Komplement Darstellung zu behandeln, besteht keine Chance Formatelementen einen positiven Wert als negativ.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und eine Ganzzahl ohne Vorzeichen als Parameter übergeben. Da Ganzzahlen ohne Vorzeichen, die nur durch ihre Größe dargestellt werden, können positive Werte als negative Werte fehlinterpretiert werden. Um diese Fehlinterpretation zu verhindern, können Sie bis zum Ende des Arrays einen NULL-Byte-Wert hinzufügen. Im Beispiel im nächsten Abschnitt veranschaulicht.  
  
-   Durch Erstellen eines Bytearrays entweder dynamisch oder statisch ohne unbedingt Aufrufen einer der vorherigen Methoden oder Ändern eines vorhandenen Bytearrays. Um zu verhindern, dass positive Werte als negative Werte fehlinterpretiert wird, können Sie bis zum Ende des Arrays einen NULL-Byte-Wert hinzufügen.  
  
 Wenn `value` ist eine leere <xref:System.Byte> Array, das neue <xref:System.Numerics.BigInteger> -Objekt initialisiert wird, auf den Wert <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Wenn `value` ist `null`, löst der Konstruktor ein <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert einen <xref:System.Numerics.BigInteger> Objekt aus, dessen Wert {5, 4, 3, 2, 1} einem Bytearray auf 5-Element. Es zeigt dann die <xref:System.Numerics.BigInteger> als dezimaler und hexadezimaler Ziffern in der Konsole dargestellten Wert. Ein Vergleich des Eingabearrays mit der Textausgabe macht verdeutlichen, warum diese Überladung von der <xref:System.Numerics.BigInteger> Klassenkonstruktor erstellt ein <xref:System.Numerics.BigInteger> Objekt, dessen Wert 4328719365 (oder 0 x 102030405). Das erste Element des Bytearrays, dessen Wert 5 ist, definiert den Wert von der niedrigsten Ordnung Byte der <xref:System.Numerics.BigInteger> -Objekt, das 0 x 05 fungiert. Das zweite Element des Bytearrays, dessen Wert 4 ist, definiert den Wert, der das zweite Byte der <xref:System.Numerics.BigInteger> -Objekt, das 0 x 04 fungiert und So weiter.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Im folgenden Beispiel wird eine Positive und Negative <xref:System.Numerics.BigInteger> -Wert, übergibt sie an der <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode, und klicken Sie dann die ursprüngliche wiederhergestellt <xref:System.Numerics.BigInteger> Werte aus dem resultierenden Bytearray. Beachten Sie, dass die beiden Werte durch identische Bytearrays dargestellt werden. Der einzige Unterschied zwischen ihnen wird in das höchstwertige Bit des letzten Elements im Bytearray. Dieses Bit ist festgelegt (der Wert des Bytes ist 0xFF), bei der Erstellung des Arrays von eine Negative <xref:System.Numerics.BigInteger> Wert. Das Bit nicht festgelegt ist (der Wert des Bytes ist 0 (null)), bei der Erstellung des Arrays von einem positiven <xref:System.Numerics.BigInteger> Wert.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Das folgende Beispiel veranschaulicht, wie Sie sicherstellen, dass ein positiver Wert nicht nicht ordnungsgemäß als ein negativer Wert instanziiert wird durch Hinzufügen von ein Byte, dessen Wert auf 0 (null) bis zum Ende des Arrays ist.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Eine Dezimalzahl.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur unter Verwendung einer <see cref="T:System.Decimal" /> Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis des Aufrufs dieser Konstruktor ist identisch mit dem expliziten Zuweisen einer <xref:System.Decimal> -Wert in einen <xref:System.Numerics.BigInteger> Variable.  
  
 Dieser Konstruktor aufrufen, kann zu Datenverlust führen; Jeder Bruchteil des `value` wird abgeschnitten, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt. Definiert ein Array von <xref:System.Decimal> Werte und übergibt dann jedes einzelnen Werts der <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor. Beachten Sie, dass die <xref:System.Decimal> Wert abgeschnitten und nicht gerundet wird, wenn er zugewiesen wurde die <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit doppelter Genauigkeit.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur mit einem Gleitkommawert mit doppelter Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Bruchteil der `value` Parameter wird abgeschnitten, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt.  
  
 Aufgrund des Mangels an Genauigkeit von der <xref:System.Double> -Datentyp, der Aufruf dieses Konstruktors kann dazu führen, dass Daten verloren gehen.  
  
 Die <xref:System.Numerics.BigInteger> -Wert, der aus der Aufruf dieses Konstruktors ist identisch mit dem Wert, der explizit zugewiesen führt eine <xref:System.Double> -Wert an ein <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt. Es veranschaulicht auch den Verlust an Genauigkeit, die auftreten können, bei der Verwendung der <xref:System.Double> -Datentyp. Ein <xref:System.Double> erhält einen hohen Wert fest, der dann zugewiesen wird ein <xref:System.Numerics.BigInteger> Objekt. Die Ausgabe zeigt, dass diese Zuweisung ein Genauigkeitsverlust umfasst. Beide Werte werden dann um eins erhöht. Die Ausgabe zeigt, dass die <xref:System.Numerics.BigInteger> Objekt gibt den geänderten Wert wieder, während die <xref:System.Double> Objekt verweist, das nicht.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NaN" />.  
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NegativeInfinity" />.  
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Eine 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur mit einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt kein Verlust der Genauigkeit, beim Instanziieren einer <xref:System.Numerics.BigInteger> Objekt die Verwendung dieses Konstruktors.  
  
 Die <xref:System.Numerics.BigInteger> -Wert, der aus der Aufruf dieses Konstruktors ist identisch mit dem Wert, die durch das Zuweisen von entsteht eine <xref:System.Int32> -Wert an ein <xref:System.Numerics.BigInteger>.  
  
 Die <xref:System.Numerics.BigInteger> Struktur enthält keine Konstruktoren mit einem Parameter vom Typ <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, oder <xref:System.UInt16>. Allerdings die <xref:System.Int32> Typ unterstützt die implizite Konvertierung von 8-Bit- und 16-Bit-Ganzzahlen mit und ohne Vorzeichen in 32-Bit-Ganzzahlen mit Vorzeichen. Daher wird dieser Konstruktor aufgerufen, wenn `value` ist eine der folgenden vier ganzzahligen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> Konstruktor zum Instanziieren <xref:System.Numerics.BigInteger> Werte aus einem Array von 32-Bit-Ganzzahlen. Darüber hinaus implizite Konvertierung, weisen Sie jeder 32-Bit-Ganzzahlwert verwendet eine <xref:System.Numerics.BigInteger> Variable. Es vergleicht dann die beiden Werte herstellen, die das resultierende <xref:System.Numerics.BigInteger> Werte entsprechen.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur mit einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt kein Verlust der Genauigkeit, beim Instanziieren einer <xref:System.Numerics.BigInteger> Objekt die Verwendung dieses Konstruktors.  
  
 Die <xref:System.Numerics.BigInteger> -Wert, der aus der Aufruf dieses Konstruktors ist identisch mit dem Wert, die durch das Zuweisen von entsteht eine <xref:System.Int64> -Wert an ein <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> Konstruktor zum Instanziieren <xref:System.Numerics.BigInteger> Werte aus einem Array von 64-Bit-Ganzzahlen. Verwendet auch implizite Konvertierung jeder 64-Bit-Ganzzahlwert zum Zuweisen einer <xref:System.Numerics.BigInteger> Variable. Es vergleicht dann die beiden Werte herstellen, die das resultierende <xref:System.Numerics.BigInteger> Werte entsprechen.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit einfacher Genauigkeit.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur mit einem Gleitkommawert mit einfacher Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Bruchteil der `value` Parameter wird abgeschnitten, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt.  
  
 Aufgrund des Mangels an Genauigkeit von der <xref:System.Single> -Datentyp, der Aufruf dieses Konstruktors kann zu Datenverlust führen.  
  
 Die <xref:System.Numerics.BigInteger> -Wert, der aus der Aufruf dieses Konstruktors ist identisch mit dem Wert, der explizit zugewiesen führt eine <xref:System.Single> -Wert an ein <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt. Es veranschaulicht auch den Verlust an Genauigkeit, die auftreten können, bei der Verwendung der <xref:System.Single> -Datentyp. Ein <xref:System.Single> erhält einen großen negativen Wert, der dann zugewiesen wird ein <xref:System.Numerics.BigInteger> Objekt. Die Ausgabe zeigt, dass diese Zuweisung ein Genauigkeitsverlust umfasst. Beide Werte werden dann um eins erhöht. Die Ausgabe zeigt, dass die <xref:System.Numerics.BigInteger> Objekt gibt den geänderten Wert wieder, während die <xref:System.Single> Objekt verweist, das nicht.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NaN" />.  
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NegativeInfinity" />.  
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Ein 32-Bit-Ganzzahlwert ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> -Struktur mit einer 32-Bit-Ganzzahl ohne Vorzeichen-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt kein Verlust der Genauigkeit, beim Instanziieren einer <xref:System.Numerics.BigInteger> Verwendung dieses Konstruktors.  
  
 Die <xref:System.Numerics.BigInteger> -Wert, der aus der Aufruf dieses Konstruktors ist identisch mit dem Wert, die durch das Zuweisen von entsteht eine <xref:System.UInt32> -Wert an ein <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> Konstruktor und zum Initialisieren einer zuweisungsanweisung <xref:System.Numerics.BigInteger> Werte aus einem Array von 32-Bit-Ganzzahlen ohne Vorzeichen. Klicken Sie dann die zwei Werte verglichen, veranschaulicht die zwei Methoden stehen zum Initialisieren einer <xref:System.Numerics.BigInteger> Wert werden identische Ergebnisse erzielt.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Numerics.BigInteger" /> Struktur mit einem 64-Bit-Ganzzahl ohne Vorzeichen-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt kein Verlust der Genauigkeit, beim Instanziieren einer <xref:System.Numerics.BigInteger> Verwendung dieses Konstruktors.  
  
 Die <xref:System.Numerics.BigInteger> -Wert, der aus der Aufruf dieses Konstruktors ist identisch mit dem Wert, die durch das Zuweisen von entsteht eine <xref:System.UInt64> -Wert an ein <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt, dessen Wert gleich <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl.</param>
        <summary>Ruft den absoluten Wert einer <see cref="T:System.Numerics.BigInteger" /> Objekt.</summary>
        <returns>Der Absolutbetrag von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer Zahl ist diese Zahl ohne Vorzeichen, wie in der folgenden Tabelle gezeigt.  
  
|`value`Parameter|Rückgabewert|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Die <xref:System.Numerics.BigInteger.Abs%2A> Methode entspricht der <xref:System.Math.Abs%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Abs%2A> -Methode zum Konvertieren einer <xref:System.Numerics.BigInteger> Wert zwischen zwei des Komplement Darstellung und Vorzeichen-Wert-Darstellung vornehmen, bevor es in eine Datei zu serialisieren. Daten in der Datei anschließend deserialisiert und zugewiesen werden, um ein neues <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert zwei <see cref="T:System.Numerics.BigInteger" /> Werte und gibt das Ergebnis zurück.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die Überladen von Operatoren oder benutzerdefinierten Operatoren nicht unterstützen können die <xref:System.Numerics.BigInteger.Add%2A> Methode, um mithilfe der Addition ausführen <xref:System.Numerics.BigInteger> Werte.  
  
 Die <xref:System.Numerics.BigInteger.Add%2A> Methode ist ein geeigneter Ersatz für die Addition-Operator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, indem sie eine Summe, die sich aus einer Addition ergibt zuweisen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Vergleicht zwei <see cref="T:System.Numerics.BigInteger" /> Werte und gibt eine ganze Zahl, der angibt, ob der erste Wert kleiner als, gleich oder größer als der zweite Wert ist.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relativen Werte von <paramref name="left" /> und <paramref name="right" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term>Wert  
  
 </term><description>Bedingung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description><paramref name="left" /> ist kleiner als <paramref name="right" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description><paramref name="left" /> ist gleich <paramref name="right" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description><paramref name="left" /> ist größer als <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die <xref:System.Numerics.BigInteger> Typ hat keine feste Bereich, Vergleiche von <xref:System.Numerics.BigInteger> Werte sind nicht gekennzeichnet, durch das Fehlen der Genauigkeit, die den Vergleich von Gleitkommazahlen charakterisiert. Im folgenden Beispiel werden zwei <xref:System.Numerics.BigInteger> Werte, die durch und jede unterscheiden hat 1,896 Ziffern haben. Die <xref:System.Numerics.BigInteger.Compare%2A> Methode meldet ordnungsgemäß, dass die beiden Werte nicht gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl mit Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl mit Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Ganzzahl mit Vorzeichen, die die Beziehung dieser Instanz mit angibt <paramref name="other" />, wie in der folgenden Tabelle gezeigt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die aktuelle Instanz gleich <paramref name="other" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, eine <xref:System.Int64> Wert der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> -Methode aufgerufen wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Ergebnis des Aufrufs der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> Methode mit ganzzahligen Werten.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einer zweiten <see cref="T:System.Numerics.BigInteger" /> und gibt eine ganze Zahl, der angibt, ob der Wert dieser Instanz kleiner, gleich oder größer als der Wert des angegebenen Objekts zurück.</summary>
        <returns>Eine Ganzzahl mit Vorzeichen, die die Beziehung dieser Instanz mit angibt <paramref name="other" />, wie in der folgenden Tabelle gezeigt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die aktuelle Instanz gleich <paramref name="other" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Numerics.BigInteger.CompareTo%2A> Methode implementiert die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> Methode. Es wird von generischen Auflistungsobjekten verwendet, um die Elemente in der Auflistung zu sortieren.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> Methode, um eine Liste der order `StarInfo` Objekte. Jede `StarInfo` Objekt enthält Informationen über einen Stern-Name und der Entfernung von der Erde in Meilen. `StarInfo`implementiert die <xref:System.IComparable%601> Schnittstelle, wodurch `StarInfo` Objekte nach generischer Auflistungsklassen sortiert werden. Die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> -Implementierung schließt nur einen Aufruf von <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Klicken Sie dann instanziiert der folgende Code vier `StarInfo` Objekte und speichert sie in einem generischen <xref:System.Collections.Generic.List%601> Objekt. Nach der <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> -Methode aufgerufen wird, `StarInfo` Objekte werden in der Reihenfolge ihrer Entfernung von der Erde angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Ganzzahl mit Vorzeichen, die die Beziehung der aktuellen Instanz in der <paramref name="obj" /> Parameter, wie in der folgenden Tabelle gezeigt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist kleiner als <paramref name="obj" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die aktuelle Instanz gleich <paramref name="obj" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist größer als <paramref name="obj" />, oder die <paramref name="obj" /> Parameter ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Numerics.BigInteger.CompareTo%2A> Methode implementiert die <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> Methode. Es ist nicht generische Auflistung von Objekten verwendet, um die Elemente in der Auflistung zu bestellen.  
  
 Die `obj` Parameter muss einen der folgenden sein:  
  
-   Ein Objekt, dessen Typ zur Laufzeit ist <xref:System.Numerics.BigInteger>.  
  
-   Ein <xref:System.Object> Variable, deren Wert `null`. Wenn der Wert der `obj` Parameter ist `null`, die Methode gibt 1 zurück, das anzeigt, die die aktuelle Instanz größer ist `obj`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> -Methode zum Vergleichen einer <xref:System.Numerics.BigInteger> Wert, wobei jedes Element in einem Objektarray  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> ist keine <see cref="T:System.Numerics.BigInteger" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl ohne Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl ohne Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Ganzzahl mit Vorzeichen, der den relativen Wert dieser Instanz angibt und <paramref name="other" />, wie in der folgenden Tabelle gezeigt.  
  
 <list type="table"><listheader><term>Rückgabewert  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term>Kleiner als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term>0 (null)  
  
 </term><description>Die aktuelle Instanz gleich <paramref name="other" />.  
  
 </description></item><item><term>Größer als 0 (null)  
  
 </term><description>Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" /> Wert durch einen anderen und gibt das Ergebnis zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Divide%2A> -Methode führt Ganzzahldivision; die aus der Division resultiert der Rest wird verworfen. Rufen Sie zum Ausführen der ganzzahligen Division Beibehaltung den Rest der <xref:System.Numerics.BigInteger.DivRem%2A> Methode. Um nur den Restwert abzurufen, rufen Sie die <xref:System.Numerics.BigInteger.Remainder%2A> Methode.  
  
 Die <xref:System.Numerics.BigInteger.Divide%2A> Methode kann verwendet werden, von Sprachen, die Überladen von Operatoren nicht unterstützen. Das Verhalten ist identisch mit der Division mit dem Divisionsoperator.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Numerics.BigInteger> Werte. Anschließend wird jedes Element als der Quotient bei einer Division, die verwendet die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, den Divisionsoperator (/) enthält, und die <xref:System.Numerics.BigInteger.DivRem%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" />ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <param name="remainder">Enthält bei Rückgabe dieser Methode eine <see cref="T:System.Numerics.BigInteger" /> Wert, der den Rest der Division darstellt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" /> Wert durch einen anderen, gibt das Ergebnis zurück, und gibt den Rest als Ausgabeparameter zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behält den Quotienten und den Rest, der aus der ganzzahligen Division resultiert. Wenn Sie nicht den Rest interessiert sind, verwenden Sie die <xref:System.Numerics.BigInteger.Divide%2A> -Methode oder der Divisionsoperator; Wenn Sie sind nur in den übrigen "interested" Verwenden der <xref:System.Numerics.BigInteger.Remainder%2A> Methode.  
  
 Das Vorzeichen des zurückgegebenen `remainder` Wert ist identisch mit der das Vorzeichen der `dividend` Parameter.  
  
 Das Verhalten der <xref:System.Numerics.BigInteger.DivRem%2A> Methode ist identisch mit der <xref:System.Math.DivRem%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Numerics.BigInteger> Werte. Anschließend wird jedes Element als der Quotient bei einer Division, die verwendet die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, den Divisionsoperator (/) enthält, und die <xref:System.Numerics.BigInteger.DivRem%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" />ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Der Wert der 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl mit Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />Wenn die 64-Bit-Ganzzahl mit Vorzeichen und die aktuelle Instanz denselben Wert haben; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn die Methode aufgerufen wird.  
  
 Um die Beziehung zwischen den beiden Objekten statt nur Testen auf Gleichheit zu bestimmen, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert einen <xref:System.Numerics.BigInteger> Objekt aus jedem ganzzahligen Typ außer <xref:System.UInt64>. Er ruft dann die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> Methode zum Vergleichen der <xref:System.Numerics.BigInteger> Wert mit dem ursprünglichen Integer-Wert, der zum übergeben wurde die <xref:System.Numerics.BigInteger> Konstruktor. Wie die Ausgabe zeigt, sind die Werte in jedem Fall gleich.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert, der angibt, ob die aktuelle Instanz und ein angegebenes <see cref="T:System.Numerics.BigInteger" /> Objekt denselben Wert haben.</summary>
        <returns>
          <see langword="true" />Wenn diese <see cref="T:System.Numerics.BigInteger" /> Objekt und <paramref name="other" /> denselben Wert haben; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601> Schnittstelle und führt etwas bessere Leistung als <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , da sie keinen konvertieren die `other` Parameter an eine <xref:System.Numerics.BigInteger> Objekt.  
  
 Um zu bestimmen, die Beziehung zwischen den beiden <xref:System.Numerics.BigInteger> Objekte anstelle von nur Testen auf Gleichheit, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung mehrerer Sterne von der Erde mit der Entfernung von Epsilon Dateisystemeinstellung von der Erde zu bestimmen, ob sie gleich sind. Im Beispiel wird jeder Überladung der <xref:System.Numerics.BigInteger.Equals%2A> Methode auf Gleichheit.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="obj" />-Argument ein <see cref="T:System.Numerics.BigInteger" />-Objekt darstellt und dessen Wert der aktuellen <see cref="T:System.Numerics.BigInteger" />-Instanz entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `obj` Argument ist ein <xref:System.Numerics.BigInteger> -Wert, der Methodenrückgabe `false`. Gibt die Methode `true` nur, wenn `obj` ist eine <xref:System.Numerics.BigInteger> -Instanz, deren Wert gleich der aktuellen Instanz ist.  
  
 Um die Beziehung zwischen den beiden Objekten statt nur Testen auf Gleichheit zu bestimmen, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel definiert Parallel <xref:System.Object> und <xref:System.Numerics.BigInteger> Arrays. Jedes Element eines Arrays hat den gleichen Wert wie das entsprechende Element im zweiten Array. Wie die Ausgabe des Beispiels zeigt, die Instanz in der <xref:System.Numerics.BigInteger> Array gilt gleich der Instanz in der <xref:System.Object> array nur, wenn die zweite Datei ist eine <xref:System.Numerics.BigInteger> und deren Werte gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />Wenn die aktuelle Instanz und die 64-Bit-Ganzzahl ohne Vorzeichen, die denselben Wert haben; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Beziehung zwischen den beiden Objekten statt nur Testen auf Gleichheit zu bestimmen, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung mehrerer Sterne von der Erde mit der Entfernung von Epsilon Dateisystemeinstellung von der Erde zu bestimmen, ob sie gleich sind. Im Beispiel wird jeder Überladung der <xref:System.Numerics.BigInteger.Equals%2A> Methode auf Gleichheit.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für das aktuelle <see cref="T:System.Numerics.BigInteger" />-Objekt zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Sucht nach den größten gemeinsamen Teiler zweier <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Der größte gemeinsame Teiler von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der größte gemeinsame Teiler ist die größte Zahl in die beiden <xref:System.Numerics.BigInteger> Werte unterteilt werden können, ohne einen Rest zurückzugeben.  
  
 Wenn die `left` und `right` Parameter sind Zahlen ungleich 0 (null), die Methode gibt immer mindestens den Wert 1 zurück, da alle Zahlen von 1 geteilt werden können. Wenn beide Parameter NULL ist, gibt die Methode den absoluten Wert des Parameters nicht 0 (null) zurück. Wenn beide Werte NULL sind, gibt die Methode NULL zurück.  
  
> [!NOTE]
>  Berechnen den größten gemeinsamen Teiler von sehr großen Werten für `left` und `right` kann ein sehr zeitraubender Vorgang sein.  
  
 Der zurückgegebene Wert den <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> Methode ist immer positive unabhängig vom Vorzeichen der `left` und `right` Parameter.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einen Aufruf der <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> -Methode und erforderlich, die nützlichsten Informationen zur Ausnahmebehandlung eine <xref:System.ArgumentOutOfRangeException>. Das Ergebnis gibt an, dass der größte gemeinsame Teiler dieser zwei Zahlen 1 ist.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" /> Objekt ist eine gerade Zahl.</summary>
        <value>
          <see langword="true" />Wenn der Wert der <see cref="T:System.Numerics.BigInteger" /> Objekt ist eine gerade Zahl ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Annehmlichkeit, der angibt, ob ein <xref:System.Numerics.BigInteger> Wert durch zwei teilbar ist. Dies entspricht dem folgenden Ausdruck:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekt <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, gibt die Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" /> Objekt <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" />Wenn der Wert der <see cref="T:System.Numerics.BigInteger" /> Objekt <see cref="P:System.Numerics.BigInteger.One" />ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet deutlich bessere Leistung als andere Vergleiche mit einem, z. B. `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" /> Objekt ist eine Potenz von zwei.</summary>
        <value>
          <see langword="true" />Wenn der Wert der <see cref="T:System.Numerics.BigInteger" /> Objekt ist eine Potenz von zwei ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, ob ein <xref:System.Numerics.BigInteger> Wert verfügt über ein einzelnes ungleich NULL-Bit festgelegt. Dies bedeutet, dass zurückgegeben `true` Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekt 1 ist (d. h. 2<sup>0</sup>) oder eine höhere Potenz von zwei. Es gibt `false` Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekt ist 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" /> Objekt <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" />Wenn der Wert der <see cref="T:System.Numerics.BigInteger" /> Objekt <see cref="P:System.Numerics.BigInteger.Zero" />ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet deutlich bessere Leistung als `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</summary>
        <returns>Der natürliche (Basis <see langword="e" />) Logarithmus <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" gezeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter wird als Zahl zur Basis 10 angegeben.  
  
 Der genaue zurückgeben dieser Methode hängt das Vorzeichen des `value`, wie in die folgende Tabelle dargestellt.  
  
|Signieren von `value` Parameter|Rückgabewert|  
|-------------------------------|------------------|  
|Positiv|Der natürliche Logarithmus des `value`; d. h. ln `value`, oder der Protokolldatei e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativ|<xref:System.Double.NaN>.|  
  
 Der Logarithmus zur Basis 10 Berechnen einer <xref:System.Numerics.BigInteger> -Wert, rufen Sie die <xref:System.Numerics.BigInteger.Log10%2A> Methode. Um den Logarithmus einer Zahl in einem anderen zu berechnen, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> Methode.  
  
 Sie finden die Quadratwurzel einer Zahl durch Aufrufen der <xref:System.Numerics.BigInteger.Log%2A> Methode zusammen mit der <xref:System.Math.Exp%2A?displayProperty=nameWithType> Methode. Beachten Sie, dass das Ergebnis <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ist das Ergebnis größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>. Das folgende Beispiel berechnet die Quadratwurzel jedes Elements in ein Array von <xref:System.Numerics.BigInteger> Werte.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Diese Methode entspricht der <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der natürliche Logarithmus von <paramref name="value" /> liegt außerhalb des Bereichs der <see cref="T:System.Double" /> -Datentyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <param name="baseValue">Die Basis des Logarithmus.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</summary>
        <returns>Die Basis <paramref name="baseValue" /> Logarithmus <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" gezeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` und `baseValue` Parameter werden als Zahlen zur Basis 10 angegeben.  
  
 Der genaue Rückgabewert Wert der Methode hängt von der das Vorzeichen `value` und für die Anmeldung und der Wert `baseValue`, wie in die folgende Tabelle dargestellt.  
  
|`value`Parameter|`baseValue`Parameter|Rückgabewert|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) – oder – (`baseValue` > 1)|LogbaseValue (`value`)|  
|`value` < 0|(beliebiger Wert)|<xref:System.Double?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` < 0|<xref:System.Double?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double?displayProperty=nameWithType>|<xref:System.Double?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = <xref:System.Double?displayProperty=nameWithType>|<xref:System.Double?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = 1|<xref:System.Double?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Der Logarithmus zur Basis 10 Berechnen einer <xref:System.Numerics.BigInteger> -Wert, rufen Sie die <xref:System.Numerics.BigInteger.Log10%2A> Methode. Um den natürlichen Logarithmus einer Zahl zu berechnen, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> Methode.  
  
 Diese Methode entspricht der <xref:System.Math.Log%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das Protokoll <paramref name="value" /> liegt außerhalb des Bereichs der <see cref="T:System.Double" /> -Datentyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</summary>
        <returns>Der Logarithmus zur Basis 10 <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" gezeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter wird als Zahl zur Basis 10 angegeben.  
  
 Der genaue Rückgabewert Wert der Methode hängt von der das Vorzeichen `value`, wie in die folgende Tabelle dargestellt.  
  
|Vorzeichen von "Value"-Parameter|Rückgabewert|  
|-----------------------------|------------------|  
|Positiv|Der Logarithmus zur Basis 10 von `value`; d. h. log10`value`.|  
|Zero|<xref:System.Double?displayProperty=nameWithType>.|  
|Negativ|<xref:System.Double?displayProperty=nameWithType>.|  
  
 Berechnet den natürlichen Logarithmus einer <xref:System.Numerics.BigInteger> -Wert, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Methode. Um den Logarithmus einer Zahl in einem anderen zu berechnen, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> Methode.  
  
 Diese Methode entspricht der <xref:System.Math.Log10%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Logarithmus zur Basis 10 von <paramref name="value" /> liegt außerhalb des Bereichs der <see cref="T:System.Double" /> -Datentyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt die größere von zwei <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Die <paramref name="left" /> oder <paramref name="right" /> Parameter, welcher Wert größer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Max%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Max%2A> aufzurufende Methode wählen Sie die größte Zahl in einem Array von <xref:System.Numerics.BigInteger> Werte.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt die kleinere von zwei <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Die <paramref name="left" /> oder <paramref name="right" /> Parameter, welcher Wert kleiner ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Min%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Min%2A> aufzurufende Methode wählen Sie die kleinste Zahl in einem Array von <xref:System.Numerics.BigInteger> Werte.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl -1 darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert -1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.MinusOne%2A> Eigenschaft wird verwendet, um den Vergleich ein <xref:System.Numerics.BigInteger> Wert auf-1 oder Zuweisen von-1 an, um eine <xref:System.Numerics.BigInteger> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Anzahl an die <c>Exponenten</c> Power.</param>
        <param name="exponent">Der Exponent zum Auslösen von <c>Wert</c> durch.</param>
        <param name="modulus">Die Anzahl durch die dividiert <c>Wert</c> potenziert mit der <c>Exponenten</c> Power.</param>
        <summary>Führt eine Modulodivision für eine zur Potenz einer anderen Zahl erhobene Zahl aus.</summary>
        <returns>Der Rest der Division <paramref name="value" /> <sup>Exponenten</sup> von <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ModPow%2A> Methode wertet der folgende Ausdruck:  
  
 (BaseValue ^ Exponent) MOD-Modulo  
  
 Zum Ausführen von Potenzierung für <xref:System.Numerics.BigInteger> Werte ohne Modulo-Division verwenden die <xref:System.Numerics.BigInteger.Pow%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel bietet eine einfache Veranschaulichung eines Aufrufs der <xref:System.Numerics.BigInteger.ModPow%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Die erste zu multiplizierende Zahl.</param>
        <param name="right">Die zweite zu multiplizierende Zahl.</param>
        <summary>Gibt das Produkt von zwei <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Multiply%2A> Methode ist für Sprachen, die Überladen von Operatoren nicht unterstützen, implementiert. Das Verhalten ist identisch mit der Multiplikation mit der Multiplikationsoperator. Darüber hinaus die <xref:System.Numerics.BigInteger.Multiply%2A> Methode ist ein geeigneter Ersatz für den Multiplikationsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, indem sie ein Produkt, das aus einer Multiplikation ergibt zuweisen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Wenn erforderlich, führt diese Methode automatisch implizite Konvertierung eines anderen ganzzahligen Typen zu <xref:System.Numerics.BigInteger> Objekte. Dies wird im Beispiel im nächsten Abschnitt veranschaulicht, in dem die <xref:System.Numerics.BigInteger.Multiply%2A> -Methode übergeben zwei <xref:System.Int64> Werte.  
  
   
  
## Examples  
 Im folgenden Beispiel wird versucht, die Multiplikation mit zwei langen ganzen Zahlen ausgeführt. Da das Ergebnis des Bereichs einer langen ganzen Zahl überschreitet eine <xref:System.OverflowException> ausgelöst wird, und die <xref:System.Numerics.BigInteger.Multiply%2A> Methode wird aufgerufen, um die Multiplikation zu behandeln. Beachten Sie, dass c# setzt voraus, dass Sie beide verwenden den `checked` Schlüsselwort (wie in diesem Beispiel) oder die `/checked+` Compileroption, um sicherzustellen, dass bei einem numerischen Überlauf eine Ausnahme ausgelöst.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Das Ergebnis der <paramref name="value" /> Parameter multipliziert mit minus eins (1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negation erhält die Additive Inverse einer Zahl. Die Additive Inverse einer Zahl ist eine Zahl, die einen Wert von 0 (null) erzeugt, wenn die ursprüngliche Nummer hinzugefügt wird.  
  
 Die <xref:System.Numerics.BigInteger.Negate%2A> Methode ist für Sprachen, die keine benutzerdefinierte Operatoren unterstützen implementiert. Das Verhalten ist identisch mit den unären Negationsoperator Negation. Darüber hinaus die <xref:System.Numerics.BigInteger.Negate%2A> Methode ist ein geeigneter Ersatz für den Negationsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die drei Möglichkeiten, um den Wert des Negieren einer <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl 1 darstellt.</summary>
        <value>Ein Objekt, dessen Wert 1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.One%2A> Eigenschaft wird normalerweise verwendet, um Vergleichen einer <xref:System.Numerics.BigInteger> Wert auf 1 oder Zuweisen von 1 bis eine <xref:System.Numerics.BigInteger> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert die Werte von zwei angegebenen <see cref="T:System.Numerics.BigInteger" /> Objekte.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Addition%2A> Methode definiert die Additionsoperation für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Add%2A> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt ein bitweises <see langword="And" /> -Operation für zwei <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Das Ergebnis des bitweisen <see langword="And" /> Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> -Methode definiert die bitweise `And` Vorgang für <xref:System.Numerics.BigInteger> Werte. Der bitweise `And` Vorgang legt ein Ergebnis nur fest, wenn die entsprechenden Bits in `left` und `right` werden festgelegt, wie in der folgenden Tabelle gezeigt.  
  
|Bit`left`|Bit`right`|Bit im Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Methode führt die bitweise `And` -Operation für zwei <xref:System.Numerics.BigInteger> Werte, als wären sie sowohl in der zwei Komplement Darstellung mit virtuellen vorzeichenerweiterung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt ein bitweises <see langword="Or" /> -Operation für zwei <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Das Ergebnis des bitweisen <see langword="Or" /> Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> -Methode definiert die bitweise `Or` Vorgang für <xref:System.Numerics.BigInteger> Werte. Der bitweise `Or` Vorgang legt ein Ergebnis nur fest, wenn eines oder beide der entsprechenden Bits in `left` und `right` festgelegt sind, wie in der folgenden Tabelle gezeigt.  
  
|Bit`left`|Bit`right`|Bit im Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Methode führt die bitweise `Or` -Operation für zwei <xref:System.Numerics.BigInteger> Werte, als wären sie sowohl in der zwei Komplement Darstellung mit virtuellen vorzeichenerweiterung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu dekrementierende Wert.</param>
        <summary>Dekrementiert eine <see cref="T:System.Numerics.BigInteger" /> -Wert um 1.</summary>
        <returns>Der Wert der <paramref name="value" /> Parameter um 1 verringert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Decrement%2A> Methode definiert, der dekrementvorgang für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Subtract%2A> Methode stattdessen. Zum Beispiel:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Da <xref:System.Numerics.BigInteger> Objekte sind unveränderlich, die <xref:System.Numerics.BigInteger.op_Decrement%2A> Operator erstellt ein neues <xref:System.Numerics.BigInteger> Objekt, dessen Wert ist, kleiner als das <xref:System.Numerics.BigInteger> dargestellte Objekt `value`. Das bedeutet, die wiederholte Aufrufe <xref:System.Numerics.BigInteger.op_Decrement%2A> stark beanspruchen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert eine angegebene <see cref="T:System.Numerics.BigInteger" /> Wert durch einen anderen angegebenen <see cref="T:System.Numerics.BigInteger" /> Wert mithilfe der ganzzahligen Division.</summary>
        <returns>Das ganzzahlige Ergebnis der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Division%2A> Methode definiert die Divisionsoperation für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Sprachen, die benutzerdefinierte Operatoren und Überladen von Operatoren nicht unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Divide%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist.<xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Numerics.BigInteger> Werte. Anschließend wird jedes Element als der Quotient bei einer Division, die verwendet die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, den Divisionsoperator (/) enthält, und die <xref:System.Numerics.BigInteger.DivRem%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" />ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine lange Ganzzahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" /> Wert gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Methode definiert, die Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Instanzmethode stattdessen.  
  
 Wenn `left` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert und einen Wert mit Vorzeichen long integer-Wert gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Methode definiert, die Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Instanzmethode stattdessen.  
  
 Wenn `right` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob die Werte von zwei <see cref="T:System.Numerics.BigInteger" /> -Objekte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Methode definiert, den Vorgang des Gleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Instanzmethode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert "und" unsigned long Integer-Wert gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Methode definiert, die Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Instanzmethode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob unsigned long Integer-Wert und ein <see cref="T:System.Numerics.BigInteger" /> Wert gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Methode definiert, die Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Instanzmethode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise exklusive <see langword="Or" /> (<see langword="XOr" />)-Operation für zwei <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Das Ergebnis des bitweisen <see langword="Or" /> Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis einer bitweisen exklusiven `Or` Vorgang ist `true` , wenn die Werte von zwei Bits optional, andernfalls sind, ist es `false`. Die folgende Tabelle zeigt die exklusive `Or` Vorgang.  
  
|Bit x in`left`|Bit x in`right`|Rückgabewert|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Methode führt die bitweise exklusive `Or` -Operation für zwei <xref:System.Numerics.BigInteger> Werte, als wären sie sowohl in der zwei Komplement Darstellung mit virtuellen vorzeichenerweiterung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> -Objekt an eine <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Bruchteil der `value` Parameter vor der Konvertierung abgeschnitten wird.

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Decimal> auf <xref:System.Numerics.BigInteger> können zwar Abschneiden Nachkommastellen der `value`, Sprachcompiler Ausführen dieser Konvertierung nicht automatisch. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.   

 Für Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 Das folgende Beispiel konvertiert die einzelnen Elemente in einem Array von <xref:System.Decimal> Werte <xref:System.Numerics.BigInteger> Objekte, und klicken Sie dann das Ergebnis jeder Konvertierung angezeigt. Beachten Sie, dass jeder Bruchteil Teil einer <xref:System.Decimal> Wert wird bei der Konvertierung abgeschnitten.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Double" /> -Wert in einen <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Bruchteil der `value` Parameter vor der Konvertierung abgeschnitten wird.

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Double> auf <xref:System.Numerics.BigInteger> können zwar Abschneiden Nachkommastellen der `value`, Sprachcompiler Ausführen dieser Konvertierung nicht automatisch. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.

 Für Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 Das folgende Beispiel konvertiert die einzelnen Elemente in einem Array von <xref:System.Double> Werte <xref:System.Numerics.BigInteger> Objekte, und klicken Sie dann das Ergebnis jeder Konvertierung angezeigt. Beachten Sie, dass jeder Bruchteil Teil einer <xref:System.Double> Wert wird bei der Konvertierung abgeschnitten.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NaN" />.  
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.PositiveInfinity" />.
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Byte" />.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt auf einen Wert Byte ohne Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CByte` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Byte> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.Byte> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Byte> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Byte> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.Byte.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Decimal" />.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> -Objekt an eine <see cref="T:System.Decimal" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CDec` in Visual Basic) verwendet wird.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Decimal> -Datentyp. 

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Decimal> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Decimal> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.Decimal.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Double" />.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> -Objekt an eine <see cref="T:System.Double" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CDbl` in Visual Basic) verwendet wird.   

 Da die <xref:System.Numerics.BigInteger> Werte sind möglich außerhalb des Bereichs der der <xref:System.Double> -Datentyp, dieser Vorgang ist eine einschränkende Konvertierung. Wenn die Konvertierung fehlschlägt, löst eine <xref:System.OverflowException>. Stattdessen, wenn die <xref:System.Numerics.BigInteger> Wert ist kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>, das resultierende <xref:System.Double> Wert <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Wenn die <xref:System.Numerics.BigInteger> Wert ist größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>, das resultierende <xref:System.Double> Wert <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 Die Konvertierung von einem <xref:System.Numerics.BigInteger> auf eine <xref:System.Double> u. einem Genauigkeitsverlust. In einigen Fällen der Verlust an Genauigkeit kann bewirken, dass die Umwandlung oder Konvertierung Operation erfolgreich ausgeführt werden kann auch dann, wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Double> -Datentyp. Dies wird im folgenden Beispiel veranschaulicht. Weist den Maximalwert einer <xref:System.Double> auf zwei <xref:System.Numerics.BigInteger> Variablen, erhöht eine <xref:System.Numerics.BigInteger> Variable, indem Sie um 9. 999e291 und testet, ob die zwei Variablen auf Gleichheit. Wie erwartet, den Aufruf der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode zeigt, dass sie ungleich sind. Allerdings die Konvertierung des größeren <xref:System.Numerics.BigInteger> Wert zurück, in eine <xref:System.Double> erfolgreich ist, obwohl die <xref:System.Numerics.BigInteger> Wert überschreitet, jetzt <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Double> Werte.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt, das eine 16-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CShort` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int16> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.Int16> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Int16> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int16> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.Int16.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert in eine 32-Bit-Ganzzahl mit Vorzeichen zu konvertieren.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt, das eine 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CInt` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int32> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.Int16> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Int32> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int32> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.Int32.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt, das eine 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CLng` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.  

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int64> -Datentyp. 

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Int64> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int64> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.Int64.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen 8-Bit-Wert mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt in eine 8-Bit-Wert mit Vorzeichen.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int16" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CSByte` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.  

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.SByte> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.SByte> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.SByte> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.SByte> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.SByte.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen Gleitkommawert mit einfacher Genauigkeit konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt in einen Gleitkommawert mit einfacher Genauigkeit.</summary>
        <returns>Ein Objekt, das die nächstgelegene mögliche Darstellung enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da dies zu Datenverlust oder einem Genauigkeitsverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CSng` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.    

 Da die <xref:System.Numerics.BigInteger> Werte sind möglich außerhalb des Bereichs der der <xref:System.Single> -Datentyp, dieser Vorgang ist eine einschränkende Konvertierung. Wenn die Konvertierung fehlschlägt, löst eine <xref:System.OverflowException>. Stattdessen, wenn die <xref:System.Numerics.BigInteger> Wert ist kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType>, das resultierende <xref:System.Single> Wert <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Wenn die <xref:System.Numerics.BigInteger> Wert ist größer als <xref:System.Single.MaxValue?displayProperty=nameWithType>, das resultierende <xref:System.Single> Wert <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 Die Konvertierung von einem <xref:System.Numerics.BigInteger> auf eine <xref:System.Single> u. einem Genauigkeitsverlust. In einigen Fällen der Verlust an Genauigkeit kann bewirken, dass die Umwandlung oder Konvertierung Operation erfolgreich ausgeführt werden kann auch dann, wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Single> -Datentyp. Dies wird im folgenden Beispiel veranschaulicht. Weist den Maximalwert einer <xref:System.Single> auf zwei <xref:System.Numerics.BigInteger> Variablen, erhöht eine <xref:System.Numerics.BigInteger> Variable, indem Sie um 9. 999e291 und testet, ob die zwei Variablen auf Gleichheit. Wie erwartet, den Aufruf der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode zeigt, dass sie ungleich sind. Allerdings die Konvertierung des größeren <xref:System.Numerics.BigInteger> Wert zurück, in eine <xref:System.Single> erfolgreich ist, obwohl die <xref:System.Numerics.BigInteger> Wert überschreitet, jetzt <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Single> Werte.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt, das Wert einer 16-Bit-Ganzzahl ohne Vorzeichen.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int32" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CUShort` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt16> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.UInt16> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.UInt16> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt16> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.UInt16.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt auf einen 32-Bit-Ganzzahl ohne Vorzeichen-Wert.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int64" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CUInt` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt32> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.UInt32> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.UInt32> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt32> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.UInt32.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Numerics.BigInteger" /> Objekt auf einen 64-Bit-Ganzzahl ohne Vorzeichen-Wert.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CULng` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt64> -Datentyp. Es ist kein Verlust der Genauigkeit im resultierenden <xref:System.UInt64> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.UInt64> Werte. Es behandelt auch ein <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt64> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert der <paramref name="value" /> ist kleiner als <see cref="F:System.UInt64.MinValue" />.  
  
 - oder -   
  
 Der Wert der <paramref name="value" /> ist größer als <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Single" /> -Wert in einen <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Bruchteil der `value` Parameter vor der Konvertierung abgeschnitten wird.
 
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Single> auf <xref:System.Numerics.BigInteger> können zwar Abschneiden Nachkommastellen der `value`, Sprachcompiler Ausführen dieser Konvertierung nicht automatisch. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) verwendet wird. Andernfalls zeigen sie einen Compilerfehler.

 Für Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 Das folgende Beispiel konvertiert die einzelnen Elemente in einem Array von <xref:System.Single> Werte <xref:System.Numerics.BigInteger> Objekte, und klicken Sie dann das Ergebnis jeder Konvertierung angezeigt. Beachten Sie, dass jeder Bruchteil Teil einer <xref:System.Single> Wert wird bei der Konvertierung abgeschnitten.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NaN" />.  
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.PositiveInfinity" />.
  
 - oder -   
  
 Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> -Instanzmethode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Wenn `left` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine <see cref="T:System.Numerics.BigInteger" /> ist größer als 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Wenn `right` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist größer als ein anderes <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist größer als eine 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist größer als eine 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer oder gleich ist ein <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Wenn `left` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist größer als oder gleich einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Wenn `right` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist größer als oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist größer als oder gleich einer 64-Bit-Ganzzahl ohne Vorzeichen-Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen größer oder gleich ist ein <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung eines Bytewerts ohne Vorzeichen zu einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Bruchteil der `value` Parameter vor der Konvertierung abgeschnitten wird.

 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.Byte> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen an einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.Int16> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen an einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.Int32> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen an einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.Int64> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 8-Bit-Ganzzahl mit Vorzeichen in eine <see cref="T:System.Numerics.BigInteger" /> Wert.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.SByte> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in eine <see cref="T:System.Numerics.BigInteger" /> Wert.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.UInt16> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in eine <see cref="T:System.Numerics.BigInteger" /> Wert.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.UInt32> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der zum Konvertieren einer <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in eine <see cref="T:System.Numerics.BigInteger" /> Wert.  
  
 Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert der enthält die <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, wird die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus der ein Compiler automatisch konvertieren kann ein <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException>. Diese Überladung kann den Compiler Konvertierungen von verarbeitet eine <xref:System.UInt64> -Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu inkrementierende Wert.</param>
        <summary>Inkrementiert eine <see cref="T:System.Numerics.BigInteger" /> -Wert um 1.</summary>
        <returns>Der Wert, der die <paramref name="value" /> Parameter um 1 erhöht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Increment%2A> Methode definiert, dem Inkrementieren negativ für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Einige Sprachen (z. B. Visual Basic), die eine Inkrementoperator fehlender oder Überladen von Operatoren nicht unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.op_Increment%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Da <xref:System.Numerics.BigInteger> Objekte sind unveränderlich, die <xref:System.Numerics.BigInteger.op_Increment%2A> Operator erstellt ein neues <xref:System.Numerics.BigInteger> Objekt, dessen Wert eine öfter als <xref:System.Numerics.BigInteger> Objekt dargestellte `value`. Aus diesem Grund wiederholte Aufrufe von <xref:System.Numerics.BigInteger.op_Increment%2A> stark beanspruchen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" /> Wert ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen können auf Ungleichheit testen, indem Sie eine der folgenden Methoden:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> -Instanzmethode, womit die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und eine lange Ganzzahl mit Vorzeichen.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Instanzmethode und seinen Wert umkehren.  
  
 Wenn `left` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert und eine 64-Bit-Ganzzahl mit Vorzeichen ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen können auf Ungleichheit testen, indem Sie eine der folgenden Methoden:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen angibt, eine <xref:System.Numerics.BigInteger> und eine lange Ganzzahl mit Vorzeichen.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 Wenn `right` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Numerics.BigInteger" />-Objekte über unterschiedliche Werte verfügen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen können auf Ungleichheit testen, indem Sie eine der folgenden Methoden:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> Methode, die die Beziehung zwischen zwei angibt <xref:System.Numerics.BigInteger> Objekte.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert und eine 64-Bit-Ganzzahl ohne Vorzeichen ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen können auf Ungleichheit testen, indem Sie eine der folgenden Methoden:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen angibt, eine <xref:System.Numerics.BigInteger> und unsigned long Integer-Wert.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" /> Wert ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen können auf Ungleichheit testen, indem Sie eine der folgenden Methoden:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen angibt, eine <xref:System.Numerics.BigInteger> und unsigned long Integer-Wert.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der zu verschiebenden Bits <c>Wert</c> auf der linken Seite.</param>
        <summary>Verschiebt eine <see cref="T:System.Numerics.BigInteger" /> Wert eine angegebene Anzahl von Bits nach links.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach links verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LeftShift%2A> Methode definiert, den Vorgang des bitweise Linksschiebe-Operators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Im Gegensatz zu den bitweise Linksschiebeoperation mit ganzzahligen Primitiven der <xref:System.Numerics.BigInteger.op_LeftShift%2A> Methode behält die Vorzeichen des ursprünglichen <xref:System.Numerics.BigInteger> Wert.  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, können eine bitweise Linksschiebeoperation ausführen, durch Multiplikation `value` von `BigInteger.Pow(2, shift)`. Das folgende Beispiel zeigt, dass die Ergebnisse an die Ergebnisse der Verwendung dieses Operators identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen ist kleiner als ein <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Wenn `left` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist kleiner als eine 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Wenn `right` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist kleiner als ein anderes <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> Methode stattdessen. Für einige Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist kleiner als eine 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen ist kleiner als ein <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als oder gleich ist einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Wenn `left` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist kleiner als oder gleich einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Wenn `right` ist ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> er wird implizit konvertierte Wert, ein <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist kleiner als oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> Wert ist kleiner als oder gleich einer 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als oder gleich ist einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Gibt den Rest zurück, die sich aus der Division zweier angegebener ergibt <see cref="T:System.Numerics.BigInteger" /> Werte.</summary>
        <returns>Der Rest, der sich aus der Division ergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Modulus%2A> Methode definiert, die Operation des Modulus-Operator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> Methode stattdessen.  
  
 Die Vorzeichen des Werts durch die Modulo-Vorgang zurückgegeben wurden, hängt das Vorzeichen des `dividend`: Wenn `dividend` positiv ist, wird die Modulo-Operation ein positives Ergebnis zurück, wenn sie negativ ist, gibt die Modulo-Operation ein negatives Ergebnis zurück. Das Verhalten der Modulo-Operation mit <xref:System.Numerics.BigInteger> Werte ist identisch mit der Modulo-Operation mit anderen ganzzahligen Typen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" />ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu multiplizierende Wert.</param>
        <param name="right">Der zweite zu multiplizierende Wert.</param>
        <summary>Multipliziert zwei angegebene <see cref="T:System.Numerics.BigInteger" />-Werte.</summary>
        <returns>Das Produkt von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Multiply%2A> Methode definiert, den Vorgang, der den Multiplikationsoperator für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein Ganzzahlwert.</param>
        <summary>Gibt das bitweise Komplement von einem <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Eine bitweise Einerkomplement der <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Methode definiert, den Vorgang des bitweisen Einerkomplementoperator für <xref:System.Numerics.BigInteger> Werte. Der bitweise Einerkomplementoperator kehrt jedes bit in einem numerischen Wert. D. h. bits `value` , sind 0 werden in das Ergebnis auf 1 festgelegt, und Bits, die den Wert 1 haben, werden in das Ergebnis auf 0 festgelegt. Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen möglicherweise in der Lage, rufen Sie die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> -Methode direkt zur ein bitweises einer Person Vorgang ergänzen. Zum Beispiel:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der zu verschiebenden Bits <c>Wert</c> rechts.</param>
        <summary>Verschiebt eine <see cref="T:System.Numerics.BigInteger" /> Wert eine angegebene Anzahl von Bits nach rechts.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach rechts verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_RightShift%2A> Methode definiert, den Vorgang des bitweise Rechtsschiebe-Operators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, können eine bitweise Rechtsschiebeoperation ausführen, durch Division `value` von `BigInteger.Pow(2, shift)` und Subtraktion 1 Mal `shift` für negative Werte. Das folgende Beispiel zeigt, dass die Ergebnisse an die Ergebnisse der Verwendung dieses Operators identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Wenn `shift` ist größer als oder gleich der Anzahl von Bits in einem positiven <xref:System.Numerics.BigInteger> Wert das Ergebnis der Rechtsschiebeoperation ist <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Wenn `shift` ist größer als die Anzahl der Bits in einem negativen <xref:System.Numerics.BigInteger> Wert das Ergebnis der Rechtsschiebeoperation ist <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert eine <see cref="T:System.Numerics.BigInteger" /> Wert aus einer anderen <see cref="T:System.Numerics.BigInteger" /> Wert.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Subtraction%2A> Methode definiert, den Vorgang des Subtraktionsoperators für <xref:System.Numerics.BigInteger> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen BigInteger-Wert.</summary>
        <returns>Das Ergebnis der <paramref name="value" /> Parameter multipliziert mit minus eins (1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> -Methode definiert die Ausführung der unäre Negationsoperator (oder die Additive Inverse-Operator) für <xref:System.Numerics.BigInteger> Werte. Der Vorgang erzeugt einen Wert, der sich in 0 (null) ergibt, wenn die ursprüngliche Nummer hinzugefügt wird. Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Numerics.BigInteger.Negate%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist.<xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Das folgende Beispiel veranschaulicht die drei verschiedene Möglichkeiten, den Wert des Negieren einer <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein Ganzzahlwert.</param>
        <summary>Gibt den Wert der <see cref="T:System.Numerics.BigInteger" /> Operanden. (Das Vorzeichen des Operanden wird nicht geändert.)</summary>
        <returns>Der Wert, der die <paramref name="value" /> Operanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Methode definiert, die Ausführung von der positive unäre Operator für <xref:System.Numerics.BigInteger> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
        <returns>Ein Wert, der die angegebene Zahl entspricht der <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` Parameter muss die angegebene Zeichenfolgendarstellung einer Zahl in der folgenden Form sein.  
  
 [*ws*] [*Anmeldung*]*Ziffern*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*Anmelden*|Einem optionalen Vorzeichen. Gültige Zeichen gemäß der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Der angegebenen Zeichenfolge die `value` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil. Darf Gruppentrennzeichen oder Dezimaltrennzeichen enthalten, und es sind keine Dezimalstellen.  
  
 Die `value` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Um eine Zeichenfolge mithilfe von den Formatierungsinformationen des einer bestimmten Kultur zu analysieren, verwenden die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> Methode.  
  
> [!IMPORTANT]
>  Bei Verwendung von der <xref:System.Numerics.BigInteger.Parse%2A> Methode, um einen Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der durch Ausgabe wurde die <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Andernfalls die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen kann bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Parse%28System.String%29> Methode zum Instanziieren zweier <xref:System.Numerics.BigInteger> Objekte. Jedes Objekt mit einer anderen Zahl multipliziert und ruft dann die <xref:System.Numerics.BigInteger.Compare%2A> Methode, um die Beziehung zwischen den beiden Werten festzulegen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" />ist nicht im richtigen Format.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von angeben <c>Wert</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der die angegebene Zahl entspricht der <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Style-Elemente (z. B. Leerzeichen, positive oder negative Vorzeichen, das Gruppentrennzeichen und das Dezimaltrennzeichen), die in zulässig sind die `value` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. `styles`muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die `style` Parameter bewirkt, dass diese Methode, die hilfreich beim Überladen `value` die angegebene Zeichenfolgendarstellung eines Hexadezimalwerts enthält, wenn das System Zahl (dezimal oder hexadezimal) durch dargestellt `value` nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen nicht zulassen möchten, oder ein symbol in `value`.  
  
 Abhängig vom Wert der `style`die `value` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [*ws*] [*$*] [*Anmeldung*] [*Ziffern*,]*Ziffern*[.* Bruchziffern*] [-e [*Anmeldung*]*Exponenten-Ziffern*] [*ws*]  
  
 Wenn `style` enthält <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>die `value` Parameter kann die folgenden Elemente enthalten:  
  
 [*ws*]*Hexdigits*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Das Währungssymbol der aktuellen Kultur stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `value` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Ziffern*<br /><br /> *Bruchziffern*<br /><br /> *Exponenten-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9. Für *Bruchziffern*, werden nur die Ziffer 0 gültig ist.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Nur die Ziffer 0 stehen als einer Dezimalstelle, damit der Analysevorgang erfolgreich ist; Wenn *Bruchziffern* enthält eine beliebige andere Ziffer, einen <xref:System.FormatException> ausgelöst wird.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis f.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die möglicherweise vorhandene in `value`.  
  
|`NumberStyles`-Wert|Elemente in zulässig `value` neben Ziffern|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (.) und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder das Zeichen "E", womit Exponentialschreibweise, zusammen mit *Exponenten-Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Dem Gruppenelement Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `value` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `value`, *Anmeldung* am Anfang des `value`, und das Dezimaltrennzeichen (*.*) Symbol. Die `value` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Gruppentrennzeichen (*,*), und das Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `value` eine hexadezimale Zahl nicht darstellen kann.|  
  
> [!IMPORTANT]
>  Bei Verwendung von der <xref:System.Numerics.BigInteger.Parse%2A> Methode, um einen Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der durch Ausgabe wurde die <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Andernfalls die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen kann bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Im Gegensatz zu den anderen <xref:System.Globalization.NumberStyles> Werte, die ermöglichen, ist jedoch nicht erforderlich, das Vorhandensein bestimmter Stilelemente in `value`, <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Style-Wert bedeutet, dass die einzelnen numerischen Zeichen in `value` immer als interpretiert werden hexadezimalen Zeichen. Gültige hexadezimale Zeichen sind 0-9, A-F und a-f. Der nur anderen Flags, die mit kombiniert werden können, die `style` Parameter sind <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration enthält ein zusammengesetztes Zahlenformat <xref:System.Globalization.NumberStyles.HexNumber>, beide Flags Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` Zeichenfolgendarstellung ist eine hexadezimale Zahl, es kann nicht vorangestellt werden alle Decoration (z. B. `0x` oder `&h`), die als eine hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` ist eine hexadezimale Zeichenfolge, die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode interpretiert `value` als eine negative Zahl, die mit zwei des Komplement Darstellung, wenn die ersten beiden Hexadezimalziffern größer als oder gleich sind gespeicherte `0x80`. Mit anderen Worten, interpretiert die Methode das höchstwertige Bit des ersten Bytes im `value` als das Vorzeichenbit. Um sicherzustellen, dass eine Hexadezimalzeichenfolge ordnungsgemäß als eine positive Zahl, die erste Zahl interpretiert wird `value` muss einen Wert von 0 (null) aufweisen. Die Methode z. B. interpretiert `0x80` wie einen negativen Wert, sondern interpretiert `0x080` oder `0x0080` als einen positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen Hexadezimalzeichenfolgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Die `value` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Rufen Sie zum Angeben der Kultur, deren Formatierungsinformationen, damit der Analysevorgang verwendet wird, der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> überladen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht Aufrufe an die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode mit mehreren möglichen Werte für die `style` Parameter. Es wird veranschaulicht, wie eine Zeichenfolge als Hexadezimalwert interpretiert werden soll und wie zu unterbinden, Leerzeichen und Symbole anmelden.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />enthält die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> oder <see cref="F:System.Globalization.NumberStyles.HexNumber" /> Flag zusammen mit einem anderen Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" />stimmt nicht mit der Eingabe von angegebenen Muster <see cref="T:System.Globalization.NumberStyles" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bietet <c>Wert</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen kulturspezifischen Format in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der die angegebene Zahl entspricht der <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` Parameter muss die angegebene Zeichenfolgendarstellung einer Zahl in der folgenden Form sein:  
  
 [*ws*] [*Anmeldung*]*Ziffern*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*Anmelden*|Einem optionalen Vorzeichen. Gültige Zeichen gemäß der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> von zurückgegebene Objekt der `provider` des Objekts <xref:System.IFormatProvider.GetFormat%2A> Methode.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Der angegebenen Zeichenfolge die `value` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil. Darf Gruppentrennzeichen oder Dezimaltrennzeichen enthalten, und es sind keine Dezimalstellen.  
  
> [!IMPORTANT]
>  Bei Verwendung von der <xref:System.Numerics.BigInteger.Parse%2A> Methode, um einen Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der durch Ausgabe wurde die <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Andernfalls die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen kann bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> Methode aufgerufen wird, ruft er die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Die <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen zum Format von bietet die `value` Parameter. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter benutzerdefinierte Formatierungsinformationen für den Analysevorgang angeben:  
  
-   Sie können übergeben ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können den tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, die Formatierung der `value` interpretiert basierend auf den <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.  
  
   
  
## Examples  
 Die folgenden Beispiele zeigen zwei Möglichkeiten, die Tilde (~) definieren, wie ein negativen Vorzeichen für die Formatierung <xref:System.Numerics.BigInteger> Werte. Beachten Sie, dass Sie zum Anzeigen der <xref:System.Numerics.BigInteger> muss Werte im gleichen Format wie die ursprünglichen Zeichenfolgen, Ihren Code Aufrufen der <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode und übergibt ihn dann der <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Im erste Beispiel definiert eine Klasse, die implementiert <xref:System.IFormatProvider> und verwendet die <xref:System.IFormatProvider.GetFormat%2A> -Methode zur Rückgabe der <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Ein <xref:System.Numerics.BigInteger> Objekt kann dann durch den folgenden Code instanziiert werden:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Im zweite Beispiel wird einfacher. Übergibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen liefert an die `provider` Parameter.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" />ist nicht im richtigen Format.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von angeben <c>Wert</c>.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bietet <c>Wert</c>.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturabhängigen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Ein Wert, der die angegebene Zahl entspricht der <paramref name="value" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Style-Elemente (z. B. Leerzeichen, positive oder negative Vorzeichen, das Gruppentrennzeichen und das Dezimaltrennzeichen), die in zulässig sind die `value` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. `styles`muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die `style` Parameter bewirkt, dass diese Methode, die hilfreich beim Überladen `value` die angegebene Zeichenfolgendarstellung eines Hexadezimalwerts enthält, wenn das System Zahl (dezimal oder hexadezimal) durch dargestellt `value` nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen nicht zulassen möchten, oder ein symbol in `value`.  
  
 Abhängig vom Wert der `style`die `value` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [*ws*] [*$*] [*Anmeldung*] [*Ziffern*,]*Ziffern*[*. Bruchziffern*] [-e [*Anmeldung*]*Exponenten-Ziffern*] [*ws*]  
  
 Wenn `style` enthält <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>die `value` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [*ws*]*Hexdigits*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der Kultur angegeben, durch die `provider` Parameter. Das Währungssymbol der aktuellen Kultur stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `value` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Ziffern*<br /><br /> *Bruchziffern*<br /><br /> *Exponenten-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9. Für *Bruchziffern*, werden nur die Ziffer 0 gültig ist.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen. Das Gruppentrennzeichen der vom angegebenen Kultur `provider` erscheinen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Das Dezimaltrennzeichen für die Kultur, die vom angegebenen `provider` erscheinen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Nur die Ziffer 0 stehen als einer Dezimalstelle, damit der Analysevorgang erfolgreich ist; Wenn *Bruchziffern* enthält eine beliebige andere Ziffer, einen <xref:System.FormatException> ausgelöst wird.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis f.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die möglicherweise vorhandene in `value`.  
  
|NumberStyles-Wert|Elemente, die in den Wert neben Ziffern zulässig|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (.) und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. zusammen mit *Exponenten-Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Dem Gruppenelement Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `value` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `value`, *Anmeldung* am Anfang des `value`, und das Dezimaltrennzeichen (.). Die `value` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Gruppentrennzeichen (,) und Dezimaltrennzeichen (.) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `value` eine hexadezimale Zahl nicht darstellen kann.|  
  
> [!IMPORTANT]
>  Bei Verwendung von der <xref:System.Numerics.BigInteger.Parse%2A> Methode, um einen Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der durch Ausgabe wurde die <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Andernfalls die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen kann bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Im Gegensatz zu den anderen <xref:System.Globalization.NumberStyles> Werte, die ermöglichen, aber keine das Vorhandensein bestimmter Stilelemente in erfordern `value`, <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Style-Wert bedeutet, dass die einzelnen numerischen Zeichen in `value` immer als interpretiert werden hexadezimalen Zeichen. Gültige hexadezimale Zeichen sind 0-9, A-F und a-f. Der nur anderen Flags, die mit kombiniert werden können, die `style` Parameter sind <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration enthält ein zusammengesetztes Zahlenformat <xref:System.Globalization.NumberStyles.HexNumber>, beide Flags Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` Zeichenfolgendarstellung ist eine hexadezimale Zahl, es kann nicht vorangestellt werden alle Decoration (z. B. `0x` oder `&h`), die als eine hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` ist eine hexadezimale Zeichenfolge, die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode interpretiert `value` als eine negative Zahl, die mit zwei des Komplement Darstellung, wenn die ersten beiden Hexadezimalziffern größer als oder gleich sind gespeicherte `0x80`. Mit anderen Worten, interpretiert die Methode das höchstwertige Bit des ersten Bytes im `value` als das Vorzeichenbit. Um sicherzustellen, dass eine Hexadezimalzeichenfolge ordnungsgemäß als eine positive Zahl, die erste Zahl interpretiert wird `value` muss einen Wert von 0 (null) aufweisen. Die Methode z. B. interpretiert `0x80` wie einen negativen Wert, sondern interpretiert `0x080` oder `0x0080` als einen positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen Hexadezimalzeichenfolgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format von bietet `value`. In der Regel `provider` kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider> und verwendet die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Methode instanziieren und Zurückgeben der <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`die <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird lediglich einige Aufrufe an die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, die mit verschiedenen Kombinationen von Werten für die `style` und `provider` Parameter.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Eine Anzahl von einzelnen Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> -Methode übergibt eine Instanz der folgenden `BigIntegerFormatProvider` Klasse, die eine Tilde (~) als negativen Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />enthält die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> oder <see cref="F:System.Globalization.NumberStyles.HexNumber" /> Flag zusammen mit einem anderen Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" />stimmt nicht mit der Eingabe von angegebenen Muster <paramref name="style" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Anzahl an die <c>Exponenten</c> Power.</param>
        <param name="exponent">Der Exponent zum Auslösen von <c>Wert</c> durch.</param>
        <summary>Löst ein <see cref="T:System.Numerics.BigInteger" /> Wert mit einem angegebenen Wert.</summary>
        <returns>Das Ergebnis der Potenzierung <paramref name="value" /> auf die <paramref name="exponent" /> Power.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Pow%2A> -Methode gibt 1 zurück, wenn der Wert des Parameters Exponent 0 ist, oder wenn die Werte von der `value` und `exponent` Parameter sind 0. Wenn `exponent` beträgt 1, der <xref:System.Numerics.BigInteger.Pow%2A> -Methode zurückkehrt `value`. Wenn `value` ist negativ ist, gibt die Methode ein negatives Ergebnis.  
  
 Diese Methode entspricht der <xref:System.Math.Pow%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Verwendung von Potenzierung ein <xref:System.Numerics.BigInteger> Wert und einen Exponenten, dessen Wert von 0 bis 10 reicht.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert, der die <paramref name="exponent" /> Parameter ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Führt der ganzzahligen Division von zwei <see cref="T:System.Numerics.BigInteger" /> Werte und gibt den Restwert zurück.</summary>
        <returns>Der Rest aus der Division von <paramref name="dividend" /> durch <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Vorzeichen des Restwertes ist das Vorzeichen der `dividend` Parameter.  
  
 Die <xref:System.Numerics.BigInteger.Remainder%2A> Methode ist für Sprachen, die keine benutzerdefinierte Operatoren unterstützen implementiert. Das Verhalten ist identisch mit der Division mithilfe des Modulo-Operators.  
  
 Wenn erforderlich, die Methode automatisch implizite Konvertierung eines anderen ganzzahligen Typen zu ausführt <xref:System.Numerics.BigInteger> Objekte, bevor er die Modulo-Operation ausführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Rest aus der <xref:System.Numerics.BigInteger.DivRem%2A> Methode mit den übrigen zurückgegebenes die <xref:System.Numerics.BigInteger.Remainder%2A> Methode, um festzulegen, dass die beiden Methoden einen identischen Rest berechnen.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" />ist 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zahl, die das Vorzeichen angibt (positiv, negativ oder 0 (null)) des aktuellen <see cref="T:System.Numerics.BigInteger" /> Objekt.</summary>
        <value>Eine Zahl, die das Vorzeichen des gibt an, die <see cref="T:System.Numerics.BigInteger" /> -Objekts, wie in der folgenden Tabelle gezeigt.  
  
 <list type="table"><listheader><term>Anzahl  
  
 </term><description>Beschreibung  
  
 </description></listheader><item><term> -1  
  
 </term><description>Der Wert dieses Objekts ist negativ.  
  
 </description></item><item><term> 0  
  
 </term><description>Der Wert dieses Objekts ist 0 (null).  
  
 </description></item><item><term> 1  
  
 </term><description>Der Wert dieses Objekts ist positiv.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Sign%2A> Eigenschaft ist identisch mit der <xref:System.Math.Sign%2A?displayProperty=nameWithType> Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert ein <see cref="T:System.Numerics.BigInteger" /> Wert von einem anderen und gibt das Ergebnis zurück.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können die <xref:System.Numerics.BigInteger.Subtract%2A> -Methode zur Subtraktion mit <xref:System.Numerics.BigInteger> Werte.  
  
 Die <xref:System.Numerics.BigInteger.Subtract%2A> Methode ist ein geeigneter Ersatz für den Subtraktionsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, indem sie die Differenz, die aus der Subtraktion, resultiert zuweist, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert eine <see cref="T:System.Numerics.BigInteger" /> Wert in ein Bytearray.</summary>
        <returns>Der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" /> Objekt in ein Array von Bytes konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes im Array, das von dieser Methode zurückgegeben werden in little-Endian-Reihenfolge angezeigt. Die niederwertigen Bytes des Wertes vorausgehen, also die höherwertigen Bytes. Das erste Byte des Arrays stellt die ersten acht Bits von der <xref:System.Numerics.BigInteger> Wert, das zweite Byte widerspiegelt, die nächsten acht Bits und So weiter. Zum Beispiel ist der Wert 1024 oder 0 x 0400, Form der folgenden zwei Bytearrays gespeichert:  
  
|Element|Byte-Wert|  
|-------------|----------------|  
|0|0 x 00|  
|1|0 x 04|  
  
 Negative Werte werden in das Array mit zwei des Komplement Darstellung in die kompakteste Form möglichen geschrieben. -1 liegt z. B. als ein einzelnes Byte an, dessen Wert `0xFF` statt als Array mit mehreren Elementen, wie z. B. `0xFF`, `0xFF` oder `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Da Darstellung immer Zweierkomplement interpretiert das höchstwertige Bit des letzten Bytes im Array (das Byte, ab Position <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) als Vorzeichenbit, gibt die Methode ein Bytearray mit einem zusätzlichen Element, dessen Wert 0 (null ist) zurück, mit denen auf eindeutig positive Werte zulässig sind, die andernfalls interpretiert werden konnte, als hätte ihre Anmelde-Bits festgelegt. Beispielsweise den Wert 120 oder `0x78` wird als ein Single-Byte-Array dargestellt: `0x78`. Jedoch 128 oder `0x80`, wird als ein 2-Byte-Array dargestellt: `0x80`, `0x00`.  
  
 Sie können einen Roundtrip eine <xref:System.Numerics.BigInteger> Wert durch Speichern in ein Bytearray und danach die Wiederherstellung mithilfe der <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor.  
  
> [!CAUTION]
>  Wenn Ihr Code den Wert einzelner Bytes im Array, das von dieser Methode zurückgegeben wird ändert, bevor sie den Wert wiederhergestellt, müssen Sie sicherstellen, dass Sie nicht versehentlich das signierte Bit ändern. Werden z. B. wenn die Änderungen einen positiven Wert erhöhen, damit der höchsten Priorität im letzten Element des Bytearrays bit festgelegt ist, wird Sie einen neuen Byte hinzufügen können, deren Wert 0 (null) bis zum Ende des Arrays entspricht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einige <xref:System.Numerics.BigInteger> Werte werden in Bytearrays dargestellt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert in der "R" oder ein Roundtrip Format der aktuellen Kultur. Wenn Sie ein anderes Format oder eine Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert enthält ein negativen Vorzeichen, dessen Wert ist negativ und einer Folge von Ziffern zwischen 0 und 9 ohne führende Nullen an. Die Minuszeichen werden definiert, indem die <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Numerics.BigInteger> Wert unter Verwendung des standardmäßigen <xref:System.Numerics.BigInteger.ToString> Methode. Es zeigt auch die zeichenfolgendarstellungen der <xref:System.Numerics.BigInteger> Werts, der von der Verwendung von einigen Standardformatbezeichner ergibt. In den Beispielen werden die Verwendung der Formatierungskonventionen der Kultur En-US angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="provider" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Methode Formate ein <xref:System.Numerics.BigInteger> Wert in der "R" oder einen Roundtrip, formatieren Sie mithilfe der <xref:System.Globalization.NumberFormatInfo> Objekt einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|Standardkultur (aktueller)|<xref:System.Numerics.BigInteger.ToString>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebene Zeichenfolge bereitstellt. Wenn `provider` ist `null`, <xref:System.Numerics.BigInteger> Wert wird mit formatiert die <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur. Die einzige Eigenschaft von der <xref:System.Globalization.NumberFormatInfo> -Objekt, das steuert, die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> ist der Wert mit dem allgemeinen Formatbezeichner <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, definiert, dass das Zeichen, die die negativen Vorzeichen darstellt.  
  
 Die `provider` Parameter kann einen der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt.  
  
-   Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine benutzerdefinierte <xref:System.Globalization.NumberFormatInfo> -Objekt, das die Tilde (~) als ein negativen Vorzeichen definiert. Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Methode verwendet dann die benutzerdefinierte <xref:System.Globalization.NumberFormatInfo> eine Negative anzuzeigenden Objekttyp <xref:System.Numerics.BigInteger> Wert.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="format" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%29> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert in einem angegebenen Format mithilfe einer <xref:System.Globalization.NumberFormatInfo> Objekt, das die Konventionen der aktuellen Kultur darstellt. Wenn Sie die "R" oder einen Roundtrip verwenden möchten, formatieren oder eine andere Kultur angegeben, Verwendung der anderen Überladungen der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|Standardkultur (aktueller)|<xref:System.Numerics.BigInteger.ToString>|  
|Round-Trip ("R")-format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die `format` Parameter kann eine beliebige gültige [numerische Standardzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), oder eine beliebige Kombination von [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`, der Rückgabewert des aktuellen <xref:System.Numerics.BigInteger> Objekt mit dem Schleifenformatbezeichner ("R") formatiert ist. Wenn `format` ist ein anderer Wert, löst die Methode eine <xref:System.FormatException>.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Unterstützung von Formatierung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Das Format der zurückgegebenen Zeichenfolge richtet sich nach der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur. Je nach den `format` Parameter, dieses Objekt wird gesteuert, Symbole, z. B. das negativen Vorzeichen, das Gruppentrennzeichen und das Dezimaltrennzeichen in der Ausgabezeichenfolge. Aufrufen, um Formatierungsinformationen für Kulturen als der aktuellen Kultur zu ermöglichen, die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> überladen.  
  
   
  
## Examples  
 Im folgende Beispiel initialisiert einen <xref:System.Numerics.BigInteger> Wert und mit jeder Standardformatzeichenfolge und einigen benutzerdefinierten Formatzeichenfolgen angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats und der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts entsprechend den Angaben in den Parametern <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert in einem angegebenen Format mithilfe der <xref:System.Globalization.NumberFormatInfo> Objekt einer angegebenen Kultur. Wenn Sie die Roundtripformat oder standardkultureinstellungen verwenden möchten, verwenden Sie andere Überladungen der der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|Standardkultur (aktueller)|<xref:System.Numerics.BigInteger.ToString>|  
|Round-Trip ("R")-format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Die `format` Parameter kann eine beliebige gültige [numerische Standardzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), oder eine beliebige Kombination von [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`, der Rückgabewert des aktuellen <xref:System.Numerics.BigInteger> Objekt mit dem Schleifenformatbezeichner ("R") formatiert ist. Wenn `format` ist ein anderer Wert, löst die Methode eine <xref:System.FormatException>.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Unterstützung von Formatierung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebene Zeichenfolge bereitstellt. Wenn die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Methode aufgerufen wird, ruft er die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Die <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen zum Formatieren der `value` Parameter, z. B. das negative Vorzeichen-Symbol, das Gruppentrennzeichen oder das Dezimaltrennzeichen. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter Formatierungsinformationen zum Angeben der <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Methode:  
  
-   Sie können übergeben ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können den tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, die Formatierung der zurückgegebenen Zeichenfolge basiert auf der <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.  
  
   
  
## Examples  
 Im folgende Beispiel initialisiert eine <xref:System.Numerics.BigInteger> Wert und wird in die Konsole, indem eine standardmäßige Formatzeichenfolge angezeigt und ein <xref:System.Globalization.NumberFormatInfo> Objekt, das die Tilde (~) als ein negativen Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl.</param>
        <param name="result">Enthält bei Rückgabe dieser Methode die <see cref="T:System.Numerics.BigInteger" /> entspricht die Anzahl der im enthaltene <c>Wert</c>, oder 0 (null), wenn die Konvertierung fehlschlägt. Die Konvertierung schlägt fehl, wenn die <c>Wert</c> Parameter ist <see langword="null" /> oder weist nicht das richtige Format. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Methode entspricht der <xref:System.Numerics.BigInteger.Parse%28System.String%29> -Methode, mit dem Unterschied, dass die It keine Ausnahme auslöst, wenn die Konvertierung fehlschlägt. Diese Methode entfällt die Notwendigkeit, die mithilfe der Ausnahmenbehandlung zum Testen einer <xref:System.FormatException> Wenn `value` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `value` Parameter muss die angegebene Zeichenfolgendarstellung einer Dezimalzahl in der folgenden Form sein:  
  
 [*ws*] [*Anmeldung*]*Ziffern*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*Anmelden*|Einem optionalen Vorzeichen. Gültige Zeichen gemäß der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur.|  
|*Ziffern*|Eine Sequenz von Dezimalzahlen im Bereich von 0 bis 9.|  
  
> [!NOTE]
>  Die Zeichenfolge, die gemäß der `value` Parameter kann keine Gruppentrennzeichen oder Dezimaltrennzeichen enthalten, und es sind keine Dezimalstellen.  
  
 Die `value` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Stil. Neben der Dezimalstelle dürfen nur führende und nachfolgende Leerzeichen mit einem vorangestellten Plus-oder Minuszeichen. Die Style-Elemente mit der kulturspezifischen Formatierungsinformationen explizit zu definieren, die in vorhanden sein können `value`, rufen Sie die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode.  
  
 Die `value` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Diese Überladung interpretiert alle Ziffern in der `value` Parameter als eine Dezimalstelle finden. Aufrufen, um die angegebene Zeichenfolgendarstellung einer Hexadezimalzahl zu analysieren, die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> stattdessen überladen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Methode zum Instanziieren zweier <xref:System.Numerics.BigInteger> Objekte. Wenn die Konvertierung erfolgreich sind, jedes Objekt mit einer anderen Zahl multipliziert und ruft dann die <xref:System.Numerics.BigInteger.Compare%2A> Methode, um die Beziehung zwischen den beiden Objekten zu bestimmen.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl. Die Zeichenfolge wird unter Verwendung des durch angegebenen Stils interpretiert <c>Stil</c>.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die im vorhanden sein können <c>Wert</c>. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu bereitstellt <c>Wert</c>.</param>
        <param name="result">Enthält bei Rückgabe dieser Methode die <see cref="T:System.Numerics.BigInteger" /> entspricht die Anzahl der im enthaltene <c>Wert</c>, oder <see cref="P:System.Numerics.BigInteger.Zero" /> bei einem Konvertierungsfehler. Die Konvertierung schlägt fehl, wenn die <c>Wert</c> Parameter ist <see langword="null" /> oder befindet sich nicht in ein kompatibles Format mit <c>Stil</c>. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturspezifischen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" /> und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich abgeschlossen wurde.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode entspricht der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> -Methode, mit dem Unterschied, dass die It keine Ausnahme auslöst, wenn die Konvertierung fehlschlägt. Diese Methode entfällt die Notwendigkeit, die mithilfe der Ausnahmenbehandlung zum Testen einer <xref:System.FormatException> Wenn `value` ist ungültig und kann nicht erfolgreich analysiert werden.  
  
 Die `style` Parameter definiert die Style-Elemente (z. B. leer- oder eine positiven oder negativen Vorzeichen), die in zulässig sind die `value` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Abhängig vom Wert der `style`die `value` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [*ws*] [*$*] [*Anmeldung*] [*Ziffern*,]*Ziffern*[.* Bruchziffern*] [-e [*Anmeldung*]*Exponenten-Ziffern*] [*ws*]  
  
 Wenn die `style` Parameter enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier>die `value` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [*ws*]*Hexdigits*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag oder am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, indem die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> Eigenschaft von der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt die <xref:System.IFormatProvider.GetFormat%2A> Methode der `provider` Parameter. Das Währungssymbol stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Anmelden*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `value` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen. Das Gruppentrennzeichen der vom angegebenen Kultur `provider` erscheinen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Das Dezimaltrennzeichen des vom angegebenen Kultur `provider` erscheinen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Bruchziffern*|Mindestens ein Vorkommen der Ziffer 0. Dezimalstellen erscheinen `value` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder die Zeichen "E", der angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*Exponenten-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis f.|  
  
 Eine Zeichenfolge mit nur Dezimalstellen (entspricht der <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Flag) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden, jedoch müssen nicht in dieser Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die möglicherweise vorhandene in `value`.  
  
|Nicht zusammengesetzte `NumberStyles` Werte|Elemente, die in den Wert neben Ziffern zulässig|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Bruchziffern* Elemente. Allerdings *Bruchziffern* muss bestehen lediglich eine oder mehrere 0-Ziffern oder die Methode gibt `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder das Zeichen "E", womit Exponentialschreibweise, zusammen mit *Exponenten-Ziffern*. Wenn `value` eine Zahl in Exponentialschreibweise, keinen es, eine Komponente nicht 0 (null), Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element vor dem *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Elements nach *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppentrennzeichen (*,*) Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die Währung (*$*) Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `value` keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `value`, *Anmeldung* am Anfang des `value`, und das Dezimaltrennzeichen (*.*) Symbol. Die `value` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die *ws*, *Anmeldung*, Gruppentrennzeichen (*,*), und das Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `value` eine hexadezimale Zahl nicht darstellen kann.|  
  
> [!IMPORTANT]
>  Bei Verwendung von der <xref:System.Numerics.BigInteger.TryParse%2A> Methode, um einen Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der durch Ausgabe wurde die <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Andernfalls die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen kann bei Verwendung der <xref:System.Numerics.BigInteger.TryParse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Wenn die <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> -Flag wird verwendet, `value` muss ein Hexadezimalwert sein. Die einzigen anderen Flags, die im vorhanden sein können `style` sind <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> -Enumeration hat ein zusammengesetztes Format <xref:System.Globalization.NumberStyles.HexNumber>, beide Flags Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` Zeichenfolgendarstellung ist eine hexadezimale Zahl, es kann nicht vorangestellt werden alle Decoration (z. B. `0x` oder `&h`), die als eine hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` ist eine hexadezimale Zeichenfolge, die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode interpretiert `value` als eine negative Zahl, die mit zwei des Komplement Darstellung, wenn die ersten beiden Hexadezimalziffern größer als oder gleich sind gespeicherte `0x80`. Mit anderen Worten, interpretiert die Methode das höchstwertige Bit des ersten Bytes im `value` als das Vorzeichenbit. Um sicherzustellen, dass eine Hexadezimalzeichenfolge ordnungsgemäß als eine positive Zahl, die erste Zahl interpretiert wird `value` muss einen Wert von 0 (null) aufweisen. Die Methode z. B. interpretiert `0x80` wie einen negativen Wert, sondern interpretiert `0x080` oder `0x0080` als einen positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen Hexadezimalzeichenfolgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format von bietet `value`. Die `provider` Parameter kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur gibt sich selbst zurück.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`die <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden einige Aufrufe an die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode, die mit verschiedenen Kombinationen von Werten für die `style` und `provider` Parameter.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Eine Anzahl von einzelnen Aufrufe der <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> -Methode übergibt eine Instanz der folgenden `BigIntegerFormatProvider` Klasse, die eine Tilde (~) als negativen Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
 - oder -   
  
 <paramref name="style" />enthält die <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> oder <see cref="F:System.Globalization.NumberStyles.HexNumber" /> Flag zusammen mit einem anderen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl null (0) darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert 0 (null) ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger> von dieser Eigenschaft zurückgegebene Objekt stellt eine bequeme Quelle der Wert 0 für Zuweisungen und Vergleiche.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
