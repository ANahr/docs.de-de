<Type Name="TypeDelegator" FullName="System.Reflection.TypeDelegator">
  <TypeSignature Language="C#" Value="public class TypeDelegator : System.Reflection.TypeInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TypeDelegator extends System.Reflection.TypeInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.TypeDelegator" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umschließt ein <see cref="T:System.Type" /> Objekt und Delegaten Methoden mit <see langword="Type" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von diesem Typ abgeleitet werden, und überschreiben Sie nur für die Elemente müssen Sie Anpassungen im angeben, sowie die Member, die durch das Programm erforderlich sind und noch nicht implementiert <xref:System.Reflection.TypeDelegator>.  
  
 <xref:System.Reflection.TypeDelegator>leitet sich von <xref:System.Type?displayProperty=nameWithType> und implementiert die meisten Eigenschaften und Methoden der <xref:System.Type>. Für jedes Element implementiert wird, <xref:System.Reflection.TypeDelegator> automatisch auf den entsprechenden Member eines internen delegiert <xref:System.Type> -Objekt, das als Argument an den Konstruktor bereitgestellt wird. Diese interne <xref:System.Type> Objekt verfügbar gemacht wird, um abgeleitete Klassen durch die `protected` <xref:System.Reflection.TypeDelegator.typeImpl> Feld.  
  
> [!NOTE]
>  Einige Mitglieder des <xref:System.Reflection.TypeDelegator> Implementierungen verfügen, obwohl die Elemente selbst einfach geerbt werden <xref:System.Type>. In diesen Fällen die Implementierung erfolgt durch eine überschriebene `protected` Methode, die einen Namen besitzt, die mit "Impl" endet. Z. B. die Implementierung für alle Überladungen der der <xref:System.Reflection.TypeDelegator.GetMethods%2A> Methode wird bereitgestellt von der überschriebenen <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> Methode. Die Implementierung für geerbte Eigenschaften, z. B. <xref:System.Type.IsPublic%2A> und <xref:System.Type.IsNestedAssembly%2A> wird bereitgestellt von der überschriebenen <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> Methode.  
  
 Abgeleitete Klassen kann einen öffentlichen Konstruktor bereitstellen, die akzeptiert eine <xref:System.Type> -Objekts entsprechend der zugehörigen Parameter und übergibt Sie einfach das Objekt, das <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> -Konstruktor dynamisch generiert oder die interne festgelegt <xref:System.Type> Objekt auf andere Weise.  
  
 Wenn eine ableitende Klasse einen Member verwendet, die nicht von implementiert ist <xref:System.Reflection.TypeDelegator>, müssen sie diesen Member überschreiben und eine Implementierung bereitstellen. Die einfachste Implementierung wird das entsprechende Element in der internen Aufrufen <xref:System.Type> Objekt verfügbar gemacht werden, indem die <xref:System.Reflection.TypeDelegator.typeImpl> Feld, aber Sie können keine Implementierung, die die Anwendung erfordert bereit. Es ist nicht notwendig, diese Member zu überschreiben, wenn sie nicht von der Anwendung verwendet werden, oder von der Bibliothek Ihre Anwendung Aufrufe funktioniert (z. B. durch die <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> Konstruktor).  
  
 Die folgenden virtuellen Methoden (`Overridable` Methoden in Visual Basic) der <xref:System.Type> werden nicht von implementiert <xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>, <xref:System.Type.GetGenericTypeDefinition%2A>, <xref:System.Type.GetGenericArguments%2A>, <xref:System.Type.GetGenericParameterConstraints%2A>, <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakeByRefType%2A>, <xref:System.Type.MakePointerType%2A> , <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.  
  
 Die folgenden virtuellen Eigenschaften (`Overridable` Eigenschaften in Visual Basic) der <xref:System.Type> werden nicht von implementiert <xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.ContainsGenericParameters%2A>, <xref:System.Type.DeclaringMethod%2A>, <xref:System.Type.GenericParameterAttributes%2A>, <xref:System.Type.GenericParameterPosition%2A> , <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDelegator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.TypeDelegator" />-Klasse mit Standardeigenschaften.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeDelegator (Type delegatingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type delegatingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor(System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="delegatingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegatingType">Die Instanz der Klasse <see cref="T:System.Type" /> , die den Aufruf der Methode eines Objekts kapselt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Reflection.TypeDelegator" /> -Klasse unter Angabe der kapselnden Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird aufgerufen, von einer Klasse zu generieren einen Delegaten, der auf Grundlage der `Type` Objekt für die Klasse, die die Methode definieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegatingType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Assembly des implementierten Typs ab.</summary>
        <value>Ein <see cref="T:System.Reflection.Assembly" /> Objekt, das die Assembly des implementierten Typs darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblys sind die Einheiten für die Bereitstellung in der common Language Runtime. Assemblys, richten Sie den Namespace für das Auflösen von Anforderungen und bestimmen, welche Ressourcen extern zur Verfügung gestellt werden und die innerhalb der Assembly zugegriffen werden kann. Die common Language Runtime bestimmen und suchen Sie die Assembly für alle ausgeführten Objekts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollqualifizierten Assemblynamen ab.</summary>
        <value>Ein <see langword="String" /> , den vollqualifizierten Assemblynamen enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Basistyp für den aktuellen Typ ab.</summary>
        <value>Der Basistyp für einen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Basistyp ist der Typ, von dem dieser Typ direkt erbt. Da die <xref:System.Object> Klassentyp ultimate Basisklasse aller anderen Typen ist, ist dies die einzige Art, die über keinen Basistyp. In diesem Fall `null` wird zurückgegeben, als der Basistyp der `Object` Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollqualifizierten Namen des implementierten Typs ab.</summary>
        <value>Ein <see langword="String" /> , den vollqualifizierten Typnamen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Zeichenfolge, enthält der vollqualifizierte Name des aktuellen `TypeDelegator`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den zugeordneten Attribute ab der <see langword="TypeDelegator" />.</summary>
        <returns>Ein <see langword="TypeAttributes" /> Objekt, das die Implementierungsflags für das Attribut darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um festzustellen, ob die `TypeDelegator` abstrakt, öffentliche und usw. ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>Binder</c> ist <see langword="null" />, wird der Standardbinder verwendet.</param>
        <param name="callConvention">Die Aufrufkonventionen.</param>
        <param name="types">Ein Array vom Typ <see langword="Type" /> , enthält eine Liste der Parameteranzahl, Reihenfolge und Typen. Typen nicht mit <see langword="null" />; verwenden Sie eine entsprechende <see langword="GetMethod" /> -Methode oder ein leeres Array, für eine Methode ohne Parameter gesucht werden soll.</param>
        <param name="modifiers">Ein Array vom Typ <see langword="ParameterModifier" /> hätten Sie dieselbe Länge als die <c>Typen</c> Array, dessen Elemente die Attribute, die Parameter der darstellen abzurufenden Methode zugeordnet.</param>
        <summary>Ruft den Konstruktor, der implementiert die <see langword="TypeDelegator" />.</summary>
        <returns>Ein <see langword="ConstructorInfo" /> -Objekt für die Methode, die den angegebenen Kriterien entspricht oder <see langword="null" /> , wenn keine Übereinstimmung gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `callConvention` Parameter gibt die Aufrufkonvention für den Einstiegspunkt an. Wenn keine Aufrufkonvention angegeben wird, den Standardwert <xref:System.Reflection.CallingConventions> Wert `Standard` verwendet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> Objekte, die für den Typ, der von der aktuellen umschlossen definierten Konstruktoren darstellen <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein Array vom Typ <see langword="ConstructorInfo" /> , enthält die angegebenen Konstruktoren für diese Klasse definiert. Wenn keine Konstruktoren definiert sind, wird ein leeres Array zurückgegeben. Abhängig vom Wert eines angegebenen Parameters werden nur öffentliche oder öffentlichen und nicht öffentlichen Konstruktoren zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasseninitialisierer stehen nur über `GetMember`, `GetMembers`, `FindMembers`, und `GetConstructors`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Gibt an, ob die Attribute die Vererbungskette dieses Typs zu suchen.</param>
        <summary>Gibt alle benutzerdefinierten Attribute für diesen Typ, der angibt, ob die Vererbungskette des Typs suchen definiert.</summary>
        <returns>Ein Array von Objekten, die alle für diesen Typ definierten benutzerdefinierten Attribute enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">Ein benutzerdefinierter Attributtyp kann nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Ein Array benutzerdefinierter Attribute, die durch Typ identifiziert werden.</param>
        <param name="inherit">Gibt an, ob die Attribute die Vererbungskette dieses Typs zu suchen.</param>
        <summary>Gibt ein Array benutzerdefinierter Attribute, die durch Typ identifiziert werden.</summary>
        <returns>Ein Array von Objekten, die in diesen Typ definierten benutzerdefinierten Attributen, die entsprechen den <paramref name="attributeType" /> Parameter, der angibt, ob die Vererbungskette des Typs, durchsucht oder <see langword="null" /> keine benutzerdefinierten Attribute für diesen Typ definiert sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Ein benutzerdefinierter Attributtyp kann nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Type" /> des eingeschlossenen Objekts bzw. verweist auf den aktuellen Array-, Zeiger- oder ByRef-Objekts.</summary>
        <returns>Der <see cref="T:System.Type" /> des Objekts enthalten oder verweist auf das aktuelle Array, Zeiger oder <see langword="ByRef" />, oder <see langword="null" /> Wenn das aktuelle <see cref="T:System.Type" /> ist kein Array, ein Zeiger oder ein <see langword="ByRef" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Ereignisses.</param>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt das angegebene Ereignis zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.EventInfo" /> -Objekt deklariert oder geerbt wurde von diesem Typ mit dem angegebenen Namen, die das Ereignis darstellt. Diese Methode gibt <see langword="null" /> Wenn kein entsprechendes Ereignis gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `bindingAttr` ist <xref:System.Reflection.BindingFlags>.`IgnoreCase`, wird die Groß-/Kleinschreibung, der die `name` Parameter wird ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" /> Objekte deklariert alle öffentlichen Ereignisse darstellen, oder der aktuelle <see langword="TypeDelegator" />.</summary>
        <returns>Gibt ein Array vom Typ <see langword="EventInfo" /> deklariert oder geerbt wurden durch den aktuellen Typ, der alle Ereignisse enthält. Wenn keine Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt die Ereignisse im angegebenen <paramref name="bindingAttr" /> , deklariert oder geerbt wurden von der aktuellen <see langword="TypeDelegator" />.</summary>
        <returns>Ein Array vom Typ <see langword="EventInfo" /> mit den Ereignissen, die im angegebenen <paramref name="bindingAttr" />. Wenn keine Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu suchenden Felds.</param>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt eine <see cref="T:System.Reflection.FieldInfo" /> Objekt, das das Feld mit dem angegebenen Namen darstellt.</summary>
        <returns>Ein <see langword="FieldInfo" /> -Objekt, das das Feld darstellt, deklariert oder geerbt wurde von diesem <see langword="TypeDelegator" /> mit dem angegebenen Namen. Gibt <see langword="null" /> Wenn kein entsprechendes Feld gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden einer `bindingAttr` von <xref:System.Reflection.BindingFlags>. NonPublic, um alle öffentlichen und nicht öffentlichen Felder zurück. Verwendung `BindingFlags.IgnoreCase` , um die Groß-/Kleinschreibung der Felder zu ignorieren, die standardmäßig Groß-/Kleinschreibung wird bei der Suche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt ein Array von <see cref="T:System.Reflection.FieldInfo" /> Objekte für den vom aktuellen Typ definiert, die die Datenfelder darstellt <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein Array vom Typ <see langword="FieldInfo" /> deklariert oder geerbt wurden von der aktuellen mit den Feldern <see langword="TypeDelegator" />. Wenn keine übereinstimmende Felder vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeDelegator.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.  
  
 Verwenden einer `bindingAttr` von <xref:System.Reflection.BindingFlags>. NonPublic, um alle öffentlichen und nicht öffentlichen Felder zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der vollqualifizierte Name der Schnittstelle, die von der aktuellen Klasse implementiert.</param>
        <param name="ignoreCase">
          <see langword="true" />Wenn die Groß-/Kleinschreibung ignoriert werden; andernfalls <see langword="false" />.</param>
        <summary>Gibt die angegebene Schnittstelle, die durch die vom aktuellen Typ implementiert <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein <see langword="Type" /> Objekt, das die Schnittstelle implementiert wird (direkt oder indirekt) von der aktuellen Klasse mit dem vollqualifizierten Namen entsprechend dem angegebenen Namen darstellt. Wenn keine Schnittstelle mit dem Namen entspricht, gefunden wurde, wird null ist zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Die <see cref="T:System.Type" /> von der Schnittstelle, um eine Zuordnung von abzurufen.</param>
        <summary>Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.InterfaceMapping" /> -Objekt, das die schnittstellenzuordnung für darstellt <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die schnittstellenzuordnung gibt an, wie eine Schnittstelle zu den tatsächlichen Methoden einer Klasse zugeordnet ist, die diese Schnittstelle implementiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle für die aktuelle Klasse und deren Basisklassen implementierten Schnittstellen zurück.</summary>
        <returns>Ein Array vom Typ <see langword="Type" /> , enthält alle auf der aktuellen Klasse und deren Basisklassen implementierten Schnittstellen. Wenn keine definiert sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Elements.</param>
        <param name="type">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="bindingAttr">Der Typ der abzurufenden Elemente.</param>
        <summary>Gibt die Member (Eigenschaften, Methoden, Konstruktoren, Felder, Ereignisse und geschachtelte Typen), die gemäß den angegebenen <paramref name="name" />, <paramref name="type" />, und <paramref name="bindingAttr" />.</summary>
        <returns>Ein Array vom Typ <see langword="MemberInfo" /> mit allen Elementen der aktuellen Klasse und die zugehörige Basisklasse, die den angegebenen Kriterien entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `bindingAttr` ist <xref:System.Reflection.BindingFlags>. NonPublic, werden alle Elemente berücksichtigt. Wenn keine Übereinstimmungen vorhanden sind, wird ein leeres Array zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt Elemente gemäß <paramref name="bindingAttr" />.</summary>
        <returns>Ein Array vom Typ <see langword="MemberInfo" /> mit allen Elementen, die von der aktuellen Klasse und deren Basisklassen, die erfüllen die <paramref name="bindingAttr" /> Filter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `bindingAttr` ist <xref:System.Reflection.BindingFlags>. NonPublic, werden alle Elemente berücksichtigt. Wenn keine Übereinstimmungen vorhanden sind, wird ein leeres Array zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Methodenname.</param>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>Binder</c> ist <see langword="null" />, wird der Standardbinder verwendet.</param>
        <param name="callConvention">Die Aufrufkonventionen.</param>
        <param name="types">Ein Array vom Typ <see langword="Type" /> , enthält eine Liste der Parameteranzahl, Reihenfolge und Typen. Typen nicht mit <see langword="null" />; verwenden Sie eine entsprechende <see langword="GetMethod" /> -Methode oder ein leeres Array, für eine Methode ohne Parameter gesucht werden soll.</param>
        <param name="modifiers">Ein Array vom Typ <see langword="ParameterModifier" /> hätten Sie dieselbe Länge als die <c>Typen</c> Array, dessen Elemente die Attribute, die Parameter der darstellen abzurufenden Methode zugeordnet.</param>
        <summary>Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein <see langword="MethodInfoInfo" /> -Objekt für die Implementierungsmethode, die den angegebenen Kriterien entspricht oder <see langword="null" /> , wenn keine Übereinstimmung gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `callConvention` Parameter gibt die Aufrufkonvention für den Einstiegspunkt an. Wenn kein <xref:System.Reflection.CallingConventions> angegeben wird, den Standardwert `CallingConventions` Wert `Standard` verwendet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt ein Array von <see cref="T:System.Reflection.MethodInfo" /> Objekte, die angegebene Methoden des Typs von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein Array von <see langword="MethodInfo" /> Objekte, die die Methoden definiert, die für dieses <see langword="TypeDelegator" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des geschachtelten Typs.</param>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt einen geschachtelten Typ gemäß <paramref name="name" /> und <paramref name="bindingAttr" /> , deklarierten oder geerbten durch den Typ, der vom aktuellen <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein <see langword="Type" /> Objekt, das den geschachtelten Typ darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt die geschachtelten Typen im angegebenen <paramref name="bindingAttr" /> , deklarierten oder geerbten durch den Typ von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein Array vom Typ <see langword="Type" /> , das geschachtelte Typen enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <summary>Gibt ein Array von <see cref="T:System.Reflection.PropertyInfo" /> Objekten, die Eigenschaften des Typs von der aktuellen umschlossen darstellen <see cref="T:System.Reflection.TypeDelegator" />.</summary>
        <returns>Ein Array von <see langword="PropertyInfo" /> Objekten, die für diese definierten Eigenschaften darstellen <see langword="TypeDelegator" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Die abzurufende Eigenschaft.</param>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>Binder</c> ist <see langword="null" />, wird der Standardbinder verwendet. Siehe <see cref="T:System.Reflection.Binder" />.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Eine Liste von Parametertypen. Die Liste darstellt, das Anzahl, Reihenfolge und Typen der Parameter. Typen können nicht null sein. Verwenden Sie eine entsprechende <see langword="GetMethod" /> -Methode oder ein leeres Array, für eine Methode ohne Parameter gesucht werden soll.</param>
        <param name="modifiers">Ein Array derselben Länge als Typen mit Elementen, die die mit den Parametern der abzurufenden Methode verknüpften Attribute darstellen.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.PropertyInfo" /> -Objekt für die Eigenschaft, die den angegebenen Kriterien entspricht, oder null, wenn keine Übereinstimmung gefunden werden kann.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die GUID (globally unique Identifier) des implementierten Typs ab.</summary>
        <value>Ein GUID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die GUID (globally unique Identifier) ist eine eindeutige Kennung der 128-Bit-Zeichenfolge, die zur Identifizierung einer Klasse oder eine Schnittstelle. Es eignet sich hauptsächlich für die Interoperabilität zwischen Microsoft .NET Framework und COM.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die aktuelle <see cref="T:System.Type" /> umfasst oder auf einen anderen Typ, der verweist, gibt an, ob die aktuelle <see cref="T:System.Type" /> ist ein Array, Zeiger oder ByRef.</summary>
        <returns>
          <see langword="true" />Wenn die <see cref="T:System.Type" /> ist ein Array, Zeiger oder ByRef; anderenfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des aufzurufenden Members. Dies kann ein Konstruktor, Methoden-, Eigenschafts- oder Feldinformationen sein. Wenn eine leere Zeichenfolge ("") übergeben wird, wird die Standardeinstellung Member aufgerufen wird.</param>
        <param name="invokeAttr">Das Attribut für den Aufruf. Diese Angabe muss eines der folgenden <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, oder <see langword="SetProperty" />. Es muss ein geeignetes Aufrufattribut angegeben werden. Wenn ein statischer Member aufgerufen werden soll, ist die <see langword="Static" /> Flag muss festgelegt werden.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>Binder</c> ist <see langword="null" />, wird der Standardbinder verwendet. Siehe <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array vom Typ <see langword="Object" /> , enthält die Anzahl, Reihenfolge und Typ der Parameter des Members aufgerufen werden. Wenn <c>Args</c> enthält eine nicht initialisierte <see langword="Object" />, es wird behandelt, als leer, die mit dem Standardbinder auf 0, 0,0 oder eine Zeichenfolge erweitert werden kann.</param>
        <param name="modifiers">Ein Array vom Typ <see langword="ParameterModifer" /> also die gleiche Länge wie <c>Args</c>, mit Elementen, die die Attribute, die den Argumenten des aufzurufenden Members zugeordnet darstellen. Ein Parameter verfügt über Attribute in der Signatur des Members zugeordnet. Verwenden Sie für ByRef <see langword="ParameterModifer.ByRef" />, und verwenden Sie für keine "," <see langword="ParameterModifer.None" />. Der Standardbinder genau diese Zuordnung. Attribute wie <see langword="In" /> und <see langword="InOut" /> werden nicht in der Bindung verwendet und angezeigt werden kann <see langword="ParameterInfo" />.</param>
        <param name="culture">Eine Instanz von <see langword="CultureInfo" /> für die Steuerung der Umwandlung von Typen. Dies ist erforderlich, z. B. um eine Zeichenfolge zu konvertieren, der 1000 darstellt ein <see langword="Double" /> Wert, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird. Wenn <c>Kultur</c> ist <see langword="null" />, <see langword="CultureInfo" /> für des aktuellen Threads <see langword="CultureInfo" /> verwendet wird.</param>
        <param name="namedParameters">Ein Array vom Typ <see langword="String" /> mit Parameternamen, die übereinstimmen ab Element 0 (null), mit der <c>Args</c> Array. Im Array muss keine Lücken vorhanden sein. Wenn <c>Args</c>. <see langword="Length" />ist größer als <c>NamedParameters</c>. <see langword="Length" />, die verbleibenden Parameter werden in Reihenfolge gefüllt.</param>
        <summary>Ruft den angegebenen Member auf. Die Methode, die aufgerufen werden soll, muss zugänglich sein und mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und der Aufrufattribute die spezifischste Übereinstimmung bereitstellen.</summary>
        <returns>Ein <see langword="Object" /> , das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Methode wird aufgerufen, wenn die beiden folgenden Bedingungen erfüllt sind:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl von Argumenten in der angegebenen Argumentliste, (es sei denn, die Standardargumente für das Element definiert sind).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`usw.). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.  
  
 Wenn die Methode ausgewählt wurde, wird sie aufgerufen werden. Eingabehilfen ist an diesem Punkt aktiviert. Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode ist verantwortlich für die Auswahl der Methode, die aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
> [!NOTE]
>  Zugriffseinschränkungen für vollständig vertrauenswürdige Code ignoriert. D. h. private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden können, und Sie aufgerufen wird, mithilfe von Reflektion im Code vollständig vertrauenswürdig ist.  
  
 Derzeit `InvokeMember` führt die Reflektion-Semantik von Microsoft .NET Framework für jeden Typ des Objekts.  
  
 Wenn das namentlich angegebene Element ein Array ist und die `BindingFlags.GetField` Flag wird festgelegt, auf `invokeAttr`, die `args` Array gibt an, die Elemente, deren Werte zurückgegeben werden. Beispielsweise der folgende Aufruf über `Type` Objekt `t` gibt den Wert des ersten Elements des Zeichenfolgenarrays MyArray, das Mitglied des aufrufenden Objekts ist:  
  
 `String ret = (String) t.InvokeMember ("MyArray", BindingFlags.GetField, null, this, new Variant[]{0});`  
  
 Sie können `InvokeMember` auf einem oder mehreren Elementen eines Memberarrays festgelegt. Alle Elemente werden auf den gleichen Wert festgelegt. Die `args` -Array muss wie folgt formatiert:  
  
```  
{index1,  
    index2,, value}  
```  
  
 Beispielsweise ist zum Festlegen des ersten Elements der MyArray aus dem vorherigen Beispiel die Syntax folgendermaßen:  
  
```  
t.InvokeMember ("MyArray", BindingFlags.SetField, null, this, new  
    Variant[]{0,"Updated"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob die <see cref="T:System.Type" /> ist ein Array.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Der zu überprüfende Typ.</param>
        <summary>Gibt einen Wert, der angibt, ob der angegebene Typ diesem Typ zugewiesen werden kann.</summary>
        <returns>
          <see langword="true" />, wenn der angegebene Typ diesem Typ zugeordnet werden kann; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob die <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob die <see cref="T:System.Type" /> ist ein COM-Objekt.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Gibt an, ob die Attribute die Vererbungskette dieses Typs zu suchen.</param>
        <param name="inherit">Ein Array benutzerdefinierter Attribute, die durch Typ identifiziert werden.</param>
        <summary>Gibt an, ob ein benutzerdefiniertes Attribut identifizierte <paramref name="attributeType" /> definiert ist.</summary>
        <returns>
          <see langword="true" />Wenn ein benutzerdefiniertes Attribut identifizierten <paramref name="attributeType" /> definiert ist; andernfalls, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Der benutzerdefinierte Attributtyp kann nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob die <see cref="T:System.Type" /> ist ein Zeiger.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob die <see cref="T:System.Type" /> zu den primitiven Typen ist.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert, der angibt, ob der Typ ein Werttyp ist; d. h. weder eine Klasse noch eine Schnittstelle.</summary>
        <returns>
          <see langword="true" />Wenn der Typ ein Werttyp ist. andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der diese Entität in den Metadaten identifiziert.</summary>
        <value>Ein Wert, der in Kombination mit dem Modul diese Entität in den Metadaten eindeutig identifiziert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Token mit dieser Eigenschaft können, die nicht verwaltete Reflektions-API übergeben werden. Weitere Informationen finden Sie unter [nicht verwalteten Reflektions-API](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul, das den implementierten Typ enthält.</summary>
        <value>Ein <see cref="T:System.Reflection.Module" /> Objekt, das das Modul des implementierten Typs darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Modul ist eine ladbaren Einheit, die Deklarationen von Typen und Implementierungen enthalten kann. Module enthalten genügend Informationen zum Aktivieren der common Language Runtime alle Implementierungsbits zu suchen, wenn das Modul geladen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der implementierten Typs mit dem Pfad entfernt.</summary>
        <value>Ein <see langword="String" /> , die den nicht qualifizierten Typnamen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Zeichenfolge, die den Namen der aktuellen `TypeDelegator`-Klasse enthält. Nur der einfache Name nicht den vollqualifizierten Namen wird zurückgegeben. Verwenden Sie zum Abrufen der Name und Pfad <xref:System.Reflection.TypeDelegator.FullName%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace des implementierten Typs ab.</summary>
        <value>Ein <see langword="String" /> , der den Namespace des Typs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft eine Zeichenfolge mit dem Namespace des aktuellen `TypeDelegator`. Beispielsweise, wenn die `TypeDelegator` ist <xref:System.Reflection.TypeFilter>, ist der zurückgegebene Namespace <xref:System.Reflection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Handle für die interne Metadatendarstellung einer implementierten Typs ab.</summary>
        <value>Ein <see langword="RuntimeTypeHandle" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Typhandle ist eine eindeutige ganze Zahl-Wert, der jeden Typ zugeordnet. Das Handle ist während der Laufzeit eindeutig.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="typeImpl">
      <MemberSignature Language="C#" Value="protected Type typeImpl;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type typeImpl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.TypeDelegator.typeImpl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein Wert, der Typinformationen angibt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden <see cref="T:System.Type" /> , die den implementierten Typ darstellt.</summary>
        <value>Der zugrunde liegende Typ.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
