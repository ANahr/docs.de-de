<Type Name="Module" FullName="System.Reflection.Module">
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Führt die Reflektion für ein Modul durch.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Modul ist eine portierbare ausführbare Datei, z. B. type.dll oder application.exe, bestehend aus einem oder mehreren Klassen und Schnittstellen. Ein einzelnes Modul kann mehrere Namespaces enthalten, und ein Namespace kann mehrere Module umfassen.  
  
 Wenn ein Modul oder mehrere Module als Einheit bereitgestellt werden, bilden sie eine Assembly. Informationen zum Erstellen einer Assemblys mit mehr als einem Modul finden Sie unter [Multifile Assemblys](~/docs/framework/app-domains/multifile-assemblies.md).  
  
 Beachten Sie, dass ein .NET Framework-Modul nicht als Modul in Visual Basic ist durch einen Programmierer dient zum Organisieren von Funktionen und Unterroutinen in einer Anwendung.  
  
   
  
## Examples  
 Die folgenden Codebeispiele zeigen, wie die Reflexion zum Abrufen von Informationen zu Modulen verwenden:  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Module" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung der <xref:System.Reflection.Module> Objekte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den entsprechenden <see cref="T:System.Reflection.Assembly" /> für diese Instanz von <see cref="T:System.Reflection.Module" />.</summary>
        <value>Ein <see langword="Assembly" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den vollständigen Namen der angegebenen Assembly im angegebenen Modul an.  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung, die benutzerdefinierten Attribute für dieses Modul enthält.</summary>
        <value>Eine Auflistung, die benutzerdefinierten Attribute für dieses Modul enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob dieses Modul und das angegebene Objekt gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="o" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein <see langword="TypeFilter" />-Objekt, das die Liste der in diesem Modul definierten Typen basierend auf dem Namen filtert. In diesem Feld wird Groß-/Kleinschreibung berücksichtigt, und es ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Filter unterstützt einen abschließenden "*" Platzhalter.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Modulnamen, die die angegebenen Suchkriterien entsprechen.  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein <see langword="TypeFilter" />-Objekt, das die Liste der in diesem Modul definierten Typen basierend auf dem Namen filtert. In diesem Feld wird Groß-/Kleinschreibung nicht berücksichtigt, und es ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Filter unterstützt einen abschließenden "*" Platzhalter.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Modulnamen, die die angegebenen Suchkriterien ignorieren die Groß-/Kleinschreibung entsprechen.  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Der Delegat, der zum Filtern der Klassen verwendet wird.</param>
        <param name="filterCriteria">Ein Objekt, das zum Filtern der Klassen verwendet wird.</param>
        <summary>Gibt ein Array von Klassen zurück, die vom angegebenen Filter und den Filterkriterien akzeptiert werden.</summary>
        <returns>Ein Array vom Typ <see langword="Type" /> mit Klassen, die vom Filter akzeptiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ReflectionTypeLoadException>ist eine besondere Klasse Load-Ausnahme. Die `ReflectionTypeLoadException.Types` -Eigenschaft enthält das Array von Klassen, die im Modul definiert und geladen wurden. Dieses Array kann einige null-Werte enthalten. Die `ReflectionTypeLoadException.LoaderExceptions` Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Klassenladeprogramm ausgelöst wurden. Richten Sie die Lücken in der Klasse Array mit den Ausnahmen.  
  
 Der Delegat, der vom `filter` wird aufgerufen, für jede Klasse in das Modul, das weiter und übergibt dabei die `Type` Objekt, das die Klasse darstellt, sowie die angegebenen `filterCriteria`. Wenn `filter` gibt eine bestimmte Klasse, dass die Klasse in das zurückgegebene Array eingeschlossen werden sollen. Wenn `filter` gibt `null`, werden alle Klassen zurückgegeben und `filterCriteria` wird ignoriert.  
  
 `FindTypes`kann nicht verwendet werden, um parametrisierte Typen z. B. Arrays zu suchen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `FindTypes` Methode.  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge, die den vollqualifizierten Namen und Pfad zu diesem Modul darstellt.</summary>
        <value>Der vollqualifizierte Modulname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie zum Abrufen der Namen ohne die Pfadangabe <xref:System.Reflection.Module.Name%2A>.  
  
 Wenn die Assembly für dieses Modul aus einem Bytearray geladen wurde und dann die `FullyQualifiedName` für das Modul: \<unbekannt >.  
  
> [!NOTE]
>  Die Groß-/Kleinschreibung des Moduls ist plattformabhängig.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den vollqualifizierten Namen des angegebenen Moduls.  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen im Pfad. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Gibt alle benutzerdefinierten Attribute zurück.</summary>
        <returns>Ein Array vom Typ <see langword="Object" /> , alle benutzerdefinierten Attribute enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den Modulnamen, die die angegebenen Suchkriterien entsprechen.  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ des abzurufenden Attributs.</param>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Ruft die benutzerdefinierten Attribute des angegebenen Typs ab.</summary>
        <returns>Ein Array vom Typ <see langword="Object" /> , alle benutzerdefinierten Attribute des angegebenen Typs enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Modulnamen des angegebenen Typs, die die angegebenen Suchkriterien entsprechen.  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />ist ein <see cref="T:System.Type" /> Objekt von der Laufzeit bereitgestellt wird. Beispielsweise <paramref name="attributeType" /> ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von <see cref="T:System.Reflection.CustomAttributeData" /> Objekte für das aktuelle Modul, das in den ReflectionOnly Kontext verwendet werden kann.</summary>
        <returns>Eine generische Liste von <see cref="T:System.Reflection.CustomAttributeData" /> Objekte, die Darstellung von Daten zu den Attributen, die für das aktuelle Modul angewendet wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die benutzerdefinierten Attribute des Codes in den ReflectionOnly Kontext, in Fällen zu untersuchen, in dem die benutzerdefinierten Attribute selbst im Code definiert werden, die in den reflektionsbezogenen Kontext geladen wird. Methoden, z. B. <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> und <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> kann nicht in solchen Fällen verwendet werden, da sie Instanzen der Attribute erstellen. Code in den ReflectionOnly Kontext kann nicht ausgeführt werden. Weitere Informationen und Beispielcode finden Sie unter der <xref:System.Reflection.CustomAttributeData> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Feldname.</param>
        <summary>Gibt ein Feld mit dem angegebenen Namen zurück.</summary>
        <returns>Ein <see langword="FieldInfo" />-Objekt mit dem angegebenen Namen oder <see langword="null" />, wenn das Feld nicht existiert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Der Feldname.</param>
        <param name="bindingAttr">Eines der <see langword="BindingFlags" />-Bitflags zum Steuern der Suche.</param>
        <summary>Gibt ein Feld mit dem angegebenen Namen und Bindungsattributen zurück.</summary>
        <returns>Ein <see langword="FieldInfo" />-Objekt mit dem angegebenen Namen und Bindungsattributen oder <see langword="null" />, wenn das Feld nicht existiert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die globalen Felder zurück, die im Modul definiert sind.</summary>
        <returns>Ein Array aus <see cref="T:System.Reflection.FieldInfo" />-Objekten, das die im Modul definierten globalen Felder darstellt. Wenn keine globalen Felder vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Module.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten, die die Suche einschränken.</param>
        <summary>Gibt die für das Modul definierten globalen Felder zurück, die den angegebenen Bindungsflags entsprechen.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Reflection.FieldInfo" />, das die für das Modul definierten globalen Felder darstellt, die den angegebenen Bindungsflags entsprechen; wenn keine globalen Felder den Bindungsflags entsprechen, wird ein leeres Array zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Module.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Methodenname.</param>
        <summary>Gibt eine Methode mit dem angegebenen Namen zurück.</summary>
        <returns>Ein <see langword="MethodInfo" />-Objekt mit dem angegebenen Namen oder <see langword="null" />, wenn die Methode nicht existiert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Methodenname.</param>
        <param name="types">Die zu suchenden Parametertypen.</param>
        <summary>Gibt eine Methode mit den angegebenen Namen und Parametertypen zurück.</summary>
        <returns>Ein <see langword="MethodInfo" />-Objekt, das den angegebenen Kriterien entspricht, oder <see langword="null" />, wenn die Methode nicht vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />, <paramref name="types" /> ist <see langword="null" />, oder <paramref name="types" /> (i) ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Methodenname.</param>
        <param name="bindingAttr">Eines der <see langword="BindingFlags" />-Bitflags zum Steuern der Suche.</param>
        <param name="binder">Ein Objekt, das <see langword="Binder" /> implementiert, das auf diese Methode bezogene Eigenschaften enthält.</param>
        <param name="callConvention">Die Aufrufkonvention für die Methode.</param>
        <param name="types">Die zu suchenden Parametertypen.</param>
        <param name="modifiers">Ein Array von Parametermodifizierern, das zur Bindung mit Parametersignaturen verwendet wird, in denen die Typen geändert wurden.</param>
        <summary>Gibt eine Methode mit dem angegebenen Namen, den Bindungsinformationen, der Aufrufkonvention, Parametertypen und Modifizierern zurück.</summary>
        <returns>Ein <see langword="MethodInfo" />-Objekt, das den angegebenen Kriterien entspricht, oder <see langword="null" />, wenn die Methode nicht vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />, <paramref name="types" /> ist <see langword="null" />, oder <paramref name="types" /> (i) ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Methodenname.</param>
        <param name="bindingAttr">Eines der <see langword="BindingFlags" />-Bitflags zum Steuern der Suche.</param>
        <param name="binder">Ein Objekt, das <see langword="Binder" /> implementiert, das auf diese Methode bezogene Eigenschaften enthält.</param>
        <param name="callConvention">Die Aufrufkonvention für die Methode.</param>
        <param name="types">Die zu suchenden Parametertypen.</param>
        <param name="modifiers">Ein Array von Parametermodifizierern, das zur Bindung mit Parametersignaturen verwendet wird, in denen die Typen geändert wurden.</param>
        <summary>Gibt die Implementierung der Methode den angegebenen Kriterien zurück.</summary>
        <returns>Ein <see langword="MethodInfo" /> Objekt, das Implementierungsinformationen wie angegeben, enthält oder <see langword="null" /> , wenn die Methode nicht vorhanden ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <paramref name="types" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die globalen Methoden zurück, die im Modul definiert sind.</summary>
        <returns>Ein Array aus <see cref="T:System.Reflection.MethodInfo" />-Objekten, das alle im Modul definierten globalen Methoden darstellt. Wenn keine globalen Methoden vorhanden sind, wird ein leeres Array zurückgegeben.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten, die die Suche einschränken.</param>
        <summary>Gibt die für das Modul definierten globalen Methoden zurück, die den angegebenen Bindungsflags entsprechen.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Reflection.MethodInfo" />, das die für das Modul definierten globalen Methoden darstellt, die den angegebenen Bindungsflags entsprechen; wenn keine globalen Methoden den Bindungsflags entsprechen, wird ein leeres Array zurückgegeben.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Zum Serialisieren oder Deserialisieren eines Objekts die Informationen und Daten erforderlich.</param>
        <param name="context">Der Kontext für die Serialisierung.</param>
        <summary>Stellt eine <see cref="T:System.Runtime.Serialization.ISerializable" /> Implementierung für serialisierte Objekte.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">Wenn diese Methode zurückgegeben, eine Kombination der <see cref="T:System.Reflection.PortableExecutableKinds" /> Werte, der angibt, die Art des Codes im Modul.</param>
        <param name="machine">Wenn diese Methode gibt einen von der <see cref="T:System.Reflection.ImageFileMachine" /> Werte, der angibt, der vom Modul verwiesen Plattform.</param>
        <summary>Ruft ein Wertepaar, der angibt, der Art des Codes in einem Modul und die Plattform, auf die vom Modul ab.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see langword="X509Certificate" /> -Objekt, das Zertifikat in der Authenticode-Signatur der Assembly, die dieses Modul gehört enthalten entspricht. Wenn die Assembly nicht mit Authenticode signiert wurde <see langword="null" /> wird zurückgegeben.</summary>
        <returns>Ein <see langword="X509Certificate" /> -Objekt, oder <see langword="null" /> Wenn die Assembly, zu der dieses Modul gehört, nicht mit Authenticode signiert wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">Der Name des zu suchenden Typs. Der Name muss im Namespace vollqualifiziert sein.</param>
        <summary>Gibt den angegebenen Typ zurück. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</summary>
        <returns>Ein <see langword="Type" />-Objekt, das den angegebenen Typ darstellt, wenn der Typ sich in diesem Modul befindet; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ an einer anderen Assembly weitergeleitet wurde, ist es immer noch von dieser Methode zurückgegeben. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Ein Typ abgerufen werden kann, aus einem bestimmten Modul mit <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Aufrufen von <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly. Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul an.  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die Klasseninitialisierer werden aufgerufen, und eine Ausnahme wird ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> ist eine Zeichenfolge mit der Länge 0 (null).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
 - oder -   
  
 Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="className" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="className" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">Der Name des zu suchenden Typs. Der Name muss im Namespace vollqualifiziert sein.</param>
        <param name="ignoreCase">
          <see langword="true" /> für die Suche ohne Beachtung der Groß-/Kleinschreibung; andernfalls <see langword="false" />.</param>
        <summary>Durchsucht das Modul mit der angegebenen Groß-/Kleinschreibung und gibt den angegebenen Typ zurück.</summary>
        <returns>Ein <see langword="Type" />-Objekt, das den angegebenen Typ darstellt, wenn der Typ sich in diesem Modul befindet; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ an einer anderen Assembly weitergeleitet wurde, ist es immer noch von dieser Methode zurückgegeben. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Ein Typ abgerufen werden kann, aus einem bestimmten Modul mit <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Aufrufen von <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly. Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul angeben `false` für die `ignoreCase` an, damit dieser Fall werden nicht ignoriert.  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die Klasseninitialisierer werden aufgerufen, und eine Ausnahme wird ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> ist eine Zeichenfolge mit der Länge 0 (null).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
 - oder -   
  
 Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="className" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="className" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">Der Name des zu suchenden Typs. Der Name muss im Namespace vollqualifiziert sein.</param>
        <param name="throwOnError">
          <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="ignoreCase">
          <see langword="true" /> für die Suche ohne Beachtung der Groß-/Kleinschreibung; andernfalls <see langword="false" />.</param>
        <summary>Gibt den angegebenen Typ, der angibt, ob Groß-/ Kleinschreibung des Moduls vornehmen und eine Ausnahme auslöst, wenn der Typ nicht gefunden werden.</summary>
        <returns>Ein <see cref="T:System.Type" /> Objekt, das den angegebenen Typ darstellt, sofern der Typ in diesem Modul deklariert ist, andernfalls ist <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `throwOnError` Parameter wirkt sich auf nur was geschieht, wenn der Typ nicht gefunden wird. Dies beeinflusst keine andere Ausnahmen, die möglicherweise ausgelöst werden. Insbesondere, wenn der Typ gefunden wird, kann nicht geladen werden kann <xref:System.TypeLoadException> kann ausgelöst werden, selbst wenn `throwOnError` ist `false`.  
  
> [!NOTE]
>  Wenn der Typ an einer anderen Assembly weitergeleitet wurde, ist es immer noch von dieser Methode zurückgegeben. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Ein Typ abgerufen werden kann, aus einem bestimmten Modul mit <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Aufrufen von <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly. Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul an. Die `throwOnError` und `ignoreCase` als Parameter angegeben sind `false`.  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die Klasseninitialisierer werden aufgerufen, und eine Ausnahme wird ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> ist eine Zeichenfolge mit der Länge 0 (null).</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
 - oder -   
  
 Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="className" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="className" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle in diesem Modul definierten Typen zurück.</summary>
        <returns>Ein Array vom Typ <see langword="Type" />, das Typen enthält, die in dem von dieser Instanz reflektierten Modul definiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException`ist eine besondere Ausnahme beim Laden. Die `ReflectionTypeLoadException.Types` -Eigenschaft enthält das Array von Typen, die im Modul definiert und geladen wurden. Dieses Array kann einige null-Werte enthalten. Die `ReflectionTypeLoadException.LoaderExceptions` Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Ladeprogramm ausgelöst wurden. Richten Sie die Lücken in der Klasse Array mit den Ausnahmen.  
  
 Z. B. wenn eine der Klassen der Klasseninitialisierer löst eine Ausnahme während der es wird geladen, eine `TargetInvocationException` befindet sich in dem entsprechenden Element des der `LoaderExceptions` Array.  
  
> [!NOTE]
>  Wenn Sie ein Typ an einer anderen Assembly weitergeleitet wurde, ist es nicht im zurückgegebenen Array enthalten. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Reflektionsberechtigung für das aktuelle Modul.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ des benutzerdefinierten Attributs zur Prüfung auf.</param>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Gibt einen Wert, der angibt, ob der Typ des angegebenen Attributs für dieses Modul angewendet wurde.</summary>
        <returns>
          <see langword="true" />Wenn eine oder mehrere Instanzen des <paramref name="attributeType" /> wurden für dieses Modul angewendet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `IsDefined` Methode.  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />ist ein <see cref="T:System.Type" /> Objekt von der Laufzeit bereitgestellt wird. Beispielsweise <paramref name="attributeType" /> ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob das Objekt eine Ressource ist.</summary>
        <returns>
          <see langword="true" />Wenn das Objekt eine Ressource ist. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `IsResource` Methode.  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version des Metadatenstreams ab.</summary>
        <value>Eine 32-Bit-Ganzzahl, die Version des Metadatenstreams darstellt. Die zwei höherwertigen Bytes die Hauptversionsnummer und die zwei niederwertigen Bytes darstellen die Nebenversionsnummer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Weitere Informationen zu den Metadatenheader finden Sie unter "Partition II: Metadata Definition and Semantics" in der Dokumentation für die Common Language Infrastructure (CLI). Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Token, das das Modul in den Metadaten identifiziert.</summary>
        <value>Ein Integer-Token, das das aktuelle Modul in den Metadaten bezeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Token mit dieser Eigenschaft können auf der nicht verwalteten Reflektions-API übergeben werden. Weitere Informationen finden Sie unter [nicht verwalteten Reflektions-API](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Handle für das Modul an.</summary>
        <value>Ein <see cref="T:System.ModuleHandle" /> Struktur für das aktuelle Modul.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen universellen eindeutigen Bezeichner (Universally Unique Identifier, UUID) ab, der zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</summary>
        <value>Eine <see cref="T:System.Guid" />, die zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In nicht verwalteten Metadaten, die GUID zurückgegeben, indem Sie die <xref:System.Reflection.Module.ModuleVersionId%2A> Eigenschaft wird als bezeichnet den `mvid`, und im GUID-Heap gespeichert wird.  
  
> [!NOTE]
>  Weitere Informationen zu Metadaten kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see langword="String" /> entfernt, die den Namen des Moduls mit dem Pfad.</summary>
        <value>Der Modulname ohne Pfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Name`ist eine plattformabhängige Zeichenfolge.  
  
 Wenn die Assembly für dieses Modul aus einem Bytearray geladen wurde und dann die `FullyQualifiedName` für das Modul: \<unbekannt >.  
  
 Verwenden Sie zum Abrufen der Name und Pfad <xref:System.Reflection.Module.FullyQualifiedName%2A>.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Auswirkung der `ScopeName`, `FullyQualifiedName`, und `Name` Eigenschaften.  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Objekt.</param>
        <param name="right">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Reflection.Module" />-Objekte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Objekt.</param>
        <param name="right">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Reflection.Module" />-Objekte ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das ein Feld im Modul identifiziert.</param>
        <summary>Gibt die vom angegebenen Metadatentoken identifizierte Feld zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.FieldInfo" /> Objekt, das das Feld, das das angegebene Metadatentoken identifizierte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auflösen ein Metadatentoken, das einen Feld identifiziert, dessen übergeordnetes Objekt `TypeSpec` verfügt über eine Signatur, die mit dem Elementtyp `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden Sie die <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen. D. h. Wenn Sie ein Metadatentoken für ein Feld auflösen, die davon abhängen die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für ein Feld im Bereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />Gibt ein Feld, dessen übergeordnetes Objekt <see langword="TypeSpec" /> verfügt über eine Signatur mit Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das ein Feld im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt das Feld identifiziert, die durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definiert.</summary>
        <returns>Ein <see cref="T:System.Reflection.FieldInfo" /> Objekt, das das Feld, das das angegebene Metadatentoken identifizierte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für ein Feld im Bereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />Gibt ein Feld, dessen übergeordnetes Objekt <see langword="TypeSpec" /> verfügt über eine Signatur mit Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden nicht für eine oder beide <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das einen Typ oder Member im Modul identifiziert.</param>
        <summary>Gibt den Typ oder Member, die durch das angegebene Metadatentoken identifiziert.</summary>
        <returns>Ein <see cref="T:System.Reflection.MemberInfo" /> Objekt, das den Typ oder Member, die durch das angegebene Metadatentoken identifiziert ist darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Metadatentoken für Auflösen einer `MethodSpec` oder `TypeSpec` , dessen Signatur enthält Elementtyp `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden die <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen. D. h. Wenn Sie ein Metadatentoken für ein Element aufgelöst werden, die davon abhängen die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für einen Typ oder Member im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="MethodSpec" /> oder <see langword="TypeSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode).  
  
 - oder -   
  
 <paramref name="metadataToken" />bezeichnet eine Eigenschaft oder ein Ereignis.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das einen Typ oder Member im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt den Typ oder Member, die durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definierten identifiziert.</summary>
        <returns>Ein <see cref="T:System.Reflection.MemberInfo" /> Objekt, das den Typ oder Member, die durch das angegebene Metadatentoken identifiziert ist darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für einen Typ oder Member im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="MethodSpec" /> oder <see langword="TypeSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden für eine oder beide nicht angegeben der <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.  
  
 - oder -   
  
 <paramref name="metadataToken" />bezeichnet eine Eigenschaft oder ein Ereignis.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Methode oder ein Konstruktor im Modul identifiziert.</param>
        <summary>Gibt die Methode oder der Konstruktor, der durch das angegebene Metadatentoken identifiziert.</summary>
        <returns>Ein <see cref="T:System.Reflection.MethodBase" /> Objekt, das die Methode oder der Konstruktor, der vom angegebenen Metadatentoken identifiziert wird darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Metadatentoken für Auflösen einer `MethodSpec` , dessen Signatur enthält Elementtyp `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden die <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen. D. h. Wenn Sie ein Metadatentoken für eine Methode, die die generischen Typparameter eines generischen Typs hängt und/oder der generischen Methode, die in der das Token eingebettet wird aufgelöst werden, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die zwei Überladungen der <xref:System.Reflection.Module.ResolveMethod%2A> -Methode zum Auflösen von Metadatentoken Aufrufs in generischen und nicht generischen Kontexten sites.  
  
 Das Codebeispiel definiert zwei generische Typen `G1<Tg1>` und `G2<Tg2>` (`G1(Of Tg1)` und `G2(Of Tg2)` in Visual Basic), von denen jede verfügt über eine generische Methode. `G1<Tg1>`verfügt auch über eine nicht generische Methode, die die Typparameter `Tg1` für ihre Parameter. Die generische Methode `GM2<Tgm2>` im Typ `G2<Tg2>` enthält mehrere Methodenaufrufe:  
  
-   Fall 1: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Verwendung der Typparameter der `G2<Tg2>` und `GM2<Tgm2>` als Typargumente. Das heißt, die Parametertypen der aufgerufenen Methode hängen die Typen, die verwendet werden, so erstellen Sie einen geschlossenen generischen Typs aus der Typdefinition für `G2<Tg2>`.  
  
-   Fall 2: Die nicht generische Methode `M1` aufgerufen wird. Die Parameter dieser Methode verwendet den Typparameter des definierenden Typs `G1<Tg1>`, das in diesem Fall durch den Typparameter von einschließenden Typ ersetzt wird `G2<Tg2>`.  
  
-   Fall 3: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.. Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.  
  
-   Fall 4: Die nicht generische Methode `M1` von der `Example` -Klasse aufgerufen wird. Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.  
  
 Darüber hinaus definiert das Beispiel die nicht generische `Example` Klasse. Diese Klasse verfügt über eine Methode `M` , die eine generische Methode aufruft:  
  
-   Fall 5: Die generische Methode `GM1` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.. Der Kontext für diese Methode hat keine einschließenden generischen Typ- oder Methodendefinition.  
  
 Für jeden Fall im Beispiel wird zuerst erstellt ein <xref:System.Reflection.MethodInfo> , die die aufgerufene Methode darstellt, und löst dann das token mithilfe der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode zu überladen, mit der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> und <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methoden zum Abrufen der Werte für die `genericTypeArguments` und `genericMethodArguments` Parameter. Dieses Verfahren kann in allen Fällen auf, da es sich bei den Methoden zurückgegebenen <xref:System.Type.EmptyTypes?displayProperty=nameWithType> für nicht generische Kontexte. Im Beispiel vergleicht die aufgelöste <xref:System.Reflection.MethodInfo> mit erstellten <xref:System.Reflection.MethodInfo>.  
  
 Im Beispiel wird dann versucht, mithilfe der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> -methodenüberladung, um das Token zu beheben. Dies funktioniert in Fällen, 3, 4 und 5, da die Methodenaufrufe nicht generische Kontext abhängig sind. In Fällen, 1 und 2 wird eine Ausnahme ausgelöst, da es nicht genügend Informationen zum Auflösen des Tokens ist.  
  
 Die Tokenwerte Metadaten werden als eine Enumeration hartcodiert. Wenn Sie dieses Codebeispiel ändern, werden die Tokenwerte wahrscheinlich geändert. Um die neuen Werte zu bestimmen, den Code kompilieren und mithilfe von Ildasm.exe mit der **/Token** Option aus, um die Assembly zu untersuchen. Das Token können an den Positionen des Aufrufs gefunden werden. Fügen Sie die neuen Werte in der Enumeration und kompilieren Sie das Beispiel.  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für eine Methode oder ein Konstruktor im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="MethodSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Methode oder ein Konstruktor im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt die Methode oder der Konstruktor, identifiziert durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definiert.</summary>
        <returns>Ein <see cref="T:System.Reflection.MethodBase" /> Objekt, das die Methode, die durch das angegebene Metadatentoken identifiziert wird darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericMethodArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die zwei Überladungen der <xref:System.Reflection.Module.ResolveMethod%2A> -Methode zum Auflösen von Metadatentoken Aufrufs in generischen und nicht generischen Kontexten sites.  
  
 Das Codebeispiel definiert zwei generische Typen `G1<Tg1>` und `G2<Tg2>`, von denen jede verfügt über eine generische Methode. `G1<Tg1>`verfügt auch über eine nicht generische Methode, die die Typparameter `Tg1` für ihre Parameter. Die generische Methode `GM2<Tgm2>` im Typ `G2<Tg2>` enthält mehrere Methodenaufrufe:  
  
-   Fall 1: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Verwendung der Typparameter der `G2<Tg2>` und `GM2<Tgm2>` als Typargumente. Das heißt, die Parametertypen der aufgerufenen Methode hängen die Typen, die verwendet werden, so erstellen Sie einen geschlossenen generischen Typs aus der Typdefinition für `G2<Tg2>`.  
  
-   Fall 2: Die nicht generische Methode `M1` aufgerufen wird. Die Parameter dieser Methode verwendet den Typparameter des definierenden Typs `G1<Tg1>`, das in diesem Fall durch den Typparameter von einschließenden Typ ersetzt wird `G2<Tg2>`.  
  
-   Fall 3: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.. Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.  
  
-   Fall 4: Die nicht generische Methode `M1` von der `Example` -Klasse aufgerufen wird. Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.  
  
 Darüber hinaus definiert das Beispiel die nicht generische `Example` Klasse. Diese Klasse verfügt über eine Methode `M` , die eine generische Methode aufruft.  
  
-   Fall 5: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.. Der Kontext für diese Methode hat keine einschließenden generischen Typ- oder Methodendefinition.  
  
 Für jeden Fall im Beispiel wird zuerst erstellt ein <xref:System.Reflection.MethodInfo> , die die aufgerufene Methode darstellt, und löst dann das token mithilfe der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode zu überladen, mit der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> und <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methoden zum Abrufen der Werte für die `genericTypeArguments` und `genericMethodArguments` Parameter. Dieses Verfahren kann in allen Fällen auf, da es sich bei den Methoden zurückgegebenen <xref:System.Type.EmptyTypes?displayProperty=nameWithType> für nicht generische Kontexte. Im Beispiel vergleicht die aufgelöste <xref:System.Reflection.MethodInfo> mit erstellten <xref:System.Reflection.MethodInfo>.  
  
 Im Beispiel wird dann versucht, mithilfe der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> -methodenüberladung, um das Token zu beheben. Dies funktioniert in Fällen, 3, 4 und 5, da die Methodenaufrufe nicht generische Kontext abhängig sind. In Fällen, 1 und 2 wird eine Ausnahme ausgelöst, da es nicht genügend Informationen zum Auflösen des Tokens ist.  
  
 Die Tokenwerte Metadaten werden als eine Enumeration hartcodiert. Wenn Sie dieses Codebeispiel ändern, werden die Tokenwerte wahrscheinlich geändert. Um die neuen Werte zu bestimmen, den Code kompilieren und mithilfe von Ildasm.exe mit der **/Token** Option aus, um die Assembly zu untersuchen. Das Token können an den Positionen des Aufrufs gefunden werden. Fügen Sie die neuen Werte in der Enumeration und kompilieren Sie das Beispiel.  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für eine Methode oder ein Konstruktor im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="MethodSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden nicht für eine oder beide <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Signatur im Modul identifiziert.</param>
        <summary>Gibt den signaturblob, das durch ein Metadatentoken identifiziert zurück.</summary>
        <returns>Ein Array von Bytes, die der Signatur-Blob darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informationen zum Metadatentoken und Signaturen kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein gültiger <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, Signatur, den richtigen oder <see langword="FieldDef" /> token im Gültigkeitsbereich des aktuellen Moduls.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das eine Zeichenfolge im String-Heap des Moduls identifiziert.</param>
        <summary>Gibt die Zeichenfolge, die durch das angegebene Metadatentoken identifiziert.</summary>
        <returns>Ein <see cref="T:System.String" /> , die einen Zeichenfolgenwert aus dem Metadaten String-Heap enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für eine Zeichenfolge im Gültigkeitsbereich des aktuellen Moduls.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das einen Typ im Modul identifiziert.</param>
        <summary>Gibt den Typ, der durch das angegebene Metadatentoken identifiziert.</summary>
        <returns>Ein <see cref="T:System.Type" /> Objekt, das den Typ, der durch das angegebene Metadatentoken identifiziert wird darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Metadatentoken für Auflösen einer `TypeSpec` enthält, dessen Signatur `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden die <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen. Wenn Sie ein Metadatentoken für einen Typ aufgelöst werden, die davon abhängen die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist, müssen Sie eine Überladung verwenden, die Sie diesen Typparameter bereitstellen können.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für einen Typ im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="TypeSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Ein Metadatentoken, das einen Typ im Modul identifiziert.</param>
        <param name="genericTypeArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente des Typs, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn dieses Typs nicht generisch ist.</param>
        <param name="genericMethodArguments">Ein Array von <see cref="T:System.Type" /> Objekten, die die generischen Typargumente der Methode, in dem das Token im Gültigkeitsbereich ist, darstellen oder <see langword="null" /> Wenn diese Methode nicht generisch ist.</param>
        <summary>Gibt den Typ identifiziert durch das angegebene Metadatentoken im Kontext von den Parametern angegebenen generischen Typ definiert.</summary>
        <returns>Ein <see cref="T:System.Type" /> Objekt, das den Typ, der durch das angegebene Metadatentoken identifiziert wird darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode des Typs, in dem `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`. Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.  
  
> [!NOTE]
>  Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden. Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# and Common Language Infrastructure-Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) der ECMA-Website.  
  
 Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />ist kein Token für einen Typ im Gültigkeitsbereich des aktuellen Moduls.  
  
 - oder -   
  
 <paramref name="metadataToken" />ist eine <see langword="TypeSpec" /> , dessen Signatur enthält Elementtyp <see langword="var" /> (einen Typparameter eines generischen Typs) oder <see langword="mvar" /> (einen Typparameter einer generischen Methode), und die erforderlichen generischen Typargumente wurden nicht für eine oder beide <paramref name="genericTypeArguments" /> und <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" />ist kein gültiges Token im Gültigkeitsbereich des aktuellen Moduls.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die den Namen des Moduls darstellt.</summary>
        <value>Der Modulname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ScopeName` Eigenschaft wird nicht von der common Language Runtime verwendet, aber Sie können es verwenden, um eine beliebige Zeichenfolge, die Sie möchten in der Eigenschaft zu speichern, wenn Sie ein Modul mit dem Metadaten-APIs ausgeben. Die Reflektion selbst lässt keine Festlegen der `ScopeName` Eigenschaft.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Auswirkung der `ScopeName`, `FullyQualifiedName`, und `Name` Eigenschaften.  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugeordnete Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe des erweiterten COM <c>IDispatch</c> Schnittstelle wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Namen des Moduls zurück.</summary>
        <returns>Ein <see langword="String" /> , die den Namen dieses Moduls darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `ToString` Methode.  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
