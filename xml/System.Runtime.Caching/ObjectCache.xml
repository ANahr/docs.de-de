<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Objektcache dar und stellt die Basis-Methoden und Eigenschaften für den Zugriff auf den Objektcache.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache> ist der primäre Typ für den Objektcache in-Memory-. Um eine benutzerdefinierte Cacheimplementierung zu entwickeln, ableiten von der <xref:System.Runtime.Caching.ObjectCache> Klasse.  
  
> [!NOTE]
>  Die <xref:System.Runtime.Caching.ObjectCache> Klasse ist neu ab dem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Die integrierte <xref:System.Runtime.Caching.MemoryCache> Klasse leitet sich von der <xref:System.Runtime.Caching.ObjectCache> Klasse. Die <xref:System.Runtime.Caching.MemoryCache> Klasse ist der Cacheimplementierung nur konkretes Objekt in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] abgeleitet, die die <xref:System.Runtime.Caching.ObjectCache> Klasse.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides">
      <para>Da die <see cref="T:System.Runtime.Caching.ObjectCache" /> nur allgemeine Cachefunktionen darstellt, besteht keine Notwendigkeit, wie ein <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz instanziiert und abgerufen werden muss. Darüber hinaus besteht keine Notwendigkeit, die konkreten Implementierungen der <see cref="T:System.Runtime.Caching.ObjectCache" /> Klasse Singletons sein muss.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" />ist kein Singleton, aber Sie sollten nur wenige oder möglicherweise nur eine erstellen <see cref="T:System.Runtime.Caching.MemoryCache" /> Instanz und Code, der Elemente zwischengespeichert, sollten diese Instanzen verwenden.  
  
</para></block>  
  
 Beim Erben von der <see cref="T:System.Runtime.Caching.ObjectCache" /> -Klasse, müssen Sie seine Methoden überschreiben.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um Initialisieren der <see cref="T:System.Runtime.Caching.ObjectCache" /> Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache, ohne dass erforderlich ist, den ein vorhandenen Cacheeintrag mit einem übereinstimmenden Schlüssel zurückgegeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen versuchen Sie es, um einen Cacheeintrag in den Cache ohne überschreiben oder Entfernen von einem vorhandenen Cacheeintrag mit dem gleichen Schlüssel einzufügen. Der Cacheeintrag kann ein typisiertes <xref:System.Runtime.Caching.CacheItem> Objekt oder ein generisches Objekt.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode und die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind ein wesentlicher Unterschied. Wenn diese Methoden einen Cacheeintrag einfügen, wenn ein entsprechender Eintrag im Cache gefunden wird die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode zurück, den vorhandene Cacheeintrag, aber die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode nicht. Mit diesen anderen methodenüberladungen kann Aufrufer ihren Code basierend auf den vorhandene Cacheeintrag benötigte optimieren. In verteilten Caches Zurückgeben eines vorhandenen Werts mithilfe der <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Methode ist möglicherweise teurer als einen booleschen Wert zurückgibt, mit <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Cacheeintrag in den Cache als einzufügende versucht eine <see cref="T:System.Runtime.Caching.CacheItem" /> Instanz, und fügt Details wie der Eintrag entfernt werden soll.</summary>
        <returns>
          <see langword="true" />Wenn der Eintrag eingefügt oder <see langword="false" /> ist ein bereits ein Eintrag im Cache mit dem gleichen Schlüssel als <paramref name="item" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> intern Methodenaufrufe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die eine Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung keine spezielle Verhaltensweisen für erfordert die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode, es kann nur implementieren die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft. Dieser Parameter ist erforderlich, wenn die <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> -Methode aufgerufen wird.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt werden kann, wenn Bereiche implementiert werden. Da Bereiche in nicht implementiert werden [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], der Standardwert ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache ohne überschreiben vorhandenen Cacheeintrag.</summary>
        <returns>
          <see langword="true" />Wenn der Eintrag eingefügt oder <see langword="false" /> ist ein bereits ein Eintrag im Cache mit dem gleichen Schlüssel als <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> intern Methodenaufrufe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die eine Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung keine spezielle Verhaltensweisen für erfordert die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode, es kann nur implementieren die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt werden kann, wenn Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache gibt Informationen darüber, wie der Eintrag entfernt wird.</summary>
        <returns>
          <see langword="true" />Wenn die Einfügung versuchen Sie es erfolgreich ausgeführt wird, oder <see langword="false" /> ist ein bereits ein Eintrag im Cache mit demselben Schlüssel wie die <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> intern Methodenaufrufe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die eine Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung keine spezielle Verhaltensweisen für erfordert die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode, es kann nur implementieren die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse versucht, einen Cacheeintrag in den Cache einzufügen, und gibt Sie einen vorhandenen Cacheeintrag mit einem übereinstimmenden Schlüssel zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode fügen Sie einen Eintrag im Cache. Wenn ein Cacheeintrag mit einem übereinstimmenden Schlüssel bereits vorhanden ist, geben sie den vorhandenen Eintrag zurück. Der Cacheeintrag kann ein <xref:System.Runtime.Caching.CacheItem> Objekt oder ein generisches Objekt.  
  
 Es gibt einen Unterschied zwischen der <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen und der <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen. Wenn diese überladenen Methoden zum Einfügen eines Cache-Eintrags, versuchen Sie, wenn ein vorhandener Eintrag gefunden wird, dass ein Schlüssel, der einem vorhandenen entspricht Cacheeintrag, eingefügt hat die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen zurückgeben den vorhandene Cacheeintrag. Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen jedoch nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt das angegebene <see cref="T:System.Runtime.Caching.CacheItem" /> Objekt in den Cache gibt Informationen darüber, wie der Eintrag entfernt wird.</summary>
        <returns>Wenn ein Cacheeintrag mit demselben Schlüssel, die den angegebenen Cacheeintrag vorhanden ist. andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt werden kann, wenn Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache mit einem Schlüssel, ein Objekt für den Cacheeintrag, eines absoluten Ablaufwerts und einen optionalen Bereich zum Hinzufügen des Caches in.</summary>
        <returns>Wenn ein Cacheeintrag mit demselben Schlüssel, die den angegebenen Cacheeintrag Wert vorhanden ist. andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> eine Überladung gibt einen Objektwert zurück, keinen <xref:System.Runtime.Caching.CacheItem> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt werden kann, wenn Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache angeben, einen Schlüssel und einen Wert für den Cacheeintrag und Informationen wie der Eintrag entfernt wird.</summary>
        <returns>Wenn ein Cacheeintrag mit demselben Schlüssel, die den angegebenen Cacheeintrag Wert vorhanden ist. andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Methode gibt einen Objektwert zurück, keinen <xref:System.Runtime.Caching.CacheItem> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, in dem Cache gefunden werden kann, wenn Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse überprüft, ob der Cacheeintrag im Cache ist bereits vorhanden.</summary>
        <returns>
          <see langword="true" />Wenn der Cache einen Cacheeintrag mit den gleichen Schlüsselwert als enthält <paramref name="key" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Der eindeutige Bezeichner für Cacheeinträge zu überwachen.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, in dem der Cacheschlüssel in, der <c>Schlüssel</c> Parameter vorhanden sind, wenn die Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse eine <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> angegebenen Cacheeinträgen vorgenommen-Objekt, das Ereignisse als Reaktion auf Änderungen an auslösen kann.</summary>
        <returns>Eine änderungsüberwachung, die von Cacheeinträgen im Cache überwacht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein abgeleiteter <xref:System.Runtime.Caching.ObjectCache> -Klasse überschreibt die <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> -Methode der Cacheimplementierung muss erstellen eine <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Objekt. Dieser spezielle geändert Monitor benachrichtigt Aufrufer aus, wenn auf die Einträge, die im angegebenen Änderungen der `keys` Parameter. Angenommen, ein Überwachungskapazität für Elemente in der `keys` Parameter aktualisiert oder aus dem Cache entfernt wird, löst ein Ereignis aus der änderungsüberwachung, die von dieser Methode erstellt.  
  
 Wenn eine Cacheimplementierung benannten Cachebereiche unterstützt, kann ein String-Wert angegeben werden, als die `regionName` Parameter. Andernfalls verwendet der Parameter standardmäßig `null`.  
  
> [!NOTE]
>  Nicht alle Cache-Implementierungen unterstützt Cacheeintrag Änderung überwacht. Um zu bestimmen, ob die Cacheimplementierung unterstützt <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Objekten finden Sie in der Dokumentation für die bestimmte Cacheimplementierung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft eine Beschreibung der Funktionen, die eine Cacheimplementierung bereitstellt.</summary>
        <value>Eine bitweise Kombination der Flags, die die Standardfunktionen von einer Cacheimplementierung angeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den angegebenen Cacheeintrag aus dem Cache als Objekt ab.</summary>
        <returns>Den Cacheeintrag, der identifizierte <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cache hinzugefügt wurde, falls Bereiche implementiert werden. Da Bereiche in nicht implementiert werden [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], der Standardwert ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft den angegebenen Cacheeintrag aus dem Cache als eine <see cref="T:System.Runtime.Caching.CacheItem" /> Instanz.</summary>
        <returns>Den Cacheeintrag, der identifizierte <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung vorhanden ist, da einige Implementierungen Cache verlängern könnte die <xref:System.Runtime.Caching.CacheItem> Klasse. In diesem Fall die <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> methodenüberladung nicht unbedingt alle Informationen über zwischengespeicherte Daten zurück. Allerdings die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> -methodenüberladung können benutzerdefinierte Caches um mehr als nur den Cachewert zurückzugeben.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Methode entspricht der <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> -Methode, außer dass die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Methodenrückgabe return den Cacheeintrag als eine <xref:System.Runtime.Caching.CacheItem> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache für den Anzahl der Cache-Eintrags berechnet werden soll, wenn die Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft die Gesamtanzahl von Cacheeinträgen im Cache ab.</summary>
        <returns>Die Anzahl von Cacheeinträgen im Cache. Wenn <paramref name="regionName" /> nicht <see langword="null" />, die Anzahl gibt die Anzahl der Einträge, die in der angegebenen Region befinden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse erstellt einen Enumerator, der zum Durchlaufen einer Auflistung von Cacheeinträgen verwendet werden kann.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cache-Implementierungen können außer Kraft setzen, und erweitern diese Methode, um eine benutzerdefinierte Iteration durch eine Auflistung von Cacheeinträgen systemverarbeitungsaufwand.  
  
> [!NOTE]
>  Ein Enumerator zurückgegeben wird in der Regel ein teurer Vorgang als den gesamte Cacheeintrag zurückzugeben.  
  
 Diese Methode wird aufgerufen, indem Sie die expliziten schnittstellenimplementierungen, die die <xref:System.Runtime.Caching.ObjectCache> Klasse wurde für die <xref:System.Collections.IEnumerable.GetEnumerator%2A> und <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die Cacheeinträge abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den die Cache-Einträge hinzugefügt wurden, wenn Bereiche implementiert werden, werden soll. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft einen Satz von Cacheeinträgen, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel/Wert-Paaren, die Einträge im Cache darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung trägt zur leistungsoptimierung für verteilte Caches, die mehrere Cacheeinträge aus dem Cache abrufen, während eines einzelnen Netzwerkaufrufs unterstützen.  
  
 Obwohl ein Aufrufer einen oder mehrere Schlüssel an die Methode übergeben werden kann, besteht keine Garantie, dass alle Schlüssel Einträge im Cache darstellen. Aus diesem Grund kann das zurückgegebene Wörterbuch weniger Elemente als die Anzahl der Schlüssel enthalten, die an die Methode übergeben wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den die Cache-Einträge hinzugefügt wurden, wenn Bereiche implementiert werden, werden soll. Da Bereiche in nicht implementiert werden [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], der Standardwert ist <see langword="null" />.</param>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die Cacheeinträge abgerufen werden soll.</param>
        <summary>Ruft einen Satz von Cacheeinträgen, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel/Wert-Paaren, die Einträge im Cache darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> methodenüberladung ist wie die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung, jedoch können Sie übergeben benannten Bereich mit der optionalen Parameter-Syntax, die von verwalteten Sprachen wie c# unterstützt wird.  
  
 Diese Methode ist eine virtuelle Methode, da die <xref:System.Runtime.Caching.ObjectCache> Klasse stellt eine Standardimplementierung, die übergibt die `params` array an die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Verweis auf einer verwalteten hostumgebung, die zur Verfügung steht <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierungen und, können Dienste hostspezifische bereitstellen <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierungen.</summary>
        <value>Ein Verweis auf einen Cache unterstützende verwaltete Hostingumgebung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Host%2A> Eigenschaft dient zur Verwendung von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Umgebungen und durch die Cache-Implementierungen, die die Implementierung des Verhaltens, das von .NET Framework abhängt gehostet Umgebung.  
  
 Die folgende Tabelle enthält den Satz von Hostdiensten Umgebung, die möglicherweise von einer verwalteten hostumgebung verfügbar und verfügbaren auf <xref:System.Runtime.Caching.ObjectCache> Implementierungen über die <xref:System.Runtime.Caching.ObjectCache.Host%2A> Eigenschaft:  
  
|Dienst|Beschreibung|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Ermöglicht umfassende Hostumgebungen Anwendung denselben Domänenbezeichner bereitzustellen, die möglicherweise von einem Cacheimplementierung für Funktionen, z. B. das Identifizieren von Leistungsindikatoren benötigt wird.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Geben Sie ein Benachrichtigungssystem benutzerdefinierte dateiänderung anstelle eines bereitgestellt, die Hostumgebungen ermöglicht die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Ermöglicht das Cache-Implementierungen Cachespeicher Verbrauch der hostumgebung. Dies ermöglicht umfassende Hostumgebungen, Speicherverbrauch über mehrere Cache Implementierungen zentral zu verwalten.|  
  
> [!NOTE]
>  Der Aufrufer dieses Eigenschaftswerts erfordern uneingeschränkten Codezugriffsberechtigungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert der Eigenschaft zugewiesen wird, ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den Wert der Eigenschaft mehr als einmal festgelegt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für alle Accessoren dieser Eigenschaft. Diese Eigenschaft kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, dass ein Cacheeintrag keinen absoluten Ablauf hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cacheeintrag, der in den Cache eingefügt wird die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> festgelegt werden, da der Ablaufwert nie ablaufen sollen Feldwert basierend auf einem absoluten Zeitpunkt zeitlich. Allerdings kann ein Cacheeintrag mit dieser Einstellung aus dem Cache aus anderen Gründen entfernt werden, die von einer bestimmten Cacheimplementierung, z. B. eine änderungsüberwachung Ereignis Entfernung verursacht durch ungenügenden Arbeitsspeicher bedingt bestimmt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für ein Cacheeintrag im Cache.</param>
        <summary>Ruft ab oder legt ihn fest der Standardindexer für die <see cref="T:System.Runtime.Caching.ObjectCache" /> Klasse.</summary>
        <value>Ein Schlüssel, der als Indexer in der Cacheinstanz dient.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten von der Set-Accessor für diese Eigenschaft entspricht der <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> Methode. Eine Cacheimplementierung konnte absoluten Ablauf des angegebenen Werts, der intern festgelegt die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> Methode. Dieses Verhalten jedoch letztendlich ist der Cache-Implementierung.  
  
 Das Verhalten von "Get"-Zugriffsmethode ist wie das Aufrufen der <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> -Methode und der Verwendung `null` für Name der Region.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen eines bestimmten <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz.</summary>
        <value>Der Name einer bestimmten Cache-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Implementierungen Cache unterstützen möglicherweise mehrere Instanzen des Caches, die in einer einzigen Anwendung ausgeführt wird. Diese Eigenschaft ermöglicht Cache-Implementierer, die einen Namen zurück, der eine bestimmte Cache-Instanz identifiziert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass ein Cacheeintrag keine gleitende Ablaufzeit hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ablauf, der auf von Dauer oder einem definierten Zeitfenster Grundlage wird auch als gleitende Ablaufzeit bezeichnet. Eine Cacheimplementierung, die Elemente, die entfernt auf die Ablaufzeit basieren werden in der Regel wird ein Element entfernt, die nicht im angegebenen Fenster Zeit zugegriffen wurde.  
  
 Ein Cacheeintrag, der in den Cache eingefügt wird die <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> Feldwert festgelegt werden, da der Ablaufwert nie aufgrund von nicht-Aktivität in einem gleitenden Zeitfenster entfernt werden soll. Allerdings kann ein Cacheelement, das entfernt werden, wenn es sich um einen absoluten Ablauf hat oder wenn einige andere Entfernung-Ereignis auftritt, eine solche Änderung Monitor oder Arbeitsspeicher Druck.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse wird den Cacheeintrag aus dem Cache entfernt.</summary>
        <returns>Ein Objekt, das den Wert der entfernte Cacheeintrag darstellt, der durch den Schlüssel angegeben wurde oder <see langword="null" /> , wenn der angegebene Eintrag nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Methode in einer benutzerdefinierten Cacheimplementierung außer Kraft setzen, ist es ein Cacheeintrag im Cache, der entspricht `key`, der Wert des entfernten Elements zurückgegeben werden soll. Wenn nichts aus dem Cache entfernt wurde, sollte die Methode zurückgeben `null`.  
  
> [!NOTE]
>  Einige verteilte Cache-Implementierungen unterstützen möglicherweise nicht die Möglichkeit, den Wert zurück, der aus dem Cache entfernt wurde. Möglicherweise der Cacheimplementierung Zurückgeben des Werts eines Cacheelements entfernt nicht unterstützt. Es könnte auch sein, da das Objekt zu marshallen, ein Rückgabewert zu teuer ist. In solchen Fällen können die Cache-Implementierungen zurückgeben `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das normale Verhalten der <xref:System.Runtime.Caching.ObjectCache.Set%2A> Überladung Methoden ist ein INSERT- oder Update-Vorgang. Ein Cacheeintrag ist, dass entweder als neuer Eintrag eingefügt, wenn der angegebene Eintrag nicht vorhanden oder der Cacheeintrag mit einem neuen Wert aktualisiert wird, wenn sie bereits vorhanden ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Element im Cache.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt den Cacheeintrag in den Cache als eine <see cref="T:System.Runtime.Caching.CacheItem" /> Instanz gibt Informationen darüber, wie der Eintrag entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel für `item` ist nicht vorhanden, `item` als ein neuer Cacheeintrag eingefügt wird. Wenn ein Element mit einem Schlüssel, der entspricht `item` vorhanden ist, wird den Wert von `item` dient zum Aktualisieren oder überschreibt den Wert der vorhandene Cacheeintrag.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt werden kann, wenn Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache zeitbasierte Ablaufdetails angeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element, das übereinstimmt `key` ist nicht im Cache vorhanden `value` und `key` werden verwendet, um als neuer Cacheeintrag einzufügen. Wenn ein Element mit einem Schlüssel, der entspricht `item` vorhanden ist, der Cacheeintrag aktualisiert oder überschrieben werden, mithilfe von `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, den der Cacheeintrag hinzugefügt werden kann, wenn Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse fügt einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung können Sie ausführlichere Entfernung oder den Ablauf von Informationen bereitstellen, die in absolute Ablaufzeit zeitbasierte verfügbar sind.  
  
 Wenn ein Element, das übereinstimmt `key` ist nicht im Cache vorhanden `value` und `key` werden verwendet, um als neuer Cacheeintrag einzufügen. Wenn ein Element mit einem Schlüssel, der entspricht `item` vorhanden ist, der Cacheeintrag aktualisiert oder überschrieben werden, mithilfe von `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterstützt die Iteration durch eine generische Auflistung.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Elemente im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Kann verwendet werden, wenn ein abgeleiteter <xref:System.Runtime.Caching.ObjectCache> Instanz umgewandelt wird eine <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Entwickler können diese Methode eine generische Auflistung von Cacheeinträgen durchlaufen.  
  
 Dies ist die Standardeinstellung <xref:System.Collections.IEnumerable.GetEnumerator%2A> Implementierung, die intern Ruft die <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
