<Type Name="EncoderFallbackBuffer" FullName="System.Text.EncoderFallbackBuffer">
  <TypeSignature Language="C#" Value="public abstract class EncoderFallbackBuffer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit EncoderFallbackBuffer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.EncoderFallbackBuffer" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Puffer bereit, der einen Fallback-Handler zulässt, der eine alternative Zeichenfolge an einen Encoder zurückzugibt, wenn eine Eingabezeichen nicht codiert werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Codierung definiert eine Zuordnung zwischen einem Unicode-Zeichen und eine codierte Bytefolge. Ein Codierungsvorgang, der eine Eingabezeichen in eine Ausgabebytefolge konvertiert, schlägt fehl, wenn für ein bestimmtes Zeichen keine Zuordnung definiert ist.  
  
 .NET Framework bietet einen Mechanismus, der als Fallback bezeichneten, wenn eine Konvertierung nicht durchgeführt werden kann. Alle Encoder-fallback-Handler müssen Folgendes implementieren:  
  
-   Ein EncoderFallback, der durch eine Klasse dargestellt wird abgeleitet aus dem <xref:System.Text.EncoderFallback> Klasse.  
  
-   Ein Encoderfallbackpuffer, der dargestellt wird, von einem Typ abgeleitet wurde. die <xref:System.Text.EncoderFallbackBuffer> -Klasse, die eine Zeichenfolge an den Konvertierungsvorgang zurückgeben kann.  
  
 Drei Strategien können Zugriffe Konvertierungsfehler behandelt:  
  
-   Zuordnung mit ähnlichen Zeichen. Der Encoderfallbackpuffer kann es sich um eine Zeichenfolge zurückgeben, die eine Annäherung an die eingegebene Zeichen darstellt. .NET Framework bietet einen ähnlichen öffentlichen <xref:System.Text.EncoderFallbackBuffer> Implementierung.  
  
-   Ersatz. Der Encoderfallbackpuffer kann eine Zeichenfolge zurückgeben, z. B. ein Fragezeichen ("?"), das angibt, dass ein Zeichen nicht codiert werden kann. In .NET Framework die <xref:System.Text.EncoderReplacementFallback> und <xref:System.Text.EncoderReplacementFallbackBuffer> Klassen bieten eine öffentliche Ersatz Fallbackpuffer-Implementierung. Der Konstruktor, der die <xref:System.Text.EncoderReplacementFallback> -Klasse können Sie die Ersetzungszeichenfolge definieren.  
  
-   Ausnahme. Die <xref:System.Text.EncoderFallbackBuffer> Implementierung löst eine Ausnahme, die angibt, dass ein Zeichen nicht codiert werden kann, und den Codierungsvorgang beendet aus. In diesem Fall muss die fallback-Handler Bereitstellen einer <xref:System.Text.EncoderFallbackBuffer> Implementierung, obwohl er keine Zeichenfolge an den Encoder zurückgegeben wird. In .NET Framework die <xref:System.Text.EncoderExceptionFallback> und <xref:System.Text.EncoderExceptionFallbackBuffer> Klassen bieten eine fallbackimplementierung öffentliche Ausnahme, die auslöst, ein <xref:System.Text.EncoderFallbackException> Wenn ein Zeichen nicht codiert werden kann.  
  
 Der Puffer in ein <xref:System.Text.EncoderFallbackBuffer> Implementierung stellt die gesamte Zeichenfolge, die an den Encoder als Antwort auf einen Encoder fallback zurückgegeben werden. Im Allgemeinen umfassen Implementierungen auch Zustandsinformationen, z. B. der Index der nächsten zurückzugebenden Zeichens an der Encoder und die Anzahl der verbleibenden Zeichen zurückgegeben werden. Da <xref:System.Text.EncoderFallbackBuffer> ist eine abstrakte Klasse dafür, dass abgeleitete Klassen, die mindestens die folgenden Member implementieren:  
  
-   Die überladenen <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> -Methode, die vom Encoder aufgerufen wird, wenn ein Zeichen nicht codiert werden kann. Der Encoder übergibt zwei Angaben für die Implementierung Fallbackpuffer: das Zeichen oder Ersatzzeichenpaar an, das nicht codiert werden kann und der Index des Zeichens in der Eingabe. In einem Encoder fallback-Ausnahmehandler wird die Ausnahme bei dieser Methode ausgelöst. Andernfalls der Methodenrückgabe `true` Wenn als Fallback vorhanden sind oder `false` Wenn dies nicht der Fall.  
  
-   Die <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> -Methode, die wiederholt vom Encoder aufgerufen wird die <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> -Methode zurückkehrt `true`. In aufeinander folgenden Aufrufen sollte der Handler jedes Zeichen in seinem Puffer zurückgeben. Wenn alle Zeichen zurückgegeben wurde, sollte es U + 0000 zurückgeben. Ein Ausnahmehandler gibt immer U + 0000 zurück.  
  
-   Die <xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A> Methode, die versucht, verschieben Sie den Zeiger der vorherigen Position im Puffer und gibt an, ob die Verschiebung erfolgreich war. Ein Ausnahmehandler immer gibt `false`.  
  
-   Die <xref:System.Text.EncoderFallbackBuffer.Remaining%2A> -Eigenschaft, womit die Anzahl der verbleibenden Zeichen, die an den Encoder zurückgegeben werden. Ein Ausnahme-fallback-Handler gibt immer 0 (null) zurück.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EncoderFallbackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.EncoderFallbackBuffer" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (char charUnknown, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(char charUnknown, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknown" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknown">Ein eingegebenes Zeichen.</param>
        <param name="index">Die Indexposition des Zeichens im Eingabepuffer.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse wird dem Fallbackpuffer zum Behandeln des angegebenen Eingabezeichens vorbereitet.</summary>
        <returns>
          <see langword="true" />Wenn der Fallbackpuffer verarbeiten kann <paramref name="charUnknown" />; <see langword="false" /> , wenn der Fallbackpuffer ignoriert <paramref name="charUnknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> und <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> -Methode <xref:System.Text.DecoderFallbackBuffer.Fallback%28System.Byte%5B%5D%2CSystem.Int32%29> , wenn sie ein unbekanntes Eingabezeichen treffen, das nicht codiert werden können. Ein Rückgabewert von `true` gibt an, dass der Fallbackpuffer des Eingabezeichens die aufrufende Methode verarbeiten kann aufrufen, wodurch die <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> Methode, um jedes Zeichen dem Fallbackpuffer abzurufen. Da es keine einzelne Zeichen verarbeitet die <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> Methode in einem Ausnahmehandler fallback löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (char charUnknownHigh, char charUnknownLow, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(char charUnknownHigh, char charUnknownLow, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknownHigh" Type="System.Char" />
        <Parameter Name="charUnknownLow" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknownHigh">Das hohe Ersatzzeichen des Eingabe-Paars.</param>
        <param name="charUnknownLow">Das niedrige Ersatzzeichen des Eingabe-Paars.</param>
        <param name="index">Die Indexposition des Ersatzzeichenpaars im Eingabepuffer.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse wird dem Fallbackpuffer, behandeln das angegebene Ersatzzeichenpaar vorbereitet.</summary>
        <returns>
          <see langword="true" />Wenn der Fallbackpuffer verarbeiten kann <paramref name="charUnknownHigh" /> und <paramref name="charUnknownLow" />; <see langword="false" /> , wenn der Fallbackpuffer das Ersatzzeichenpaar ignoriert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> und <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> -Methode <xref:System.Text.EncoderFallbackBuffer.Fallback%28System.Char%2CSystem.Char%2CSystem.Int32%29> treten ein Ersatzzeichenpaar in der Eingabe. Ein Rückgabewert von `true` gibt an, dass der Fallbackpuffer das Ersatzzeichenpaar die aufrufende Methode verarbeiten kann aufrufen, wodurch die <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> Methode, um jedes Zeichen dem Fallbackpuffer abzurufen.  Da es keine einzelne Zeichen verarbeitet die <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> Methode in einem Ausnahmehandler fallback löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextChar">
      <MemberSignature Language="C#" Value="public abstract char GetNextChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetNextChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.GetNextChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft das nächste Zeichen im Fallbackpuffer ab.</summary>
        <returns>Das nächste Zeichen im Fallbackpuffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft ein Codierungsvorgang die <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> Methode, wenn der Vorgang ein unbekanntes Zeichen oder Ersatzzeichenpaar in der Eingabe gefunden wird. Z. B. im Fall von ein fallback, Ersatz, wenn die <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> -Methode zurückkehrt `true`, besteht eine Ersatzzeichenfolge, die anstelle einer unbekannten Eingabe codiert werden kann. Ruft die Codierung der <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> Methode wiederholt und ruft den Ersatz ein Zeichen zu einem Zeitpunkt. Wenn alle Zeichen im Fallbackpuffer an den Encoder zurückgegeben wurden die <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> Methode sollte U + 0000 zurückgeben.  
  
 Für eine Ausnahme-fallback-Handler die <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> Methode sollte U + 0000 zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public abstract bool MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.MovePrevious" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse bewirkt, dass beim nächsten Aufruf von der <see cref="M:System.Text.EncoderFallbackBuffer.GetNextChar" /> Methode, um den Puffer vor der aktuellen Position des Zeichens zugreifen.</summary>
        <returns>
          <see langword="true" />Wenn die <see cref="M:System.Text.EncoderFallbackBuffer.MovePrevious" /> Vorgang war erfolgreich, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein fallback Ausnahmehandler zurückgeben sollte `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remaining">
      <MemberSignature Language="C#" Value="public abstract int Remaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Remaining" />
      <MemberSignature Language="DocId" Value="P:System.Text.EncoderFallbackBuffer.Remaining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft die Anzahl der Zeichen in der aktuellen <see cref="T:System.Text.EncoderFallbackBuffer" /> -Objekt, das noch verarbeitet werden soll.</summary>
        <value>Die Anzahl der Zeichen im aktuellen Fallbackpuffer, die noch nicht verarbeitet wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> -Methode zurückkehrt `true` Wenn <xref:System.Text.EncoderFallbackBuffer.Remaining%2A> ein Wert ungleich NULL ist.  
  
 Für eine Ausnahme-fallback-Handler die <xref:System.Text.DecoderFallbackBuffer.Remaining%2A> Methode sollte 0 (null) zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alle Daten und Status der Informationen zu diesem Fallbackpuffer wird initialisiert.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Nach dem Aufruf der <see cref="M:System.Text.EncoderFallbackBuffer.Reset" /> -Methode, die <see cref="P:System.Text.EncoderFallbackBuffer.Remaining" /> Eigenschaft sollte "0" zurückgegeben der <see cref="M:System.Text.EncoderFallbackBuffer.GetNextChar" /> Methode sollte U + 0000 zurückgeben und die <see cref="M:System.Text.EncoderFallbackBuffer.MovePrevious" /> -Methode zurückgeben sollte <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
