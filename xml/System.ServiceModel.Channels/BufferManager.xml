<Type Name="BufferManager" FullName="System.ServiceModel.Channels.BufferManager">
  <TypeSignature Language="C#" Value="public abstract class BufferManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit BufferManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.BufferManager" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Viele Windows Communication Foundation (WCF)-Features erfordern die Verwendung aufwendig zu erstellender und zu zerstörender Puffer. Mit der <see cref="T:System.ServiceModel.Channels.BufferManager" />-Klasse können Sie einen Pufferpool verwalten. Der Pool und die zugehörigen Puffer werden beim Instanziieren dieser Klasse erstellt und nach der Freigabe von der Garbage Collection wieder zerstört. Wenn Sie einen Puffer verwenden möchten, können Sie einen aus dem Pool nehmen und nach Abschluss der Arbeit wieder im Pool ablegen. Dieser Vorgang ist wesentlich schneller, als jedes Mal, wenn Sie einen Puffer benötigen, eine neuen zu erstellen und wieder zu zerstören.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse wird im Allgemeinen verwendet, während Sie benutzerdefinierte Encoder oder benutzerdefinierte Transportkanäle implementieren.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BufferManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Channels.BufferManager" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da dieser Konstruktor `protected` ist, können Sie ihn nur von einer abgeleiteten Klasse aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public abstract void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die derzeit im Manager zwischengespeicherten Puffer frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBufferManager">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.BufferManager CreateBufferManager (long maxBufferPoolSize, int maxBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.BufferManager CreateBufferManager(int64 maxBufferPoolSize, int32 maxBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.CreateBufferManager(System.Int64,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BufferManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxBufferPoolSize" Type="System.Int64" />
        <Parameter Name="maxBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxBufferPoolSize">Die maximale Größe des Pools.</param>
        <param name="maxBufferSize">Die maximale Größe eines einzelnen Puffers.</param>
        <summary>Erstellt einen neuen Puffermanager mit einer angegebenen maximalen Pufferpoolgröße und einer maximalen Größe für jeden einzelnen Puffer im Pool</summary>
        <returns>Gibt ein <see cref="T:System.ServiceModel.Channels.BufferManager" />-Objekt mit den angegebenen Parametern zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie einen neuen Pufferpool mit so vielen Puffern, wie erstellt werden können, erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">
          <block subset="none" type="note">
            <para>  
 In der [.NET für Windows Store-apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), fangen Sie die basisklassenausnahme <see cref="T:System.OutOfMemoryException" />, stattdessen.  
  
</para>
          </block>  
  
 Der Arbeitsspeicher reichte nicht aus, um den angeforderten Pufferpool zu erstellen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxBufferPoolSize" /> oder <paramref name="maxBufferSize" /> war kleiner als 0 (Null).</exception>
      </Docs>
    </Member>
    <Member MemberName="ReturnBuffer">
      <MemberSignature Language="C#" Value="public abstract void ReturnBuffer (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReturnBuffer(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.ReturnBuffer(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Verweis auf den Puffer, der zurückgegeben wird.</param>
        <summary>Gibt einen Puffer an den Pool zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Puffer wird an den Pool zurückgegeben und steht für eine erneute Verwendung zur Verfügung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" />-Verweis darf nicht <see langword="null" /> sein.</exception>
        <exception cref="T:System.ArgumentException">Die Länge des <paramref name="buffer" /> entspricht nicht der Pufferlängeneigenschaft des Pools.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeBuffer">
      <MemberSignature Language="C#" Value="public abstract byte[] TakeBuffer (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] TakeBuffer(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.TakeBuffer(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Die Größe des angeforderten Puffers in Byte.</param>
        <summary>Ruft einen Puffer mit mindestens der angegebenen Größe aus dem Pool ab.</summary>
        <returns>Ein Bytearray, das der angeforderten Größe des Puffers entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Falls erfolgreich, gibt das System einen Bytearray-Puffer mit mindestens der angeforderten Größe zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> darf nicht kleiner 0 (Null) sein.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
