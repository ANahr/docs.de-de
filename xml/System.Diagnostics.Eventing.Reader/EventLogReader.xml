<Type Name="EventLogReader" FullName="System.Diagnostics.Eventing.Reader.EventLogReader">
  <TypeSignature Language="C#" Value="public class EventLogReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLogReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Ermöglicht es Ihnen, Ereignisse aus einem Ereignisprotokoll basierend auf einer Ereignisabfrage zu lesen. Die Ereignisse, die von diesem Objekt gelesen werden, werden als zurückgegeben <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> Objekte.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 Z. B. Code mit dieser Klasse finden Sie unter [How To: Abfrage nach Ereignissen](http://msdn.microsoft.com/en-us/5231a436-4cf2-4539-90d2-a04813aba069) oder [How To: Zugriff und Informationen zum Lesen von Ereignis](http://msdn.microsoft.com/en-us/14db3375-d305-49ae-aa24-aedbe906e76c).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.Diagnostics.Eventing.Reader.EventLogQuery)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventQuery" Type="System.Diagnostics.Eventing.Reader.EventLogQuery" />
      </Parameters>
      <Docs>
        <param name="eventQuery">Die Ereignisabfrage verwendet, um die Ereignisse abzurufen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> -Klasse unter Angabe einer Ereignisabfrage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des Ereignisprotokolls auf Ereignisse abgerufen werden soll.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> -Klasse durch Angabe eines aktiven Ereignisprotokolls Ereignisse abgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery, System.Diagnostics.Eventing.Reader.EventBookmark bookmark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery, class System.Diagnostics.Eventing.Reader.EventBookmark bookmark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.Diagnostics.Eventing.Reader.EventLogQuery,System.Diagnostics.Eventing.Reader.EventBookmark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventQuery" Type="System.Diagnostics.Eventing.Reader.EventLogQuery" />
        <Parameter Name="bookmark" Type="System.Diagnostics.Eventing.Reader.EventBookmark" />
      </Parameters>
      <Docs>
        <param name="eventQuery">Die Ereignisabfrage verwendet, um die Ereignisse abzurufen.</param>
        <param name="bookmark">Das Lesezeichen (Platzhalter) als Startposition in das Ereignisprotokoll oder einen Datenstrom von Ereignissen verwendet. Nur Ereignisse protokolliert, nachdem das Lesezeichenereignis von der Abfrage zurückgegeben werden.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> -Klasse unter Angabe einer Ereignisabfrage und ein Lesezeichen, das als Anfangsposition für die Abfrage verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (string path, System.Diagnostics.Eventing.Reader.PathType pathType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Diagnostics.Eventing.Reader.PathType pathType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.String,System.Diagnostics.Eventing.Reader.PathType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="pathType" Type="System.Diagnostics.Eventing.Reader.PathType" />
      </Parameters>
      <Docs>
        <param name="path">Der Name, der das Ereignisprotokoll auf Ereignisse abgerufen oder der Pfad zur Datei Ereignisprotokoll auf Ereignisse abgerufen werden soll.</param>
        <param name="pathType">Gibt an, ob die im Pfadparameter verwendete Zeichenfolge den Namen eines Ereignisprotokolls oder den Pfad zu einer Ereignisprotokolldatei angibt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> Klasse, indem der Name des Ereignisprotokolls Ereignisse abgerufen oder den Pfad zu einer Protokolldatei, um die Ereignisse abgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Eventing.Reader.EventLogReader.BatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Anzahl der Ereignisse aus dem Datenstrom von Ereignissen, die bei jedem Lesevorgang abgerufen.</summary>
        <value>Gibt einen Ganzzahlwert zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelReading">
      <MemberSignature Language="C#" Value="public void CancelReading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelReading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.CancelReading" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den aktuellen Abfragevorgang ab.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von diesem Objekt verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Die von diesem Objekt verwendeten nicht verwalteten Ressourcen frei, und optional die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogStatus">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Diagnostics.Eventing.Reader.EventLogStatus&gt; LogStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Diagnostics.Eventing.Reader.EventLogStatus&gt; LogStatus" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Eventing.Reader.EventLogReader.LogStatus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Diagnostics.Eventing.Reader.EventLogStatus&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Status der einzelnen-Ereignisprotokoll oder Protokolldatei, die der Ereignisabfrage in diesem Objekt zugeordnet.</summary>
        <value>Gibt eine Liste von <see cref="T:System.Diagnostics.Eventing.Reader.EventLogStatus" /> Objekte, die jeweils Statusinformationen über ein Ereignisprotokoll die Ereignisabfrage in diesem Objekt zugeordneten enthalten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEvent">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Eventing.Reader.EventRecord ReadEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Eventing.Reader.EventRecord ReadEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.Reader.EventRecord</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das nächste Ereignis, das von der Ereignisabfrage in diesem Objekt zurückgegeben wird.</summary>
        <returns>Gibt ein <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Z. B. Code mit dieser Klasse finden Sie unter [How To: Abfrage nach Ereignissen](http://msdn.microsoft.com/en-us/5231a436-4cf2-4539-90d2-a04813aba069).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEvent">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Eventing.Reader.EventRecord ReadEvent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Eventing.Reader.EventRecord ReadEvent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.Reader.EventRecord</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die maximale Zeit, zu der Lesevorgang an, bevor der Vorgang abgebrochen wird.</param>
        <summary>Liest das nächste Ereignis, das von der Ereignisabfrage in diesem Objekt zurückgegeben wird.</summary>
        <returns>Gibt ein <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Diagnostics.Eventing.Reader.EventBookmark bookmark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Diagnostics.Eventing.Reader.EventBookmark bookmark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Seek(System.Diagnostics.Eventing.Reader.EventBookmark)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Diagnostics.Eventing.Reader.EventBookmark" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das Lesezeichen (Platzhalter) als Startposition in das Ereignisprotokoll oder einen Datenstrom von Ereignissen verwendet. Nur Ereignisse, die protokolliert wurden, nachdem das Lesezeichenereignis von der Abfrage zurückgegeben werden.</param>
        <summary>Ändert die Position im Stream, in dem das nächste Ereignis, das gelesen wird stammen wird durch Angeben eines Lesezeichenereignisses. Keine Ereignisse protokolliert werden, bevor das Lesezeichenereignis abgerufen werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Funktion nur für Resultsets, die von einem Administrator oder operationskanal oder von EVTX-Protokolldateien verwenden. Diese Funktion wird nicht unterstützt für analytische und Debuggen von Kanälen, oder für ETL-Dateien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Diagnostics.Eventing.Reader.EventBookmark bookmark, long offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Diagnostics.Eventing.Reader.EventBookmark bookmark, int64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Seek(System.Diagnostics.Eventing.Reader.EventBookmark,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Diagnostics.Eventing.Reader.EventBookmark" />
        <Parameter Name="offset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das Lesezeichen (Platzhalter) als Startposition in das Ereignisprotokoll oder einen Datenstrom von Ereignissen verwendet. Nur Ereignisse, die protokolliert wurden, nachdem das Lesezeichenereignis von der Abfrage zurückgegeben werden.</param>
        <param name="offset">Der Offset Anzahl von Ereignissen, die die Position des Lesezeichens zu ändern.</param>
        <summary>Ändert die Position im ereignisdatenstrom, woher das nächste Ereignis, das gelesen wird stammen wird durch Angeben einer Lesezeichenereignis und einen Offset für die Anzahl von Ereignissen für das Lesezeichen. Keine Ereignisse protokolliert werden, bevor das Lesezeichen plus Offset abgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Funktion nur für Resultsets, die von einem Administrator oder operationskanal oder von EVTX-Protokolldateien verwenden. Diese Funktion wird nicht unterstützt für analytische und Debuggen von Kanälen, oder für ETL-Dateien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.IO.SeekOrigin origin, long offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.IO.SeekOrigin origin, int64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Seek(System.IO.SeekOrigin,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
        <Parameter Name="offset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="origin">Ein Wert aus der <see cref="T:System.IO.SeekOrigin" /> -Enumeration definiert, an welcher Stelle in den Datenstrom von Ereignissen, um Abfragen von Ereignissen zu starten.</param>
        <param name="offset">Der Offset Anzahl der Ereignisse, die den Ursprung hinzugefügt werden soll.</param>
        <summary>Ändert die Position im Stream, in dem das nächste Ereignis, das gelesen wird stammen wird durch Angeben einer Anfangsposition und einen Offset von der Startposition. Keine Ereignisse protokolliert werden, bevor die Anfangsposition plus Offset abgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Funktion nur für Resultsets, die von einem Administrator oder operationskanal oder von EVTX-Protokolldateien verwenden. Diese Funktion wird nicht unterstützt für analytische und Debuggen von Kanälen, oder für ETL-Dateien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
