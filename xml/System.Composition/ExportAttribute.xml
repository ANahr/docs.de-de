<Type Name="ExportAttribute" FullName="System.Composition.ExportAttribute">
  <TypeSignature Language="C#" Value="public class ExportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ExportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Composition.ExportAttribute" />
  <AssemblyInfo>
    <AssemblyName>System.Composition.AttributedModel</AssemblyName>
    <AssemblyVersion>1.0.31.0</AssemblyVersion>
    <AssemblyVersion>1.0.32.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Property, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt an, dass ein Typ, eine Eigenschaft, ein Feld oder eine Methode einen bestimmten Export bereitstellt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Im Modell attributierten Programmierung ExportAttribute-Attribut deklariert, dass ein Teil wird exportiert oder liefert dem Kompositionscontainer ein Objekt, das einen bestimmten Vertrag erfüllt. Während der Komposition bestehen aus Teilen, Importen, die übereinstimmende Verträge solcher Abhängigkeiten, die durch das exportierte Objekt gefüllt.

Das Attribut ExportAttribute kann entweder eine ganze Klasse oder eine Eigenschaft oder Methode einer Klasse anwenden. Wenn sie auf die gesamte Klasse angewendet wird, wird eine Instanz der Klasse das exportierte Objekt. Wenn sie auf einen Member einer Klasse angewendet wird, wird das exportierte Objekt der Wert dieses Elements sein.

Gibt an, ob ein Vertrag übereinstimmt, wird in erster Linie durch die Vertragsnamen und Vertragstyp bestimmt. Weitere Informationen finden Sie unter der <xref:System.Composition.ImportAttribute> Verweis. 



## Examples  
 Das folgende Beispiel zeigt ExportAttribute auf drei Klassen und drei Importe, die sie entsprechen angewendet wird.  

```csharp
//Default export infers type and contract name from the
//exported type.  This is the preferred method.
[Export]
public class MyExport1
{
    public String data = "Test Data 1.";
}

public class MyImporter1
{
    [Import]
    public MyExport1 importedMember { get; set; }
}

public interface MyInterface
{

}

//Specifying the contract type may be important if
//you want to export a type other then the base type,
//such as an interface.
[Export(typeof(MyInterface))]
public class MyExport2 : MyInterface
{
    public String data = "Test Data 2.";
}

public class MyImporter2
{
    //The import must match the contract type!
    [Import(typeof(MyInterface))]
    public MyExport2 importedMember { get; set; }
}

//Specifying a contract name should only be 
//needed in rare caes. Usually, using metadata
//is a better approach.
[Export("MyContractName", typeof(MyInterface))]
public class MyExport3 : MyInterface
{
    public String data = "Test Data 3.";
}

public class MyImporter3
{
    //Both contract name and type must match!
    [Import("MyContractName", typeof(MyInterface))]
    public MyExport3 importedMember { get; set; }
}

class Program
{      

    static void Main(string[] args)
    {
        AggregateCatalog catalog = new AggregateCatalog();
        catalog.Catalogs.Add(new AssemblyCatalog(typeof(MyExport1).Assembly));
        CompositionContainer _container = new CompositionContainer(catalog);
        MyImporter1 test1 = new MyImporter1();
        MyImporter2 test2 = new MyImporter2();
        MyImporter3 test3 = new MyImporter3();
        _container.SatisfyImportsOnce(test1);
        _container.SatisfyImportsOnce(test2);
        _container.SatisfyImportsOnce(test3);
        Console.WriteLine(test1.importedMember.data);
        Console.WriteLine(test2.importedMember.data);
        Console.WriteLine(test3.importedMember.data);
        Console.ReadLine();

    }
}
```

```vb
'Default export infers type and contract name from the
'exported type.  This is the preferred method.
<Export()>
Public Class MyExport1
    Public ReadOnly Property data As String
        Get
            Return "Test Data 1."
        End Get
    End Property
End Class

Public Class MyImporter1

    <Import()>
    Public Property ImportedMember As MyExport1

End Class

Public Interface MyInterface

End Interface

'Specifying the contract type may be important if
'you want to export a type other then the base type,
'such as an interface.
<Export(GetType(MyInterface))>
Public Class MyExport2
    Implements MyInterface
    Public ReadOnly Property data As String
        Get
            Return "Test Data 2."
        End Get
    End Property
End Class

Public Class MyImporter2
    'The import must match the contract type!
    <Import(GetType(MyInterface))>
    Public Property ImportedMember As MyExport2
End Class

'Specifying a contract name should only be 
'needed in rare caes. Usually, using metadata
'is a better approach.
<Export("MyContractName", GetType(MyInterface))>
Public Class MyExport3
    Implements MyInterface
    Public ReadOnly Property data As String
        Get
            Return "Test Data 3."
        End Get
    End Property
End Class

Public Class MyImporter3
    'Both contract name and type must match!
    <Import("MyContractName", GetType(MyInterface))>
    Public Property ImportedMember As MyExport3
End Class



Sub Main()
    Dim catalog As AggregateCatalog = New AggregateCatalog()
    catalog.Catalogs.Add(New AssemblyCatalog(GetType(MyExport1).Assembly))
    Dim container As CompositionContainer = New CompositionContainer(catalog)
    Dim test1 As MyImporter1 = New MyImporter1()
    Dim test2 As MyImporter2 = New MyImporter2()
    Dim test3 As MyImporter3 = New MyImporter3()
    container.SatisfyImportsOnce(test1)
    container.SatisfyImportsOnce(test2)
    container.SatisfyImportsOnce(test3)
    Console.WriteLine(test1.ImportedMember.data)
    Console.WriteLine(test2.ImportedMember.data)
    Console.WriteLine(test3.ImportedMember.data)
    Console.ReadLine()
End Sub
```

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Composition.ExportAttribute" /> -Klasse, exportieren den Typ oder Member unter der Name des Vertrags mit diesem Attribut gekennzeichnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Mit diesem Attribut markierte Methoden müssen einen Vertragsnamen oder einen Typ entweder Angeben der <xref:System.Composition.ExportAttribute(String)> oder <xref:System.Composition.ExportAttribute(Type)> Methode.

Der Name des Vertrags wird verglichen mit der <xref:System.StringComparer.Ordinal> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contractName">Der Name des Vertrags, der verwendet wird, um den Typ oder Member, die mit diesem Attribut gekennzeichnet zu exportieren oder <see langword="null" /> oder eine leere Zeichenfolge ("") der Name des Vertrags zu verwenden.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Composition.ExportAttribute" /> exportieren den Typ oder Member-Klasse, unter dem angegebenen Vertragsnamen mit diesem Attribut gekennzeichnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Mit diesem Attribut markierte Methoden müssen einen Vertragsnamen oder einen Typ entweder Angeben der <xref:System.Composition.ExportAttribute(String)> oder <xref:System.Composition.ExportAttribute(Type)> Methode.

Der Name des Vertrags wird verglichen mit der <xref:System.StringComparer.Ordinal> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute (Type contractType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type contractType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor(System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="contractType">Ein Typ aus der abgeleitet werden, soll der Name des Vertrags, der verwendet wird, um den Typ oder Member, die mit diesem Attribut gekennzeichnet zu exportieren oder <see langword="null" /> der Name des Vertrags zu verwenden.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Composition.ExportAttribute" /> -Klasse, exportieren den Typ oder Member mit diesem Attribut unter dem Vertragsnamen, abgeleitet aus dem angegebenen Typ gekennzeichnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Mit diesem Attribut markierte Methoden müssen einen Vertragsnamen oder einen Typ entweder Angeben der <xref:System.Composition.ExportAttribute(String)> oder <xref:System.Composition.ExportAttribute(Type)> Methode.

Der Name des Vertrags wird verglichen mit der <xref:System.StringComparer.Ordinal> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute (string contractName, Type contractType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName, class System.Type contractType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor(System.String,System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
        <Parameter Name="contractType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="contractName">Der Name des Vertrags, der verwendet wird, um den Typ oder Member, die mit diesem Attribut gekennzeichnet zu exportieren oder <see langword="null" /> oder eine leere Zeichenfolge ("") der Name des Vertrags zu verwenden.</param>
        <param name="contractType">Der Typ, der exportiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Composition.ExportAttribute" /> Klasse, wobei den angegebenen Typ unter dem angegebenen Vertragsnamen exportiert.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractName">
      <MemberSignature Language="C#" Value="public string ContractName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContractName" />
      <MemberSignature Language="DocId" Value="P:System.Composition.ExportAttribute.ContractName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, der Name des Vertrags, der verwendet wird, um den Typ oder Member, die mit diesem Attribut gekennzeichnet zu exportieren.</summary>
        <value>Der Name des Vertrags, der verwendet wird, um den Typ oder Member zu exportieren, die mit diesem Attribut gekennzeichnet werden. Der Standardwert ist eine leere Zeichenfolge („“).</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractType">
      <MemberSignature Language="C#" Value="public Type ContractType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ContractType" />
      <MemberSignature Language="DocId" Value="P:System.Composition.ExportAttribute.ContractType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Vertrags, der vom Element exportiert wird, die von diesem Attribut gekennzeichnet ist.</summary>
        <value>Der Typ des Exports bereitgestellt werden. Der Standardwert ist <see langword="null" />, d. h., die der Typ abgerufen werden durch einen Blick auf den Typ des Elements, das diesem Export angefügt ist.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
