<Type Name="TextFieldParser" FullName="Microsoft.VisualBasic.FileIO.TextFieldParser">
  <TypeSignature Language="C#" Value="public class TextFieldParser : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextFieldParser extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt Methoden und Eigenschaften zur Analyse strukturierter Textdateien bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `TextFieldParser` -Objekt stellt Methoden und Eigenschaften zur Analyse strukturierter Textdateien. Analysieren eine Textdatei mit der `TextFieldParser` ähnelt der Iteration über eine Textdatei, während die `ReadFields` Methode zum Extrahieren von Textfeldern ist vergleichbar mit Teilen der Zeichenfolgen.  
  
 Die `TextFieldParser` können zwei Arten von Dateien analysieren: mit Trennzeichen oder feste Breite. Einige Eigenschaften, z. B. `Delimiters` und `HasFieldsEnclosedInQuotes` sind nur sinnvoll bei der Arbeit mit durch Trennzeichen getrennte Dateien dagegen die `FieldWidths` Eigenschaft ist sinnvoll, nur bei der Arbeit mit Dateien mit fester Breite.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `Microsoft.VisualBasic.FileIO.TextFieldParser` Objekt.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennte Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird durch eine Tabstopps getrennte Textdatei analysiert `Bigfile`.  
  
 [!code-vb[VbVbalrTextFieldParser#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#17)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Der Stream, der analysiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.TextReader)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" />. Die <see cref="T:System.IO.TextReader" /> Stream analysiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `reader` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="Nothing" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Der vollständige Pfad der Datei, die analysiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei gemäß der `path` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Der Stream, der analysiert werden.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Die um zu verwenden, wenn die Codierung zeichencodierung wird nicht aus Datei bestimmt. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Der vollständige Pfad der Datei, die analysiert werden.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Die um zu verwenden, wenn die Codierung zeichencodierung wird nicht aus Datei bestimmt. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei gemäß der `path` Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />ist eine leere Zeichenfolge oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Der Stream, der analysiert werden.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Die um zu verwenden, wenn die Codierung zeichencodierung wird nicht aus Datei bestimmt. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
 Wenn die `detectEncoding` Parameter ist `True`, diesen Konstruktor versucht, die Codierung durch einen Blick auf die ersten drei Bytes der Datei bzw. dem Stream zu erkennen. Er erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge-Marken beginnt. Sie andernfalls die Codierung von angegebene `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (string path, System.Text.Encoding defaultEncoding, bool detectEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding defaultEncoding, bool detectEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="String" />. Der vollständige Pfad der Datei, die analysiert werden.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Die um zu verwenden, wenn die Codierung zeichencodierung wird nicht aus Datei bestimmt. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` Objekt zum Analysieren der Datei gemäß der `path` Parameter.  
  
 Wenn die `detectEncoding` Parameter ist `True`, diesen Konstruktor versucht, die Codierung durch einen Blick auf die ersten drei Bytes der Datei bzw. dem Stream zu erkennen. Er erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge-Marken beginnt. Sie andernfalls die Codierung von angegebene `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />ist eine leere Zeichenfolge oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextFieldParser (System.IO.Stream stream, System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding defaultEncoding, bool detectEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="defaultEncoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncoding" Type="System.Boolean" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />. Der Stream, der analysiert werden.</param>
        <param name="defaultEncoding">
          <see cref="T:System.Text.Encoding" />. Die um zu verwenden, wenn die Codierung zeichencodierung wird nicht aus Datei bestimmt. Der Standardwert ist <see cref="P:System.Text.Encoding.UTF8" />.</param>
        <param name="detectEncoding">
          <see langword="Boolean" />. Gibt an, ob am Anfang der Datei nach Bytereihenfolgemarken gesucht werden soll. Der Standardwert ist <see langword="True" />.</param>
        <param name="leaveOpen">
          <see langword="Boolean" />. Gibt an, ob lassen <c>Stream</c> beim Öffnen der <see langword="TextFieldParser" /> -Objekt ist geschlossen. Der Standardwert ist <see langword="False" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="TextFieldParser" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues `TextFieldParser` dargestellte Objekt, das Analysieren der Datei oder den stream, der die `stream` Parameter.  
  
 Wenn die `detectEncoding` Parameter ist `True`, diesen Konstruktor versucht, die Codierung durch einen Blick auf die ersten drei Bytes der Datei bzw. dem Stream zu erkennen. Er erkennt automatisch UTF-8 "," little-Endian Unicode und big-Endian Unicode-Text, wenn die Datei mit den entsprechenden Bytereihenfolge-Marken beginnt. Sie andernfalls die Codierung von angegebene `defaultEncoding` verwendet wird.  
  
> [!CAUTION]
>  Wenn Sie einen Satz von Zeichen mit einer bestimmten kultureinstellung kompilieren und dieser dieselben Zeichen mit einer anderen kultureinstellung abrufen, werden die Zeichen möglicherweise nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="defaultEncoding" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die aktuelle <see langword="TextFieldParser" /> Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel schließt den `TextFieldParser.FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommentTokens">
      <MemberSignature Language="C#" Value="public string[] CommentTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] CommentTokens" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.CommentTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert Kommentartoken. Ein Kommentartoken ist eine Zeichenfolge am Anfang einer Zeile, die angibt, dass die Zeile ein Kommentar ist und vom Parser ignoriert werden soll.</summary>
        <value>Ein Array von Zeichenfolgen, die alle des Kommentars enthält Token für die <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Mit der Länge Null Kommentartoken werden ignoriert.  
  
   
  
## Examples  
 In diesem Beispiel gibt an, dass für die `TextFieldParser`, `FileReader` Zeilen ab der ein einfaches Anführungszeichen (') ignoriert werden sollen.  
  
 [!code-vb[VbVbalrTextFieldParser#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Kommentartoken enthält Leerzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delimiters">
      <MemberSignature Language="C#" Value="public string[] Delimiters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Delimiters" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.Delimiters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Trennzeichen für eine Textdatei.</summary>
        <value>Ein Zeichenfolgenarray, das alle Feldtrennzeichen für enthält die <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist genannte nur, wenn die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> -Eigenschaftensatz auf `FieldType.Delimited`.  
  
 Definieren die Trennzeichen für eine Textdatei ebenfalls mit erreicht werden kann die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters%2A> Methode.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `Delimiters` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennte Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel gibt an, dass das Trennzeichen für die `TextFieldParser` Objekt `FileReader`, ist ein Komma (,).  
  
 [!code-vb[VbVbalrTextFieldParser#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Trennzeichenwert um ein neue Zeilenumbruchzeichen, eine leere Zeichenfolge festgelegt ist oder <see langword="Nothing" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familynewslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Boolesch. <see langword="True" />Gibt sowohl verwaltete als auch nicht verwaltete Ressourcen frei; <see langword="False" /> nur nicht verwaltete Ressourcen frei.</param>
        <summary>Gibt vom <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt verwendete Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndOfData">
      <MemberSignature Language="C#" Value="public bool EndOfData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfData" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.EndOfData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt <see langword="True" /> treten keine nicht leeren, Zeilen nicht kommentierten zwischen der aktuellen Cursorposition und dem Ende der Datei.</summary>
        <value>
          <see langword="True" />Wenn es keine weiteren Daten sind lesen; andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann beim Lesen aus Dateien verwendet werden, um zu bestimmen, das Ende der Daten gelesen werden können.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `EndOfData` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `EndofData` Eigenschaft so durchlaufen Sie alle Felder in der Datei mit den `TextFieldReader`, `FileReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorLine">
      <MemberSignature Language="C#" Value="public string ErrorLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorLine" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Zeile, die die letzte verursachte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> Ausnahme.</summary>
        <value>Die Zeile, die die letzte verursachte <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> Ausnahme.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahmen ausgelöst wurden, wird eine leere Zeichenfolge zurückgegeben.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber%2A> Eigenschaft kann verwendet werden, um die Nummer der Zeile angezeigt, die die Ausnahme verursacht hat.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ErrorLine` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ErrorLine` die Zeile, die das aktuelle verursacht anzuzeigende Eigenschaft <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahme.  
  
 [!code-vb[VbVbalrTextFieldParser#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorLineNumber">
      <MemberSignature Language="C#" Value="public long ErrorLineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ErrorLineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Nummer der Zeile, die die aktuellste verursacht <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> Ausnahme.</summary>
        <value>Die Nummer der Zeile, die die aktuellste verursacht <see cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException" /> Ausnahme.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn kein <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahmen ausgelöst wurden, wird-1 zurückgegeben.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine%2A> Eigenschaft kann verwendet werden, um die Nummer der Zeile angezeigt, die die Ausnahme verursacht hat. Leerzeilen und Kommentare werden nicht ignoriert, wenn die Nummer der Zeile bestimmt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ErrorLineNumber` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ErrorLineNumber` Eigenschaft, um die Position der Zeile, die das aktuelle verursacht anzuzeigen <xref:Microsoft.VisualBasic.FileIO.MalformedLineException> Ausnahme.  
  
 [!code-vb[VbVbalrTextFieldParser#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldWidths">
      <MemberSignature Language="C#" Value="public int[] FieldWidths { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] FieldWidths" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.FieldWidths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kennzeichnet die Breite der einzelnen Spalten in der Textdatei, die analysiert wird.</summary>
        <value>Ein Array mit ganzen Zahlen, das die Breite jeder Spalte in der Textdatei enthält, die analysiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist genannte nur, wenn die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType%2A> -Eigenschaftensatz auf `FieldType.FixedWidth`. Wenn der letzte Eintrag im Array kleiner als oder gleich 0 (null) ist, wird davon ausgegangen, dass das Feld variabler Breite aufweisen.  
  
 Die <xref:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths%2A> Methode kann auch verwendet werden, um Feldbreiten festzulegen.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `FieldWidths` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 In diesem Beispiel liest die Datei `ParserText.txt`, die erste Spalte ist 5 Zeichen breit, die zweite ist 10, der dritte ist 11 und der vierte ist variabler Breite angeben der breiten;  
  
 [!code-vb[VbVbalrTextFieldParser#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Wert der Zeilenbreite an einem beliebigen Speicherort nicht der letzte Eintrag des Arrays ist kleiner als oder gleich 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TextFieldParser ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht die <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> -Objekt den Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbagecollection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasFieldsEnclosedInQuotes">
      <MemberSignature Language="C#" Value="public bool HasFieldsEnclosedInQuotes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasFieldsEnclosedInQuotes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.HasFieldsEnclosedInQuotes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt beim Analysieren einer Datei mit Trennzeichen an, ob die Felder in Anführungszeichen eingeschlossen sind.</summary>
        <value>
          <see langword="True" />Wenn Felder in Anführungszeichen eingeschlossen sind; andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Wenn die Eigenschaft `True`, der Parser wird davon ausgegangen, dass Felder in Anführungszeichen eingeschlossen sind ("") und Zeilenenden enthalten kann.  
  
 Wenn ein Feld in Anführungszeichen, z. B. eingeschlossen ist `abc, "field2a,field2b", field3` und diese Eigenschaft ist `True`, klicken Sie dann alle Text in Anführungszeichen eingeschlossen wird unverändert zurückgegeben werden, da in diesem Beispiel würden `abc|field2a,field2b|field3`. Wenn diese Eigenschaft auf `False` würde in diesem Beispiel machen return `abc|"field2a|field2b"|field3`.  
  
   
  
## Examples  
 In diesem Beispiel wird die `HasFieldsEnclosedInQuotes` Eigenschaft `True` für `myReader`.  
  
 [!code-vb[VbVbalrTextFieldParser#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public long LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LineNumber" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.LineNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die aktuelle Zeilennummer oder -1 zurück, wenn im Stream keine weiteren Zeichen verfügbar sind.</summary>
        <value>Die aktuelle Zeilennummer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Leerzeilen und Kommentare werden nicht ignoriert, wenn die Nummer der Zeile bestimmt.  
  
   
  
## Examples  
 In diesem Beispiel sucht nach dem Namen "Jones" in der Textdatei und meldet welche Zeile(n) es auftritt.  
  
 [!code-vb[VbVbalrTextFieldParser#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PeekChars">
      <MemberSignature Language="C#" Value="public string PeekChars (int numberOfChars);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string PeekChars(int32 numberOfChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.PeekChars(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numberOfChars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numberOfChars">
          <see langword="Int32" />. Die Anzahl der zu lesenden Zeichen. Erforderlich.</param>
        <summary>Liest die angegebene Anzahl von Zeichen, ohne die Cursorposition zu ändern.</summary>
        <returns>Eine Zeichenfolge, die die angegebene Anzahl gelesener Zeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `numberOfChars` Wert muss kleiner als die Gesamtzahl der Zeichen in der Zeile sein. Ist dies nicht der Fall, die zurückgegebene Zeichenfolge `PeekChars` wird auf die Länge der Zeile abgeschnitten werden.  
  
 Leere Zeilen werden ignoriert.  
  
 End-of-Line-Zeichen werden nicht zurückgegeben.  
  
 Die `PeekChars` Methode führt keine Analyse; ein End-of-Line-Zeichen in einem Feld mit Trennzeichen als tatsächliches Ende der Zeile interpretiert wird.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `PeekChars` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Bestimmen Sie das Format eines Felds vor dem Analysieren ihn|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet `PeekChars` ermittelt das Ende der Daten und Analyse der Datei an diesem Punkt beendet.  
  
 [!code-vb[VbVbalrTextFieldParser#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="numberOfChars" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadFields">
      <MemberSignature Language="C#" Value="public string[] ReadFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string[] ReadFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest alle Felder in der aktuellen Zeile, gibt sie als Zeichenfolgenarray zurück und setzt den Cursor in die nächste Zeile mit Daten.</summary>
        <returns>Ein Array von Zeichenfolgen, das Feldwerte für die aktuelle Zeile enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit Benutzer beim Analysieren von Textdateien in verschiedenen Formaten können die `ReadFields` -Methode untersucht dann die Werte der `TextFieldType`, `Delimiters`, und `FieldWidths`, wenn sie festgelegt sind, jedes Mal aufgerufen wird. Benutzer müssen nicht ordnungsgemäß konfiguriert die `TextFieldType` und `FieldWidths` oder `Delimiters` Eigenschaften nach Bedarf. Wenn `TextFieldType` festgelegt ist, um `Delimited`, und `Delimiters` nicht festgelegt ist, oder wenn `TextFieldType` auf festgelegt ist `FixedWidth` und `FieldWidths`, wird eine Ausnahme ausgelöst.  
  
 Wenn `ReadFields` erkennt leere Zeilen werden sie übersprungen und die nächste nicht leere Zeile zurückgegeben.  
  
 Wenn die `ReadFields` Methode die aktuelle Zeile kann nicht analysiert werden, es wird eine Ausnahme ausgelöst und nicht zur nächsten Zeile verschoben. Dadurch kann es sich um die Anwendung versucht, die Zeile erneut analysiert.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `ReadFields` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennten Datei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Datei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ReadFields` Methode zum Lesen aus der durch Trennzeichen getrennte Datei `ParserText.txt`. Das Beispiel schreibt die Felder `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Ein Feld kann nicht analysiert werden, mithilfe des angegebenen Formats.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die aktuelle Zeile als Zeichenfolge zurück und setzt den Cursor in die nächste Zeile.</summary>
        <returns>Die aktuelle Zeile aus der Datei oder dem Datenstrom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadLine` Methode führt keine Analyse; ein End-of-Line-Zeichen in einem Feld mit Trennzeichen als tatsächliches Ende der Zeile interpretiert wird.  
  
 `Nothing`wird zurückgegeben, wenn das Ende der Datei erreicht ist.  
  
   
  
## Examples  
 In diesem Beispiel liest mithilfe der Datei `ParserText.txt` und schreibt ihn auf `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#15)]  
  
 Wenn `Testfile.txt` nicht vorhanden ist, wird erstellt, indem die `WriteAllText` Methode.  
  
 In diesem Beispiel schreibt die Felder als eine einzelne Zeichenfolge; Jede Zeile in einer eigenen Zeile in der Zieldatei angezeigt haben eine `VbCrLf` Zeichen am Ende jeder Zeile angefügt werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.ReadToEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest die verbleibende Textdatei und gibt sie als Zeichenfolge zurück.</summary>
        <returns>Der verbleibende Text aus der Datei oder dem Datenstrom.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein erweiterter Member. Es werden keine in IntelliSense angezeigt, es sei denn, Sie klicken Sie auf die **alle** Registerkarte.  
  
 Wenn keine weiteren zu lesen, da das Ende der Datei erreicht wurde, `Nothing` wird zurückgegeben.  
  
 Die `ReadToEnd` Methode nicht leere Zeilen und Kommentare ignoriert.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ReadToEnd` Methode zum Lesen der vollständigen Datei `ParserText.txt` und schreibt es in die Datei `Testfile.txt`.  
  
 [!code-vb[VbVbalrTextFieldParser#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#10)]  
  
 Wenn `Testfile.txt` nicht vorhanden ist, wird erstellt, indem die `WriteAllText` Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDelimiters">
      <MemberSignature Language="C#" Value="public void SetDelimiters (params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetDelimiters(string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetDelimiters(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delimiters">Array des Typs <see langword="String" />.</param>
        <summary>Legt die Trennzeichen für den Reader auf den angegebenen Werten, und den Typ des Felds auf <see langword="Delimited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den vorhandenen Inhalt der `Delimiters` Eigenschaft sind deaktiviert, wenn diese Methode festgelegt ist.  
  
 Diese Methode bietet eine Möglichkeit, die Trennzeichen festlegen, ohne das Erstellen eines Arrays.  
  
 Die folgende Tabelle enthält ein Beispiel für eine Aufgabe mit der `SetDelimiters` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Analysieren einer Textdatei|[Analysieren von Textdateien mit dem TextFieldParser-Objekt](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In diesem Beispiel öffnet einen Text-Feld-Parser und definiert das Trennzeichen als `vbTab`.  
  
 [!code-vb[VbVbalrTextFieldParser#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#4)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der Datei, die Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Trennzeichen ist mit der Länge Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFieldWidths">
      <MemberSignature Language="C#" Value="public void SetFieldWidths (params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void SetFieldWidths(int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.TextFieldParser.SetFieldWidths(System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fieldWidths">Array von <see langword="Integer" />.</param>
        <summary>Legt die Trennzeichen für den Reader auf die angegebenen Werte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den vorhandenen Inhalt der `Delimiters` Eigenschaft sind deaktiviert, wenn diese Option festgelegt ist.  
  
 Diese Methode bietet eine Möglichkeit, die Trennzeichen festlegen, ohne das Erstellen eines Arrays.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `SetFieldWidths` Methode.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Eine Textdatei zu analysieren.|[Analysieren von Textdateien mit dem TextFieldParser-Objekt](~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird einen Textfeld Parser geöffnet und definiert die Breite des Felds als `5`.  
  
 [!code-vb[VbVbalrTextFieldParser#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#12)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der Datei, die Sie analysieren möchten.  
  
 Im folgenden Beispiel wird einen Textfeld Parser geöffnet und definiert die Feldbreiten `5`, `10`, und die Variable.  
  
 [!code-vb[VbVbalrTextFieldParser#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#13)]  
  
 Ersetzen Sie den Pfad `C:\logs\test.log` durch den Pfad und Name der Datei, die Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextFieldType">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.FieldType TextFieldType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.FileIO.FieldType TextFieldType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.FieldType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die zu analysierende Datei Trennzeichen enthält oder eine feste Breite aufweist.</summary>
        <value>Ein <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TextFieldType" /> Wert, der angibt, ob die zu analysierende Datei Trennzeichen enthält oder mit fester Breite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert dieser Eigenschaft ist begrenzt.  
  
 Die folgende Tabelle enthält Beispiele für Aufgaben im Zusammenhang mit der `TextFieldType` Eigenschaft.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen Sie aus einer durch Trennzeichen getrennte Textdatei|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lesen Sie aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lesen Sie aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und gibt an, dass Trennzeichen verwendet werden.  
  
 [!code-vb[VbVbalrTextFieldParser#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#19)]  
  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und gibt an, dass es mit fester Breite ist.  
  
 [!code-vb[VbVbalrTextFieldParser#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimWhiteSpace">
      <MemberSignature Language="C#" Value="public bool TrimWhiteSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimWhiteSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.TextFieldParser.TrimWhiteSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob vorangestellte und nachfolgende Leerzeichen aus Feldwerten entfernt werden sollen.</summary>
        <value>
          <see langword="True" />Wenn die führende und nachfolgende Leerzeichen aus Feldwerten entfernt werden soll; andernfalls <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `True`.  
  
   
  
## Examples  
 In diesem Beispiel wird eine `TextFieldParser`, `FileReader`, und legt die `TrimWhiteSpace` Eigenschaft `True`.  
  
 [!code-vb[VbVbalrTextFieldParser#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrTextFieldParser/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
