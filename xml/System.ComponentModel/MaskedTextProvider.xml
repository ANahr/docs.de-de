<Type Name="MaskedTextProvider" FullName="System.ComponentModel.MaskedTextProvider">
  <TypeSignature Language="C#" Value="public class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MaskedTextProvider extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.MaskedTextProvider" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Maske-Analyse-Dienst, der von einer beliebigen Anzahl von Steuerelementen verwendet werden kann, maskiert unterstützen, z. B. die <see cref="T:System.Windows.Forms.MaskedTextBox" /> Steuerelement.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Forms.MaskedTextBox> Steuerelement enthält eine Maske, bestehend aus einem Literalzeichen und Formatierung-Elemente, die alle Benutzereingaben anhand eines tests. Anstelle einer bestimmten Maske-Analysemodul mit dauerhaft zuordnen <xref:System.Windows.Forms.MaskedTextBox>, Windows Forms bietet es als separater Dienst, dargestellt durch die <xref:System.ComponentModel.MaskedTextProvider> Klasse, die in der Dokumentation für die Syntax der Maskierungssprache erläutert definiert die <xref:System.Windows.Forms.MaskedTextBox.Mask%2A> Eigenschaft.  
  
 Viele der Elemente der <xref:System.Windows.Forms.MaskedTextBox> Klasse verweisen, deren Implementierung auf entsprechend benannten Member der zugeordneten <xref:System.ComponentModel.MaskedTextProvider>. Z. B. die <xref:System.Windows.Forms.MaskedTextBox.PromptChar%2A?displayProperty=nameWithType> Eigenschaft von der <xref:System.Windows.Forms.MaskedTextBox> Klasse bezieht sich bei allen Zugriffen auf die <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> von der <xref:System.ComponentModel.MaskedTextProvider> Klasse.  
  
 Verwendet von Mask-Analysemodul <xref:System.ComponentModel.MaskedTextProvider> wird nach dem MaskedEdit-Steuerelement in Microsoft Visual Basic-Version 6 enthalten modelliert. Die Maskierungssprache wird beschrieben, in der Dokumentation für die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Eigenschaft.  
  
 Die folgenden drei unterschiedlichen Zeichenfolgen stehen im Zusammenhang mit der <xref:System.ComponentModel.MaskedTextProvider> Klasse.  
  
|Zeichenfolgennamen|Beschreibung|  
|-----------------|-----------------|  
|Eingabezeichen oder Zeichenfolge|Stellt die Zeichen, die als Eingabe, die die Maske angewendet wird. In Wirklichkeit die Eingabezeichenfolge kann besteht aus mehreren Eingabevorgänge, einschließlich <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, und <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>. Aus diesem Grund kann die Eingabezeichenfolge nicht direkt zugegriffen werden. Die Behandlung der Eingabezeichenfolge Aspekte stehen jedoch über die <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> und <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>, und <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> Eigenschaften.|  
|Format|Stellt die Eingabe, die Formatierung der Maske verwendet, um die Eingabezeichenfolge in die formatierte Zeichenfolge zu transformieren. Diese Zeichenfolge wird festgelegt, der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> und erfolgt hauptsächlich über die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Eigenschaft. Merkmale der Maske sind auch über andere Member verfügbar, z. B. die <xref:System.ComponentModel.MaskedTextProvider.Length%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, und <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> Eigenschaften.|  
|Formatierte Zeichenfolge|Stellt die Zeichenfolge, die entsteht, wenn die vollständige Maske auf die Eingabezeichenfolge angewendet wird. Die formatierte Zeichenfolge kann abgefragt werden, mit vielen Mitgliedern der Klasse, einschließlich <xref:System.ComponentModel.MaskedTextProvider.Item%2A>, <xref:System.ComponentModel.MaskedTextProvider.Length%2A>, <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskFull%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A>, <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A>und so weiter. Der vollständige Wert der formatierten Zeichenfolge steht aus der <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> und <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methoden.|  
  
> [!NOTE]
>  Die Eingabezeichenfolge kann direkte Benutzereingabe, wie im Fall von darstellen, die <xref:System.Windows.Forms.MaskedTextBox>, oder können von anderen Prozessen nicht direkt zugeordnete-e/a-Benutzervorgänge generiert werden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung dieses Konstruktors entspricht genau dem folgenden Aufruf der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <param name="restrictToAscii">
          <see langword="true" />Eingabe für ASCII-kompatible Zeichen beschränken; andernfalls <see langword="false" /> um den gesamten Unicode-Satz zu ermöglichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske und ASCII-Einschränkungswert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung dieses Konstruktors entspricht genau dem folgenden Aufruf der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', restrictToASCII)`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <param name="culture">Ein <see cref="T:System.Globalization.CultureInfo" /> dient außerdem zur Region Akzent Trennzeichen festgelegt.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske und Kultur entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung dieses Konstruktors entspricht genau dem folgenden Aufruf der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Char,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <param name="passwordChar">Ein <see cref="T:System.Char" /> , der für eine Kennwortzeichenfolge eingegebenen Zeichen angezeigt wird.</param>
        <param name="allowPromptAsInput">
          <see langword="true" />um die Eingabeaufforderungszeichen als Eingabe zu ermöglichen. andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske Kennwortzeichen und Prompt Usage-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung dieses Konstruktors entspricht genau dem folgenden Aufruf der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , null, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <param name="culture">Ein <see cref="T:System.Globalization.CultureInfo" /> dient außerdem zur Region Akzent Trennzeichen festgelegt.</param>
        <param name="restrictToAscii">
          <see langword="true" />Eingabe für ASCII-kompatible Zeichen beschränken; andernfalls <see langword="false" /> um den gesamten Unicode-Satz zu ermöglichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske, die Kultur und die ASCII-Einschränkungswert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung dieses Konstruktors entspricht genau dem folgenden Aufruf der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', restrictToAscii)`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Char,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <param name="culture">Ein <see cref="T:System.Globalization.CultureInfo" /> dient außerdem zur Region Akzent Trennzeichen festgelegt.</param>
        <param name="passwordChar">Ein <see cref="T:System.Char" /> , der für eine Kennwortzeichenfolge eingegebenen Zeichen angezeigt wird.</param>
        <param name="allowPromptAsInput">
          <see langword="true" />um die Eingabeaufforderungszeichen als Eingabe zu ermöglichen. andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske, Kultur, Kennwortzeichen und Prompt Usage-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung dieses Konstruktors entspricht genau dem folgenden Aufruf der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor:  
  
 `MaskedTextProvider(mask , culture, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Char,System.Char,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
        <Parameter Name="promptChar" Type="System.Char" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" /> , input Mask-Eigenschaft darstellt.</param>
        <param name="culture">Ein <see cref="T:System.Globalization.CultureInfo" /> dient außerdem zur Region Akzent Trennzeichen festgelegt.</param>
        <param name="allowPromptAsInput">Ein <see cref="T:System.Boolean" /> Wert, der angibt, ob die Eingabeaufforderungszeichen als gültiges Eingabezeichen zugelassen werden soll.</param>
        <param name="promptChar">Ein <see cref="T:System.Char" /> , der als Platzhalter für Benutzereingaben angezeigt wird.</param>
        <param name="passwordChar">Ein <see cref="T:System.Char" /> , der für eine Kennwortzeichenfolge eingegebenen Zeichen angezeigt wird.</param>
        <param name="restrictToAscii">
          <see langword="true" />Eingabe für ASCII-kompatible Zeichen beschränken; andernfalls <see langword="false" /> um den gesamten Unicode-Satz zu ermöglichen.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.ComponentModel.MaskedTextProvider" /> -Klasse unter Verwendung der angegebenen Maske, Kultur, Prompt Verwendungswert, Aufforderungszeichen, Kennwortzeichen und Einschränkungswert ASCII.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor stellt die allgemeinste überladene Form dar. Die `mask` Parameter entsprechen die Maskingsprache definiert, indem Sie die <xref:System.ComponentModel.MaskedTextProvider> -Klasse, die in detailliert erläutert wird die <xref:System.Windows.Forms.MaskedTextBox.Mask%2A?displayProperty=nameWithType> Eigenschaft von der <xref:System.Windows.Forms.MaskedTextBox> Klasse.  
  
 Da die neutrale Kulturen kulturspezifischen Informationen, können nicht abgefragt werden die <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor verwendet die <xref:System.Globalization.CultureInfo.GetCultures%2A> Methode zum Suchen nach der ersten nicht neutrale Kultur zum Bestimmen der geeigneten Trennzeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Parameter ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.  
  
 - oder -   
  
 Die Maske enthält ein oder mehrere nicht druckbare Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Char" /> Wert, der die formatierte Zeichenfolge angefügt werden soll.</param>
        <summary>Fügt das angegebene Eingabezeichen an das Ende der formatierten Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn das eingegebene Zeichen erfolgreich hinzugefügt wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29> Methode fügt die `input` Zeichenwert an die erste verfügbare Position in der formatierten Zeichenfolge nach der Position, die zuletzt zugewiesen wurde, der dargestellt wird, indem Sie die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Eigenschaft. Diese Methode wird für keines der folgenden Gründe fehlschlagen:  
  
-   Der Eingabewert `input`, ist nicht gedruckt werden, oder es stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
-   Es gibt keine verfügbaren Bearbeitungspositionen in der formatierten Zeichenfolge, oder es gibt keine verfügbaren Bearbeitungspositionen, nachdem die letzte Position zugewiesen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.String" /> mit Zeichenwerten, die formatierte Zeichenfolge angefügt werden soll.</param>
        <summary>Fügt die Zeichen in der angegebenen Eingabezeichenfolge am Ende der formatierten Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen aus der Eingabezeichenfolge erfolgreich hinzugefügt wurden. andernfalls <see langword="false" /> um anzugeben, dass keine Zeichen hinzugefügt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29> Methode fügt die Zeichen aus dem `input` Zeichenfolge, die die formatierte Zeichenfolge, beginnend mit dem ersten verfügbaren Position nach <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. Diese Methode wird für keines der folgenden Gründe fehlschlagen:  
  
-   Keines der Zeichen in den Eingabewert `input`, sind nicht gedruckt werden können, oder der Eingabewert entspricht nicht seinem entsprechenden Maskenelement.  
  
-   Es sind nicht genügend verfügbare Bearbeitungspositionen in der formatierten Zeichenfolge nach der letzten Position zugewiesen.  
  
 Wenn diese Methode fehlschlägt, wird keine Ergänzungen erfolgen und der Methodenrückgabe `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Char" /> Wert, der die formatierte Zeichenfolge angefügt werden soll.</param>
        <param name="testPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem der Versuch unternommen wurde, das Zeichen hinzu. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Fügt das angegebene Eingabezeichen an das Ende der formatierten Zeichenfolge und gibt dann die Position und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn das eingegebene Zeichen erfolgreich hinzugefügt wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Methode versucht, das Hinzufügen der `input` Zeichenwert an die erste verfügbare Position in der formatierten Zeichenfolge nach der Position, die zuletzt zugewiesen wurde, der dargestellt wird, indem Sie die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Eigenschaft. Diese Methode schlägt fehl, wenn alle verfügbaren Positionen vor der letzten zugewiesenen Position befinden. Diese Methode wird für keines der folgenden Gründe fehlschlagen:  
  
-   Der Eingabewert `input`, ist nicht gedruckt werden, oder es stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
-   Es gibt keine verfügbaren Bearbeitungspositionen in der formatierten Zeichenfolge, oder es gibt keine verfügbaren Bearbeitungspositionen, nachdem die letzte Position zugewiesen.  
  
 Diese Methode funktioniert genauso wie der überschriebenen Version einer einzelnes <xref:System.Char> Parameter <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29>, außer dass es sich um zusätzliche Informationen ausgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.String" /> mit Zeichenwerten, die formatierte Zeichenfolge angefügt werden soll.</param>
        <param name="testPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem der Versuch unternommen wurde, das Zeichen hinzu. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Fügt die Zeichen in der angegebenen Eingabezeichenfolge am Ende der formatierten Zeichenfolge und gibt dann die Position und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen aus der Eingabezeichenfolge erfolgreich hinzugefügt wurden. andernfalls <see langword="false" /> um anzugeben, dass keine Zeichen hinzugefügt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Methode fügt die Zeichen aus dem `input` Zeichenfolge, die die formatierte Zeichenfolge, beginnend mit dem ersten verfügbaren Position nach <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>. Diese Methode wird für keines der folgenden Gründe fehlschlagen:  
  
-   Keines der Zeichen in den Eingabewert `input`, sind nicht gedruckt werden können, oder der Eingabewert entspricht nicht seinem entsprechenden Maskenelement.  
  
-   Es sind nicht genügend verfügbare Bearbeitungspositionen in der formatierten Zeichenfolge nach der letzten Position zugewiesen.  
  
 Wenn diese Methode fehlschlägt, wird keine Ergänzungen erfolgen und der Methodenrückgabe `false`.  
  
 Diese Methode funktioniert genauso wie der überschriebenen Version einer einzelnes <xref:System.String> Parameter <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29>, außer dass es sich um zusätzliche Informationen ausgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPromptAsInput">
      <MemberSignature Language="C#" Value="public bool AllowPromptAsInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPromptAsInput" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Eingabeaufforderungszeichen oder nicht als gültiges Eingabezeichen behandelt werden sollen.</summary>
        <value>
          <see langword="true" />Wenn der Benutzer eingeben kann <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" /> in das Steuerelement; anderenfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> den Wert der Eigenschaft wird festgelegt, der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor.  
  
 Selbst wenn <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> ist `true`, Eingabeaufforderungszeichen muss für die aktuelle Position in der Maske gültig sein, um akzeptiert zu werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsciiOnly">
      <MemberSignature Language="C#" Value="public bool AsciiOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsciiOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Maske Zeichen außerhalb des ASCII-Zeichensatzes akzeptiert.</summary>
        <value>
          <see langword="true" />Wenn nur ASCII akzeptiert wird. <see langword="false" /> Wenn <see cref="T:System.ComponentModel.MaskedTextProvider" /> kann jedes beliebige Unicode-Zeichen akzeptieren. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> den Wert der Eigenschaft wird festgelegt, der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor.  
  
 Wenn `true`, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> Benutzereingabe in eine ASCII-Zeichensatz beschränkt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssignedEditPositionCount">
      <MemberSignature Language="C#" Value="public int AssignedEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AssignedEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der bearbeitbaren Zeichenpositionen, die bereits erfolgreich einen Eingabewert zugewiesen wurden.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl der bearbeitbaren Zeichenpositionen in der input Mask-Eigenschaft, die bereits einen Zeichenwert in der formatierten Zeichenfolge zugewiesen wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtanzahl der bearbeitbaren Zeichenpositionen, dargestellt durch die <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> -Eigenschaft muss die Summe der entsprechen den <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> und die <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AvailableEditPositionCount">
      <MemberSignature Language="C#" Value="public int AvailableEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AvailableEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der bearbeitbaren Zeichenpositionen in der input Mask-Eigenschaft, die nicht noch einen Eingabewert zugewiesen wurden.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl der bearbeitbaren positioniert, das noch einen Zeichenwert zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtanzahl der bearbeitbaren Zeichenpositionen, dargestellt durch die <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> -Eigenschaft muss die Summe der entsprechen den <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> und die <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle bearbeitbaren Eingabezeichen aus der formatierten Zeichenfolge, die durch Eingabeaufforderungszeichen ersetzt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Clear> Methode initialisiert die formatierte Zeichenfolge, die Eingabeaufforderungszeichen in allen bearbeitbaren Positionen eingefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear([out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear(System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Löscht alle bearbeitbaren Eingabezeichen aus der formatierten Zeichenfolge ist, ersetzt diese durch Eingabeaufforderungszeichen, und gibt dann beschreibende Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Clear%28System.ComponentModel.MaskedTextResultHint%40%29> Methode initialisiert die formatierte Zeichenfolge, die Eingabeaufforderungszeichen in allen bearbeitbaren Positionen eingefügt. Funktionen gleichwertig, um die überschriebene Version, die keine Parameter akzeptiert <xref:System.ComponentModel.MaskedTextProvider.Clear>, außer es werden zusätzliche Informationen ausgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie der aktuellen <see cref="T:System.ComponentModel.MaskedTextProvider" />.</summary>
        <returns>Die <see cref="T:System.ComponentModel.MaskedTextProvider" /> Objekt, die diese Methode erstellt, umgewandelt in ein Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Clone%2A> Methode gibt eine neue Kopie des aktuellen <xref:System.ComponentModel.MaskedTextProvider>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kultur, die den Wert der lokalisierbaren Trennzeichen und Platzhalter in der Eingabemaske bestimmt.</summary>
        <value>Ein <see cref="T:System.Globalization.CultureInfo" /> , enthält die Informationen zur Kultur input Mask-Eigenschaft zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Culture%2A> Eigenschaft wird festgelegt, der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPasswordChar">
      <MemberSignature Language="C#" Value="public static char DefaultPasswordChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char DefaultPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßige Kennwort Zeichen verwendet kryptische Benutzereingabe ab.</summary>
        <value>Ein <see cref="T:System.Char" /> , die das standardmäßige Kennwortzeichen darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> Eigenschaft wird definiert, der <xref:System.ComponentModel.MaskedTextProvider> Klasse, um das Sternchenzeichen (*) werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditPositionCount">
      <MemberSignature Language="C#" Value="public int EditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der bearbeitbaren Positionen in der formatierten Zeichenfolge ab.</summary>
        <value>Eine <see cref="T:System.Int32" /> , die die Anzahl der bearbeitbaren Positionen in der formatierten Zeichenfolge enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtanzahl der bearbeitbaren Zeichenpositionen, dargestellt durch die <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> -Eigenschaft muss gleich die Summe der der <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> und <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> Eigenschaften. Dieser Wert schließt die erforderlichen und optionalen bearbeitbaren Zeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditPositions">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator EditPositions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator EditPositions" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen neu erstellten Enumerator für die bearbeitbaren Positionen in der formatierten Zeichenfolge ab.</summary>
        <value>Ein <see cref="T:System.Collections.IEnumerator" /> unterstützt, die Enumeration, über die bearbeitbaren Positionen in der formatierten Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei jedem Zugriff auf die <xref:System.ComponentModel.MaskedTextProvider.EditPositions%2A> Eigenschaft eine temporäre Sammlung der bearbeitbaren Positionen wird erstellt, die die abgerufenen <xref:System.Collections.IEnumerator> arbeitet.  
  
 Die Auflistung ist schreibgeschützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge mit der Suche begonnen werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position des ersten zugewiesenen bearbeitbaren Position nach der angegebenen Position mit dem angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> bearbeitbaren Position gefunden; zugewiesen, die die nullbasierte Position des ersten darstellt andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literale kopiert, aus der Maske. Die bearbeitbaren Zeichenpositionen werden entweder belegt sein, durch die Eingabeaufforderungszeichen aus der Maske, wenn sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen kopiert, wenn sie eine Eingabe zugewiesen wurden.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> Methode wird verwendet, um nach einer angegebenen Position und suchen Sie die Richtung für das erste Zeichen des zugewiesenen zu suchen. Das Ergebnis kann anschließend übergeben werden, als Parameter an die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer, um den zugewiesenen Wert an dieser Position abzurufen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> und <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> Methoden zur Ergänzung dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beendet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position des ersten bearbeitbaren Position zwischen den angegebenen Positionen, die mit der angegebenen suchrichtung zugewiesen.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> bearbeitbaren Position gefunden; zugewiesen, die die nullbasierte Position des ersten darstellt andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literale kopiert, aus der Maske. Die bearbeitbaren Zeichenpositionen werden entweder belegt sein, durch die Eingabeaufforderungszeichen aus der Maske, wenn sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen kopiert, wenn sie eine Eingabe zugewiesen wurden.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> Methode wird verwendet, um nach dem ersten zugewiesenen Zeichen zwischen zwei angegebenen Positionen liegen, verwenden die angegebene suchrichtung suchen. Das Ergebnis kann anschließend übergeben werden, als Parameter an die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer, um den zugewiesenen Wert an dieser Position abzurufen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> und <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> Methoden zur Ergänzung dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge mit der Suche begonnen werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position des ersten bearbeitbaren Position nach der angegebenen Position mit dem angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> darstellt die nullbasierte Position des ersten bearbeitbaren Position gefunden; andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Methode wird verwendet, um die Suche nach der nächsten zugewiesenen oder nicht bearbeitbaren Position in der formatierten Zeichenfolge nach der angegebenen Position zugewiesenen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Methode ist das Gegenstück dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beendet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position des ersten bearbeitbaren Position zwischen den angegebenen Positionen, die mit der angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> darstellt die nullbasierte Position des ersten bearbeitbaren Position gefunden; andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Methode wird verwendet, um nach dem ersten bearbeitbaren Zeichen zwischen zwei angegebenen Positionen liegen, verwenden die angegebene suchrichtung suchen. Das Ergebnis kann anschließend übergeben werden, als Parameter an die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer, um den zugewiesenen Wert an dieser Position abzurufen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Methode ist das Gegenstück dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge mit der Suche begonnen werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten nicht bearbeitbaren Position nach der angegebenen Position mit dem angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> darstellt die nullbasierte Position der ersten literal Position gefunden; andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> Methode wird verwendet, um nach dem nächsten Literalzeichen in die formatierte Zeichenfolge nach der angegebenen Position gesucht. Das Ergebnis kann anschließend übergeben werden, als Parameter an die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer, um den literalen Wert an dieser Position abzurufen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> Methode ist das Gegenstück dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beendet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten nicht bearbeitbaren Position zwischen den angegebenen Positionen, die mit der angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> darstellt die nullbasierte Position der ersten literal Position gefunden; andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> Methode ist für die Suche nach dem ersten Literalzeichen zwischen zwei angegebenen Positionen liegen, verwenden die angegebene suchrichtung verwendet. Das Ergebnis kann anschließend übergeben werden, als Parameter an die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer, um den literalen Wert an dieser Position abzurufen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> Methode ist das Gegenstück dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge mit der Suche begonnen werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position des ersten nicht zugewiesenen bearbeitbaren Position nach der angegebenen Position mit dem angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> darstellt die nullbasierte Position der ersten nicht zugewiesenen bearbeitbaren Position, der aufgetreten ist; andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literale kopiert, aus der Maske. Die bearbeitbaren Zeichenpositionen werden entweder belegt sein, durch die Eingabeaufforderungszeichen aus der Maske, wenn sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen kopiert, wenn sie eine Eingabe zugewiesen wurden.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> Methode wird verwendet, um nach einer angegebenen Position und suchen Sie die Richtung für das erste nicht zugewiesene Zeichen suchen. Die Eingabeaufforderungszeichen sollte diese Position belegen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> und <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> Methoden zur Ergänzung dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Suche beendet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" /> , der angibt, der Suche Richtung; entweder <see langword="true" /> um vorwärts zu suchen oder <see langword="false" /> um rückwärts zu suchen.</param>
        <summary>Gibt die Position des ersten nicht zugewiesenen bearbeitbaren Position zwischen den angegebenen Positionen, die mit der angegebenen suchrichtung zurück.</summary>
        <returns>Bei Erfolg ein <see cref="T:System.Int32" /> darstellt die nullbasierte Position der ersten nicht zugewiesenen bearbeitbaren Position, der aufgetreten ist; andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literale kopiert, aus der Maske. Die bearbeitbaren Zeichenpositionen werden entweder belegt sein, durch die Eingabeaufforderungszeichen aus der Maske, wenn sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen kopiert, wenn sie eine Eingabe zugewiesen wurden.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> Methode wird verwendet, um das erste nicht zugewiesene Zeichen zwischen zwei angegebenen Positionen liegen, verwenden die angegebene suchrichtung suchen. Die Eingabeaufforderungszeichen sollte diese Position belegen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> und <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> Methoden zur Ergänzung dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOperationResultFromHint">
      <MemberSignature Language="C#" Value="public static bool GetOperationResultFromHint (System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetOperationResultFromHint(valuetype System.ComponentModel.MaskedTextResultHint hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint(System.ComponentModel.MaskedTextResultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" />
      </Parameters>
      <Docs>
        <param name="hint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> in der Regel als Output-Parameter von einem früheren Vorgang abgerufenen Wert.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.ComponentModel.MaskedTextResultHint" /> Erfolg oder Fehler kennzeichnet.</summary>
        <returns>
          <see langword="true" />Wenn das angegebene <see cref="T:System.ComponentModel.MaskedTextResultHint" /> Wert darstellt, Erfolg, andernfalls <see langword="false" /> , wenn diese Fehler darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden Methoden der <xref:System.ComponentModel.MaskedTextProvider> Klasse enthalten einen Parameter vom Typ <xref:System.ComponentModel.MaskedTextResultHint> dient außerdem zur Ausgabe von Informationen über den Vorgang der Methode: <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Clear%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>, <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> , <xref:System.ComponentModel.MaskedTextProvider.Set%2A>, <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A>, und <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A>. Die <xref:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint%2A> Methode interpretiert diesen Wert und gibt einen booleschen Wert, der angibt, ob die <xref:System.ComponentModel.MaskedTextResultHint> angezeigt wird, dass der Vorgang eine erfolgreich oder fehlerhaft war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeLiterals">
      <MemberSignature Language="C#" Value="public bool IncludeLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob in der Eingabemaske Literalzeichen in die formatierte Zeichenfolge aufgenommen werden sollen.</summary>
        <value>
          <see langword="true" />Wenn Sie Literale enthalten sind; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften werden bestimmt, ob Aufforderungszeichen und Literalzeichen angezeigt, beim Aufrufen werden der <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode. Durch Festlegen von diesen beiden Eigenschaften auf `false`, die analysierte Zeichenfolge nur die vom Benutzer eingegebenen Zeichen dar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludePrompt">
      <MemberSignature Language="C#" Value="public bool IncludePrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludePrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob <see cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" /> wird verwendet, um das Nichtvorhandensein von Benutzereingaben, die die formatierte Zeichenfolge angezeigt.</summary>
        <value>
          <see langword="true" />Wenn die Eingabeaufforderungszeichen verwendet wird, um die Positionen darstellen, bei denen keine Benutzereingaben angegeben wurde; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften werden bestimmt, ob Aufforderungszeichen und Literalzeichen angezeigt, beim Aufrufen werden der <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode. Durch Festlegen von diesen beiden Eigenschaften auf `false`, die analysierte Zeichenfolge nur die vom Benutzer eingegebenen Zeichen dar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.Char" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge das Zeichen eingefügt werden soll.</param>
        <summary>Fügt das angegebene Zeichen an der angegebenen Position in der formatierten Zeichenfolge ein.</summary>
        <returns>
          <see langword="true" />Wenn die Einfügung erfolgreich war; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Methode fügt ein Zeichen in der ersten Bearbeitungsposition erreicht oder überschritten, angegeben durch die `pos` Parameter. Diese Methode verschiebt alle vorhandene Zeichen hinter der Einfügemarke veranlasst eine Position, um Platz für die eingefügten `input` Zeichen. Wenn einer der folgenden Fehler tritt auf, und die Einfügemarke nicht ausgeführt wird. der Methodenrückgabe `false`.  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Ein bearbeitbare Zeichen wurde nicht gefunden, in der formatierten Zeichenfolge erreicht oder überschritten der angegebenen Position `pos`.  
  
-   Das Einfügezeichen `input`, ist nicht gültiges Eingabezeichen, da es nicht druckbaren oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
-   Es sind keine verfügbaren Positionen rechts neben der Einfügemarke, damit vorhandene Zeichen können nicht verschoben werden.  
  
-   Verschieben der vorhandenen Zeichen würde zu eine Verletzung der Maske führen.  
  
 Ein leeres `input` Zeichenfolge bewirkt keine Änderung in der formatierten Zeichenfolge, aber zurück `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.String" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge zum Einfügen der Eingabezeichenfolge.</param>
        <summary>Fügt die angegebene Zeichenfolge an einer angegebenen Position in der formatierten Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn die Einfügung erfolgreich war; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Methode fügt jedes Zeichen aus der `input` Zeichenfolge in den Bearbeitungspositionen befindet sich an Position `pos` und darüber hinaus. Diese Methode verschiebt alle vorhandene Zeichen nach die Einfügemarke veranlasst eine Position für die einzelnen Zeichen eingefügt. Wenn einer der folgenden Fehler auftritt, keine Einfügung erfolgt und die Methode gibt `false`.  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Nicht genügend bearbeitbare Zeichen vorhanden sind, in die formatierte Zeichenfolge an oder hinter der angegebenen Position `pos`, um alle Zeichen aus Einfügen der `input` Zeichenfolge.  
  
-   Eine oder mehrere der Einfügezeichen sind nicht gültiges Eingabezeichen, denn sie nicht gedruckt werden können sind oder deren entsprechende Maskenelement stimmen nicht überein.  
  
-   Es sind nicht genügend verfügbare Positionen rechts neben der Einfügemarke, damit vorhandene Zeichen können nicht verschoben werden.  
  
-   Verschieben der vorhandenen Zeichen würde zu eine Verletzung der Maske führen. Beachten Sie, dass dieses verschieben wird beim Einfügen der einzelnen Zeichen erfolgt.  
  
 Ein leeres `input` Zeichenfolge bewirkt keine Änderung in der formatierten Zeichenfolge, aber zurück `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.Char" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge das Zeichen eingefügt werden soll.</param>
        <param name="testPosition">Wenn die Methode erfolgreich ist, der letzten positionieren, in dem ein Zeichen eingefügt wurde. andernfalls das erste positionieren, wo die Einfügung fehlerhaft war. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Einfügevorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Fügt das angegebene Zeichen an der angegebenen Position innerhalb der formatierten Zeichenfolge zurückgeben, die letzte Position der Einfügemarke und den Status des Vorgangs an.</summary>
        <returns>
          <see langword="true" />Wenn die Einfügung erfolgreich war; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Methode fügt ein Zeichen in der ersten Bearbeitungsposition erreicht oder überschritten, angegeben durch die `pos` Parameter. Diese Methode verschiebt alle vorhandene Zeichen hinter der Einfügemarke veranlasst eine Position, um Platz für die eingefügten `input` Zeichen. Wenn einer der folgenden Fehler tritt auf, und die Einfügemarke nicht ausgeführt wird. der Methodenrückgabe `false`.  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Ein bearbeitbare Zeichen wurde nicht gefunden, in der formatierten Zeichenfolge erreicht oder überschritten der angegebenen Position `pos`.  
  
-   Das Einfügezeichen `input`, ist nicht gültiges Eingabezeichen, da es nicht druckbaren oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
-   Es sind keine verfügbaren Positionen rechts neben der Einfügemarke, damit vorhandene Zeichen können nicht verschoben werden.  
  
-   Verschieben der vorhandenen Zeichen würde zu eine Verletzung der Maske führen.  
  
 Ein leeres `input` Zeichenfolge bewirkt keine Änderung in der formatierten Zeichenfolge, aber zurück `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.String" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge zum Einfügen der Eingabezeichenfolge.</param>
        <param name="testPosition">Wenn die Methode erfolgreich ist, der letzten positionieren, in dem ein Zeichen eingefügt wurde. andernfalls das erste positionieren, wo die Einfügung fehlerhaft war. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Einfügevorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Fügt die angegebene Zeichenfolge an einer angegebenen Position innerhalb der formatierten Zeichenfolge zurückgeben, die letzte Position der Einfügemarke und den Status des Vorgangs an.</summary>
        <returns>
          <see langword="true" />Wenn die Einfügung erfolgreich war; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> Methode fügt jedes Zeichen aus der `input` Zeichenfolge in den Bearbeitungspositionen befindet sich an Position `pos` und darüber hinaus. Diese Methode verschiebt alle vorhandene Zeichen nach die Einfügemarke veranlasst eine Position für die einzelnen Zeichen eingefügt. Wenn einer der folgenden Fehler auftritt, keine Einfügung erfolgt und die Methode gibt `false`.  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Nicht genügend bearbeitbare Zeichen vorhanden sind, in die formatierte Zeichenfolge an oder hinter der angegebenen Position `pos`, um alle Zeichen aus Einfügen der `input` Zeichenfolge.  
  
-   Eine oder mehrere der Einfügezeichen sind nicht gültiges Eingabezeichen, denn sie nicht gedruckt werden können sind oder deren entsprechende Maskenelement stimmen nicht überein.  
  
-   Es sind nicht genügend verfügbare Positionen rechts neben der Einfügemarke, damit vorhandene Zeichen können nicht verschoben werden.  
  
-   Verschieben der vorhandenen Zeichen würde zu eine Verletzung der Maske führen. Beachten Sie, dass dieses verschieben wird beim Einfügen der einzelnen Zeichen erfolgt.  
  
 Ein leeres `input` Zeichenfolge bewirkt keine Änderung in der formatierten Zeichenfolge, aber zurück `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvalidIndex">
      <MemberSignature Language="C#" Value="public static int InvalidIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 InvalidIndex" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die obere Grenze des Bereichs der ungültigen Indizes ab.</summary>
        <value>Ein Wert, den größten ungültigen Index darstellt, wie durch die Implementierung eines Anbieters bestimmt. Wenn der niedrigste gültige Index 0 ist, gibt diese Eigenschaft beispielsweise-1 zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InvalidIndex%2A> Eigenschaft wird verwendet, um ein Ergebnis darzustellen, die nicht für Indizierungsvorgänge, z. B. die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Methode.  
  
 Wenn Sie den Anbieter oder eigenen Dienst implementieren, sollten Sie diese Eigenschaft verwenden, entscheiden, ob ein Index ungültig, anstatt eine feste Programmierung Kenntnisse über ungültige Werte ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAvailablePosition">
      <MemberSignature Language="C#" Value="public bool IsAvailablePosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAvailablePosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der Maske zu testen.</param>
        <summary>Bestimmt, ob die angegebene Position für die Zuweisung verfügbar ist.</summary>
        <returns>
          <see langword="true" />Wenn die angegebene Position in der formatierten Zeichenfolge bearbeitbar ist und nicht zugewiesen wurden noch, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IsAvailablePosition%2A> -Methode zurückkehrt `true` nur, wenn alle der folgenden Bedingungen erfüllt sind:  
  
-   Die `pos` Parameter innerhalb der Grenzen der formatierten Zeichenfolge ist; der Wert ist größer als oder gleich 0 (null) und kleiner als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Die angegebene Position ist ein bearbeitbares Zeichen.  
  
-   Ein Zeichen wurde an dieser Position nicht bereits zugewiesen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEditPosition">
      <MemberSignature Language="C#" Value="public bool IsEditPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEditPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der Maske zu testen.</param>
        <summary>Bestimmt, ob die angegebene Position bearbeitbar ist.</summary>
        <returns>
          <see langword="true" />Wenn die angegebene Position in der formatierten Zeichenfolge bearbeitbar ist. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IsEditPosition%2A> -Methode zurückkehrt `true` nur, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die `pos` Parameter innerhalb der Grenzen der formatierten Zeichenfolge ist; der Wert ist größer als oder gleich 0 (null) und kleiner als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Die angegebene Position ist ein bearbeitbares Zeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPassword">
      <MemberSignature Language="C#" Value="public bool IsPassword { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPassword" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der bestimmt, ob die formatierte Zeichenfolge Kennwortschutz angewendet werden soll.</summary>
        <value>
          <see langword="true" />Wenn die Eingabezeichenfolge ist als eine Kennwortzeichenfolge behandelt werden soll. andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kennwortschutz kann mithilfe einer der folgenden zwei Arten initiiert werden:  
  
-   Festlegen der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft nicht`null` Wert.  
  
-   Festlegen der <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A> Eigenschaft `true`., wodurch auch die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft, um die <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> Wert.  
  
 <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A>wird verwendet, durch die <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> und <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methoden, um zu bestimmen, ob die tatsächliche Eingabezeichen Offenlegen oder verbergen sie mit <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidInputChar">
      <MemberSignature Language="C#" Value="public static bool IsValidInputChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidInputChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <summary>Bestimmt, ob das angegebene Zeichen ein gültiges Eingabezeichen ist.</summary>
        <returns>
          <see langword="true" />Wenn das angegebene Zeichen einen gültigen Wert für die Eingaben enthält. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Eingabezeichen enthalten alle druckbare Zeichen, die die Buchstaben, Ziffern, Interpunktion, Symbole und das Leerzeichen enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidMaskChar">
      <MemberSignature Language="C#" Value="public static bool IsValidMaskChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidMaskChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <summary>Bestimmt, ob das angegebene Zeichen eine gültige Maskenzeichen ist.</summary>
        <returns>
          <see langword="true" />Wenn das angegebene Zeichen einen gültiger Wert enthält. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Maskenzeichen umfassen alle druckbare Zeichen, die die Buchstaben, Ziffern, Interpunktion, Symbole und das Leerzeichen enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidPasswordChar">
      <MemberSignature Language="C#" Value="public static bool IsValidPasswordChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidPasswordChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <summary>Bestimmt, ob das angegebene Zeichen ein gültiges Kennwort ein Zeichen ist.</summary>
        <returns>
          <see langword="true" />Wenn das angegebene Zeichen einen gültiges Kennwort ein-Wert enthält. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültiges Kennwort ein Zeichen enthalten alle druckbaren Zeichen sowie das Null-Zeichen verwendet wird, um die Kennwort-Funktion deaktivieren. Druckbare Zeichen sind Buchstaben, Ziffern, Interpunktion, Symbole und das Leerzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Ein nullbasierter Index des abzurufenden Elements.</param>
        <summary>Ruft das Element an der angegebenen Position in der formatierten Zeichenfolge ab.</summary>
        <value>Die <see cref="T:System.Char" /> an der angegebenen Position in der formatierten Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Eigenschaft ist der Standardindexer für die <xref:System.ComponentModel.MaskedTextProvider> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" />ist kleiner als 0 (null) oder größer als oder gleich der <see cref="P:System.ComponentModel.MaskedTextProvider.Length" /> der Maske.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastAssignedPosition">
      <MemberSignature Language="C#" Value="public int LastAssignedPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastAssignedPosition" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Index in der Maske des Eingabezeichens, das die Maske zugewiesen wurde.</summary>
        <value>Wenn die Maske mindestens ein Eingabezeichen zugewiesen wurde ein <see cref="T:System.Int32" /> , enthält des Indexes der äußersten rechten Position zugewiesen, wenn keine Position zugewiesen wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> Eigenschaft darstellt, die am weitesten entfernten Bearbeitungsposition in der Maske, relativ zum Ursprung, der eine Eingabezeichen zugewiesen wurde. Für Sprachen Lesen von links nach rechts (LNR), z. B. Englisch ist dies der äußersten rechten Position zugewiesen; Dazu gehören auch die am weitesten links stehende Position für Sprachen, die rechts-nach-links (RTL) zu lesen Daten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge der Maske, lückenlos Maske Modifizierer Zeichen ab.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl von Positionen in der Maske, mit Ausnahme der Zeichen, die Input Mask ändern.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> Eigenschaft darstellt, die Gesamtzahl der Zeichen in der Maske, einschließlich der Zeichen literal und bearbeitet werden. Die Anzahl von Literalzeichen kann bestimmt werden, durch den Wert der Subtraktion der <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> aus der <xref:System.ComponentModel.MaskedTextProvider.Length%2A>.  
  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A>Außerdem wird die Länge der formatierten Zeichenfolge ist, einschließlich Eingabezeichen, Literale und Eingabeaufforderungszeichen beschrieben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mask">
      <MemberSignature Language="C#" Value="public string Mask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Mask" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die input Mask-Eigenschaft ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit der vollständigen Maske.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Eigenschaft wird festgelegt, der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor. Diese Maske darf nur gültige Zeichen, wie von der Maskierungssprache definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaskCompleted">
      <MemberSignature Language="C#" Value="public bool MaskCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskCompleted" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob alle erforderliche Eingaben in die formatierte Zeichenfolge vorgenommen wurden.</summary>
        <value>
          <see langword="true" />Wenn alle erforderlichen Eingaben in die Maske eingegeben wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> Eigenschaft überprüft nur die Eingabe erforderlicher Elemente. Um zu bestimmen, ob alle erforderlichen und optionalen Eingabeelemente eingegeben wurden, verwenden die <xref:System.Windows.Forms.MaskedTextBox.MaskFull%2A?displayProperty=nameWithType> Eigenschaft von der <xref:System.Windows.Forms.MaskedTextBox> stattdessen.  
  
 Der aktuelle Wert der die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Eigenschaft bestimmt, welche Formatierungselemente ausmachen erforderlich sind, und welche sind optional.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaskFull">
      <MemberSignature Language="C#" Value="public bool MaskFull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskFull" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob alle erforderliche und optionale Eingaben in die formatierte Zeichenfolge vorgenommen wurden.</summary>
        <value>
          <see langword="true" />Wenn alle erforderliche und optionale Eingaben vorgenommen wurden; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu überprüfen, ob ausschließlich erforderliche Eingabeelemente eingegeben wurden, verwenden die <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> Eigenschaft stattdessen. Der aktuelle Wert der die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> Eigenschaft bestimmt, welche Formatierungselemente ausmachen erforderlich sind, und welche sind optional.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, die Zeichen für den tatsächlichen Eingabezeichen ersetzt werden muss.</summary>
        <value>Die <see cref="T:System.Char" /> Wert, der als Kennwortzeichen verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für sensible Benutzereingaben ist es gängige Praxis, die tatsächlichen Informationen vom Benutzer eingegeben werden, während der a-Vorgänge zu verbergen. Wenn die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaftensatz nicht`null` Zeichen, z. B. Ausgabemethoden <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> und <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> verdecken die Eingabezeichen mit dem angegebenen Kennwortzeichen. Wenn diese Eigenschaft auf `null` Schutzfunktionalität Kennwort wird deaktiviert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Angegebene Kennwortzeichen beim Festlegen dieser Eigenschaft identisch mit dem aktuellen Aufforderungszeichen ist <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />. Die beiden müssen unterschiedlich sein.</exception>
        <exception cref="T:System.ArgumentException">Das Zeichen angegebene beim Festlegen dieser Eigenschaft ein gültiges Kennwort ein Zeichen ist nicht gemäß der <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="PromptChar">
      <MemberSignature Language="C#" Value="public char PromptChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PromptChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt das Zeichen, das Nichtvorhandensein von Benutzereingaben für alle verfügbaren Bearbeitungspositionen.</summary>
        <value>Das Zeichen, über das der Benutzer zur Eingabe aufgefordert wird. Der Standardwert ist ein Unterstrich (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> Eigenschaft darstellt, die Prompt-Zeichen, das von verwendet wird, die <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> und <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methoden, um den aktuellen Status der formatierte Eingabezeichenfolge darstellen. Ein Eingabeaufforderungszeichen befindet sich im bearbeitbaren Positionen, die nicht noch einen Eingabewert zugewiesen wurden. Einige Versionen von der <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode auch hängen vom Wert von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene Aufforderungszeichen beim Festlegen dieser Eigenschaft mit dem aktuellen Kennwortzeichen identisch ist <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />. Die beiden müssen unterschiedlich sein.</exception>
        <exception cref="T:System.ArgumentException">Das Zeichen angegebene beim Festlegen dieser Eigenschaft ein gültiges Kennwort ein Zeichen ist nicht gemäß der <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" /> Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt das letzte zugewiesene Zeichen aus der formatierten Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich entfernt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> Methode hat keine Auswirkung, wenn keine Zeichen zugewiesen der Maske noch vorhanden sind.  
  
 Wenn das letzte zugewiesene Zeichen aus der formatierten Zeichenfolge entfernt wird, wird die bearbeitbare Maskenzeichen für diese Position, sodass nachfolgende Eingabe zurückgesetzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove([out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove(System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="testPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in denen das Zeichen entfernt wurde. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Entfernt das letzte zugewiesene Zeichen aus der formatierten Zeichenfolge und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich entfernt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> Methode hat keine Auswirkung, wenn keine Zeichen zugewiesen der Maske noch vorhanden sind.  
  
 Wenn das letzte zugewiesene Zeichen aus der formatierten Zeichenfolge entfernt wird, wird die bearbeitbare Maskenzeichen für diese Position, sodass nachfolgende Eingabe zurückgesetzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position des zugewiesenen Zeichens zu entfernen.</param>
        <summary>Entfernt das zugewiesene Zeichen an der angegebenen Position aus der formatierten Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich entfernt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> Methode hat keine Auswirkung, wenn keine zugewiesenen Zeichen an der angegebenen Entfernung Position vorhanden sind. Literalzeichen sind von dieser Methode nicht betroffen.  
  
 Wenn ein Zeichen entfernt wird, werden auf der linken Seite So füllen Sie die Lücke, die durch das Entfernen der verbleibenden höher positioniertes Zeichen in der Maske verschoben. Frei gewordene Positionen werden für die Eingabe zurückgesetzt. Wenn die Bewegung der Zeichen durch die Maskendefinition verhindert wird, keine Entfernung auftritt, und <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> gibt `false`.  
  
 Dieser Methodenaufruf entspricht genau dem folgenden Aufruf der überladenen <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%28System.Int32%2CSystem.Int32%29> Version:  
  
 `RemoveAt(pos, pos);`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Der nullbasierte Index des ersten Zeichens zugewiesenen zu entfernen.</param>
        <param name="endPosition">Der nullbasierte Index des letzten Zeichens zugewiesenen zu entfernen.</param>
        <summary>Entfernt die zugewiesenen Zeichen zwischen den angegebenen Positionen in der formatierten Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich entfernt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> Methode hat keine Auswirkung, wenn keine zugewiesenen Zeichen an der angegebenen Entfernung Positionen vorhanden sind.  
  
 Wenn ein Zeichen entfernt wird, werden auf der linken Seite So füllen Sie die Lücke, die durch das Entfernen der verbleibenden höher positioniertes Zeichen in der Maske verschoben. Frei gewordene Positionen werden für die Eingabe zurückgesetzt. Wenn die Bewegung der Zeichen durch die Maskendefinition verhindert wird, keine Entfernung auftritt, und <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> gibt `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="startPosition">Der nullbasierte Index des ersten Zeichens zugewiesenen zu entfernen.</param>
        <param name="endPosition">Der nullbasierte Index des letzten Zeichens zugewiesenen zu entfernen.</param>
        <param name="testPosition">Im Erfolgsfall die nullbasierte Position in der formatierten Zeichenfolge der, in denen die Zeichen tatsächlich entfernt wurden; andernfalls das erste positionieren, wo der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Entfernt die zugewiesenen Zeichen zwischen den angegebenen Positionen in der formatierten Zeichenfolge und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich entfernt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> Methode hat keine Auswirkung, wenn keine zugewiesenen Zeichen an der angegebenen Entfernung Positionen vorhanden sind.  
  
 Wenn ein Zeichen entfernt wird, werden auf der linken Seite So füllen Sie die Lücke, die durch das Entfernen der verbleibenden höher positioniertes Zeichen in der Maske verschoben. Frei gewordene Positionen werden für die Eingabe zurückgesetzt. Wenn die Bewegung der Zeichen durch die Maskendefinition verhindert wird, keine Entfernung auftritt, und <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> gibt `false`.  
  
 Diese Version von <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> bietet zwei zusätzliche Output-Parameter, um weitere Informationen zum Betrieb der Methode zu vermitteln.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.Char" /> -Wert, der den vorhandenen Wert ersetzt.</param>
        <param name="position">Die nullbasierte Position, suchen Sie nach dem ersten bearbeitbaren Zeichen ersetzt werden soll.</param>
        <summary>Ersetzt ein einzelnes Zeichen an oder hinter der angegebenen Position mit dem Wert des angegebenen Zeichens.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich ersetzt wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%29> Methode sucht nach der ersten bearbeitbaren Position in der formatierten Zeichenfolge erreicht oder überschritten der angegebenen Position `pos`. Wenn eine gefunden wird, wird der Wert der bearbeitbaren Position geändert, auf das angegebene Zeichen `input`. Eine der folgenden Bedingungen führt zu Fehler, der bewirkt, dass kein Ersatz ausgeführt werden und den Wert `false` zurückgegeben werden:  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Ein bearbeitbare Zeichen wurde nicht gefunden, in der formatierten Zeichenfolge erreicht oder überschritten der angegebenen Position `pos`.  
  
-   Das Ersatzzeichen `input`, ist nicht gültiges Eingabezeichen, da es nicht druckbaren oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.String" /> Wert verwendet, um die vorhandenen bearbeitbaren Zeichen zu ersetzen.</param>
        <param name="position">Die nullbasierte Position, suchen Sie nach dem ersten bearbeitbaren Zeichen ersetzt werden soll.</param>
        <summary>Ersetzt einen Bereich von bearbeitbaren Zeichen ab der angegebenen Position mit der angegebenen Zeichenfolge.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen erfolgreich ersetzt wurden. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> Methode sucht nach der ersten bearbeitbaren Position an oder hinter der angegebenen Position `pos`. Betrieb unter der Annahme, dass genügend bearbeitbaren Positionen nach diesem Zeitpunkt vorhanden sind, werden die vorhandenen Zeichenwerte nacheinander ersetzt, mit dem Inhalt des Ersatz-Parameters, `input`.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, erfolgt keine Ersetzung und <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> gibt `false`.  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Es sind nicht genügend bearbeitbaren Positionen in der formatierten Zeichenfolge, die den Inhalt der Ersatzzeichenfolge enthalten.  
  
-   Einer der Werte Zeichen Ersatz ist ungültig, da er nicht druckbaren ist oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.Char" /> -Wert, der den vorhandenen Wert ersetzt.</param>
        <param name="position">Die nullbasierte Position, suchen Sie nach dem ersten bearbeitbaren Zeichen ersetzt werden soll.</param>
        <param name="testPosition">Im Erfolgsfall die nullbasierte Position in der formatierten Zeichenfolge, in denen das letzte Zeichen ersetzt wurde; andernfalls das erste positionieren, wo der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis der Ersetzung kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Ersetzt ein einzelnes Zeichen an oder hinter der angegebenen Position mit dem Zeichenwert der angegebenen und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich ersetzt wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Methode sucht nach der ersten bearbeitbaren Position in der formatierten Zeichenfolge erreicht oder überschritten der angegebenen Position `pos`. Wenn eine gefunden wird, wird der Wert der bearbeitbaren Position geändert, auf das angegebene Zeichen `input`. Eine der folgenden Bedingungen in einen Fehlerzustand, der bewirkt, dass kein Ersatz ausgeführt werden und den Wert führt `false` zurückgegeben werden:  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Ein bearbeitbare Zeichen wurde nicht gefunden, in der formatierten Zeichenfolge erreicht oder überschritten der angegebenen Position `pos`.  
  
-   Das Ersatzzeichen `input`, ist nicht gültiges Eingabezeichen, da es nicht druckbaren oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 Zusätzlich zu den Rückgabewert hat diese Methode zwei Output-Parameter, um zusätzliche Informationen zu den Ersetzungsvorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.String" /> Wert verwendet, um die vorhandenen bearbeitbaren Zeichen zu ersetzen.</param>
        <param name="position">Die nullbasierte Position, suchen Sie nach dem ersten bearbeitbaren Zeichen ersetzt werden soll.</param>
        <param name="testPosition">Im Erfolgsfall die nullbasierte Position in der formatierten Zeichenfolge, in denen das letzte Zeichen ersetzt wurde; andernfalls das erste positionieren, wo der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis der Ersetzung kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Ersetzt einen Bereich von bearbeitbaren Zeichen ab der angegebenen Position mit der angegebenen Zeichenfolge und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen erfolgreich ersetzt wurden. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Methode sucht nach der ersten bearbeitbaren Position an oder hinter der angegebenen Position `pos`. Betriebssystem auf der Annahme, dass genügend bearbeitbaren Positionen nach diesem Zeitpunkt vorhanden sind, werden die vorhandenen Zeichenwerte nacheinander ersetzt, mit dem Inhalt des Ersatz-Parameters, `input`.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, erfolgt keine Ersetzung und <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> gibt `false`.  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist.  
  
-   Es sind nicht genügend bearbeitbaren Positionen in der formatierten Zeichenfolge, die den Inhalt der Ersatzzeichenfolge enthalten.  
  
-   Einer der Werte Zeichen Ersatz ist ungültig, da er nicht druckbaren ist oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 Zusätzlich zu den Rückgabewert hat diese Methode zwei Output-Parameter, um zusätzliche Informationen zu den Ersetzungsvorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.Char" /> -Wert, der den vorhandenen Wert ersetzt.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Ersetzung wird gestartet.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Ersetzung endet.</param>
        <param name="testPosition">Im Erfolgsfall die nullbasierte Position in der formatierten Zeichenfolge, in denen das letzte Zeichen ersetzt wurde; andernfalls das erste positionieren, wo der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis der Ersetzung kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Ersetzt ein einzelnes Zeichen zwischen der angegebenen Anfangs- und Endposition mit der angegebene Zeichenwert ein, und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn das Zeichen erfolgreich ersetzt wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> Methode sucht nach der ersten bearbeitbaren Position in der formatierten Zeichenfolge zwischen dem angegebenen Start- und Endposition. Wenn eine gefunden wird, wird der Wert der bearbeitbaren Position geändert, auf das angegebene Zeichen `input`. Eine der folgenden Bedingungen in einen Fehlerzustand, der bewirkt, dass kein Ersatz ausgeführt werden und den Wert führt `false` zurückgegeben werden:  
  
-   Die `startPos` oder `endPos` Parameter vor dem Start der formatierten Zeichenfolge bzw. hinter dem Ende zeigen.  
  
-   Ein bearbeitbare Zeichen im angegebenen Zeitraum nicht gefunden.  
  
-   Das Ersatzzeichen `input`, ist nicht gültiges Eingabezeichen, da es nicht druckbaren oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 Zusätzlich zu den Rückgabewert hat diese Methode zwei Output-Parameter, um zusätzliche Informationen zu den Ersetzungsvorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.String" /> Wert verwendet, um die vorhandenen bearbeitbaren Zeichen zu ersetzen.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Ersetzung wird gestartet.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, in dem die Ersetzung endet.</param>
        <param name="testPosition">Im Erfolgsfall die nullbasierte Position in der formatierten Zeichenfolge, in denen das letzte Zeichen ersetzt wurde; andernfalls das erste positionieren, wo der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis der Ersetzung kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Ersetzt einen Bereich von bearbeitbaren Zeichen zwischen der angegebenen Anfangs- und Endposition mit der angegebenen Zeichenfolge und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen erfolgreich ersetzt wurden. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> Methode sucht nach der ersten bearbeitbaren Position in der formatierten Zeichenfolge zwischen dem angegebenen Start- und Endposition. Betriebssystem auf der Annahme, dass genügend bearbeitbaren Positionen nach diesem Zeitpunkt vorhanden sind, werden die vorhandenen Zeichenwerte nacheinander ersetzt, mit dem Inhalt des Ersatz-Parameters, `input`.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, erfolgt keine Ersetzung und <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> gibt `false`.  
  
-   Die `startPos` oder `endPos` Parameter vor dem Start der formatierten Zeichenfolge bzw. hinter dem Ende zeigen.  
  
-   Es sind nicht genügend bearbeitbaren Positionen in der formatierten Zeichenfolge, die den Inhalt der Ersatzzeichenfolge enthalten.  
  
-   Einer der Werte Zeichen Ersatz ist ungültig, da er nicht druckbaren ist oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 Zusätzlich zu den Rückgabewert hat diese Methode zwei Output-Parameter, um zusätzliche Informationen zu den Ersetzungsvorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetOnPrompt">
      <MemberSignature Language="C#" Value="public bool ResetOnPrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnPrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, wie ein dem Aufforderungszeichen entsprechendes Eingabezeichen behandelt werden soll, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />Wenn das Eingabeaufforderungszeichen eingegeben haben, als Eingabe führt dazu, die aktuelle bearbeitbare Position in der Maske zurückgesetzt werden sollen dass; andernfalls <see langword="false" /> um anzugeben, dass die Eingabeaufforderungszeichen als normales Eingabezeichen verarbeitet werden. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider>zwei Kategorien von Zeichen, Leerzeichen und Eingabeaufforderungszeichen, können auf besondere Weise behandelt werden. Normalerweise wird jedes Eingabezeichen getestet werden, für die Maske und entweder akzeptiert oder abgelehnt. Unter der Voraussetzung, die <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> Eigenschaft wird auf einen Wert festgelegt, außer `null`, Festlegen der <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> Eigenschaft `true` führt dazu, für die Eingabeaufforderungszeichen besondere Verarbeitung vorgenommen. Wenn ein Aufforderungszeichen hinzugefügt wird, bewirkt, dass die aktuelle Position der Maske Zeichen, deren Wert gelöscht werden und der aktuellen Position bis zum nächsten bearbeitbaren Zeichen erweitert werden.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>hat Vorrang vor den <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Eigenschaft wie in der folgenden Tabelle beschrieben.  
  
|<xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>|<xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>|Resultierendes Verhalten|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|  
|`true`|`true`|Die Eingabeaufforderungszeichen hinzugefügt werden kann, und er bewirkt, dass die aktuelle Maskenposition zurückgesetzt werden sollen. Der Standardwert.|  
|`true`|`false`|Die Eingabeaufforderungszeichen hinzugefügt werden kann, und er bewirkt, dass die aktuelle Maskenposition zurückgesetzt werden sollen.|  
|`false`|`true`|Das Aufforderungszeichen wird als normales Eingabezeichen verarbeitet.|  
|`false`|`false`|Das Eingabeaufforderungszeichen ist ungültig und Methoden, die bei dem Versuch, das Zeichen hinzufügen fehl.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetOnSpace">
      <MemberSignature Language="C#" Value="public bool ResetOnSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnSpace" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, wie ein eingegebenes Leerzeichen zu behandeln ist, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />Wenn die Eingabe eines Leerzeichens führt dazu, dass die aktuelle bearbeitbare Position in der Maske zurückgesetzt werden sollen; andernfalls <see langword="false" /> , um anzugeben, dass es als normales Eingabezeichen verarbeitet werden. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider>zwei Kategorien von Zeichen, Leerzeichen und Eingabeaufforderungszeichen, können auf besondere Weise behandelt werden. Normalerweise wird jedes Eingabezeichen getestet werden, für die Maske und entweder akzeptiert oder abgelehnt. Festlegen der <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> Eigenschaft `true` führt in die aktuelle Zeichenposition für Maske wird gelöscht und die aktuelle Position, die auf das nächste bearbeitbare Zeichen erweitert werden.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A>ist nützlich, wenn Zuweisung von Text mit Ausnahme der Eingabeaufforderung gespeichert wurde, in die Eingabeaufforderung durch ein Leerzeichen ersetzt. Vor dem Wiederherstellen der solch einer Zeichenfolge mit der Einstellung <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> zu `true` die Eingabeaufforderungszeichen an den Positionen, die durch Leerzeichen in der Eingabezeichenfolge belegt wird zurückgesetzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.String" /> Wert verwendet, um die formatierte Zeichenfolge festzulegen.</param>
        <summary>Legt die formatierte Zeichenfolge auf die angegebene Eingabezeichenfolge fest.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen erfolgreich festgelegt wurden. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Methode löscht den vorhandenen Inhalt der formatierten Zeichenfolge und wendet dann die Maske für die `input` Zeichenfolge, die den Inhalt der formatierten Zeichenfolge zu aktualisieren.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, bleibt die formatierte Zeichenfolge unverändert und <xref:System.ComponentModel.MaskedTextProvider.Set%2A> gibt `false`.  
  
-   Es sind nicht genügend bearbeitbaren Positionen in der formatierten Zeichenfolge, die den Inhalt der Ersatzzeichenfolge enthalten.  
  
-   Einer der Werte Zeichen Ersatz ist ungültig, da er nicht druckbaren ist oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die <see cref="T:System.String" /> Wert verwendet, um die formatierte Zeichenfolge festzulegen.</param>
        <param name="testPosition">Im Erfolgsfall die nullbasierte Position in der formatierten Zeichenfolge, in denen das letzte Zeichen tatsächlich festgelegt wurde; andernfalls das erste positionieren, wo der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Festlegungsvorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Legt die formatierte Zeichenfolge auf die angegebene Eingabezeichenfolge und gibt dann die Deinstallation und beschreibende Informationen.</summary>
        <returns>
          <see langword="true" />Wenn alle Zeichen erfolgreich festgelegt wurden. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Methode löscht den vorhandenen Inhalt der formatierten Zeichenfolge und wendet dann die Maske für die `input` Zeichenfolge, die den Inhalt der formatierten Zeichenfolge zu aktualisieren.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, bleibt die formatierte Zeichenfolge unverändert und <xref:System.ComponentModel.MaskedTextProvider.Set%2A> gibt `false`.  
  
-   Es sind nicht genügend bearbeitbaren Positionen in der formatierten Zeichenfolge, die den Inhalt der Ersatzzeichenfolge enthalten.  
  
-   Einer der Werte Zeichen Ersatz ist ungültig, da er nicht druckbaren ist oder stimmt nicht mit seinem entsprechenden Maskenelement überein.  
  
 Diese Version von <xref:System.ComponentModel.MaskedTextProvider.Set%2A> bietet zwei zusätzliche Output-Parameter, um weitere Informationen zum Betrieb der Methode zu vermitteln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLiterals">
      <MemberSignature Language="C#" Value="public bool SkipLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob Literalzeichenpositionen in der Maske mit unterschiedlichen gleichen Werten überschrieben werden können.</summary>
        <value>
          <see langword="true" />Sichern Literale hinzugefügt werden, um zu ermöglichen; andernfalls <see langword="false" /> Literalzeichen überschreiben den Benutzer nicht zu erlauben. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eingabeformate darf Literalzeichen und bearbeitet werden. Wenn versucht wird, eine Eingabezeichen an die Position in einer Maske, die durch einen Literalwert, der Wert des belegten Hinzufügen der <xref:System.Windows.Forms.MaskedTextBox.SkipLiterals%2A> -Eigenschaft bestimmt das Ergebnis.  
  
-   Wenn diese Eigenschaft ist `true`, es ist zulässig, ein Literal mit dem gleichen Wert zu überschreiben, wenn Eingabezeichen hinzufügen. Angenommen, ein Schrägstrichzeichen, `'/'`, konnte der dritten Position der Maske hinzugefügt werden `"00/00/000"`.  
  
-   Wenn diese Eigenschaft ist `false`, es ist nicht zulässig, eine Maskenposition von Literalzeichen belegt ausnahmslos zuweisen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDisplayString">
      <MemberSignature Language="C#" Value="public string ToDisplayString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToDisplayString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Die formatierte Zeichenfolge zurückgegeben in einem anzeigbaren Format.</summary>
        <returns>Der formatierte <see cref="T:System.String" /> , fordert und Maske Literale enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> Methode umfasst immer Aufforderungszeichen und Literalzeichen im Rückgabewert, unabhängig vom Wert für die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> oder <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften. Diese Methode wird immer Kennwortzeichen angezeigt, wenn die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> ist-Eigenschaftensatz auf einen Zeichenwert außer `null`.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A>wird häufig verwendet, um die Zeichenfolge in der zugehörigen Elemente einer Benutzeroberfläche angezeigt, wie z. B. erhalten <xref:System.Windows.Forms.MaskedTextBox>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die formatierte Zeichenfolge, die alle Werte für das zugewiesene Zeichen enthält.</summary>
        <returns>Der formatierte <see cref="T:System.String" /> , die alle zugewiesenen Zeichenwerte umfasst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw.. Es gibt stets den ursprünglichen Eingabezeichen ignoriert den Wert der die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft.  
  
> [!IMPORTANT]
>  Da diese Methode Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte er mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" />um die tatsächliche bearbeitbaren Zeichen zurückgegeben. andernfalls <see langword="false" /> gibt an, dass die <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> Eigenschaft ist mit Sicherheit berücksichtigt werden.</param>
        <summary>Die formatierte Zeichenfolge, optional einschließlich Kennwortzeichen zurückgegeben.</summary>
        <returns>Der formatierte <see cref="T:System.String" /> , Literale, fordert und optional Kennwortzeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw.. Wenn die `ignorePasswordChar` Parameter ist `true`, die ursprünglichen Eingabezeichen ignoriert den Wert der wird zurückgegeben, die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft. Wenn dieser Parameter ist `false`, wird bearbeitet werden Benutzereingaben beeinträchtigen, wenn die Kennwortzeichen verwendet die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft wird auf einen Wert festgelegt, außer `null`.  
  
> [!IMPORTANT]
>  Da diese Methode möglicherweise Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte es mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrompt">
          <see langword="true" />Die zurückgegebene Zeichenfolge Eingabeaufforderungszeichen einschließt; andernfalls <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" />Die zurückgegebene Zeichenfolge Literalzeichen einschließt; andernfalls <see langword="false" />.</param>
        <summary>Gibt die formatierte Zeichenfolge, optional einschließlich Aufforderungszeichen und Literalzeichen zurück.</summary>
        <returns>Der formatierte <see cref="T:System.String" /> , umfasst alle das zugewiesene Zeichen und schließt optional die Literale und aufgefordert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode enthält, fordert und Literale nach den Werten der der `IncludePrompt` und `IncludeLiterals` Parameter bzw.. Beachten Sie, dass diese Parameter die Werte der überschreiben die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften. Diese Methode gibt stets den ursprünglichen Eingabezeichen ignoriert den Wert der die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft.  
  
> [!IMPORTANT]
>  Da diese Methode Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte er mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, darunter die zugewiesenen Zeichenwerte andernfalls die <see cref="F:System.String.Empty" /> Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, ab der Position `startPos` und die nachfolgenden Anzahl von angegebenen Zeichen, einschließlich der `length` Parameter. Die zurückgegebene Zeichenfolge enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw.. Die zurückgegebene Zeichenfolge enthält die ursprünglichen Eingabezeichen; die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft wird immer ignoriert.  
  
> [!IMPORTANT]
>  Da diese Methode Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte er mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn in den Eingabeparametern Diskrepanzen vorliegen:  
  
-   Wenn `startPos` ist kleiner als 0 (null), die Startposition 0 (null) festgelegt ist.  
  
-   Wenn `startPos` ist größer als oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer ist als die verbleibende Anzahl von Zeichen, die letzten die Startposition, nur die verbleibenden Zeichen zurückgegeben werden.  
  
-   Wenn `length` kleiner oder gleich 0 (null), wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" />um die tatsächliche bearbeitbaren Zeichen zurückgegeben. andernfalls <see langword="false" /> gibt an, dass die <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> Eigenschaft ist mit Sicherheit berücksichtigt werden.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, optional einschließlich Kennwortzeichen zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, darunter Literale, fordert und optional Kennwortzeichen; andernfalls die <see cref="F:System.String.Empty" /> Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, ab der Position `startPos` und die nachfolgenden Anzahl von angegebenen Zeichen, einschließlich der `length` Parameter. Die zurückgegebene Zeichenfolge enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw.. Wenn die `ignorePasswordChar` Parameter ist `true`, die ursprünglichen Eingabezeichen ignoriert den Wert der wird zurückgegeben, die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft. Wenn dieser Parameter ist `false`, wird bearbeitet werden Benutzereingaben beeinträchtigen, wenn die Kennwortzeichen verwendet die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft wird auf einen Wert festgelegt, außer `null`.  
  
> [!IMPORTANT]
>  Da diese Methode möglicherweise Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte es mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn in den Eingabeparametern Diskrepanzen vorliegen:  
  
-   Wenn `startPos` ist kleiner als 0 (null), die Startposition 0 (null) festgelegt ist.  
  
-   Wenn `startPos` ist größer als oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer ist als die verbleibende Anzahl von Zeichen, die letzten die Startposition, nur die verbleibenden Zeichen zurückgegeben werden.  
  
-   Wenn `length` kleiner oder gleich 0 (null), wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="includePrompt">
          <see langword="true" />Die zurückgegebene Zeichenfolge Eingabeaufforderungszeichen einschließt; andernfalls <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" />Die zurückgegebene Zeichenfolge Literalzeichen einschließt; andernfalls <see langword="false" />.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, optional einschließlich Aufforderungszeichen und Literalzeichen.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, darunter alle das zugewiesene Zeichen und schließt optional die Literale und fordert; andernfalls die <see cref="F:System.String.Empty" /> Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, ab der Position `startPos` und die nachfolgenden Anzahl von angegebenen Zeichen, einschließlich der `length` Parameter. Die zurückgegebene Zeichenfolge enthält, fordert und Literale nach den Werten der der `IncludePrompt` und `IncludeLiterals` Parameter bzw.. Beachten Sie, dass diese Parameter die Werte der überschreiben die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften. Diese Methode gibt stets den ursprünglichen Eingabezeichen ignoriert den Wert der die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft.  
  
> [!IMPORTANT]
>  Da diese Methode Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte er mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn in den Eingabeparametern Diskrepanzen vorliegen:  
  
-   Wenn `startPos` ist kleiner als 0 (null), die Startposition 0 (null) festgelegt ist.  
  
-   Wenn `startPos` ist größer als oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer ist als die verbleibende Anzahl von Zeichen, die letzten die Startposition, nur die verbleibenden Zeichen zurückgegeben werden.  
  
-   Wenn `length` kleiner oder gleich 0 (null), wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar">
          <see langword="true" />um die tatsächliche bearbeitbaren Zeichen zurückgegeben. andernfalls <see langword="false" /> gibt an, dass die <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" /> Eigenschaft ist mit Sicherheit berücksichtigt werden.</param>
        <param name="includePrompt">
          <see langword="true" />Die zurückgegebene Zeichenfolge Eingabeaufforderungszeichen einschließt; andernfalls <see langword="false" />.</param>
        <param name="includeLiterals">
          <see langword="true" />um Literalzeichen in die zurückgegebene Zeichenfolge zurückgegeben. andernfalls <see langword="false" />.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, optional einschließlich der Aufforderung, Literal-und das Kennwort zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, darunter alle das zugewiesene Zeichen und schließt optional die Literale, fordert und Kennwortzeichen; andernfalls die <see cref="F:System.String.Empty" /> Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teilzeichenfolge der formatierten Zeichenfolge ist, ab der Position `startPos` und die nachfolgenden Anzahl von angegebenen Zeichen, einschließlich der `length` Parameter. Die zurückgegebene Zeichenfolge enthält, fordert und Literale nach den Werten der der `IncludePrompt` und `IncludeLiterals` Parameter bzw.. Beachten Sie, dass diese Parameter die Werte der überschreiben die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften. Wenn die `ignorePasswordChar` Parameter ist `true`, die ursprünglichen Eingabezeichen ignoriert den Wert der wird zurückgegeben, die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft. Wenn dieser Parameter ist `false`, wird bearbeitet werden Benutzereingaben beeinträchtigen, wenn die Kennwortzeichen verwendet die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft wird auf einen Wert festgelegt, außer `null`.  
  
> [!IMPORTANT]
>  Da diese Methode möglicherweise Informationen angezeigt, die in der Regel in der Benutzeroberfläche von Kennwortzeichen geschützt ist wird, sollte es mit äußerster Vorsicht verwendet werden, um zu vermeiden, versehentlich vertrauliche Daten offenzulegen.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn in den Eingabeparametern Diskrepanzen vorliegen:  
  
-   Wenn `startPos` ist kleiner als 0 (null), die Startposition 0 (null) festgelegt ist.  
  
-   Wenn `startPos` ist größer als oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer ist als die verbleibende Anzahl von Zeichen, die letzten die Startposition, nur die verbleibenden Zeichen zurückgegeben werden.  
  
-   Wenn `length` kleiner oder gleich 0 (null), wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyChar">
      <MemberSignature Language="C#" Value="public bool VerifyChar (char input, int position, out System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyChar(char input, int32 position, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <param name="position">Die Position in der Maske So testen Sie das eingegebene Zeichen vor.</param>
        <param name="hint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Testet, ob das angegebene Zeichen erfolgreich an der angegebenen Position festgelegt werden konnte.</summary>
        <returns>
          <see langword="true" />Wenn der angegebene Zeichenwert für die angegebene Position gültig ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A> Methode überprüft, ob ein einzelnes Zeichenwert eine gültige Eingabe an der angegebenen Position in der formatierten Zeichenfolge darstellt. Von dieser Methode zurückgegeben `false` folgende Gründe vorliegen:  
  
-   Die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> von der <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>.  
  
-   Das Zeichen `input` ist kein gültiges Eingabezeichen, als durch die <xref:System.ComponentModel.MaskedTextProvider.IsValidInputChar%2A> Methode.  
  
-   Die `input` ist nicht kompatibel mit der Maskenelement an der angegebenen Position `pos`.  
  
 Die letzte Bedingung kann der aktuelle Wert der hängen die <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>, <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> und <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> Eigenschaften.  
  
 Um eine gesamte Eingabezeichenfolge gegen die Maske zu testen, verwenden Sie eines der <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Methoden stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyEscapeChar">
      <MemberSignature Language="C#" Value="public bool VerifyEscapeChar (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyEscapeChar(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <param name="position">Die Position in der Maske So testen Sie das eingegebene Zeichen vor.</param>
        <summary>Testet, ob das angegebene Zeichen an der angegebenen Position mit Escapezeichen versehen werden würde.</summary>
        <returns>
          <see langword="true" />Wenn das angegebene Zeichen an der angegebenen Position mit Escapezeichen versehen werden würde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Zeichen gilt als *mit Escapezeichen versehen* gültige Eingabe ist, jedoch nicht an dieser Position in der formatierten Zeichenfolge zugewiesen ist. Escapezeichen werden in den folgenden drei Kategorien eingeteilt:  
  
-   Eingabeaufforderungszeichen werden mit Escapezeichen versehen, wenn die <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Eigenschaft ist `true`.  
  
-   Eingabezeichen werden mit Escapezeichen versehen, wenn sie den gleichen Wert wie das Literal in der Maske aufweisen, und wenn die <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> Eigenschaft ist `true`.  
  
-   Leerzeichen werden mit Escapezeichen versehen, wenn die <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> Eigenschaft ist `true`.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar%2A> Methode gibt auch zurück `false` Wenn die `pos` -Parameter ist kleiner als 0 (null) oder größer als die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> von der <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.String" />-Wert.</param>
        <summary>Testet, ob die angegebene Zeichenfolge erfolgreich festgelegt werden konnte.</summary>
        <returns>
          <see langword="true" />Wenn die angegebene Zeichenfolge eine gültige Eingabe ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> gilt die `input` Zeichenfolge gegen die Maske, ohne tatsächlich ändern die formatierte Zeichenfolge, um zu testen, ob `input` in ein entsprechendes gültig wäre <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Vorgang. Diese Methode gibt auch zurück `true` ist Eingabe `null` oder hat die Länge Null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.String" />-Wert.</param>
        <param name="testPosition">Bei Erfolg wird die nullbasierte Position des letzten Zeichens tatsächlich getestet. andernfalls das erste positionieren, wo der Test fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" /> , die das Ergebnis des Vorgangs Test kurz beschrieben. Ein Ausgabeparameter.</param>
        <summary>Testet, ob die angegebene Zeichenfolge erfolgreich festgelegt werden konnte, und gibt dann die Position und beschreibende Informationen an.</summary>
        <returns>
          <see langword="true" />Wenn die angegebene Zeichenfolge eine gültige Eingabe ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> gilt die `input` Zeichenfolge gegen die Maske, ohne tatsächlich ändern die formatierte Zeichenfolge, um zu testen, ob `input` in ein entsprechendes gültig wäre <xref:System.ComponentModel.MaskedTextProvider.Set%2A> Vorgang. Diese Methode gibt auch zurück `true` ist Eingabe `null` oder hat die Länge Null.  
  
 Diese Version von <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> bietet zwei zusätzliche Output-Parameter, um weitere Informationen zum Betrieb der Methode zu vermitteln.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
