<Type Name="DbExpressionBuilder" FullName="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder">
  <TypeSignature Language="C#" Value="public static class DbExpressionBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DbExpressionBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine API bereit, um <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s zu erstellen, und lässt zu, dass auf diese API als Erweiterungsmethoden für den Ausdruckstyp selbst zugegriffen werden kann.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Die Funktion, die den gesamte Vorgang definiert.</param>
        <param name="argument">Das Argument für das die aggregate-Funktion berechnet werden soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" />.</summary>
        <returns>Eine neue Funktion, die aggregate mit einem Verweis auf die angegebene Funktion und das Argument ist. Die Funktion Aggregat Distinct-Eigenschaft weist den Wert <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" />oder <paramref name="argument" /> null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" />ist keine Aggregatfunktion oder hat mehr als ein Argument, oder der Ergebnistyp des <paramref name="argument" /> ist nicht gleich oder heraufstufbar auf den Parametertyp <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateDistinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Die Funktion, die den gesamte Vorgang definiert.</param>
        <param name="argument">Das Argument für das die aggregate-Funktion berechnet werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" /> , die auf unterschiedliche Weise angewendet wird.</summary>
        <returns>Eine neue Funktion, die aggregate mit einem Verweis auf die angegebene Funktion und das Argument ist. Die Funktion Aggregat Distinct-Eigenschaft weist den Wert <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> oder <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" />ist keine Aggregatfunktion oder hat mehr als ein Argument, oder der Ergebnistyp des <paramref name="argument" /> ist nicht gleich oder heraufstufbar auf den Parametertyp <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="predicate">Eine Methode, die ein Prädikat für die auszuwertende für jedes Element des Eingabesets darstellt.    Diese Methode muss es sich um einen Ausdruck mit einem booleschen Wert als Ergebnistyp erzeugen, die das Prädikat Logik bereitstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> , der bestimmt, ob das angegebene Prädikat für alle Elemente des Eingabesatzes enthält.</summary>
        <returns>Eine neue DbQuantifierExpression, die die All-Vorgangs darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="predicate" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="Predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Ein Ausdruck, der Bindung, die das Eingabeset angibt.</param>
        <param name="predicate">Ein Ausdruck, der ein Prädikat für die auszuwertende für jedes Element des Eingabesets darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> , der bestimmt, ob das angegebene Prädikat für alle Elemente des Eingabesatzes enthält.</summary>
        <returns>Eine neue DbQuantifierExpression, die die All-Vorgangs darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="predicate" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" />muss ein boolesches Ergebnis nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbAndExpression And (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbAndExpression And(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbAndExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein boolescher Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein boolescher Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbAndExpression" /> , die dem logischen und die linke und rechte Argument ausführt.</summary>
        <returns>Eine neue DbAndExpression mit den angegebenen Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />und <paramref name="right" /> verfügt nicht über einen booleschen Wert als Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Any (this System.Data.Common.CommandTrees.DbExpression source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Any(class System.Data.Common.CommandTrees.DbExpression source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , der bestimmt, ob es sich bei das angegebenen Mengenargument nicht leer ist.</summary>
        <returns>Ein neues <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> angewendet, um ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="predicate">Eine Methode, die das Prädikat, das für jeden Member des Eingabesets ausgewertet darstellt. Diese Methode muss es sich um einen Ausdruck mit einem booleschen Wert als Ergebnistyp erzeugen, die das Prädikat Logik bereitstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> , der bestimmt, ob das angegebene Prädikat für jedes Element des Eingabesatzes enthält.</summary>
        <returns>Eine neue DbQuantifierExpression, die die jeden Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="predicate" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Ein Ausdruck, der Bindung, die das Eingabeset angibt.</param>
        <param name="predicate">Ein Ausdruck, der ein Prädikat für die auszuwertende für jedes Element des Eingabesets darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" /> , der bestimmt, ob das angegebene Prädikat für jedes Element des Eingabesatzes enthält.</summary>
        <returns>Eine neue DbQuantifierExpression, die die jeden Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="predicate" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt; As (this System.Data.Common.CommandTrees.DbAggregate value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt; As(class System.Data.Common.CommandTrees.DbAggregate value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbAggregate,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbAggregate" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert im Schlüssel/Wert-Paar.</param>
        <param name="alias">Der Schlüssel im Schlüssel/Wert-Paar.</param>
        <summary>Gibt die angegebenen Argumente als Schlüssel/Wert-Paar-Objekt zurück.</summary>
        <returns>Ein Schlüssel/Wert-Paar-Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt; As (this System.Data.Common.CommandTrees.DbExpression value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt; As(class System.Data.Common.CommandTrees.DbExpression value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert im Schlüssel/Wert-Paar.</param>
        <param name="alias">Der Schlüssel im Schlüssel/Wert-Paar.</param>
        <summary>Gibt die angegebenen Argumente als Schlüssel/Wert-Paar-Objekt zurück.</summary>
        <returns>Ein Schlüssel/Wert-Paar-Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding Bind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding Bind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Der Ausdruck zum Binden.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , die einen generierten Variablennamen verwendet, um den angegebenen Ausdruck zu binden.</summary>
        <returns>Eine neue ausdrucksbindung mit den angegebenen Ausdruck und einer generierten Variablenname.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />ein Ergebnis Auflistung verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding BindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding BindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der Ausdruck zum Binden.</param>
        <param name="varName">Name der Variablen, die für die Bindung verwendet werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , die der angegebene Variablenname verwendet, um den angegebenen Ausdruck zu binden</summary>
        <returns>Eine neue ausdrucksbindung mit dem angegebenen Ausdruck und der Variablenname.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="varName" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />ein Ergebnis Auflistung verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="Case">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCaseExpression Case (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, System.Data.Common.CommandTrees.DbExpression elseExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCaseExpression Case(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, class System.Data.Common.CommandTrees.DbExpression elseExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCaseExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="whenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="thenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="elseExpression" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="whenExpressions">Eine Liste der Ausdrücke, denen die bedingte für jeden Fall.</param>
        <param name="thenExpressions">Eine Liste von Ausdrücken, die das Ergebnis jeder Fall zu bieten.</param>
        <param name="elseExpression">Ein Ausdruck, der das Ergebnis definiert, wenn keine Groß-/Kleinschreibung verglichen wird.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbCaseExpression" />.</summary>
        <returns>Eine neue DbCaseExpression mit dem angegebenen Fällen und Standardresultsets.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="whenExpressions" />oder <paramref name="thenExpressions" /> ist null oder enthält Null, oder <paramref name="elseExpression" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="whenExpressions" />oder <paramref name="thenExpressions" /> ist leer oder <paramref name="whenExpressions" /> enthält ein Ausdruck mit einem Ergebnistyp für nicht boolesche oder keine gleichen Ergebnistyp vorhanden ist, für alle Ausdrücke in <paramref name="thenExpressions" /> und <paramref name="elseExpression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CastTo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCastExpression CastTo (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage toType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCastExpression CastTo(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage toType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCastExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="toType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Das Argument, auf dem die Umwandlung angewendet werden sollen.</param>
        <param name="toType">Geben Sie die Metadaten, die den Typ für die Umwandlung angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbCastExpression" /> , die für einen Umwandlungsvorgang auf ein polymorphes Argument gilt.</summary>
        <returns>Eine neue "DbCastExpression" mit dem angegebenen Argument und der Ziel-Typ.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> oder <paramref name="toType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die angegebene Umwandlung ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der Konstante Wert darstellen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit dem angegebenen konstanten Wert.</summary>
        <returns>Ein neues DbConstantExpression mit dem angegebenen Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />ist keine Instanz eines gültigen konstantentyps.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (this System.Data.Metadata.Edm.TypeUsage constantType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(class System.Data.Metadata.Edm.TypeUsage constantType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Data.Metadata.Edm.TypeUsage,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constantType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="constantType">Der Typ des konstanten Werts.</param>
        <param name="value">Der Konstante Wert darstellen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> des angegebenen primitiven Typs mit dem angegebenen konstanten Wert.</summary>
        <returns>Ein neues DbConstantExpression mit dem angegebenen Wert und den Ergebnistyp <paramref name="constantType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> oder <paramref name="constantType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />ist keine Instanz eines gültigen konstantentyps <paramref name="constantType" /> einen primitiven Typ ist, stellt keine dar oder <paramref name="value" /> wird von einem anderen primitiven Typ als die dargestellte <paramref name="constantType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge, die in dem das Verweiselement befindet.</param>
        <param name="keyValues">Eine Auflistung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s, die die Schlüsselwerten bereitstellen. Diese Ausdrücke müssen (in Anzahl, Typ und die Reihenfolge) entsprechen den Schlüsseleigenschaften des Entitätstyps verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> , die einen Verweis auf eine bestimmte Entität basierend auf Werten codiert.</summary>
        <returns>Legen Sie einen neuen DbRefExpression, der das Element mit den angegebenen Schlüsselwerten in die angegebene Entität verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> ist NULL, oder <paramref name="keyValues" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="keyValues" /> entspricht nicht der Anzahl der Schlüsselelemente deklariert, indem die <paramref name="entitySet" />des Elementtyps oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Schlüsselelement kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge, die in dem das Verweiselement befindet.</param>
        <param name="keyValues">Eine Auflistung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s, die die Schlüsselwerten bereitstellen. Diese Ausdrücke müssen (in Anzahl, Typ und die Reihenfolge) entsprechen den Schlüsseleigenschaften des Entitätstyps verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> , die einen Verweis auf eine bestimmte Entität basierend auf Werten codiert.</summary>
        <returns>Legen Sie einen neuen DbRefExpression, der das Element mit den angegebenen Schlüsselwerten in die angegebene Entität verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> ist NULL, oder <paramref name="keyValues" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="keyValues" /> entspricht nicht der Anzahl der Schlüsselelemente deklariert, indem die <paramref name="entitySet" />des Elementtyps oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Schlüsselelement kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge, die in dem das Verweiselement befindet.</param>
        <param name="entityType">Der spezifische Typ der Entität, auf die verwiesen wird. Dies muss ein Entitätstyp aus derselben Hierarchie als Elementtyp der Entitätssammlung.</param>
        <param name="keyValues">Eine Auflistung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s, die die Schlüsselwerten bereitstellen. Diese Ausdrücke müssen (in Anzahl, Typ und die Reihenfolge) entsprechen den Schlüsseleigenschaften des Entitätstyps verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> , die einen Verweis auf eine bestimmte Entität eines bestimmten Typs basierend auf Werten codiert.</summary>
        <returns>Legen Sie einen neuen DbRefExpression, der das Element mit den angegebenen Schlüsselwerten in die angegebene Entität verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />oder <paramref name="entityType" /> null ist, oder <paramref name="keyValues" /> ist null oder Null enthält.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="keyValues" /> entspricht nicht der Anzahl der Schlüsselelemente deklariert, indem die <paramref name="entitySet" />des Elementtyps oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Schlüsselelement kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge, die in dem das Verweiselement befindet.</param>
        <param name="entityType">Der spezifische Typ der Entität, auf die verwiesen wird. Dies muss ein Entitätstyp aus derselben Hierarchie als Elementtyp der Entitätssammlung.</param>
        <param name="keyValues">Eine Auflistung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s, die die Schlüsselwerten bereitstellen. Diese Ausdrücke müssen (in Anzahl, Typ und die Reihenfolge) entsprechen den Schlüsseleigenschaften des Entitätstyps verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> , die einen Verweis auf eine bestimmte Entität eines bestimmten Typs basierend auf Werten codiert.</summary>
        <returns>Legen Sie einen neuen DbRefExpression, der das Element mit den angegebenen Schlüsselwerten in die angegebene Entität verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />oder <paramref name="entityType" /> null ist, oder <paramref name="keyValues" /> ist null oder Null enthält.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="keyValues" /> entspricht nicht der Anzahl der Schlüsselelemente deklariert, indem die <paramref name="entitySet" />des Elementtyps oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Schlüsselelement kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die angibt, die Logik für jedes Element des Eingabesets einmal ausgewertet.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> , ergibt die angegebenen <paramref name="apply" /> Ausdruck einmal für jedes Element einer gegebenen Eingabe festgelegt, erzeugen eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten. Zeilen, für die <paramref name="apply" /> auf einen leeren Satz ausgewertet wird, sind nicht enthalten.</summary>
        <returns>Eine neue DbApplyExpression mit dem angegebenen Eingabe- und apply-Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von "CrossApply".</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das Ergebnis des <paramref name="apply" /> enthält einen Namen oder einen Ausdruck, der null ist.</exception>
        <exception cref="T:System.ArgumentException">Das Ergebnis des <paramref name="apply" /> enthält einen Namen oder einen Ausdruck, der in einer ausdrucksbindung ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , die das Eingabeset angibt.</param>
        <param name="apply">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , Logik einmal für jedes Element des Eingabesets ausgewertet angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> , ergibt die angegebenen <paramref name="apply" /> Ausdruck einmal für jedes Element einer gegebenen Eingabe festgelegt, erzeugen eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten. Zeilen, für die <paramref name="apply" /> auf einen leeren Satz ausgewertet wird, sind nicht enthalten.</summary>
        <returns>Eine neue DbApplyExpression mit dem angegebenen Eingabe- und apply-Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von "CrossApply".</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="apply" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpressionBinding})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCrossJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Eine Liste der ausdrucksbindungen, die das Eingabeset angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbCrossJoinExpression" /> bedingungslos verknüpft die Sätze, die von der Liste der Eingabeausdruck Bindungen angegeben.</summary>
        <returns>Eine neue DbCrossJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von CrossJoin, die die bedingungslosen Join der Eingabespalten Mengen darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputs" />ist null oder enthält null Elemente.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputs" />enthält weniger als 2 ausdrucksbindungen an.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deref">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDerefExpression Deref (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDerefExpression Deref(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDerefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die den Verweis enthält. Dieser Ausdruck muss einen Verweis Typ aufweisen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression" /> , die eine bestimmte Entität einen Verweisausdruck abruft.</summary>
        <returns>Eine neue DbDerefExpression, die die angegebene Entität abruft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />ein Ergebnis Verweistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDistinctExpression Distinct (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDistinctExpression Distinct(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDistinctExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der den Satz an eine der distinct-Vorgang über den definiert.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbDistinctExpression" /> entfernt, die Duplikate aus dem angegebenen Mengenargument.</summary>
        <returns>Eine neue DbDistinctExpression, die die distinct-Vorgang auf dem angegebenen Mengenargument angewendet darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Divide (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Divide(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , der das linke Argument durch das rechte Argument dividiert.</summary>
        <returns>Eine neue DbArithmeticExpression, das den Divisionsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen numerischen Ergebnistyp besteht zwischen <paramref name="left" /> oder <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbElementExpression Element (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbElementExpression Element(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbElementExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbElementExpression" /> , der einen Satz in ein Singleton konvertiert.</summary>
        <returns>Eine DbElementExpression, die die Konvertierung des Mengenarguments in ein Singleton darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression Equal (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression Equal(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> , die die linke und rechte Argument für Gleichheit vergleicht.</summary>
        <returns>Eine neue DbComparisonExpression gleichheitsüberprüfung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen auf Gleichheit vergleichbar Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExceptExpression Except (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExceptExpression Except(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExceptExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der zum Definieren der linken Seite Mengenargument.</param>
        <param name="right">Ein Ausdruck, der zum Definieren von rechts Mengenargument.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbExceptExpression" /> die Subtraktion des rechten Mengenarguments aus dem linken Satzargument berechnet.</summary>
        <returns>Neue eines DbExceptExpression darf, das den Unterschied der das linke Argument aus dem rechten Argument darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gemeinsamen Auflistungsergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Exists (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Exists(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , der bestimmt, ob es sich bei das angegebenen Mengenargument nicht leer ist.</summary>
        <returns>Ein neues <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> angewendet, um ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="False">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression False { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression False" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit den booleschen Wert <see langword="false" />.</summary>
        <value>Ein <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit den booleschen Wert <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Filter (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Filter(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Ein Ausdruck, der Bindung, die das Eingabeset angibt.</param>
        <param name="predicate">Ein Ausdruck, der ein Prädikat für die auszuwertende für jedes Element des Eingabesets darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> , filtert die Elemente in der angegebenen Eingabesets mithilfe des angegebenen Prädikats.</summary>
        <returns>Eine neue "DbFilterExpression", der die gefilterte Menge erzeugt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="predicate" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="predicate" />muss ein boolesches Ergebnis nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das linke set-Argument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das rechte set-Argument angibt.</param>
        <param name="joinCondition">Eine Methode, die die Bedingung darstellt, bei der die Verknüpfung stattfinden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Logik der Joinbedingung bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die durch den linken und rechten Ausdruck angegebenen set-Argumente bei der angegebenen Joinbedingung verknüpft und dabei FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet.</summary>
        <returns>Ein neuer DbJoinExpression mit FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />, der den vollständigen äußeren Joinvorgang darstellt, der unter der angegebenen Joinbedingung auf das linke und rechte Eingabeset angewendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , links Mengenargument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , rechts Mengenargument angibt.</param>
        <param name="joinCondition">Ein Ausdruck, der die Bedingung für den join angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> , die von der linken und rechten ausdrucksbindungen, auf die angegebene Join-Bedingung mit FullOuterJoin als angegebenen Mengen verknüpft die <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> der FullOuterJoin, die den vollständigen äußeren Join-Vorgang angewendet wird, auf der linken und rechten Eingabeset unter der angegebenen Join-Bedingung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntityRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbEntityRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Der Ausdruck, der die Entität enthält. Dieser Ausdruck muss einen Entitätsergebnistyp aufweisen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression" /> , der die Ref der angegebenen Entität in der strukturellen Form abruft.</summary>
        <returns>Eine neue DbEntityRefExpression, die einen Verweis auf die angegebene Entität abruft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />Ergebnis Entitätstyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRefKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefKeyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Der Ausdruck, der den Verweis enthält. Dieser Ausdruck muss einen Verweis Typ mit einer Entitätselementtyp aufweisen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression" /> , der die Schlüsselwerte des angegebenen Verweises in der strukturellen Form abruft.</summary>
        <returns>Eine neue DbRefKeyExpression, die die Schlüsselwerte des angegebenen Verweises abruft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />ein Ergebnis Verweistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> , der bestimmt, ob das linke Argument größer als das rechte Argument ist.</summary>
        <returns>Eine neue DbComparisonExpression darstellt, das größer-als-Vergleich.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine Reihenfolge vergleichbar gleichen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> , der bestimmt, ob das linke Argument größer als oder gleich dem rechten Argument ist.</summary>
        <returns>Eine neue DbComparisonExpression, das den größer-als-oder-gleich-Vergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine Reihenfolge vergleichbar gleichen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Der Ausdruck zum Binden.</param>
        <summary>Erstellt eine neue Gruppe ausdrucksbindung, die generierte Variablen- und Gruppenvariablennamen dürfen verwendet werden, um den angegebenen Ausdruck zu binden.</summary>
        <returns>Eine neue Gruppe ausdrucksbindung mit dem angegebenen Ausdruck und einer generierten Variablennamen und gruppenvariablenname.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs(System.Data.Common.CommandTrees.DbExpression,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
        <Parameter Name="groupVarName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der Ausdruck zum Binden.</param>
        <param name="varName">Name der Variablen, die für die Bindung verwendet werden soll.</param>
        <param name="groupVarName">Name der Variablen, die verwendet werden soll, auf die Gruppe verweisen, wenn die neue Gruppe ausdrucksbindung in einer Group by-Ausdruck verwendet wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> , die der angegebene Variablenname und Gruppenvariablennamen dürfen verwendet, um den angegebenen Ausdruck zu binden.</summary>
        <returns>Eine neue Gruppe ausdrucksbindung mit dem angegebenen Ausdruck, Variablennamen und gruppenvariablenname.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="varName" /> oder <paramref name="groupVarName" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="input" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupByExpression GroupBy (this System.Data.Common.CommandTrees.DbGroupExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupByExpression GroupBy(class System.Data.Common.CommandTrees.DbGroupExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy(System.Data.Common.CommandTrees.DbGroupExpressionBinding,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbAggregate}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupByExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbGroupExpressionBinding" RefType="this" />
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
        <Parameter Name="aggregates" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" /> , die das Eingabeset angibt.</param>
        <param name="keys">Eine Liste der Zeichenfolgenausdruck Paare, die das Gruppieren von Spalten zu definieren.</param>
        <param name="aggregates">Eine Liste von Ausdrücken, die Aggregate anzuwendende angeben.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbGroupByExpression" /> , gruppiert die Elemente der Eingabe, die die angegebenen Gruppenschlüssel danach richten, und wendet die angegebenen Aggregate.</summary>
        <returns>Ein neues DbGroupAggregate mit dem angegebenen Eingabesets, Gruppierungsschlüssel und Aggregate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbGroupAggregate kann die Liste der Schlüssel oder die Liste der Aggregate, leer zu sein, aber nicht beides.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="keys" /> oder <paramref name="aggregates" /> ist null, <paramref name="keys" /> enthält eine Spalte null-Schlüssel oder einen Ausdruck, oder <paramref name="aggregates" /> einen fügt die aggregierte Spalte null-Namen oder ein Aggregat enthält.</exception>
        <exception cref="T:System.ArgumentException">Beide <paramref name="keys" /> und <paramref name="aggregates" /> sind leer, oder ein ungültiger oder doppelter Spaltenname angegeben wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das linke set-Argument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das rechte set-Argument angibt.</param>
        <param name="joinCondition">Eine Methode, die die Bedingung darstellt, bei der die Verknüpfung stattfinden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Logik der Joinbedingung bereitstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> , die von der linken und rechten-Ausdrücken, die angegebene Join-Bedingung, wobei InnerJoin als angegebenen Mengen verknüpft die <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von InnerJoin, die der inner Join-Operation angewendet werden, auf der linken und rechten Eingabeset unter der angegebenen Join-Bedingung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , links Mengenargument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , rechts Mengenargument angibt.</param>
        <param name="joinCondition">Ein Ausdruck, der die Bedingung für den join angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> , die von der linken und rechten ausdrucksbindungen, auf die angegebene Join-Bedingung, wobei InnerJoin als angegebenen Mengen verknüpft die <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von InnerJoin, die der inner Join-Operation angewendet werden, auf der linken und rechten Eingabeset unter der angegebenen Join-Bedingung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" />muss ein boolesches Ergebnis nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIntersectExpression Intersect (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIntersectExpression Intersect(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIntersectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der zum Definieren der linken Seite Mengenargument.</param>
        <param name="right">Ein Ausdruck, der zum Definieren von rechts Mengenargument.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbIntersectExpression" /> , berechnet die Schnittmenge des linken und rechten.</summary>
        <returns>Eine neue DbIntersectExpression, die die Schnittmenge der linke und rechte Argument darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gemeinsamen Auflistungsergebnistyp besteht zwischen <paramref name="left" /> oder <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="lambda">Ein <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> Instanz, die die anzuwendende Lambda-Funktion darstellt.</param>
        <param name="arguments">Eine Liste von Ausdrücken, die die Argumente bereitstellen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> , die Anwendung der angegebenen Lambda-Funktion auf den angegebenen Argumenten darstellt.</summary>
        <returns>Eine neue DbLambdaExpression, die die Anwendung der Lambda-Funktion darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> oder <paramref name="arguments" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="arguments" /> entspricht nicht die Anzahl der Variablen deklariert, indem <paramref name="lambda" />, oder <paramref name="arguments" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht zu diesem heraufstufbar gleich dem entsprechenden Variablentyp ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="lambda">Ein <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> Instanz, die die anzuwendende Lambda-Funktion darstellt.</param>
        <param name="arguments">Ausdrücke, die die Argumente bereitstellen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" /> , die Anwendung der angegebenen Lambda-Funktion auf den angegebenen Argumenten darstellt.</summary>
        <returns>Eine neue DbLambdaExpression, die die Anwendung der Lambda-Funktion darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="lambda" /> oder <paramref name="arguments" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="arguments" /> entspricht nicht die Anzahl der Variablen deklariert, indem <paramref name="lambda" />, oder <paramref name="arguments" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht zu diesem heraufstufbar gleich dem entsprechenden Variablentyp ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Metadaten für die aufzurufende Funktion.</param>
        <param name="arguments">Eine Liste von Ausdrücken, die die Argumente der Funktion bereitstellen.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" />, die den Aufruf der angegebenen Funktion mit den angegebenen Argumenten darstellt.</summary>
        <returns>Eine neue DbFunctionExpression, die den Funktionsaufruf darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> ist NULL, oder <paramref name="arguments" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="arguments" /> entspricht nicht der Anzahl der von <paramref name="function" /> deklarierten Parameter, oder <paramref name="arguments" /> enthält einen Ausdruck, dessen Ergebnistyp nicht gleich dem entsprechenden Funktionsparametertyp bzw. nicht dazu heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="function">Metadaten für die aufzurufende Funktion.</param>
        <param name="arguments">Ausdrücke, die die Argumente für die Funktion bereitstellen.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" />, die den Aufruf der angegebenen Funktion mit den angegebenen Argumenten darstellt.</summary>
        <returns>Eine neue DbFunctionExpression, die den Funktionsaufruf darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> ist NULL, oder <paramref name="arguments" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="arguments" /> entspricht nicht der Anzahl der von <paramref name="function" /> deklarierten Parameter, oder <paramref name="arguments" /> enthält einen Ausdruck, dessen Ergebnistyp nicht gleich dem entsprechenden Funktionsparametertyp bzw. nicht dazu heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsEmptyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> , der bestimmt, ob das angegebene Argument eine leere Menge.</summary>
        <returns>Eine neue DbIsEmptyExpression mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />sammlungsergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsNullExpression IsNull (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsNullExpression IsNull(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression" /> , der bestimmt, ob das angegebene Argument null ist.</summary>
        <returns>Eine neue DbIsNullExpression mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />verfügt über einen Ergebnistyp für die Auflistung ein.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOf">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOf (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOf(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Instanz angibt.</param>
        <param name="type">Geben Sie die Metadaten, die den Typ angibt, dem Ergebnistyp der Instanz verglichen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> , der bestimmt, ob das angegebene Argument vom angegebenen Typ oder einen Untertyp ist.</summary>
        <returns>Eine neue DbIsOfExpression mit dem angegebenen Instanz und Typ und DbExpressionKind IsOf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression erfordert, dass `argument` wurde von einem polymorphen Ergebnistyp, und dass `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Ergebnistyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />befindet sich nicht in derselben Typhierarchie mit dem Ergebnistyp des <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOfOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Instanz angibt.</param>
        <param name="type">Geben Sie die Metadaten, die den Typ angibt, dem Ergebnistyp der Instanz verglichen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" /> Ausdruck, der bestimmt, ob das angegebene Argument des angegebenen Typs und nur dieses Typs (kein Untertyp) ist.</summary>
        <returns>Eine neue DbIsOfExpression mit der angegebenen Instanz und die Art und die DbExpressionKind IsOfOnly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression erfordert, dass `argument` wurde von einem polymorphen Ergebnistyp, und dass `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Ergebnistyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />befindet sich nicht in derselben Typhierarchie mit dem Ergebnistyp des <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression Join (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression Join(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="outer">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das äußere Mengenargument angibt.</param>
        <param name="inner">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das innere Mengenargument angibt.</param>
        <param name="outerKey">Eine Methode, die angibt, wie der Wert des äußeren Schlüssels von einem Element der äußeren Menge abgeleitet werden sollte.</param>
        <param name="innerKey">Eine Methode, die angibt, wie der Wert des inneren Schlüssels von einem Element der inneren Menge abgeleitet werden sollte.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, die die von den äußeren und inneren Ausdrücken angegebenen Mengen nach einer Gleichheitsbedingung zwischen den angegebenen äußeren und inneren Schlüsseln verknüpft, wobei InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von InnerJoin, die den Vorgang der inneren Verknüpfung darstellt, der auf den linken und rechten Eingabeset unter einer Verknüpfungsbedingung, die die Werte des äußeren und inneren Schlüssels auf Gleichheit vergleicht, angewendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="outerKey" /> oder <paramref name="innerKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die von <paramref name="outerKey" /> und <paramref name="innerKey" /> erzeugten Ausdrücke sind nicht auf Gleichheit vergleichbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join``1(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Der Typ des der <c>Selektor</c>.</typeparam>
        <param name="outer">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das äußere Mengenargument angibt.</param>
        <param name="inner">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das innere Mengenargument angibt.</param>
        <param name="outerKey">Eine Methode, die angibt, wie der Wert des äußeren Schlüssels von einem Element der äußeren Menge abgeleitet werden sollte.</param>
        <param name="innerKey">Eine Methode, die angibt, wie der Wert des inneren Schlüssels von einem Element der inneren Menge abgeleitet werden sollte.</param>
        <param name="selector">Eine Methode, die angibt, wie ein Element des Resultsets von Elementen der inneren und äußeren Menge abgeleitet werden sollte. Diese Methode muss eine Instanz eines Typs produzieren, der mit „Join“ kompatibel ist und in eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> aufgelöst werden kann. Anforderungen an die Kompatibilität für <c>TSelector</c> sind in den Hinweisen beschrieben.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" />, die den angegebenen Selektor über die von den äußeren und inneren Ausdrücken angegebenen Mengen projiziert, verknüpft nach einer Gleichheitsbedingung zwischen den angegebenen äußeren und inneren Schlüsseln, wobei InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbProjectExpression mit dem angegebenen Selektor als Projektion und eine neue DbJoinExpression als Eingabe. Die eingegebene DbJoinExpression wird mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von InnerJoin erstellt, die den Vorgang der inneren Verknüpfung darstellt, der auf den linken und rechten Eingabeset unter einer Verknüpfungsbedingung, die die Werte des äußeren und inneren Schlüssels auf Gleichheit vergleicht, angewendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die Kompatibilität bei Join `TSelector` abgeleitet werden müssen <xref:System.Data.Common.CommandTrees.DbExpression>, oder ein anonymer Typ mit DbExpression-abgeleiteten Eigenschaften werden muss. Die folgenden Beispiele von unterstützten Typen sind `TSelector`:  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => o.Property("Name"))  
```  
  
 (`TSelector` ist <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => new { OName = o.Property("Name"), IName = i.Property("Name") })  
```  
  
 (`TSelector` ist ein anonymer Typ mit DbExpression-abgeleiteten Eigenschaften).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das Ergebnis von <paramref name="selector" /> nach der Konvertierung in DbExpression ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Das Ergebnis von <paramref name="Selector" /> ist nicht kompatibel mit SelectMany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbVariableReferenceExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Ein Ausdruck, der die Logik der Lambda-Funktion definiert.</param>
        <param name="variables">Eine <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" />-Sammlung, die die formalen Parameter der Lambda-Funktion darstellt. Diese Variablen sind gültig für die Verwendung im <c>body</c>-Ausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> mit den angegebenen Inline-Lambda-Funktionsimplementierungs- und formalen Parametern.</summary>
        <returns>Eine neue DbLambda, die eine Inline-Lambda-Funktion mit den angegebenen Body- und formalen Parameter beschreibt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" />ist null oder enthält Null, oder <paramref name="body" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" />enthält mehr als ein Element mit dem gleichen Variablennamen an.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, params System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbVariableReferenceExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Data.Common.CommandTrees.DbVariableReferenceExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Ein Ausdruck, der die Logik der Lambda-Funktion definiert.</param>
        <param name="variables">Eine <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" />-Sammlung, die die formalen Parameter der Lambda-Funktion darstellt. Diese Variablen sind gültig für die Verwendung im <c>body</c>-Ausdruck.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> mit den angegebenen Inline-Lambda-Funktionsimplementierungs- und formalen Parametern.</summary>
        <returns>Eine neue DbLambda, die eine Inline-Lambda-Funktion mit den angegebenen Body- und formalen Parameter beschreibt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variables" />ist null oder enthält Null, oder <paramref name="body" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variables" />enthält mehr als ein Element mit dem gleichen Variablennamen an.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das linke set-Argument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das rechte set-Argument angibt.</param>
        <param name="joinCondition">Eine Methode, die die Bedingung darstellt, bei der die Verknüpfung stattfinden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Logik der Joinbedingung bereitstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> , die von der linken und rechten-Ausdrücken, auf die angegebene Join-Bedingung, unter Verwendung LeftOuterJoin als angegebenen Mengen verknüpft die <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von LeftOuterJoin, das den linken äußeren Join-Vorgang angewendet wird, auf der linken und rechten Eingabeset unter der angegebenen Join-Bedingung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , links Mengenargument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , rechts Mengenargument angibt.</param>
        <param name="joinCondition">Ein Ausdruck, der die Bedingung für den join angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" /> , die von der linken und rechten ausdrucksbindungen, auf die angegebene Join-Bedingung mit LeftOuterJoin als angegebenen Mengen verknüpft die <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von LeftOuterJoin, das den linken äußeren Join-Vorgang angewendet wird, auf der linken und rechten Eingabeset unter der angegebenen Join-Bedingung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="joinCondition" />muss ein boolesches Ergebnis nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> , der bestimmt, ob das linke Argument kleiner als das rechte Argument ist.</summary>
        <returns>Eine neue DbComparisonExpression darstellt kleiner-als-Vergleich.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine Reihenfolge vergleichbar gleichen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> , der bestimmt, ob das linke Argument kleiner oder gleich dem rechten Argument ist.</summary>
        <returns>Eine neue DbComparisonExpression, das den kleiner-als-oder-gleich-Vergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen Ergebnistyp, der sowohl auf Gleichheit - und Reihenfolge vergleichbar ist, besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabezeichenfolge angibt.</param>
        <param name="pattern">Ein Ausdruck, der die Zeichenfolge angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> , vergleicht die angegebene Eingabezeichenfolge mit dem angegebenen Muster.</summary>
        <returns>Eine neue DbLikeExpression mit der angegebenen Eingabe, Muster und ein null-Escapezeichen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="Argument" /> oder <paramref name="pattern" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="Argument" />oder <paramref name="pattern" /> verfügt nicht über einen Ergebnistyp Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern, System.Data.Common.CommandTrees.DbExpression escape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern, class System.Data.Common.CommandTrees.DbExpression escape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="escape" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabezeichenfolge angibt.</param>
        <param name="pattern">Ein Ausdruck, der die Zeichenfolge angibt.</param>
        <param name="escape">Einen optionalen Ausdruck, der die Escapezeichenfolge angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" /> , vergleicht die angegebene Eingabezeichenfolge mit dem angegebenen Muster mit optionaler Escapezeichen.</summary>
        <returns>Eine neue DbLikeExpression mit der angegebenen Eingabe, Muster und Escapezeichen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" />, <paramref name="pattern" /> oder <paramref name="escape" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />, <paramref name="pattern" /> oder <paramref name="escape" /> verfügt nicht über einen Ergebnistyp Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="Limit">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Limit (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Limit(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabeauflistung angibt.</param>
        <param name="count">Ein Ausdruck, der den Wert angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> , die die Anzahl der Elemente in der argumentauflistung auf die angegebene Anzahl Grenzwert beschränkt. Beschränkungsvorgang verknüpfte Ergebnisse sind nicht in der Ausgabe enthalten.</summary>
        <returns>Eine neue DbLimitExpression mit dem angegebenen Argument und der Count-Grenzwerte, die nicht gebunden Ergebnisse.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="count" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />verfügt nicht über einen Auflistungsergebnistyp oder <paramref name="count" /> verfügt nicht über einen Ergebnistyp, der gleich oder heraufstufbar in einen 64-Bit-Ganzzahl-Typ ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Minus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Minus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Minus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , der das rechte Argument aus das linke Argument subtrahiert.</summary>
        <returns>Eine neue DbArithmeticExpression, die die Operation der Mengensubtraktion darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen numerischen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Modulo (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Modulo(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , berechnet den Rest des linken Arguments dividiert durch das rechte Argument.</summary>
        <returns>Ein neues, DbArithmeticExpression darstellt, die modulo-Operation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen numerischen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Multiply (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Multiply(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , der das linke Argument mit dem rechten Argument multipliziert.</summary>
        <returns>Eine neue DbArithmeticExpression, dem der Multiplikationsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen numerischen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Common.CommandTrees.DbExpression navigateFrom, System.Data.Metadata.Edm.RelationshipEndMember fromEnd, System.Data.Metadata.Edm.RelationshipEndMember toEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Common.CommandTrees.DbExpression navigateFrom, class System.Data.Metadata.Edm.RelationshipEndMember fromEnd, class System.Data.Metadata.Edm.RelationshipEndMember toEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="fromEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
        <Parameter Name="toEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="navigateFrom">Ein Ausdruck, der die Instanz gibt an, von der die Navigation erfolgen soll.</param>
        <param name="fromEnd">Die Metadaten für die Eigenschaft, die das Ende der Beziehung darstellt, von dem die Navigation erfolgen soll.</param>
        <param name="toEnd">Die Metadaten für die Eigenschaft, die das Ende der Beziehung darstellt, zu dem Navigationsbereich erfolgen soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> , die die Navigation einer Beziehung zusammensetzungen oder Zuordnungen darstellt.</summary>
        <returns>Eine neue DbRelationshipNavigationExpression, die die Navigation des angegebenen darstellt in bzw. aus einer Beziehung Ende der angegebene Beziehungstyp aus der angegebenen Navigations-Zielinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression>erfordert, dass Navigation immer aus einem Verweis erfolgt, weshalb `navigateFrom` muss immer einen Verweistyp für das Ergebnis haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fromEnd" />, <paramref name="toEnd" /> oder <paramref name="navigateFrom" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromEnd" />und <paramref name="toEnd" /> werden nicht vom selben Beziehungstyp deklariert oder <paramref name="navigateFrom" /> weist den Ergebnistyp, der nicht kompatibel mit den Eigenschaftentyp des ist <paramref name="fromEnd" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, System.Data.Common.CommandTrees.DbExpression navigateFrom);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, class System.Data.Common.CommandTrees.DbExpression navigateFrom) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Metadata.Edm.RelationshipType,System.String,System.String,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.RelationshipType" RefType="this" />
        <Parameter Name="fromEndName" Type="System.String" />
        <Parameter Name="toEndName" Type="System.String" />
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="type">Die Metadaten für den Beziehungstyp aus, der die Beziehung darstellt.</param>
        <param name="fromEndName">Der Name der Eigenschaft den Beziehungstyp, der das Ende der Beziehung darstellt, aus dem Navigationsbereich erfolgen soll.</param>
        <param name="toEndName">Der Name der Eigenschaft den Beziehungstyp, der das Ende der Beziehung darstellt, zu dem Navigationsbereich erfolgen soll.</param>
        <param name="navigateFrom">Ein Ausdruck die gibt die Instanz aus der Naviagtion erfolgen soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" /> , die die Navigation einer Beziehung zusammensetzungen oder Zuordnungen darstellt.</summary>
        <returns>Eine neue DbRelationshipNavigationExpression, die die Navigation des angegebenen darstellt in bzw. aus einer Beziehung Ende der angegebene Beziehungstyp aus der angegebenen Navigations-Zielinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression>erfordert, dass Navigation immer aus einem Verweis erfolgt, weshalb `navigateFrom` muss immer einen Verweistyp für das Ergebnis haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />, <paramref name="fromEndName" />, <paramref name="toEndName" /> oder <paramref name="navigateFrom" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" />ist nicht mit dieser Befehlsstruktur Metadaten-Arbeitsbereich verknüpft oder <paramref name="navigateFrom" /> mit einer anderen Befehlsstruktur verknüpft ist oder <paramref name="type" /> Beziehungs-End-Eigenschaft mit dem Namen deklariert keine <paramref name="toEndName" /> oder <paramref name="fromEndName" />, oder <paramref name="navigateFrom" /> verfügt über ein Ergebnis Typ, der nicht kompatibel mit den Eigenschaftentyp des Beziehungs-End-Eigenschaft mit dem Namen ist <paramref name="fromEndName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Negate (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Negate(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , die den Wert des Arguments negiert.</summary>
        <returns>Eine neue DbArithmeticExpression, die die negationsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine numerischen Ergebnistyp vorhanden ist, für die <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="instanceType">Der Typ der neuen Instanz.</param>
        <param name="arguments">Ausdrücke, die Werte der neuen Instanzen, interpretiert gemäß der Typ der Instanz angeben.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Wenn das Typargument vom Auflistungstyp ist, geben Sie die Argumente der Elemente der Auflistung. Andernfalls werden die Argumente als Eigenschaft oder Spalte Werte in der neuen Instanz verwendet.</summary>
        <returns>Eine neue DbNewInstanceExpression mit dem angegebenen Typ und die Argumente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `instanceType` ist ein Geben Sie dann jeder Ausdruck in eine Auflistung `arguments` benötigen einen Ergebnistyp aus, zu dem Elementtyp des ist, die `instanceType`. Wenn `instanceType` ist ein Zeilentyp `arguments` beliebig viele Ausdrücke in der Zeilentyp Spalten vorhanden sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Spalte gleich oder heraufstufbar sein darf. Ein Zeilentyp, der keine Spalten deklariert, ist ungültig. Wenn `instanceType` ist ein Entitätstyp `arguments` muss enthalten, wie viele Ausdrücke als dort Eigenschaften, die durch den Typ definiert sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Eigenschaft gleich oder heraufstufbar sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" />oder <paramref name="arguments" /> null ist, oder <paramref name="arguments" /> Null enthält.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" />ist leer oder die Ergebnistypen der enthaltenen Ausdrücke entsprechen nicht die Anforderungen der <paramref name="instanceType" /> (wie im Abschnitt "Hinweise" erläutert).</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instanceType">Der Typ der neuen Instanz.</param>
        <param name="arguments">Ausdrücke, die Werte der neuen Instanzen, interpretiert gemäß der Typ der Instanz angeben.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Wenn das Typargument vom Auflistungstyp ist, geben Sie die Argumente der Elemente der Auflistung. Andernfalls werden die Argumente als Eigenschaft oder Spalte Werte in der neuen Instanz verwendet.</summary>
        <returns>Eine neue DbNewInstanceExpression mit dem angegebenen Typ und die Argumente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `instanceType` ist ein Geben Sie dann jeder Ausdruck in eine Auflistung `arguments` benötigen einen Ergebnistyp aus, zu dem Elementtyp des ist, die `instanceType`. Wenn `instanceType` ist ein Zeilentyp `arguments` beliebig viele Ausdrücke in der Zeilentyp Spalten vorhanden sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Spalte gleich oder heraufstufbar sein darf. Ein Zeilentyp, der keine Spalten deklariert, ist ungültig. Wenn `instanceType` ist ein Entitätstyp `arguments` muss enthalten, wie viele Ausdrücke als dort Eigenschaften, die durch den Typ definiert sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Eigenschaft gleich oder heraufstufbar sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instanceType" />oder <paramref name="arguments" /> null ist, oder <paramref name="arguments" /> Null enthält.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" />ist leer oder die Ergebnistypen der enthaltenen Ausdrücke entsprechen nicht die Anforderungen der <paramref name="instanceType" /> (wie im Abschnitt "Hinweise" erläutert).</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="elements">Eine Liste von Ausdrücken, die die Elemente der Auflistung bereitstellen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> , die eine Auflistung mit den angegebenen Elementen erstellt. Der Typ der Auflistung basiert auf den allgemeinen Typ der Elemente. Wenn kein gemeinsamer Elementtyp vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Eine neue DbNewInstanceExpression mit dem angegebenen Sammlungstyp und Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" />ist null, oder Null enthält.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" />ist leer oder enthält Ausdrücke, die für die keine gleichen Ergebnistyp vorhanden ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (params System.Data.Common.CommandTrees.DbExpression[] elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Data.Common.CommandTrees.DbExpression[] elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elements">Eine Liste von Ausdrücken, die die Elemente der Auflistung bereitstellen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> , die eine Auflistung mit den angegebenen Elementen erstellt. Der Typ der Auflistung basiert auf den allgemeinen Typ der Elemente. Wenn kein gemeinsamer Elementtyp vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Eine neue DbNewInstanceExpression mit dem angegebenen Sammlungstyp und Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elements" />ist null, oder Null enthält...</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elements" />ist leer oder enthält Ausdrücke, die für die keine gleichen Ergebnistyp vorhanden ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewEmptyCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection (this System.Data.Metadata.Edm.TypeUsage collectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection(class System.Data.Metadata.Edm.TypeUsage collectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="collectionType">Die Typmetadaten für die Sammlung zu erstellen</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> , erstellt eine leere Auflistung des Typs angegebenen Auflistung.</summary>
        <returns>Eine neue DbNewInstanceExpression durch den angegebenen Auflistung und ein leeres <paramref name="Arguments" /> Liste.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collectionType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionType" />ist nicht vom Auflistungstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="columnValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="columnValues">Eine Liste von Zeichenfolge-"DbExpression" Schlüssel-Wert-Paaren, die die Struktur und die Werte der Zeile definiert.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" /> erstellt, die eine Zeile mit den angegebenen benannten Spalten und den angegebenen Werten, die als Ausdrücke angegeben werden.</summary>
        <returns>Eine neue DbNewInstanceExpression, die die zur Erstellung der Zeile darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="columnValues" />ist null oder ein Element mit einem null-Spalte-Namen oder den Ausdruck enthält.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="columnValues" />ist leer oder enthält ein doppelter oder Ungültiger Spaltenname.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNotExpression Not (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNotExpression Not(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNotExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein boolescher Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" /> , das die logische Negation des angegebenen Arguments ausführt.</summary>
        <returns>Eine neue DbNotExpression mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />muss ein boolesches Ergebnis nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression NotEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression NotEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" /> , vergleicht die linke und rechte Argument auf Ungleichheit.</summary>
        <returns>Eine neue DbComparisonExpression der Ungleichheitsvergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen auf Gleichheit vergleichbar Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNullExpression Null (this System.Data.Metadata.Edm.TypeUsage nullType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNullExpression Null(class System.Data.Metadata.Edm.TypeUsage nullType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nullType">Der Typ des null-Werts.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbNullExpression" />, die einen typisierten null-Wert darstellt.</summary>
        <returns>Eine Instanz der "DbNullExpression".</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nullType" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfType (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfType(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die das Eingabeset angibt.</param>
        <param name="type">Geben Sie die Metadaten für den Typ, den Elemente des Eingabesatzes benötigen, in die Ergebnismenge eingeschlossen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> sind ein Satz erzeugt bestehend aus den Elementen der angegebenen Eingabe, des angegebenen Typs.</summary>
        <returns>Eine neue DbOfTypeExpression mit dem angegebenen Mengenargument, Typ und ein ExpressionKind von <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression erfordert, dass `argument` verfügt über eine Sammlung Ergebnistyp mit einem polymorphen Elementtyp und dass `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Elementtyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />verfügt nicht über einen Auflistungsergebnistyp oder <paramref name="type" /> ist kein Typ in der gleichen Typhierarchie als Elementtyp des Auflistungstyps Ergebnis des <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfTypeOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die das Eingabeset angibt.</param>
        <param name="type">Geben Sie die Metadaten für den Typ, den Elemente des Eingabesatzes genau übereinstimmen müssen, in die Ergebnismenge eingeschlossen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" /> , dass ein Satz erzeugt bestehend aus den Elementen der angegebenen Eingabe, die genau den angegebenen Typ aufweisen.</summary>
        <returns>Eine neue DbOfTypeExpression mit dem angegebenen Mengenargument, Typ und ein ExpressionKind von <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfTypeOnly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression erfordert, dass `argument` verfügt über eine Sammlung Ergebnistyp mit einem polymorphen Elementtyp und dass `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Elementtyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />verfügt nicht über einen Auflistungsergebnistyp oder <paramref name="type" /> ist kein Typ in der gleichen Typhierarchie als Elementtyp des Auflistungstyps Ergebnis des <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOrExpression Or (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOrExpression Or(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOrExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein boolescher Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein boolescher Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein <see cref="T:System.Data.Common.CommandTrees.DbOrExpression" /> , das die logischen oder die linke und rechte Argument ausführt.</summary>
        <returns>Eine neue DbOrExpression mit den angegebenen Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />oder <paramref name="right" /> verfügt nicht über einen booleschen Wert als Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierung Schlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit dem angegebenen Sortierschlüssel in aufsteigender Reihenfolge und Sort-standardsortierung mit angegebenen Eingabesets sortiert.</summary>
        <returns>Eine neue DbSortExpression, die die Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierung Schlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <param name="collation">Die Sortierung zu verwendende Sortierung.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit dem angegebenen Sortierschlüssel in aufsteigender Sortierreihenfolge und die angegebene Sortierung mit angegebenen Eingabesets sortiert.</summary>
        <returns>Eine neue DbSortExpression, die die Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbare Zeichenfolgentypen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierung Schlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die die angegebenen Eingabesets mit dem angegebenen Sortierschlüssel in absteigender Reihenfolge und Sort-standardsortierung sortiert.</summary>
        <returns>Eine neue DbSortExpression, die die Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierung Schlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <param name="collation">Die Sortierung zu verwendende Sortierung.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit dem angegebenen Sortierschlüssel in absteigender Sortierreihenfolge und die angegebene Sortierung mit angegebenen Eingabesets sortiert.</summary>
        <returns>Eine neue DbSortExpression, die die Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbare Zeichenfolgentypen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die angibt, die Logik für jedes Element des Eingabesets einmal ausgewertet.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> , ergibt die angegebenen <paramref name="apply" /> Ausdruck einmal für jedes Element einer gegebenen Eingabe festgelegt, erzeugen eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten. Zeilen, für die <paramref name="apply" /> ergibt ein leeres Resultset weisen eine übernehmen den Spaltenwert der <see langword="null" />.</summary>
        <returns>Eine neue DbApplyExpression mit dem angegebenen Eingabe- und apply-Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von "OuterApply".</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Das Ergebnis des <paramref name="apply" /> enthält einen Namen oder einen Ausdruck, der null ist.</exception>
        <exception cref="T:System.ArgumentException">Das Ergebnis des <paramref name="apply" /> enthält einen Namen oder einen Ausdruck, der in einer ausdrucksbindung ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , die das Eingabeset angibt.</param>
        <param name="apply">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" /> , Logik einmal für jedes Element des Eingabesets ausgewertet angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> , ergibt die angegebenen <paramref name="apply" /> Ausdruck einmal für jedes Element einer gegebenen Eingabe festgelegt, erzeugen eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten. Zeilen, für die <paramref name="apply" /> ergibt ein leeres Resultset weisen eine übernehmen den Spaltenwert der <see langword="null" />.</summary>
        <returns>Eine neue DbApplyExpression mit dem angegebenen Eingabe- und apply-Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von "OuterApply".</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="apply" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbParameterReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des Parameters, auf die verwiesen wird.</param>
        <param name="name">Der Name des Parameters, auf den verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> , die auf einen Parameter mit dem angegebenen Namen und Typ verweist.</summary>
        <returns>Ein DbParameterReferenceExpression, der einen Verweis auf einen Parameter mit dem angegebenen Namen und Typ darstellt. Der Ergebnistyp des Ausdrucks ist identisch mit <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Plus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Plus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , durch das rechte Argument das linke Argument hinzugefügt.</summary>
        <returns>Eine neue DbArithmeticExpression, dem der Additionsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gleichen numerischen Ergebnistyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Project (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Project(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="projection" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Ein Ausdruck, der Bindung, die das Eingabeset angibt.</param>
        <param name="projection">Ein Ausdruck, der Project über der Menge.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> , die den angegebenen Ausdruck über dem angegebenen Eingabeset projiziert.</summary>
        <returns>Eine neue "DbProjectExpression", die die Projektion Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="projection" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.EdmProperty propertyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.EdmProperty propertyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EdmProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyMetadata" Type="System.Data.Metadata.Edm.EdmProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, von dem die Eigenschaft abgerufen werden soll. Kann null sein, wenn die Eigenschaft statisch ist.</param>
        <param name="propertyMetadata">Die Metadaten für die Eigenschaft abgerufen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> , die das Abrufen der angegebenen Eigenschaft darstellt.</summary>
        <returns>Einen neuen DbPropertyExpression, die das Abrufen der Eigenschaft darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyMetadata" />ist null oder <paramref name="instance" /> null ist und die Eigenschaft ist nicht statisch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.NavigationProperty navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.NavigationProperty navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.NavigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="navigationProperty" Type="System.Data.Metadata.Edm.NavigationProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, aus der die Navigationseigenschaft abgerufen werden soll.</param>
        <param name="navigationProperty">Metadaten für die Navigationseigenschaft, die abgerufen werden.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> , die das Abrufen der angegebenen Navigationseigenschaft darstellt.</summary>
        <returns>Einen neuen DbPropertyExpression, die das Abrufen der Navigation Eigenschaft darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="navigationProperty" /> oder <paramref name="instance" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="relationshipEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz aus der End-Member der Beziehung abgerufen werden soll.</param>
        <param name="relationshipEnd">Metadaten für die End-Member der Beziehung abgerufen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> , die den Abruf von End-Member der angegebenen Beziehung darstellt.</summary>
        <returns>Einen neuen DbPropertyExpression, die den Beziehung End-Member-Abruf darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipEnd" />ist null oder <paramref name="instance" /> null ist und die Eigenschaft ist nicht statisch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, von dem die Eigenschaft abgerufen werden soll.</param>
        <param name="propertyName">Der Name der abzurufenden Eigenschaft.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" /> , die den Abruf von dem Instance-Eigenschaft mit dem angegebenen Namen aus der angegebenen Instanz darstellt.</summary>
        <returns>Einen neuen DbPropertyExpression, der das Abrufen der Eigenschaft darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyName" />ist null oder <paramref name="instance" /> null ist und die Eigenschaft ist nicht statisch.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ist keine Eigenschaft mit dem angegebenen Namen deklariert, durch den Typ des <paramref name="instance" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge in dem das Verweiselement befindet.</param>
        <param name="keyRow">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> erstellt, die einem Datensatz mit Spalten, die (in Anzahl, Typ und die Reihenfolge) entsprechen den Schlüsseleigenschaften des Entitätstyps verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> , die einen Verweis auf eine bestimmte Entität basierend auf Werten codiert.</summary>
        <returns>Legen Sie einen neuen DbRefExpression, der das Element mit den angegebenen Schlüsselwerten in die angegebene Entität verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow`Ein Ausdruck, der die Schlüsselwerte angibt, die die Entität verwiesen wird, innerhalb der angegebenen Entität identifizieren festgelegt werden soll. Der Ergebnistyp des `keyRow` sollte eine entsprechende Spalte für jede Schlüsseleigenschaft definiert, indem enthalten `entitySet's` Entitätstyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" /> oder <paramref name="keyRow" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyRow" />einen Datensatz Ergebnistyp keinen, der die Schlüsseleigenschaften des Entitätstyps die referenzierten Entitätenmenge entspricht.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow, System.Data.Metadata.Edm.EntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow, class System.Data.Metadata.Edm.EntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EntityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge in dem das Verweiselement befindet.</param>
        <param name="keyRow">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> erstellt, die einem Datensatz mit Spalten, die (in Anzahl, Typ und die Reihenfolge) entsprechen den Schlüsseleigenschaften des Entitätstyps verwiesen wird.</param>
        <param name="entityType">Der Typ der Entität, die der Verweis verweisen soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" /> , die einen Verweis auf eine bestimmte Entität basierend auf Werten codiert.</summary>
        <returns>Legen Sie einen neuen DbRefExpression, der das Element mit den angegebenen Schlüsselwerten in die angegebene Entität verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow`Ein Ausdruck, der die Schlüsselwerte angibt, die die Entität verwiesen wird, innerhalb der angegebenen Entität identifizieren festgelegt werden soll. Der Ergebnistyp des `keyRow` sollte eine entsprechende Spalte für jede Schlüsseleigenschaft definiert, indem enthalten `entitySet's` Entitätstyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySet" />, <paramref name="keyRow" /> oder <paramref name="entityType" /> ist null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entityType" />befindet sich nicht in derselben Typhierarchie als Entitätstyp der Entitätenmenge oder <paramref name="keyRow" /> verfügt nicht über einen Datensatz Ergebnistyp, der die Schlüsseleigenschaften des Entitätstyps die referenzierten Entitätenmenge entspricht.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbScanExpression Scan (this System.Data.Metadata.Edm.EntitySetBase targetSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbScanExpression Scan(class System.Data.Metadata.Edm.EntitySetBase targetSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan(System.Data.Metadata.Edm.EntitySetBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbScanExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSet" Type="System.Data.Metadata.Edm.EntitySetBase" RefType="this" />
      </Parameters>
      <Docs>
        <param name="targetSet">Die Metadaten für die Entität oder Beziehung Menge zu verweisen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbScanExpression" /> , Entitäts- oder Beziehungstyps festgelegten verweist.</summary>
        <returns>Ein neues DbScanExpression basierend auf den angegebenen Entität oder Beziehung.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetSet" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TProjection&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt; projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, !!TProjection&gt; projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProjection" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="projection" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProjection">Der Methodenergebnistyp von <c>Projektion</c>.</typeparam>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="projection">Eine Methode, die angibt, wie den projizierten Ausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss eine Instanz eines Typs, die kompatibel mit erzeugen wählen und aufgelöst werden kann, in einem <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Anforderungen an die Kompatibilität für <c>TProjection</c> sind in den Hinweisen beschrieben.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> , die den angegebenen Ausdruck über dem angegebenen Eingabeset auswählt.</summary>
        <returns>Eine neue "DbProjectExpression", die die select-Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die Kompatibilität mit Select, `TProjection` abgeleitet werden müssen <xref:System.Data.Common.CommandTrees.DbExpression>, oder ein anonymer Typ mit DbExpression-abgeleiteten Eigenschaften werden muss. Die folgenden Beispiele von unterstützten Typen sind `TProjection`:  
  
```  
source.Select(x => x.Property("Name"))  
```  
  
 `TProjection`ist <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.Select(x => new { Name = x.Property("Name") })  
```  
  
 (`TProjection` ist ein anonymer Typ mit DbExpression-abgeleiteten-Eigenschaft).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das Ergebnis des <paramref name="projection" /> ist null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die Logik für jedes Element des Eingabesets einmal ausgewertet darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> , ergibt die angegebenen <paramref name="apply" /> Ausdruck einmal für jedes Element einer gegebenen Eingabe festgelegt, erzeugen eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten. Zeilen, für die <paramref name="apply" /> auf einen leeren Satz ausgewertet wird, sind nicht enthalten. Ein <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> wird erstellt, wählt die <paramref name="apply" /> Spalte aus jeder Zeile wird, erzeugt der gesamten Auflistung <paramref name="apply" /> Ergebnisse.</summary>
        <returns>Eine neue "DbProjectExpression", die die Spalte übernehmen aus einer neuen DbApplyExpression mit den angegebenen Eingaben und Apply-Bindungen auswählt und eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von "CrossApply".</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="apply" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="apply" /> verfügt nicht über einen Sammlungstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Der Methodenergebnistyp von <c>Selektor</c>.</typeparam>
        <param name="source">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die Logik für jedes Element des Eingabesets einmal ausgewertet darstellt.</param>
        <param name="selector">Eine Methode, die angibt, wie ein Element des Ergebnisses ein Element der Eingabe angegebene abgeleitet werden sollte und anwenden. Diese Methode muss eine Instanz eines Typs, die kompatibel mit SelectMany erzeugen und aufgelöst werden kann, in einem <see cref="T:System.Data.Common.CommandTrees.DbExpression" />. Anforderungen an die Kompatibilität für <c>TSelector</c> sind in den Hinweisen beschrieben.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" /> , ergibt die angegebenen <paramref name="apply" /> Ausdruck einmal für jedes Element einer gegebenen Eingabe festgelegt, erzeugen eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten. Zeilen, für die <paramref name="apply" /> auf einen leeren Satz ausgewertet wird, sind nicht enthalten. Ein <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> wird erstellt, wählt das angegebene <paramref name="selector" /> , der jede Zeile die gesamte Sammlung der Ergebnisse erzeugt.</summary>
        <returns>Eine neue "DbProjectExpression", die das Ergebnis der angegebenen Auswahl aus einer neuen DbApplyExpression mit der angegebenen Eingabe ausgewählt und Anwenden von Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von "CrossApply".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kompatibel mit SelectMany, `TSelector` muss abgeleitet sein <xref:System.Data.Common.CommandTrees.DbExpression>, oder ein anonymer Typ mit DbExpression-abgeleiteten Eigenschaften werden muss. Die folgenden Beispiele von unterstützten Typen sind `TSelector`:  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => apply.Property("Name"))  
```  
  
 (`TSelector` ist <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => new { SourceName = source.Property("Name"), RelatedName = apply.Property("Name") })  
```  
  
 (`TSelector` ist ein anonymer Typ mit DbExpression-abgeleiteten Eigenschaften).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das Ergebnis des <paramref name="selector" /> bei der Konvertierung in "DbExpression" null ist.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="apply" /> verfügt nicht über einen Sammlungstyp. muss vom Auflistungstyp nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbSortExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbSortExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbSortExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , sortierte Eingabeset angibt.</param>
        <param name="count">Ein Ausdruck der gibt an, wie viele Elemente der geordneten Menge zu überspringen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> , die die angegebene Anzahl von Elementen aus dem angegebenen sortierten Eingabeset überspringt.</summary>
        <returns>Eine neue "DbSkipExpression", die den Skip-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="count" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" />ist kein <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> oder <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> oder weist den Ergebnistyp, der gleich oder heraufstufbar nicht in einen 64-Bit-Ganzzahl-Typ ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Ein Ausdruck, der Bindung, die das Eingabeset angibt.</param>
        <param name="sortOrder">Eine Liste der Sort-Spezifikationen, die bestimmen, wie die Elemente des Eingabesatzes sortiert werden sollen.</param>
        <param name="count">Ein Ausdruck der gibt an, wie viele Elemente der geordneten Menge zu überspringen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" /> , sortiert die angegebene Eingabe, die von den Spezifikationen für die angegebene Sortierung festgelegt werden, bevor die angegebene Anzahl von Elementen übersprungen wird.</summary>
        <returns>Eine neue "DbSkipExpression", die den Skip-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="sortOrder" /> oder <paramref name="count" /> null ist, oder <paramref name="sortOrder" /> Null enthält.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" />ist leer, oder <paramref name="count" /> nicht <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> oder <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> oder weist den Ergebnistyp, der gleich oder heraufstufbar nicht in einen 64-Bit-Ganzzahl-Typ ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression Sort (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression Sort(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Ein Ausdruck, der Bindung, die das Eingabeset angibt.</param>
        <param name="sortOrder">Eine Liste der Sort-Spezifikationen, die bestimmen, wie die Elemente des Eingabesatzes sortiert werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , sortiert die angegebene Eingabe, die von den angegebenen Sortierschlüsselwert Spezifikationen festgelegt.</summary>
        <returns>Eine neue DbSortExpression, die den Sortiervorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />oder <paramref name="sortOrder" /> null ist, oder <paramref name="sortOrder" /> Null enthält.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortOrder" /> ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Take (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Take(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabeauflistung angibt.</param>
        <param name="count">Ein Ausdruck, der den Wert angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" /> , die die Anzahl der Elemente in der argumentauflistung auf die angegebene Anzahl Grenzwert beschränkt. Beschränkungsvorgang verknüpfte Ergebnisse sind nicht in der Ausgabe enthalten.</summary>
        <returns>Eine neue DbLimitExpression mit dem angegebenen Argument und der Count-Grenzwerte, die nicht gebunden Ergebnisse.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="count" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argument" />verfügt nicht über einen Auflistungsergebnistyp <paramref name="count" /> verfügt nicht über einen Ergebnistyp, der gleich oder heraufstufbar in einen 64-Bit-Ganzzahl-Typ ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein DbSortExpression, der das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit einer Sortierreihenfolge, die die Sortierreihenfolge von der angegebenen Reihenfolge enthält Eingabesatz zusammen mit dem angegebenen Sortierschlüssel in aufsteigender Sortierreihenfolge und mit der standardsortierung.</summary>
        <returns>Eine neue DbSortExpression, die den neuen gesamte Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sortKey" />ein Reihenfolge vergleichbar Ergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Ein DbSortExpression, der das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <param name="collation">Die Sortierung zu verwendende Sortierung.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit einer Sortierreihenfolge, die die Sortierreihenfolge von der angegebenen Reihenfolge enthält Eingabesatz zusammen mit dem angegebenen Sortierschlüssel in aufsteigender Sortierreihenfolge, und klicken Sie mit der angegebenen Sortierung.</summary>
        <returns>Eine neue DbSortExpression, die den neuen gesamte Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbare Zeichenfolgentypen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein DbSortExpression, der das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit einer Sortierreihenfolge, die die Sortierreihenfolge von der angegebenen Reihenfolge enthält Eingabesatz zusammen mit dem angegebenen Sortierschlüssel in absteigender Reihenfolge und mit der standardsortierung.</summary>
        <returns>Eine neue DbSortExpression, die den neuen gesamte Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Ein DbSortExpression, der das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck, der einen angegebenen Member des Eingabesets abgeleitet. Diese Methode muss einen Ausdruck mit einem Datentyp, Ergebnis der Reihenfolge vergleichbar, die die Sortierreihenfolge bereitstellt erzeugen key Definition.</param>
        <param name="collation">Die Sortierung zu verwendende Sortierung.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" /> , die mit einer Sortierreihenfolge, die die Sortierreihenfolge von der angegebenen Reihenfolge enthält Eingabesatz zusammen mit dem angegebenen Sortierschlüssel in absteigender Reihenfolge und mit der angegebenen Sortierung.</summary>
        <returns>Eine neue DbSortExpression, die den neuen gesamte Order by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Durch erzeugte Ausdruck <paramref name="sortKey" /> verfügt nicht über einen Ergebnistyp Reihenfolge vergleichbare Zeichenfolgentypen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit aufsteigende Sortierung Reihenfolge und Standard-Sortierung.</summary>
        <returns>Eine neue Sortierklausel mit dem angegebenen Sortierschlüssel und eine aufsteigende Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />ein Reihenfolge vergleichbar Ergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <param name="collation">Die Sortierung zu verwendende Sortierung.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit eine aufsteigende Sortierreihenfolge und der angegebenen Sortierung.</summary>
        <returns>Eine neue Sortierklausel mit dem angegebenen Sortierschlüssel Sortierung und aufsteigende Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />ist leer oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />ein Reihenfolge vergleichbar Ergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit eine absteigende Sortierreihenfolge Reihenfolge und der standardsortierung.</summary>
        <returns>Eine neue Sortierklausel mit dem angegebenen Sortierschlüssel und eine absteigende Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />ein Reihenfolge vergleichbar Ergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <param name="collation">Die Sortierung zu verwendende Sortierung.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit eine absteigende Sortierreihenfolge und der angegebenen Sortierung.</summary>
        <returns>Eine neue Sortierklausel mit dem angegebenen Sortierschlüssel Sortierung und absteigende Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="collation" />ist leer oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" />ein Reihenfolge vergleichbar Ergebnistyp verfügt nicht über.</exception>
      </Docs>
    </Member>
    <Member MemberName="TreatAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbTreatExpression TreatAs (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage treatType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbTreatExpression TreatAs(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage treatType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbTreatExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="treatType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Instanz angibt.</param>
        <param name="treatType">Geben Sie die Metadaten für die Treat-Typ.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression" />.</summary>
        <returns>Eine neue DbTreatExpression mit dem angegebenen Argument und Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbTreatExpression erfordert, dass `argument` wurde von einem polymorphen Ergebnistyp, und dass `treatType` ist ein Typ aus der gleichen Typhierarchie wie dieser Ergebnistyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> oder <paramref name="treatType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="treatType" />befindet sich nicht in derselben Typhierarchie mit dem Ergebnistyp des <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="True">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression True { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression True" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit den booleschen Wert <see langword="true" />.</summary>
        <value>Ein <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit den booleschen Wert <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnaryMinus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" /> , die den Wert des Arguments negiert.</summary>
        <returns>Eine neue DbArithmeticExpression, die die negationsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine numerischen Ergebnistyp vorhanden ist, für die <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Union (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Union(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der zum Definieren der linken Seite Mengenargument.</param>
        <param name="right">Ein Ausdruck, der zum Definieren von rechts Mengenargument.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> , berechnet die Union der linken und rechten Argumente festlegen, ohne Duplikate.</summary>
        <returns>Eine neue "DbExpression", die berechnet die Union, ohne Duplikate, die von der die linke und rechte Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gemeinsamen Auflistungsergebnistyp mit einem auf Gleichheit vergleichbar Elementtyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnionAll">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbUnionAllExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der zum Definieren der linken Seite Mengenargument.</param>
        <param name="right">Ein Ausdruck, der zum Definieren von rechts Mengenargument.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbUnionAllExpression" /> , berechnet die Union der linken und rechten Argumente und Duplikate nicht entfernt.</summary>
        <returns>Eine neue DbUnionAllExpression, Union, einschließlich der Duplikate, von der die linke und rechte Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Keine gemeinsamen Auflistungsergebnistyp mit einem auf Gleichheit vergleichbar Elementtyp besteht zwischen <paramref name="left" /> und <paramref name="right" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbVariableReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der Variable, auf die verwiesen wird.</param>
        <param name="name">Der Name der Variable, auf die verwiesen wird.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" /> , die auf eine Variable mit dem angegebenen Namen und Typ verweist.</summary>
        <returns>Einen DbVariableReferenceExpression, der einen Verweis auf eine Variable mit dem angegebenen Namen und Typ darstellt. Der Ergebnistyp des Ausdrucks ist identisch mit <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Where (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Where(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="predicate">Eine Methode, die das Prädikat, das für jeden Member des Eingabesets ausgewertet darstellt.    Diese Methode muss es sich um einen Ausdruck mit einem booleschen Wert als Ergebnistyp erzeugen, die das Prädikat Logik bereitstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" /> , filtert die Elemente in der angegebenen Eingabesets mithilfe des angegebenen Prädikats.</summary>
        <returns>Eine neue DbQuantifierExpression, die die jeden Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der von <paramref name="predicate" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
