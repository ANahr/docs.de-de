<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die Windows-zugriffssteuerungssicherheit für ein benanntes Semaphor dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt gibt an, über Zugriffsrechte für ein benanntes Systemsemaphor und gibt außerdem an, wie Zugriffsversuche überwacht werden. Über die Zugriffsrechte für das Semaphor werden als Regeln ausgedrückt, mit jeder Zugriffsregel durch eine <xref:System.Security.AccessControl.SemaphoreAccessRule> Objekt. Jede Überwachungsregel wird dargestellt, indem ein <xref:System.Security.AccessControl.SemaphoreAuditRule> Objekt.  
  
 Dies spiegelt den zugrunde liegenden Windows-Sicherheitssystem, in dem jedes sicherungsfähige Objekt verfügt über höchstens einen besitzerverwaltete Zugriffssteuerungsliste (DACL), steuert den Zugriff auf gesicherte Objekt und darf höchstens eine Systemzugriffssteuerungsliste (SACL), der angibt, denen der Zugriff Versuche werden überwacht. Die DACL und SACL sind Listen von Zugriffssteuerungseinträgen (ACE) sortiert, die Zugriff und die Überwachung für Benutzer und Gruppen angeben. Ein <xref:System.Security.AccessControl.SemaphoreAccessRule> oder <xref:System.Security.AccessControl.SemaphoreAuditRule> Objekt möglicherweise mehr als ein ACE darstellen.  
  
> [!NOTE]
>  Ein <xref:System.Threading.Semaphore> Objekt kann ein lokales Semaphor oder ein benanntes Systemsemaphor darstellen. Windows-zugriffssteuerungssicherheit ist nur für System benannte Semaphoren sinnvoll.  
  
 Die <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule>, und <xref:System.Security.AccessControl.SemaphoreAuditRule> Klassen blenden die Implementierungsdetails von ACLs und ACEs. Sie können damit siebzehn verschiedenen ACE-Typen und die Komplexität der ordnungsgemäßen Verwaltung der Vererbung und Weitergabe von Zugriffsrechten ignorieren. Diese Objekte sind aber auch zu verhindern, dass die folgenden häufigen Zugriffssteuerungsfehler konzipiert:  
  
-   Erstellen eine Sicherheitsbeschreibung mit einer null-DACL an. Ein null-Verweis auf eine DACL ermöglicht allen Benutzern auf ein Objekt, das potenziell erstellen einen Denial-of-Service-Angriff Zugriffsregeln hinzufügen. Ein neues <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt beginnt immer mit einer leeren DACL, die für alle Benutzer der Zugriff verweigert wird.  
  
-   Verletzung der die kanonische Reihenfolge der ACEs. Wenn die ACE-Liste in die DACL nicht kanonische Reihenfolge gehalten wird, möglicherweise versehentlich auf Benutzer Zugriff auf das gesicherte Objekt gewährt werden. Verweigerte Zugriffsrechte müssen z. B. immer vor zulässigen Zugriffsrechte aufgeführt werden. <xref:System.Security.AccessControl.SemaphoreSecurity>Objekte beibehalten die richtige Reihenfolge intern.  
  
-   Bearbeiten von Security Descriptor Flags, die nur Ressourcen-Manager-gesteuert werden soll.  
  
-   Das Erstellen ungültiger Kombinationen von ACE-Flags.  
  
-   Bearbeiten von geerbten ACEs aus. Vererbung und Weitergabe werden von den Ressourcen-Manager als Reaktion auf Änderungen behandelt, die Sie Zugriffs-und Überwachungsregeln vornehmen.  
  
-   Einfügen von bedeutungslosen ACEs in ACLs aus.  
  
 Die nur Funktionen, die nicht durch die Sicherheitsobjekte .NET unterstützt werden gefährliche Aktivitäten, die von der Mehrheit der Anwendungsentwickler, z. B. die folgenden vermieden werden sollte:  
  
-   Low-Level-Aufgaben, die normalerweise von den Ressourcen-Manager ausgeführt werden.  
  
-   Hinzufügen oder Entfernen von Zugriffssteuerungseinträgen Möglichkeiten, die die kanonische Reihenfolge nicht beibehalten.  
  
 Zum Ändern der Windows-zugriffssteuerungssicherheit für ein benanntes Semaphor verwendet die <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> Methode zum Abrufen der <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt. Ändern Sie das Sicherheitsobjekt durch Hinzufügen und Entfernen von Regeln, und verwenden Sie dann die <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> -Methode erneut an.  
  
> [!IMPORTANT]
>  Änderungen an einer <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt haben keinen Einfluss auf die Zugriffsebenen der das benannte Semaphor erst nach dem Aufruf der <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> Methode, um das benannte Semaphor geänderte Sicherheitsobjekts zuweisen.  
  
 Um zugriffssteuerungssicherheit aus einem Semaphor in einen anderen kopieren möchten, verwenden die <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> Methode zum Abrufen einer <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt, das die Zugriffs- und Überwachungsrichtlinien Regeln für das erste Semaphor darstellt, verwenden Sie die <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> Methode oder einen Konstruktor, der eine akzeptiert<xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, das zweite Semaphor diese Regeln zuweisen.  
  
 Benutzer mit einer Investition in Security Descriptor Definition Language (SDDL) können die <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Methode, um die festgelegten Zugriffsregeln für ein benanntes Semaphor, und die <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> Methode, um eine Zeichenfolge abzurufen, die die Zugriffsregeln im SDDL-Format darstellt. Dies ist nicht für Neuentwicklungen empfohlen.  
  
> [!NOTE]
>  Sicherheit auf Synchronisierungsobjekte ist Windows 98 oder Windows Millennium Edition nicht unterstützt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Trennung zwischen <xref:System.Security.AccessControl.AccessControlType.Allow> Regeln und <xref:System.Security.AccessControl.AccessControlType.Deny> Regeln und die Kombination der Rechte auf kompatible Regeln anzeigt. Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu und zeigt das resultierende Paar von Regeln. Anschließend können Sie neue Rechte für den aktuellen Benutzer und das Ergebnis wird angezeigt, dass der neuen Rechte mit dem vorhandenen zusammengeführt werden <xref:System.Security.AccessControl.AccessControlType.Allow> Regel.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Klasse mit Standardwerten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein neues <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt beginnt immer mit einer leeren freigegebenen Zugriffssteuerungsliste (DACL), die für alle Benutzer der Zugriff verweigert wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Klasse wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Systemsemaphors, deren Sicherheit Zugriffssteuerungsregeln werden abgerufen werden sollen.</param>
        <param name="includeSections">Eine Kombination von <see cref="T:System.Security.AccessControl.AccessControlSections" /> Flags, die die abzurufenden Abschnitte angeben.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> -Klasse mit den angegebenen Abschnitten von Zugriffssteuerungsregeln-Sicherheit über das Systemsemaphor mit dem angegebenen Namen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor können Sie die zugriffssteuerungssicherheit für ein benanntes Systemsemaphor abrufen, ohne zuvor einen <xref:System.Threading.Semaphore> Objekt.  
  
 Bei der Arbeit mit benannten Systemobjekte Vorsicht. Es ist ein Systemobjekt, das mit dem Namen `name` keine Semaphore ist, kann die Sicherheit der Steuerelement-Zugriff abgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Klasse wird unter Windows 98 oder Windows Millennium Edition nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Enumeration ab, die die <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> -Klasse Zugriffsrechte darstellt.</summary>
        <value>Ein <see cref="T:System.Type" /> Objekt darstellt der <see cref="T:System.Security.AccessControl.SemaphoreRights" /> Enumeration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> -Klasse überschreiben die <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> -Eigenschaft und der Rückgabewert den Typ, die sie verwenden, um die Darstellung von Zugriffsrechten. Beim Arbeiten mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Enumerationstyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Ein <see cref="T:System.Security.Principal.IdentityReference" /> , identifiziert des Benutzers oder Gruppe die Regel gilt.</param>
        <param name="accessMask">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.SemaphoreRights" /> Werte angibt, die Zugriffsrechte gewähren oder verweigern, eine ganze Zahl umgewandelt.</param>
        <param name="isInherited">Ohne Bedeutung für benannte Semaphoren, da sie keine Hierarchie aufweisen.</param>
        <param name="inheritanceFlags">Ohne Bedeutung für benannte Semaphoren, da sie keine Hierarchie aufweisen.</param>
        <param name="propagationFlags">Ohne Bedeutung für benannte Semaphoren, da sie keine Hierarchie aufweisen.</param>
        <param name="type">Eines der <see cref="T:System.Security.AccessControl.AccessControlType" /> Werte, die angibt, ob die Rechte gewährt oder verweigert werden.</param>
        <summary>Erstellt eine neue Zugriffsregel für den angegebenen Benutzer mit den angegebenen Zugriffsrechten, Zugriffssteuerung und Flags.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Objekt, das die angegebenen Berechtigungen für den angegebenen Benutzer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Methode zum Erstellen von Zugriffssteuerungsregeln ist die Verwendung von den Konstruktoren für die <xref:System.Security.AccessControl.SemaphoreAccessRule> Klasse.  
  
> [!NOTE]
>  Obwohl Vererbung und Weitergabe Flags für benannte Semaphoren bedeutungslos sind, ist es weiterhin möglich, geben sie dies nicht empfohlen, die da es unnötig die Verwaltung der Regeln, z. B. etwas komplizierter macht durch die Kombination von Regeln stören Andernfalls würde, die kompatibel sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, oder <paramref name="type" /> gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="accessMask" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" />ist nicht vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" />, noch von einem Typ, z. B. <see cref="T:System.Security.Principal.NTAccount" /> , die konvertiert werden kann, auf den Typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, die die <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> -Klasse Zugriffsregeln darstellt.</summary>
        <value>Ein <see cref="T:System.Type" /> Objekt darstellt der <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> -Klasse überschreiben die <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> Eigenschaft und die Rückgabewerte der Darstellung von Zugriffsregeln Typ. Bei der Arbeit mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Zugriffsregeltyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die Zugriffsregel hinzufügen.</param>
        <summary>Sucht nach einer Abgleichsregel, mit der die neue Regel zusammengeführt werden kann. Wenn keiner gefunden werden, fügt die neue Regel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> Methode sucht Regeln mit dem gleichen Benutzer oder die Gruppe und die gleiche <xref:System.Security.AccessControl.AccessControlType> als `rule`. Wenn keiner gefunden werden, `rule` hinzugefügt wird. Wenn eine entsprechende Regel gefunden wird, wird die Rechte in `rule` mit einer vorhandenen Regel zusammengeführt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Trennung zwischen <xref:System.Security.AccessControl.AccessControlType.Allow> Regeln und <xref:System.Security.AccessControl.AccessControlType.Deny> Regeln und die Kombination der Rechte auf kompatible Regeln anzeigt. Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu und zeigt das resultierende Paar von Regeln. Anschließend können Sie neue Rechte für den aktuellen Benutzer und das Ergebnis wird angezeigt, dass der neuen Rechte mit dem vorhandenen zusammengeführt werden <xref:System.Security.AccessControl.AccessControlType.Allow> Regel.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die hinzuzufügende Überwachungsregel. Durch diese Regel angegebene Benutzer bestimmt die Suche.</param>
        <summary>Sucht eine Überwachungsregel mit der die neue Regel zusammengeführt werden kann. Wenn keiner gefunden werden, fügt die neue Regel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> Methode sucht nach Regeln mit dem gleichen Benutzer oder Gruppe als `rule`. Wenn keiner gefunden werden, `rule` hinzugefügt wird. Wenn eine entsprechende Regel gefunden wird, werden die Flags in `rule` in die vorhandene Regel zusammengeführt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Ein <see cref="T:System.Security.Principal.IdentityReference" /> , identifiziert des Benutzers oder Gruppe die Regel gilt.</param>
        <param name="accessMask">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.SemaphoreRights" /> Werte angibt, die Zugriffsrechte zu überwachen, um eine ganze Zahl umgewandelt.</param>
        <param name="isInherited">Ohne Bedeutung für benannte Wait-Handles, da sie keine Hierarchie aufweisen.</param>
        <param name="inheritanceFlags">Ohne Bedeutung für benannte Wait-Handles, da sie keine Hierarchie aufweisen.</param>
        <param name="propagationFlags">Ohne Bedeutung für benannte Wait-Handles, da sie keine Hierarchie aufweisen.</param>
        <param name="flags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.AuditFlags" /> Werte, die angeben, ob erfolgreiche oder fehlgeschlagene überwacht.</param>
        <summary>Erstellt eine neue Überwachungsregel, die den Benutzer angibt, den die Regel an, die Zugriffsrechte zu überwachen und das Ergebnis, das die Überwachungsregel gilt.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Objekt, das die angegebene Überwachungsregel für den angegebenen Benutzer darstellt. Der Rückgabetyp der Methode ist die Basisklasse <see cref="T:System.Security.AccessControl.AuditRule" />, aber der Rückgabewert der abgeleiteten Klasse sicher umgewandelt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Methode zum Erstellen von Überwachungsregeln ist die Verwendung von den Konstruktoren für die <xref:System.Security.AccessControl.SemaphoreAuditRule> Klasse.  
  
> [!NOTE]
>  Obwohl Vererbung und Weitergabe Flags für benannte Semaphoren bedeutungslos sind, ist es weiterhin möglich, anzugeben. Dies wird nicht empfohlen, da sie unnötig die Verwaltung der Regeln, z. B. kompliziert durch die Kombination von Regeln, die sonst kompatibel stören.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, oder <paramref name="flags" /> gibt einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="accessMask" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" />ist nicht vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" />, noch von einem Typ, z. B. <see cref="T:System.Security.Principal.NTAccount" /> , die konvertiert werden kann, auf den Typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, die die <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> -Klasse Überwachungsregeln darstellt.</summary>
        <value>Ein <see cref="T:System.Type" /> Objekt darstellt der <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen die <xref:System.Security.AccessControl.ObjectSecurity> -Klasse überschreiben die <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> -Eigenschaft und der Rückgabewert den Typ, die sie verwenden, um die Überwachung für die Darstellung. Bei der Arbeit mit Arrays oder Auflistungen, die mehrere Typen der Sicherheitsobjekte enthalten, verwenden Sie diese Eigenschaft, um zu bestimmen, den richtigen Audit Regeltyp mit einzelnen Sicherheitsobjekts verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Ein <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> , der angibt, dass des Benutzers und <see cref="T:System.Security.AccessControl.AccessControlType" /> zum Durchsuchen und einen Satz von Vererbung und Weitergabe Flags, die eine entsprechende Regel, wenn gefunden wird, muss mit kompatibel sein. Gibt an, dass die Rechte, die aus der kompatiblen Regel entfernt werden sollen, wenn gefunden.</param>
        <summary>Sucht nach einer Zugriffssteuerungsregel mit demselben Benutzer und <see cref="T:System.Security.AccessControl.AccessControlType" /> (zulassen oder verweigern) als die angegebene Regel und kompatible Vererbung und Weitergabeflags; Wenn eine solche Regel gefunden wird, die in die angegebene Regel enthaltenen Rechte werden entfernt daraus.</summary>
        <returns>
          <see langword="true" />Wenn eine kompatible Regel gefunden wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.SemaphoreSecurity> wird für eine Regel mit demselben Benutzer und die gleiche durchsucht <xref:System.Security.AccessControl.AccessControlType> als Wert `rule`. Wenn keine solche Regel gefunden wird, wird keine Aktion ausgeführt, und die Methode gibt `false`. Wenn Abgleichsregeln gefunden werden, werden ihre Kompatibilität und Vererbung-Flags für die Kompatibilität mit den Flags, die im angegebenen überprüft `rule`. Wenn keine kompatible Regel gefunden wird, wird keine Aktion ausgeführt, und die Methode gibt `false`. Wenn eine Regel mit kompatiblen Flags gefunden wird, wird die Rechte in angegebenen `rule` werden aus der kompatiblen Regel entfernt und die Methode gibt `true`. Wenn `rule` gibt die Rechte, die nicht in der kompatiblen Regel enthalten sind, in Bezug auf diese Rechte wird keine Aktion ausgeführt. Wenn alle Rechte aus der kompatiblen Regel entfernt werden, wird die gesamte Regel aus dem aktuellen entfernt <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt.  
  
> [!IMPORTANT]
>  Obwohl Sie die Vererbung und Weitergabe Flags für Zugriffsregeln Semaphore, angeben können, erstellen sie mit der <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> -Methode, dies wird nicht empfohlen. Vererbung und Weitergabe haben keine Bedeutung für benannte Semaphoren, und sie machen die Wartung von Zugriffsregeln komplizierter.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> -Methode zum Entfernen von Berechtigungen eine <xref:System.Security.AccessControl.AccessControlType.Allow> Regel einer <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt. Darüber hinaus wird gezeigt, dass andere Rechte in `rule` werden ignoriert.  
  
 Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt und fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu. Die Rechte gewährt: <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, und <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>. Das Beispiel erstellt dann eine neue Regel für den aktuellen Benutzer einschließlich <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> und <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> Rechte, und mithilfe der Regel mit der <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> -Methode zum Entfernen <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> aus der <xref:System.Security.AccessControl.AccessControlType.Allow> -Regel in der <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt. Die unnötige <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> mit der rechten Maustaste im `rule` wird ignoriert.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Ein <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> , der angibt, dass des Benutzers und <see cref="T:System.Security.AccessControl.AccessControlType" /> gesucht. Alle von dieser Regel festgelegten Rechte werden ignoriert.</param>
        <summary>Sucht nach allen Zugriffssteuerungsregeln mit demselben Benutzer und <see cref="T:System.Security.AccessControl.AccessControlType" /> (zulassen oder verweigern) wie die angegebene Regel und, wenn es gefunden wurde, entfernt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt wird für Regeln mit demselben Benutzer und die gleiche durchsucht <xref:System.Security.AccessControl.AccessControlType> als Wert `rule`. Alle Rechte `rule` beim Ausführen dieser Suche werden ignoriert. Wenn keine übereinstimmenden Regeln gefunden werden, wird keine Aktion ausgeführt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, dass die <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> -Methode entfernt alle Regeln, die Benutzer zu entsprechen und <xref:System.Security.AccessControl.AccessControlType>, Rechte ignoriert.  
  
 Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu und führt dann zusätzliche Rechte in der <xref:System.Security.AccessControl.AccessControlType.Allow> Regel. Das Beispiel erstellt dann eine neue Regel, die ermöglicht es dem aktuellen Benutzer in Besitz zu nehmen, und entfernen Sie mithilfe der Regel die <xref:System.Security.AccessControl.AccessControlType.Allow> Regel aus der <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das zu entfernende <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />-Element.</param>
        <summary>Sucht nach einer Zugriffssteuerungsregel an, die mit dem angegebenen übereinstimmt Regel und, wenn es gefunden wurde, entfernt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regel entfernt wird, nur dann, wenn sie genau `rule` in alle Details, einschließlich der Flags. Andere Regeln mit demselben Benutzer und <xref:System.Security.AccessControl.AccessControlType> sind nicht betroffen.  
  
> [!IMPORTANT]
>  Eine Regel darstellt, eine oder mehrere zugrunde liegenden Zugriffssteuerungseinträge (ACE), und diese Einträge werden aufgeteilt oder nach Bedarf kombiniert werden, wenn Sie die Zugriffsregeln für die Sicherheit für einen Benutzer ändern. Daher eine Regel ist nicht mehr vorhanden, in der bestimmten Form er hatte, als er hinzugefügt wurde, und klicken Sie in diesem Fall die <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> Methode nicht entfernen können.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, dass die <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> Methode erfordert eine genaue Übereinstimmung, um eine Regel zu entfernen und Regeln zum Zulassen und Verweigern von Berechtigungen sind unabhängig voneinander.  
  
 Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu und führt dann zusätzliche Rechte in der <xref:System.Security.AccessControl.AccessControlType.Allow> Zugriffsregel. Im Beispiel übergibt dann die ursprüngliche <xref:System.Security.AccessControl.AccessControlType.Allow> -Regel an die <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> -Methode, und zeigt die Ergebnisse, die anzeigt, dass nichts gelöscht wird. Im Beispiel wird dann eine Regel, die entspricht, erstellt der <xref:System.Security.AccessControl.AccessControlType.Allow> Regel "" die <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt und erfolgreich verwendet die <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> Methode, um die Regel zu entfernen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Ein <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> , den Benutzer suchen und einen Satz von Vererbung und Weitergabe Flags, die einen übereinstimmenden auszuschließen, angibt, falls gefunden, die mit kompatibel sein müssen. Gibt an, dass die Rechte, die aus der kompatiblen Regel entfernt werden sollen, wenn gefunden.</param>
        <summary>Sucht nach einem Steuerelement Überwachungsregel mit dem gleichen Benutzer als die angegebene Regel und kompatible Vererbung und Weitergabeflags; Wenn eine kompatible Regel gefunden wird, werden die in die angegebene Regel enthaltenen Rechte daraus entfernt.</summary>
        <returns>
          <see langword="true" />Wenn eine kompatible Regel gefunden wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.SemaphoreSecurity> wird eine Überwachungsregel, die denselben Benutzer wie gesucht `rule`. Wenn keine solche Regel gefunden wird, wird keine Aktion ausgeführt, und die Methode gibt `false`. Wenn Abgleichsregeln gefunden werden, werden ihre Kompatibilität und Vererbung-Flags für die Kompatibilität mit den Flags, die im angegebenen überprüft `rule`. Wenn keine kompatible Regel gefunden wird, wird keine Aktion ausgeführt, und die Methode gibt `false`. Wenn eine Regel mit kompatiblen Flags gefunden wird, wird die Rechte in angegebenen `rule` werden aus der kompatiblen Regel entfernt und die Methode gibt `true`. Wenn `rule` gibt die Rechte, die nicht in der kompatiblen Regel enthalten sind, in Bezug auf diese Rechte wird keine Aktion ausgeführt. Wenn alle Rechte aus der kompatiblen Regel entfernt werden, wird die gesamte Regel aus dem aktuellen entfernt <xref:System.Security.AccessControl.SemaphoreSecurity> Objekt.  
  
> [!IMPORTANT]
>  Obwohl Sie die Vererbung und Weitergabe Flags für Überwachungsregeln Semaphore, angeben können, erstellen sie mit der <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> -Methode, dies wird nicht empfohlen. Vererbung und Weitergabe haben keine Bedeutung für benannte Semaphoren, und sie machen die Pflege Überwachungsregeln komplizierter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Ein <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> , die den zu suchenden Benutzers angibt. Alle von dieser Regel festgelegten Rechte werden ignoriert.</param>
        <summary>Sucht für alle Regeln mit demselben Benutzer wie die angegebene Regel überwachen und, sofern gefunden, entfernt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.SemaphoreSecurity> wird gesucht Überwachungsregeln, die denselben Benutzer wie `rule`. Alle Rechte `rule` beim Ausführen dieser Suche werden ignoriert. Alle Abgleichsregeln werden entfernt. Wenn keine übereinstimmenden Regeln gefunden werden, wird keine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das zu entfernende <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />-Element.</param>
        <summary>Sucht nach einer Überwachungsregel, die genau mit dem angegebenen übereinstimmt Regel und, wenn es gefunden wurde, entfernt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regel entfernt wird, nur dann, wenn sie genau `rule` in alle Details, einschließlich der Flags. Andere Überwachungsregeln für denselben Benutzer sind nicht betroffen.  
  
> [!IMPORTANT]
>  Eine Regel darstellt, eine oder mehrere zugrunde liegenden Zugriffssteuerungseinträge (ACE), und diese Einträge werden aufgeteilt oder nach Bedarf kombiniert werden, wenn Sie die Überwachungssicherheitsregeln für einen Benutzer ändern. Daher eine Regel ist nicht mehr vorhanden, in der bestimmten Form er hatte, als er hinzugefügt wurde, und klicken Sie in diesem Fall die <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> Methode nicht entfernen können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das hinzuzufügende <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />. Durch diese Regel angegebene Benutzer bestimmt die Regeln zu entfernen, bevor diese Regel hinzugefügt wird.</param>
        <summary>Entfernt alle Zugriffsregeln mit dem gleichen Benutzer als die angegebene Regel unabhängig von <see cref="T:System.Security.AccessControl.AccessControlType" />, und fügt dann die angegebene Regel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es keine Access-Regeln sind, deren Benutzer, die angegebene Regel übereinstimmt `rule` hinzugefügt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht wie die <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> Methode ersetzt alle Regeln für den übereinstimmenden Benutzer durch die Regel für die Übereinstimmung angegeben.  
  
 Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt und fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu. Das Beispiel erstellt dann eine neue Regel, die der aktuelle Benutzer Vollzugriff, und mithilfe der <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> Methode, um sowohl die bestehenden Regeln mit der neuen Regel zu ersetzen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das hinzuzufügende <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />. Der Benutzer und <see cref="T:System.Security.AccessControl.AccessControlType" /> gegen diese Regel bestimmen die Regeln zu entfernen, bevor diese Regel hinzugefügt wird.</param>
        <summary>Entfernt alle Zugriffssteuerungsregeln mit demselben Benutzer und <see cref="T:System.Security.AccessControl.AccessControlType" /> (zulassen oder verweigern) als die angegebene Regel und fügt dann die angegebene Regel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Regel hat <xref:System.Security.AccessControl.AccessControlType.Allow>, die Auswirkungen dieser Methode sind alle entfernen <xref:System.Security.AccessControl.AccessControlType.Allow> Regeln für den angegebenen Benutzer, die sie durch die angegebene Regel ersetzt werden. Wenn die angegebene Regel hat <xref:System.Security.AccessControl.AccessControlType.Deny>, dass alle <xref:System.Security.AccessControl.AccessControlType.Deny> Regeln für den angegebenen Benutzer durch die angegebene Regel ersetzt werden.  
  
 Wenn es keine Regeln, deren Benutzer sind und <xref:System.Security.AccessControl.AccessControlType> entsprechen die angegebene Regel `rule` hinzugefügt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht wie die <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> -Methode entfernt alle Regeln, die sowohl mit den Benutzer entsprechen und die <xref:System.Security.AccessControl.AccessControlType> von `rule`, ersetzen sie mit `rule`.  
  
 Das Beispiel erstellt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt und fügt die Regeln, die zulassen und verweigern verschiedene Rechte für den aktuellen Benutzer hinzu. Das Beispiel erstellt dann eine neue Regel, die der aktuelle Benutzer Vollzugriff, und mithilfe der <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> Methode zum Ersetzen des vorhandenen Zulassungsregel mit der neuen Regel. Die Regel, die Zugriff ablehnt, wird nicht beeinflusst.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheitsobjekt, nicht angefügt ein <xref:System.Threading.Semaphore> Objekt. Beispiele, die Sicherheitsobjekte angefügt werden, finden Sie <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> und <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das hinzuzufügende <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />. Durch diese Regel angegebene Benutzer bestimmt die Regeln zu entfernen, bevor diese Regel hinzugefügt wird.</param>
        <summary>Entfernt alle mit demselben Benutzer als die angegebene Regel unabhängig von Überwachungsregeln der <see cref="T:System.Security.AccessControl.AuditFlags" /> -Wert und fügt dann die angegebene Regel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es keine Überwachungsregeln sind, deren Benutzer, die angegebene Regel übereinstimmt `rule` hinzugefügt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
