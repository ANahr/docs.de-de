<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Gibt den Typ der Elemente im Stapel an.</typeparam>
    <summary>Stellt eine LIFO (Last-In-First-Out)-Auflistung variabler Größe von Instanzen desselben angegebenen Typs dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601>wird als Array implementiert.  
  
 Aufruflisten und Warteschlangen sind nützlich, wenn Sie die temporäre Speicherung für Informationen benötigen; d. h., wenn sein soll ein Element zu verwerfen, sobald dessen Wert abgerufen. Verwendung <xref:System.Collections.Generic.Queue%601> Wenn müssen Sie die Informationen in der gleichen Reihenfolge zugegriffen werden, dass er in der Auflistung gespeichert wird. Verwendung <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> Wenn Sie die Informationen in umgekehrter Reihenfolge zugreifen müssen.  
  
 Verwenden der <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> und <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> Typen, wenn Sie die Sammlung von mehreren Threads gleichzeitig zugreifen müssen.  
  
 Eine übliche Verwendung für <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> ist Variable Status während der Aufrufe anderer Prozeduren erhalten bleiben.  
  
 Drei wichtigsten Operationen ausgeführt werden können, auf eine <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> und seine Elemente:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A>Fügt ein Element am Anfang der <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A>Entfernt ein Element vom Anfang der <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A>Gibt ein Element am Anfang der <xref:System.Collections.Generic.Stack%601> jedoch nicht aus entfernt die <xref:System.Collections.Generic.Stack%601>.  
  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente der <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.Stack%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich. Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> ist kleiner als die Kapazität des Stapels <xref:System.Collections.Generic.Stack%601.Push%2A> ist ein o(1)-Vorgang. Wenn die Kapazität erhöht werden, um das neue Element aufzunehmen muss <xref:System.Collections.Generic.Stack%601.Push%2A> wird eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A>ist ein o(1)-Vorgang.  
  
 <xref:System.Collections.Generic.Stack%601>akzeptiert `null` als ein gültiger Wert für Referenztypen und doppelte Elemente lässt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generische Klasse. Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
 Ein <see cref="T:System.Collections.Generic.Stack`1" /> Unterstützung für mehrere Reader gleichzeitig, solange die Auflistung nicht geändert wird.  Deshalb ist die Enumeration einer Auflistung systemintern kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.Stack`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.Stack%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.Stack%601>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, diesen Konstruktor und verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generische Klasse.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, aus der Elemente kopiert werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.Stack`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.Stack%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.Stack%601>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Die Elemente kopiert werden, auf die <xref:System.Collections.Generic.Stack%601> in der gleichen Reihenfolge, die sie gelesen werden, indem Sie die <xref:System.Collections.Generic.IEnumerator%601> der Auflistung.  
  
 Dieser Konstruktor ist eine O (`n`) Vorgang, wobei `n` ist die Anzahl der Elemente im `collection`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, diesen Konstruktor und verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generische Klasse.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die anfängliche Anzahl von Elementen, die das <see cref="T:System.Collections.Generic.Stack`1" /> enthalten kann.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Collections.Generic.Stack`1" /> -Klasse, ist leer und verfügt über die angegebene anfängliche Kapazität oder der anfänglichen Standardkapazität, welcher Wert größer ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.Stack%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben entfällt die Notwendigkeit einer Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <xref:System.Collections.Generic.Stack%601>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Dieser Konstruktor ist eine O (`n`) Vorgang, wobei `n` ist `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Objekte aus dem <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A>ist auf 0 (null) festgelegt, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  
  
 Die Kapazität bleibt unverändert. Die Kapazität des Zurücksetzen der <xref:System.Collections.Generic.Stack%601>, rufen Sie <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Indem Sie eine leere <xref:System.Collections.Generic.Stack%601> legt die Kapazität der <xref:System.Collections.Generic.Stack%601> auf die festgelegte Standardkapazität.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.Stack`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.Stack`1" /> befindet.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.Stack`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standardgleichheitsvergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, der Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.Stack`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die <see cref="T:System.Collections.Generic.Stack`1" /> in ein vorhandenes eindimensionales <see cref="T:System.Array" />, beginnend am angegebenen Arrayindex begonnen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, auf das Array in der Last in First Out (LIFO)-Reihenfolge die Elemente einer Folge von Aufrufen an zurückgegebenes <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.Stack`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.Stack`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.Generic.Stack`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität der <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> speichern können. <xref:System.Collections.Generic.Stack%601.Count%2A>ist die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.Generic.Stack%601>.  
  
 Die Kapazität ist immer größer als oder gleich <xref:System.Collections.Generic.Stack%601.Count%2A>. Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> überschreitet die Kapazität beim Hinzufügen von Elementen, die Kapazität wird erhöht, indem automatisch Neuzuordnen des internen Arrays vor dem Kopieren der alten Elemente und das Hinzufügen neuer Elemente.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator für die <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> für das <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass die <xref:System.Collections.Generic.Stack%601> generische Klasse aufzählbar ist. Die `foreach` Anweisung (`For Each` in Visual Basic `for each` in C++) wird verwendet, um die Auflistung der Warteschlange.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Objekt am Anfang der <see cref="T:System.Collections.Generic.Stack`1" /> ohne es zu entfernen.</summary>
        <returns>Das Objekt am Anfang der <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode, aber <xref:System.Collections.Generic.Stack%601.Peek%2A> ändert die <xref:System.Collections.Generic.Stack%601> nicht.  
  
 Wenn Typ `T` ist ein Verweistyp `null` geschoben werden können, auf die <xref:System.Collections.Generic.Stack%601> als Platzhalter, wenn erforderlich.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.Stack`1" /> ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt, und gibt das Objekt am Anfang der <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Das Objekt entfernt vom oberen Rand der <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode, aber <xref:System.Collections.Generic.Stack%601.Peek%2A> ändert die <xref:System.Collections.Generic.Stack%601> nicht.  
  
 Wenn Typ `T` ist ein Verweistyp `null` geschoben werden können, auf die <xref:System.Collections.Generic.Stack%601> als Platzhalter, wenn erforderlich.  
  
 <xref:System.Collections.Generic.Stack%601>wird als Array implementiert. Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.Stack`1" /> ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das auf dem <see cref="T:System.Collections.Generic.Stack`1" /> abgelegt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt ein Objekt am Anfang des <see cref="T:System.Collections.Generic.Stack`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601>wird als Array implementiert.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> bereits gleich der Kapazität, die Kapazität der <xref:System.Collections.Generic.Stack%601> wird von automatisch Neuzuordnen des internen Arrays erhöht und die vorhandenen Elemente werden in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn Typ `T` ist ein Verweistyp `null` geschoben werden können, auf die <xref:System.Collections.Generic.Stack%601> als Platzhalter, wenn erforderlich. Belegt einen Slot im Stapel, und wie ein Objekt behandelt.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> ist kleiner als die Kapazität des Stapels <xref:System.Collections.Generic.Stack%601.Push%2A> ist ein o(1)-Vorgang. Wenn die Kapazität erhöht werden, um das neue Element aufzunehmen muss <xref:System.Collections.Generic.Stack%601.Push%2A> wird eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.Push%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generische Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  
  
 - oder -   
  
 <paramref name="array" />verfügt nicht über nullbasierter Indizierung.  
  
 - oder -   
  
 Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.  
  
 - oder -   
  
 Der Typ des Quell-<see cref="T:System.Collections.ICollection" />s kann nicht automatisch in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value>
          <see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.Stack`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  In seltenen Fällen, in denen Enumerationen mit Schreibzugriff greift auf Inhalte, müssen Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor der Zugriff auf die Auflistung.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.Stack`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor der Zugriff auf die Auflistung. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die <see cref="T:System.Collections.Generic.Stack`1" /> in ein neues Array.</summary>
        <returns>Ein neues Array mit Kopien der Elemente aus der <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, auf das Array in der Last in First Out (LIFO)-Reihenfolge die Elemente einer Folge von Aufrufen an zurückgegebenes <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse, einschließlich der <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichenfolgen mit Standardkapazität erstellt und verwendet die <xref:System.Collections.Generic.Stack%601.Push%2A> Methode, um fünf Zeichenfolgen auf dem Stapel abgelegt. Die Elemente im Stapel werden aufgelistet, die ändert nicht des Status des Stapels. Die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um die erste Zeichenfolge vom Stapel pop. Die <xref:System.Collections.Generic.Stack%601.Peek%2A> Methode wird verwendet, betrachten Sie das nächste Element im Stapel befindet, und klicken Sie dann die <xref:System.Collections.Generic.Stack%601.Pop%2A> Methode wird verwendet, um geholt.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A> Methode wird verwendet, um ein Array erstellen, und kopieren sie die Stapelelemente, und klicken Sie dann das Array übergeben wird, um die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor, akzeptiert <xref:System.Collections.Generic.IEnumerable%601>, erstellen mit der Reihenfolge der Elemente eine Kopie des Stapels rückgängig gemacht. Die Elemente des Kopiervorgangs werden angezeigt.  
  
 Ein Array mit der zweimal der Größe des Stapels erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A> Methode wird verwendet, um die Elemente des Arrays in der Mitte des Arrays ab. Die <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor verwendet, um die Erstellung einer Kopie des Stapels mit der Reihenfolge der Elemente, die umgekehrt; daher drei null-Elemente werden am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A> Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "4" in der ersten Kopie des Stapels, wonach die <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode löscht die Kopie und die <xref:System.Collections.Generic.Stack%601.Count%2A> Eigenschaft zeigt, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich im <see cref="T:System.Collections.Generic.Stack`1" /> befindlichen Elemente fest, sofern diese Anzahl unter 90 Prozent der aktuellen Kapazität liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um Speicher für eine Auflistung Mehraufwand zu minimieren, wenn die Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten erneut zugewiesen werden, und Kopieren einer großen <xref:System.Collections.Generic.Stack%601> jedoch sehr aufwändig sein kann daher die <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> Methode bewirkt nichts, wenn die Liste an mehr als 90 % der Kapazität ist. Dadurch wird vermieden, für einen relativ kleinen zu großen neuzuordnungen Kosten anfallen.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Zurücksetzen einer <xref:System.Collections.Generic.Stack%601> Aufrufen auf ihren ursprünglichen Zustand der <xref:System.Collections.Generic.Stack%601.Clear%2A> Methode vor dem Aufruf <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> Methode. Indem Sie eine leere <xref:System.Collections.Generic.Stack%601> legt die Kapazität der <xref:System.Collections.Generic.Stack%601> auf die festgelegte Standardkapazität.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
