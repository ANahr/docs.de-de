<Type Name="SecurityTokenParameters" FullName="System.ServiceModel.Security.Tokens.SecurityTokenParameters">
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenParameters" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenParameters extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Security</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gibt eine <see langword="abstract" /> Klasse, die bei Implementierung Sicherheitstokenparameter darstellt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sicherheitstokenparameter bieten Informationen zu den Token (z.&#160;B. Tokentyp, Aussteller usw.), die vom Sicherheitsbindungselement angefordert werden.  
  
 Die Klassen der Sicherheitstokenparameter, die hiervon abgeleitet werden, sind eine Auflistung von Tokeneigenschaften und -methoden und werden für die Erstellung verschiedener Sicherheitsbindungselemente und Token verwendet. Nicht alle Eigenschaften sind für alle abgeleitete Klassen relevant. Zum Beispiel hat der <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.ReferenceStyle%2A> keine Relevanz bei einem ausgestellten Token (SAML-Token).  
  
   
  
## Examples  
 Der folgende Code zeigt eine benutzerdefinierte Überschreibung dieser Klasse mit dem Namen *CreditCardTokenParameters*.  
  
 [!code-csharp[c_CustomToken#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_customtoken/cs/source.cs#2)]
 [!code-vb[c_CustomToken#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_customtoken/vb/source.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Unterschied zwischen diesen Überladungen liegt im Ursprung der Instanzeigenschaftenwerte. Mit <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.%23ctor%2A> werden für sie die entsprechenden Standardwerte festgelegt. Mit <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.%23ctor%2A> werden sie aus der Instanz abgerufen, auf die der Eingabeparameter verweist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die neuen Instanzeigenschaftswerte werden auf ihre Standardwerte festgelegt:  
  
-   Für <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> ist <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.AlwaysToRecipient> festgelegt.  
  
-   Für <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.ReferenceStyle%2A> ist <xref:System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle.Internal> festgelegt.  
  
-   Für <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.RequireDerivedKeys%2A> ist `true` festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenParameters (System.ServiceModel.Security.Tokens.SecurityTokenParameters other);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Security.Tokens.SecurityTokenParameters other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.#ctor(System.ServiceModel.Security.Tokens.SecurityTokenParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="other">Die andere Instanz dieser Klasse.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />-Klasse aus einer anderen Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die neuen Instanzeigenschaftswerte werden auf die entsprechenden Werte in `other` festgelegt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SecurityTokenParameters Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Security.Tokens.SecurityTokenParameters Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SecurityTokenParameters</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klont eine andere Instanz dieser Klasseninstanz.</summary>
        <returns>Eine Kopie des <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" /> Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.Clone%2A>-Methode und die <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore%2A>-Methode folgen dem Kernentwurfsmuster. In diesem Muster führt diese Methode Validierungen durch und ruft anschließend <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore%2A> auf, bei dem es sich um eine `abstract`-Methode handelt, die in abgeleiteten Klassen zum Durchführen der Kernfunktionalität überschrieben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es ist nicht möglich, diese Instanz der Klasse zu klonen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected abstract System.ServiceModel.Security.Tokens.SecurityTokenParameters CloneCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Security.Tokens.SecurityTokenParameters CloneCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SecurityTokenParameters</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klont eine andere Instanz dieser Klasseninstanz.</summary>
        <returns>Ein <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" /> -Instanz, die Kopie darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.Clone%2A>-Methode und die <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore%2A>-Methode folgen dem Kernentwurfsmuster. <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CloneCore%2A>ist eine `abstract` Methode, die überschrieben wird, in abgeleiteten Klassen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateKeyIdentifierClause">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateKeyIdentifierClause (System.IdentityModel.Tokens.SecurityToken token, System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle referenceStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityToken token, valuetype System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle referenceStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.CreateKeyIdentifierClause(System.IdentityModel.Tokens.SecurityToken,System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="referenceStyle" Type="System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle" />
      </Parameters>
      <Docs>
        <param name="token">Das Token.</param>
        <param name="referenceStyle">Der Verweis-Stil des Sicherheitstokens.</param>
        <summary>Erstellt eine Schlüsselbezeichnerklausel für ein Token.</summary>
        <returns>Die schlüsselbezeichnerklausel für ein Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode muss in einer abgeleiteten Klasse implementiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAsymmetricKey">
      <MemberSignature Language="C#" Value="protected abstract bool HasAsymmetricKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAsymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.HasAsymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft einen Wert, der angibt, ob das Token über einen asymmetrischen Schlüssel verfügt.</summary>
        <value>
          <see langword="true" />, wenn das Token über einen asymmetrischen Schlüssel verfügt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asymmetrische Schlüssel werden bei Verschlüsselungen eingesetzt, die mit einem öffentlichen und einem privaten Schlüssel durchgeführt werden, zwischen denen eine mathematische Beziehung besteht. Der öffentliche Schlüssel wird überall verteilt, aber der private Schlüssel wird geheim gehalten. Bei der Verschlüsselung durch öffentliche Schlüssel ist kein Austausch eines gemeinsamen Schlüssels erforderlich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InclusionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode InclusionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode InclusionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Tokeneinschlussanforderungen ab oder legt sie fest.</summary>
        <value>Die tokeneinschlussanforderungen an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit den Tokeneinschlussanforderungen wird angegeben, ob das Token als Teil der Anforderung und Antwort serialisiert werden muss.  
  
 Die <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode> Enumeration hat die folgenden Werte:  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.AlwaysToInitiator>  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.AlwaysToRecipient>  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.Never>  
  
-   <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode.Once>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeSecurityTokenRequirement">
      <MemberSignature Language="C#" Value="protected abstract void InitializeSecurityTokenRequirement (System.IdentityModel.Selectors.SecurityTokenRequirement requirement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitializeSecurityTokenRequirement(class System.IdentityModel.Selectors.SecurityTokenRequirement requirement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InitializeSecurityTokenRequirement(System.IdentityModel.Selectors.SecurityTokenRequirement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requirement" Type="System.IdentityModel.Selectors.SecurityTokenRequirement" />
      </Parameters>
      <Docs>
        <param name="requirement">Die Anforderung des Sicherheitstokens.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse initialisiert eine sicherheitstokenanforderung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Tokenanforderung wird als Eingabe in den Sicherheits-Manager zur Verfügung gestellt, um einen Sicherheitstokenanbieter oder einen Sicherheitstokenauthentifizierer für das Token zu erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MatchesKeyIdentifierClause">
      <MemberSignature Language="C#" Value="protected virtual bool MatchesKeyIdentifierClause (System.IdentityModel.Tokens.SecurityToken token, System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle referenceStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool MatchesKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityToken token, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, valuetype System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle referenceStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.MatchesKeyIdentifierClause(System.IdentityModel.Tokens.SecurityToken,System.IdentityModel.Tokens.SecurityKeyIdentifierClause,System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
        <Parameter Name="referenceStyle" Type="System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle" />
      </Parameters>
      <Docs>
        <param name="token">Das Sicherheitstoken.</param>
        <param name="keyIdentifierClause">Die angegebene Schlüsselbezeichnerklausel.</param>
        <param name="referenceStyle">Der Verweis-Stil des Sicherheitstokens.</param>
        <summary>Gibt an, ob ein Token eine schlüsselbezeichnerklausel übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn das Token der Schlüsselbezeichnerklausel entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="referenceStyle" /> ist nicht <see cref="F:System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle.External" /> oder <see cref="F:System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle.Internal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReferenceStyle">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle ReferenceStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle ReferenceStyle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.ReferenceStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SecurityTokenReferenceStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Tokenverweisstil ab oder legt ihn fest.</summary>
        <value>Der Verweis-Stil für das Token.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Tokenverweisstil gibt an, wie in der SOAP-Nachricht auf das Token verwiesen wird.  
  
 Diese Eigenschaft gibt einen Member einer Enumeration zurück, mit der der gewünschte Verweisstil für die Generierung von Sicherheitstokenverweisen (STR) auf die Sicherheitstoken der Signatur- und Verschlüsselungselemente in der Nachricht festgelegt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein ungültiger Tokenverweisstil wurde mit <see langword="set" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="RequireDerivedKeys">
      <MemberSignature Language="C#" Value="public bool RequireDerivedKeys { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RequireDerivedKeys" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.RequireDerivedKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Schlüssel von den ursprünglichen Prüfschlüsseln abgeleitet werden können.</summary>
        <value>
          <see langword="true" />, wenn Schlüssel vom Tokenschlüssel abgeleitet werden müssen, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[indigo2](~/includes/indigo2-md.md)] muss Schlüssel vom Tokenschlüssel ableiten, wenn die Signatur und Verschlüsselung mit dem Token ausgeführt wírd.  
  
 Abgeleitete Schlüssel stammen aus sicheren Konversationen, in denen freigegebene Sicherheitskontexte bestehen, sodass auf alle Nachrichten in der Konversation die gleiche Sicherheitsstufe angewendet werden kann. Ein Sicherheitskontexttoken schließt einen freigegebenen geheimen Schlüssel ein, der für die Nachrichtensignierung und -verschlüsselung verwendet wird. Der freigegebene geheime Schlüssel wird verwendet, um abgeleitete Schlüssel zu erstellen. Um auch während langer Konversationen eine hohe Sicherheitsstufe aufrechtzuerhalten, können regelmäßig neue abgeleitete Schlüssel erstellt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsClientAuthentication">
      <MemberSignature Language="C#" Value="protected abstract bool SupportsClientAuthentication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsClientAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.SupportsClientAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft einen Wert, der angibt, ob das Token die Clientauthentifizierung unterstützt.</summary>
        <value>
          <see langword="true" />, wenn das Token die Clientauthentifizierung unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsClientWindowsIdentity">
      <MemberSignature Language="C#" Value="protected abstract bool SupportsClientWindowsIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsClientWindowsIdentity" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.SupportsClientWindowsIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft einen Wert, der angibt, ob das Token eine Windows-Identität zur Authentifizierung unterstützt.</summary>
        <value>
          <see langword="true" />, wenn das Token eine Windows-Identität zur Authentifizierung unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsServerAuthentication">
      <MemberSignature Language="C#" Value="protected abstract bool SupportsServerAuthentication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsServerAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.Tokens.SecurityTokenParameters.SupportsServerAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse ruft einen Wert, der angibt, ob das Token die Serverauthentifizierung unterstützt.</summary>
        <value>
          <see langword="true" />, wenn das Token die Serverauthentifizierung unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Security.Tokens.SecurityTokenParameters.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt eine Textdarstellung dieser Instanz der Klasse an.</summary>
        <returns>Eine Textdarstellung dieser Instanz der Klasse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode zeigt den Namen dieser Klasse, <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A>, <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.ReferenceStyle%2A> und <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.RequireDerivedKeys%2A> an.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
