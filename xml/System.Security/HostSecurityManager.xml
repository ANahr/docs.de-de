<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die Steuerung und die Anpassung des Verhaltens von Sicherheit für Anwendungsdomänen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Erstellen einer neuen <xref:System.AppDomain>, die common Language Runtime-Abfragen die <xref:System.AppDomainManager> das Vorhandensein einer <xref:System.Security.HostSecurityManager>, teilnimmt Entscheidungen über die Sicherheit für die <xref:System.AppDomain>.  Hosten von Anbietern sollten implementieren einen Host-Sicherheits-Manager, die von erben die <xref:System.Security.HostSecurityManager> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine sehr einfache Implementierung von einem <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
    <block subset="none" type="overrides">
      <para>Ein Mitglied einer <see cref="T:System.Security.HostSecurityManager" /> werden aufgerufen, wenn eine Assembly geladen ist, entweder implizit oder explizit wird. Die <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> und <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> Methoden müssen keine Assemblys laden, da auf diese Weise den Membern der führt die <see cref="T:System.Security.HostSecurityManager" /> rekursiv aufgerufen wird. Um Zirkelverweise zu vermeiden, erstellen Sie neue Instanzen von Klassen, die Assemblys geladen, entweder implizit oder explizit im Konstruktor der Klasse, die abgeleitet dazu <see cref="T:System.Security.HostSecurityManager" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.HostSecurityManager" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
        <block subset="none" type="overrides">
          <para>Erstellen Sie Instanzen von Klassen, die Assemblys, die entweder explizit oder implizit geladen wird, die in diesem Konstruktor verursachen kann.  Der Get-Accessor für die <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> Eigenschaft und die <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> und <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> Methoden werden aufgerufen, wenn eine Assembly geladen wird, und deren nachfolgende Laden der Assemblys dazu, Zirkuläre Verweise dass führt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Der Beweis für die Anwendung aktiviert werden.</param>
        <param name="activatorEvidence">Optional der Beweis für die Aktivierung einer Anwendungsdomäne.</param>
        <param name="context">Der Trust-Kontext.</param>
        <summary>Bestimmt, ob eine Anwendung ausgeführt werden soll.</summary>
        <returns>Ein Objekt, das Informationen zur Vertrauenswürdigkeit der Anwendung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden. Die grundlegende Implementierung ruft die Anwendung Sicherheits-Manager, um festzustellen, ob die Anwendung ausgeführt werden soll.  
  
 Den Aktivator Beweis verwendet der basisimplementierung nicht. Jedoch kann eine überschriebene Implementierung den Aktivator Beweis verwenden, um zu bestimmen, der Sicherheitsbeweise für die Anwendungsdomäne, bei dem Versuch, die Anwendung zu aktivieren.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> Methode für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationEvidence" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein <see cref="T:System.Runtime.Hosting.ActivationArguments" /> Objekt konnte nicht in den Anwendungsbeweis gefunden werden.  
  
 - oder -   
  
 Die <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" /> Eigenschaft in den Aktivierungsargumenten ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Security.Policy.ApplicationTrust" /> gewähren Menge enthält keine minimale Anforderung angegebene durch Festlegen der <see cref="T:System.ActivationContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Sicherheitsrichtlinie für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Die Sicherheitsrichtlinie für die aktuelle Anwendungsdomäne. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann in einer abgeleiteten Klasse überschrieben werden. Gibt die basisimplementierung immer `null`.  
  
 Diese Eigenschaft wird am aufgerufen <xref:System.AppDomain> Zeitpunkt der Erstellung. Er ermöglicht es einem Host bereitstellen eine Richtlinie für den aktuellen <xref:System.AppDomain>.  Eine Richtlinienebene umfasst Folgendes:  
  
-   Ein Satz von Codegruppen, die in einer einzelnen Stammstruktur organisiert werden.  
  
-   Ein Satz von benannten Berechtigungssätze, die durch die Codegruppen an Berechtigungen zu, dass der Code angehört Code erteilt werden verwiesen wird.  
  
-   Eine Liste der vollständig vertrauenswürdigen Assemblys.  
  
> [!IMPORTANT]
>  Finden Sie Hinweise zur Vererbung für den <xref:System.Security.HostSecurityManager> kritische Implementierungsinformationen-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Verwenden Sie zum Aktivieren der CAS-Richtlinie für die Kompatibilität mit früheren Versionen von .NET Framework die [ &lt;LegacyCasPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Flag, das die Richtlinie Sicherheitskomponenten relevant an den Host darstellt.</summary>
        <value>Einer der Enumerationswerte, der Komponenten der Sicherheitsrichtlinie angibt. Die Standardeinstellung ist <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann in einer abgeleiteten Klasse überschrieben werden. Gibt die basisimplementierung immer <xref:System.Security.HostSecurityManagerOptions.AllFlags>.  
  
 Der abgeleitete Host kann den Wert dieser Eigenschaft, wenn nur eine Teilmenge der Ändern der <xref:System.Security.HostSecurityManagerOptions> von Interesse ist.  Möglichen Teilmengen sind none, der verweigerte Berechtigungssatz, der Richtlinienebene und Assemblybeweis.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.Flags%2A> -Eigenschaft für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Der Beweistyp.</param>
        <summary>Fordert einen bestimmten Beweistyp für die Anwendungsdomäne.</summary>
        <returns>Der Beweis der angeforderten Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden. Gibt die grundlegende Implementierung `null`.  
  
 Die common Language Runtime ruft diese Methode auf, wenn Beweise, des angegebenen Typs für die aktuelle benötigt wird <xref:System.AppDomain>. Der zurückgegebene Wert dient als Host bereitgestellte Beweise und befindet sich in der <xref:System.AppDomain.Evidence%2A> Auflistung von der <xref:System.AppDomain.CurrentDomain%2A> Eigenschaft. Sie können die <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> Methode, um den generierten Beweis aus der Auflistung abzurufen.  
  
 Um einen Rückruf an diese Methode zu erhalten, müssen die Hosts angeben den <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> -flag in der <xref:System.Security.HostSecurityManager.Flags%2A> Eigenschaft.  
  
 Mit dieser Methode generieren Beweise können Hosts zu verzögern, Beweis-Generierung für eine <xref:System.AppDomain> bis des Beweises benötigt wird. In der Version von .NET Framework 3.5 und früheren Versionen war es erforderlich, geben Sie <xref:System.AppDomain> Beweis zur Ladezeit durch Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> Methode. Wir empfehlen die Verwendung <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> anstelle von nachweisen <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 Die <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Methode zurückgerufen nur für Typen von Beweisen, die der Host in der Überschreibung der angegeben hat die <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> Methode.  
  
 Ein Rückgabewert von `null` gibt an, dass der Host Beweis dieses bestimmten Typs generieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> Methode für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Der Beweistyp.</param>
        <param name="assembly">Die Zielassembly.</param>
        <summary>Fordert einen bestimmten Beweistyp für die Assembly an.</summary>
        <returns>Der angeforderte Assemblybeweis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden. Gibt die grundlegende Implementierung `null`.  
  
 Die common Language Runtime ruft diese Methode auf, wenn Beweise, des angegebenen Typs für die aktuelle Assembly benötigt wird. Der zurückgegebene Wert dient als Host bereitgestellte Beweise und befindet sich in der <xref:System.Reflection.Assembly.Evidence%2A> Eigenschaft. Können Sie die <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> Methode zum Abrufen des generierten Beweis aus der <xref:System.Reflection.Assembly.Evidence%2A> Eigenschaft.  
  
 Um einen Rückruf an diese Methode zu erhalten, müssen die Hosts angeben den <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> -flag in der <xref:System.Security.HostSecurityManager.Flags%2A> Eigenschaft.  
  
 Mit dieser Methode generieren Beweise können Hosts zu verzögern, Beweis-Generierung für eine <xref:System.AppDomain> bis des Beweises benötigt wird. In der .NET Framework 3.5 und früheren Versionen war es erforderlich, geben Sie <xref:System.AppDomain> Beweis zur Ladezeit durch Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> Methode. Wir empfehlen die Verwendung <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> anstelle von nachweisen <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 Die <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Methode zurückgerufen nur für Typen von Beweisen, die der Host in der Überschreibung der angegeben hat die <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> Methode.  
  
 Ein Rückgabewert von `null` gibt an, dass der Host Beweis dieses bestimmten Typs generieren kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt die Beweistypen, die der Host für die Anwendungsdomäne bereitstellen kann, wenn angefordert.</summary>
        <returns>Ein Array von Beweistypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden. Gibt die grundlegende Implementierung `null`.  
  
 Die Typen, die von dieser Methode zurückgegebene bestimmen, ob die <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Methode wird in aufgerufen. Das Vorhandensein eines Typs in dieser Liste bedeutet nicht, dass der Host dieser Beweistyp generiert werden muss, aber es werden kann. Aus diesem Grund empfiehlt es sich um stark angeben, anstatt unter-Angeben der Typen in dieser Liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Die Zielassembly.</param>
        <summary>Bestimmt die Beweistypen, die der Host für die Assembly bereitstellen kann, wenn angefordert.</summary>
        <returns>Ein Array von Beweistypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch eine abgeleitete Klasse überschrieben werden. Gibt die grundlegende Implementierung `null`.  
  
 Die Typen, die von dieser Methode zurückgegebene bestimmen, ob die <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Methode wird in aufgerufen. Das Vorhandensein eines Typs in dieser Liste bedeutet nicht, dass der Host dieser Beweistyp generiert werden muss, aber es werden kann. Aus diesem Grund empfiehlt es sich um stark angeben, anstatt unter-Angeben der Typen in dieser Liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Zusätzliche Beweise für das Hinzufügen der <see cref="T:System.AppDomain" /> Beweis.</param>
        <summary>Stellt den Beweis der Anwendungsdomäne für die geladene Assembly.</summary>
        <returns>Der Beweis für verwendet werden soll die <see cref="T:System.AppDomain" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann in einer abgeleiteten Klasse überschrieben werden.  
  
 Diese Methode wird aufgerufen, wenn ein <xref:System.AppDomain> Objekt erstellt wird. Die `inputEvidence` Parameter ist der berechnete Beweis aus der common Language Runtime. Die hostimplementierung können erweitern oder reduzieren den Beweis. Der Rückgabewert ist der Beweis für die Anwendungsdomäne verwendet werden soll.  Beweise zurück als übergeben, die basisimplementierung immer die `inputEvidence` Parameter.  
  
> [!IMPORTANT]
>  Finden Sie Hinweise zur Vererbung für den <xref:System.Security.HostSecurityManager> kritische Implementierungsinformationen-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Die geladene Assembly.</param>
        <param name="inputEvidence">Zusätzliche Beweis der Assemblybeweis hinzu.</param>
        <summary>Stellt den Assemblybeweis für die geladene Assembly.</summary>
        <returns>Der Beweis für die Assembly verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann in einer abgeleiteten Klasse überschrieben werden.  
  
 Diese Methode wird aufgerufen, wenn eine Assembly geladen ist, entweder implizit oder explizit wird. Die übergebene Parameter werden die geladene Assembly und der berechnete Beweis aus der common Language Runtime. Die hostimplementierung können erweitern oder reduzieren den Beweis. Der Rückgabewert ist der Beweis für die Assembly verwendet werden soll.  Beweise zurück als übergeben, die basisimplementierung immer die `inputEvidence` Parameter.  
  
> [!IMPORTANT]
>  Finden Sie Hinweise zur Vererbung für den <xref:System.Security.HostSecurityManager> kritische Implementierungsinformationen-Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> Methode für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, der zum Auswerten der Richtlinie verwendet wird.</param>
        <summary>Bestimmt, welche Berechtigungen Code auf Basis der angegebenen Beweise gewährt werden.</summary>
        <returns>Der Berechtigungssatz, der durch das Sicherheitssystem erteilt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft das Sicherheitsrichtlinienmodul, mit der angegebenen Beweise bereitstellen. Das Ergebnis wird durch die Sicherheitsrichtlinie bestimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
