<Type Name="BuildRequestDataFlags" FullName="Microsoft.Build.Execution.BuildRequestDataFlags">
  <TypeSignature Language="C#" Value="public enum BuildRequestDataFlags" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed BuildRequestDataFlags extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Execution.BuildRequestDataFlags" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Flags, die zusätzliche Kontrolle über die Buildanforderung.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="IgnoreExistingProjectState">
      <MemberSignature Language="C#" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags IgnoreExistingProjectState = int32(4)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn dieses Flag vorhanden ist und das Projekt zuvor erstellt wurde auf einem Knoten, deren Affinität ist inkompatibel mit der Affinität für diese Anforderung benötigt, diese Buildanforderung ignoriert des Projektzustands (jedoch nicht die Zielergebnisse), die zuvor generiert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Flag vorhanden ist, wird dieses Verhalten ist nicht in der Regel erwünscht. Dieses Flag wird nur für die Fälle bereitgestellt, in dem der Client weiß, dass die neue Buildanforderung nicht von der Zustand des Projekts von einer früheren Anforderung wieder generiert abhängig ist. Dieses Flag können Sie eine Leistungssteigerung bei inkompatible Knotenaffinitäten bereitstellen, da MSBuild hätten zum Serialisieren des Projektzustands von einem Knoten zu einem anderen Serialisieren des Projektzustands kann speicherintensiv sein, je nach Datenmenge das Projekt wurde bereits generiert.  
  
 Dieses Flag hat keine Auswirkung auf Zielergebnisse, wenn eine vorherige Anforderung ein Ziel erstellt, die neue Anforderung nicht das Ziel neu erstellt wird. Darüber hinaus wird keines der Projekt-Status Mutationen der aufgetreten ist, als Folge zuvor erstellen, die auf erneut angewendet werden muss.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Keine Flags.</summary>
      </Docs>
    </Member>
    <Member MemberName="ProvideProjectStateAfterBuild">
      <MemberSignature Language="C#" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ProvideProjectStateAfterBuild = int32(2)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn dieses Flag vorhanden ist, wird <see cref="T:Microsoft.Build.Execution.BuildResult" /> ausgestellt in Antwort auf diese Anforderung enthält <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="ReplaceExistingProjectInstance">
      <MemberSignature Language="C#" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ReplaceExistingProjectInstance = int32(1)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn dieses Flag vorhanden ist, wird die vorhandene ProjectInstance im Build durch dieses ersetzt.</summary>
      </Docs>
    </Member>
  </Members>
</Type>
