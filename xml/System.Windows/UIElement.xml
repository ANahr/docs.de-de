<Type Name="UIElement" FullName="System.Windows.UIElement">
  <TypeSignature Language="C#" Value="public class UIElement : System.Windows.Media.Visual, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi UIElement extends System.Windows.Media.Visual implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.UidProperty("Uid")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.UIElement" />eine Basisklasse für WPF Core Level-Implementierungen wird auf Windows Presentation Foundation (WPF)-Elemente und grundlegenden darstellungsmerkmalen erstellt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement>bietet einen Ausgangspunkt für Layouteigenschaften sowie verfügbar macht, die virtuelle Methoden, die abgeleitete Klassen überschreiben können, die das Layout des Elements und seiner untergeordneten Elemente Renderingverhalten beeinflussen können.  
  
 Ein Großteil der Eingabe und Fokussierung Verhalten für Elemente im Allgemeinen wird auch in definiert die <xref:System.Windows.UIElement> Klasse. Dies schließt die Ereignisse für die Tastatur, Maus und Stifteingabe und Eigenschaften der entsprechenden Status. Viele dieser Ereignisse sind Routingereignisse, und viele der Eingabe-bezogene Ereignisse haben beide eine bubbling-routing-Version als auch eine Tunneling-Version des Ereignisses. Diese gepaarte Ereignisse sind in der Regel die Ereignisse von Belang für Autoren von Steuerelementen.  
  
 <xref:System.Windows.UIElement>von der ereignissteuerung [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] Zusammenhang mit der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Ereignismodell, einschließlich der Methoden, die auslösen kann, die angegebene Routingereignisse, die von einer Elementinstanz definiert sind.  
  
 Im Hinblick auf die Architektur <xref:System.Windows.UIElement> kann ein Fensterhandle in weitgehend betrachtet werden [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] Programmierung oder ein Element in [!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)] programmieren. <xref:System.Windows.UIElement>wird von einem Basiselement auf WPF-Kernebene.  
  
 Ein <xref:System.Windows.UIElement> umfasst die folgenden Funktionen, die von speziell definiert sind die <xref:System.Windows.UIElement> Klasse:  
  
-   Kann als untergeordnetes Element rendern (<xref:System.Windows.UIElement> leitet sich von <xref:System.Windows.Media.Visual>, eine hohe Ebene Graphics-Klasse)  
  
-   Enthält die Logik, mit der Größe und position von untergeordneten Elementen von, einem <xref:System.Windows.UIElement> (bei der Interpretation durch ein Layoutsystem)  
  
-   Können reagieren auf Benutzereingaben (einschließlich der Kontrolle über die Eingabe, durch Behandeln des Ereignisses routing oder routing von Befehlen Sendeziel abrufen)  
  
-   Weitergeleitete Ereignisse auslösen kann, die eine Route durch die logische Elementstruktur übertragen werden.  
  
-   Einige Aspekte des Animationssystems unterstützt  
  
 <xref:System.Windows.FrameworkElement>ist der WPF-Frameworkebene vorgenommene Implementierung-Klasse, die baut auf <xref:System.Windows.UIElement>, und fügt der Interaktionen mit dem WPF-Frameworkebene. <xref:System.Windows.FrameworkElement>hinzugefügt und definiert die folgenden Funktionen:  
  
-   Zusätzliche Framework-spezifische Layouteigenschaften  
  
-   Unterstützung für umfangreichere Metadaten, die Eigenschaften zu melden  
  
-   Klasse-spezifische Implementierung der bestimmte Eingabe Basisklassen und ihre angefügten Eigenschaften oder angefügte Ereignisse  
  
-   Unterstützung von Stilen  
  
-   Unterstützung für weitere Animationen  
  
 Eine andere verwandte Klasse ist <xref:System.Windows.ContentElement>. Die <xref:System.Windows.ContentElement> Klasse implementiert Großteil derselben Member wie <xref:System.Windows.UIElement>; der Unterschied zwischen diesen beiden Klassen mit ihrer beabsichtigten im allgemeinen Modell platziert werden muss. Ein <xref:System.Windows.UIElement> abgeleitete Klasse definiert ein relativ starres Inhaltsmodell, was bedeutet, dass es Beschränkungen gibt, welche Elemente mit untergeordneten Elementen in Markup möglicherweise. Möglicherweise Kapazität zum Erstellen von weniger restriktiv untergeordneter Inhalt einem <xref:System.Windows.UIElement>, aber dieser Kapazität in der Regel im angegebenen Inhaltseigenschaften zentralisiert wird. Ein <xref:System.Windows.ContentElement> abgeleiteten Klasse wird in der Regel nicht so restriktiv zu Inhalten, um Szenarien wie z. B. Dokumente mit fortlaufendem zu unterstützen.  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement.Visibility%2A>Status wirkt sich auf alle Eingaben, die Verarbeitung durch dieses Element. Elemente, die nicht sichtbar sind nicht Treffertests beteiligt und empfangen, auch wenn der Mauszeiger über die Grenzen befindet, auf dem wäre des Elements keine Standardereignisse für Tastatureingaben, wenn sichtbar waren.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.UIElement" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellen einer neuen Instanz, der Typ ist jedoch <xref:System.Windows.UIElement> ist ungewöhnlich, dass im Anwendungscode, da <xref:System.Windows.UIElement> wird von einem Basiselement. Finden Sie unter [basieren Elemente Übersicht](~/docs/framework/wpf/advanced/base-elements-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Ein Bezeichner für das zu behandelnde Routingereignis.</param>
        <param name="handler">Ein Verweis auf die Handlerimplementierung.</param>
        <summary>Fügt einen Routingereignishandler für ein bestimmtes Routingereignis hinzu, wobei der Handler der Handlerauflistung für das aktuelle Element hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den gleichen Handler für das gleiche Ereignis mehrmals hinzufügen, ohne eine Ausnahme auszulösen. Der Handler wird jedoch tatsächlich mehrmals aufgerufen, wenn das Ereignis behandelt wird. Deshalb erwägen Sie, wie dieses Verhalten Nebeneffekte haben kann, die in Ihrem Handlerimplementierung berücksichtigt werden sollten.  
  
 Mithilfe dieser Methode die Implementierung der "hinzufügen"-Accessor für die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Ereignis Zugriffsmuster eines benutzerdefinierten Routingereignisses.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Ein Bezeichner für das zu behandelnde Routingereignis.</param>
        <param name="handler">Ein Verweis auf die Handlerimplementierung.</param>
        <param name="handledEventsToo">
          <see langword="true" />, wenn der Handler registriert werden soll, sodass er selbst dann aufgerufen wird, wenn das Routingereignis in den zugehörigen Ereignisdaten als behandelt markiert ist, <see langword="false" />, wenn der Handler mit der Standardbedingung registriert werden soll, dass er nicht aufgerufen wird, wenn das Routingereignis bereits als behandelt markiert ist.  
  
 Der Standardwert ist <see langword="false" />.  
  
 Legen Sie die Anforderung zum erneuten Behandeln eines Routingereignisses nicht gewohnheitsmäßig fest.</param>
        <summary>Fügt einen Routingereignishandler für ein bestimmtes Routingereignis hinzu, wobei der Handler der Handlerauflistung für das aktuelle Element hinzugefügt wird. Legen Sie <paramref name="handledEventsToo" /> auf <see langword="true" /> fest, damit der bereitgestellte Handler für ein Routingereignis aufgerufen wird, das bereits von einem anderen Element auf der Ereignisroute als behandelt markiert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verarbeitung von Eingabeereignissen auf niedriger Ebene in eine praktische Möglichkeit ist eine komplexe Aufgabe. Viele Steuerelemente implementieren Verhalten, in dem ein bestimmtes Ereignis als behandelt markiert ist, und wird durch ein anderes intuitiver Ereignis ersetzt. Im Allgemeinen wird ein Steuerelement nur ein Eingabeereignis Plattform als behandelt markiert Wenn einige Entwurf Absicht dafür vorhanden ist. In bestimmten Szenarien möglicherweise diesen Entwurf Absichten nicht was Ihre bestimmten Verarbeitung des Eingabeereignisses erforderlich ist. Es ist für die folgenden Szenarien, registrieren Handler mit `handledEventsToo` als `true` eignet. Aber Sie sollten Sie keine routinemäßig. Ereignishandler als Antwort auf alle Ereignisse aufrufen, selbst wenn behandelt wird ein eigene Anwendungsereignis Verarbeitungslogik erschweren. Wenn die Handlerlogik eine erhebliche ist möglicherweise eine Abnahme der Leistung angezeigt. Sie sollten die Verwendung der Handler für bereits verarbeitet Ereignisse für Situationen, in denen Sie bereits während des Entwicklungsprozesses ermittelt haben, die bestimmte Steuerelemente Ereignisse behandeln, die Sie weiterhin mit der Anwendungslogik behandeln möchten, Anfügen reservieren.  
  
 Ein weiteres Verfahren zum Vermeiden von der Klasse, die bestimmte Kombinationen von Ereignis-Control-Standardverhalten der Fehlerbehandlung ist die Verwendung des Ereignisses Preview Alternative. Z. B. wenn <xref:System.Windows.UIElement.MouseLeftButtonDown> markiert wird durch die Klassenbehandlung, können Sie möglicherweise hinzuzufügenden Handler für <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> stattdessen.  
  
 Sie können den gleichen Handler für das gleiche Ereignis mehrmals hinzufügen, ohne eine Ausnahme auszulösen. Der Handler wird jedoch tatsächlich mehrmals aufgerufen, wenn das Ereignis behandelt wird. Deshalb erwägen Sie, wie dieses Verhalten Nebeneffekte haben kann, die in Ihrem Handlerimplementierung berücksichtigt werden sollten.  
  
 Mithilfe dieser Methode die Implementierung der "hinzufügen"-Accessor für die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Ereignis Zugriffsmuster eines benutzerdefinierten Routingereignisses.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler wird aufgerufen, auf die <xref:System.Windows.FrameworkElement.Initialized> Ereignis auf einer Seite, die an eines der benannten Elemente auf der Seite mithilfe einen definierten Handler anfügt `handledEventsToo` `true`. Dieser Handler wird aufgerufen werden, selbst wenn ein anderes Element entlang der Route, die gemeinsam genutzte Ereignisdaten als behandelt, die vor dem Erreichen der Behandlungselement in der Route gekennzeichnet.  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">Die Ereignisroute, der Handler hinzugefügt werden.</param>
        <param name="e">Die Ereignisdaten, die verwendet werden, die Handler hinzuzufügen. Diese Methode verwendet die <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> Eigenschaft der Ereignisdaten, die Handler zu erstellen.</param>
        <summary>Fügt dem angegebenen Handler <see cref="T:System.Windows.EventRoute" /> für den aktuellen <see cref="T:System.Windows.UIElement" /> Ereignishandlerauflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, durch den Inhaltshostelemente (implementieren <xref:System.Windows.IContentHost> oder nicht) hinzuzufügenden Handler für untergeordnete Elemente, die <xref:System.Windows.EventRoute>. Dies ist normalerweise nicht erforderlich für <xref:System.Windows.UIElement>, da für alle Elemente in einer abgeschlossenen logischen Struktur automatisch Handler hinzugefügt werden. In einigen Fällen, in denen <xref:System.Windows.ContentElement> und <xref:System.Windows.UIElement> werden gemischt in auf Vorlagen basierenden Strukturen, das dazwischen liegende Elemente aus der Vorlage muss eine Route hinzugefügt werden. Beide <xref:System.Windows.ContentElement> und <xref:System.Windows.UIElement> unterstützen eine Version dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt einen Wert fest, der angibt, ob dieses Element als Ziel eines Drag &amp; Drop-Vorgangs verwendet werden kann.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />, wenn dieses Element als Ziel eines Drag &amp; Drop-Vorgangs verwendet werden kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Drag & Drop-Vorgänge sind nicht standardmäßig aktiviert und muss absichtlich aktiviert werden, indem <xref:System.Windows.UIElement.AllowDrop%2A> auf `true`. Über diese Einstellung "Grundlegend" Drag-and-Drop-Verhalten basiert vollständig auf implementierungsspezifisch und ist nicht definiert, indem <xref:System.Windows.UIElement> oder eine beliebige andere Basiselement-Klasse. Bestimmte Steuerelemente, z. B. <xref:System.Windows.Controls.RichTextBox>, verfügen über ein Standardverhalten. Weitere Informationen zu Drag & Drop, finden Sie unter [Drag- and -Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).  
  
 <xref:System.Windows.FrameworkElement>überschreibt die Metadaten für diese Abhängigkeitseigenschaft in ihrer Implementierung. Insbesondere <xref:System.Windows.FrameworkElement> bestimmt diese Eigenschaft, um die Vererbung von Eigenschaftenwerten zulassen (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> ist `true` in Metadaten). Die Vererbung von Eigenschaftswerten in diesem Kontext bedeutet, dass, wenn kein anderer Wert für untergeordnete Elemente vorhanden sind <xref:System.Windows.UIElement.AllowDrop%2A> über die lokalen Werte oder Formate den Wert des nächsten übergeordneten Elements mit diesem Wert zugewiesen (erneut aus, entweder in Stilen, standardmäßig zugewiesen Werte, oder einen lokalen Wert), und klicken Sie dann der Wert aus dem übergeordneten Element für alle zuvor nicht zugewiesene untergeordneten Elemente vom Eigenschaftensystem zugewiesen werden. In der Praxis bedeutet dies, Sie können angeben, ob Löschvorgänge an den Root-Element, und, dass der Wert für alle untergeordneten Elemente weitergegeben wird, die nicht speziell verfügen, die zugewiesen werden, als `false`.  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.AllowDropProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird für Markup der <xref:System.Windows.UIElement.AllowDrop%2A> Eigenschaft `true` unter Verwendung eines Attributs auf einen <xref:System.Windows.Controls.TextBox>sowie einige andere Einstellung verwandter Eigenschaften, die in aggregierter Form, mit denen <xref:System.Windows.Controls.TextBox> an das Ziel ein mehrzeiliges Textfeld-Datenobjekt sein bei Es wird gezogen. Das vollständige Beispiel finden Sie unter [Beispiel Datei gelöscht laden](http://msdn.microsoft.com/en-us/be90d645-dd61-4f53-93bb-87902d086ef7).  
  
 [!code-xaml[DragDrop_DropOpenTextFile#UIElementAllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/DragDrop_DropOpenTextFile/CS/window1.xaml#uielementallowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.AllowDrop" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet eine Animation auf eine angegebene Abhängigkeitseigenschaft für dieses Element an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist versiegelt und kann nicht überschrieben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">Der Bezeichner für die zu animierende Eigenschaft.</param>
        <param name="clock">Die Animationsuhr, die die Animation steuert und deklariert.</param>
        <summary>Wendet eine Animation auf eine angegebene Abhängigkeitseigenschaft für dieses Element an. Alle vorhandenen Animationen werden beendet und durch die neue Animation ersetzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Animation aus einer Eigenschaft zu entfernen, geben Sie den Bezeichner für diese Eigenschaft als `dp` , und geben Sie `clock` als `null`. Dadurch wird die Animation entfernt, und auf den Basiswert die animierte Eigenschaft festgelegt ist. Die ursprünglich zugeordnete Animationsuhr wird jedoch nicht beendet. Alle anderen dieser Uhr zugewiesenen Animationen werden weiterhin ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel ein <xref:System.Windows.Shapes.Rectangle> `myAnimatedRectangle` verfügt über eine bestimmte zeitgesteuerte Animation angewendet, indem Aufrufen <xref:System.Windows.UIElement.ApplyAnimationClock%2A> .  
  
 [!code-csharp[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/ClockControllerSpeedRatioExample.cs#uielementapplyanimationclock)]
 [!code-vb[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/clockcontrollerspeedratioexample.vb#uielementapplyanimationclock)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="clock">Die Animationsuhr, die die Animation steuert und deklariert.</param>
        <param name="handoffBehavior">Ein Wert aus der Enumeration. Die Standardeinstellung ist <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, die eine vorhandene Animation beendet und durch das neue Element ersetzt wird.</param>
        <summary>Wendet eine Animation auf eine angegebene Abhängigkeitseigenschaft für dieses Element, mit der Möglichkeit, um anzugeben, was geschieht, wenn die Eigenschaft bereits eine laufende Animation aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Animation aus einer Eigenschaft zu entfernen, geben Sie den Bezeichner für diese Eigenschaft als `dp` , und geben Sie `clock` als `null`. Dadurch wird die Animation entfernt, und auf den Basiswert die animierte Eigenschaft festgelegt ist. Die ursprünglich zugeordnete Animationsuhr wird jedoch nicht beendet. Alle anderen dieser Uhr zugewiesenen Animationen werden weiterhin ausgeführt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob mindestens eine Fingereingabe für dieses Element erfasst wird.</summary>
        <value>
          <see langword="true" />Wenn mindestens eine Fingereingabe ist für dieses Element erfasst; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob mindestens eine Fingereingabe auf diesem Element oder für alle untergeordneten Elemente in seiner visuellen Struktur erfasst werden.</summary>
        <value>
          <see langword="true" />Wenn mindestens eine Fingereingabe für dieses Element oder seine untergeordneten Elemente in seiner visuellen Struktur erfasst; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob mindestens eine Fingereingabe auf dieses Element erfasst wird.</summary>
        <value>
          <see langword="true" />Wenn mindestens eine Fingereingabe über diesem Element gedrückt wird. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob mindestens eine Fingereingabe auf dieses Element oder seine untergeordneten Elemente in seiner visuellen Struktur registriert ist.</summary>
        <value>
          <see langword="true" />Wenn mindestens eine Fingereingabe über diesem Element oder seine untergeordneten Elemente in seiner visuellen Struktur gedrückt wird. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.AreAnyTouchesOver" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arrange">
      <MemberSignature Language="C#" Value="public void Arrange (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Arrange(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Die endgültige Größe, die das übergeordnete Element für das untergeordnete Element berechnet, als eine <see cref="T:System.Windows.Rect" />-Instanz.</param>
        <summary>Positioniert untergeordnete Elemente und bestimmt die Größe für ein <see cref="T:System.Windows.UIElement" />. Übergeordnete Elemente rufen diese Methode aus ihrer <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />-Implementierung (oder einer Entsprechung auf WPF-Frameworkebene) auf, um eine rekursive Layoutaktualisierung auszuführen. Diese Methode stellt die zweite Übergabe einer Layoutaktualisierung dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für WPF-Frameworkebene Element ableiten Szenarien Verhalten für <xref:System.Windows.UIElement.Arrange%2A> sollte nicht (und nicht möglich ist, es sei denn, Sie Schatten) geändert werden. Stattdessen sollten Sie überschreiben die <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> Implementierung in Ihrer Klasse. Ihre <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> -Implementierung aufgerufen wird intern von <xref:System.Windows.UIElement.Arrange%2A> als Teil des Standard WPF-Frameworkebene Layoutvorgänge. Ihre <xref:System.Windows.UIElement.ArrangeCore%2A> Implementierung sollte auch aufrufen, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> für jedes untergeordnete Element, wenn sie über untergeordnete Elemente verfügt.  
  
 Für WPF-Kernebenen-Element Ableiten von Szenarien, die das Verhalten für <xref:System.Windows.UIElement.Arrange%2A> sollte nicht (und nicht möglich ist, es sei denn, Sie Schatten) geändert werden. Sie sollten stattdessen überschreiben <xref:System.Windows.UIElement.ArrangeCore%2A> in Ihrer Klasse. Ihre <xref:System.Windows.UIElement.ArrangeCore%2A> -Implementierung aufgerufen wird intern von <xref:System.Windows.UIElement.Arrange%2A> als Teil des Standard WPF-Frameworkebene Layoutvorgänge. Dies setzt jedoch voraus verwenden Sie WPF-Frameworkebene Layout und die zugehörige Layoutsystem häufig nicht der Fall ist, wenn Sie Elemente in der WPF-Kernebenen von speziell ableiten, werden die <xref:System.Windows.UIElement> Elementklasse basieren. Ihre <xref:System.Windows.UIElement.ArrangeCore%2A> Implementierung sollte auch aufrufen, <xref:System.Windows.UIElement.Arrange%2A> für jedes untergeordnete Element, wenn sie über untergeordnete Elemente verfügt. Beachten Sie, dass das WPF-Kernebenen-Szenario setzt voraus, dass Sie nicht verwenden eine <xref:System.Windows.FrameworkElement> abgeleitete Klasse, da <xref:System.Windows.FrameworkElement> Verschlüssen <xref:System.Windows.FrameworkElement.ArrangeCore%2A>.  
  
 Berechnung der WPF-Frameworkebene layoutpositionierung [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] besteht aus einem <xref:System.Windows.UIElement.Measure%2A> aufrufen und eine <xref:System.Windows.UIElement.Arrange%2A> aufrufen. Während der <xref:System.Windows.UIElement.Measure%2A> Aufruf der, das Layoutsystem bestimmt ein Element größenanforderungen mithilfe einer bereitgestellten <xref:System.Windows.Size> (`availableSize`) Argument. Während der <xref:System.Windows.UIElement.Arrange%2A> Aufruf, der das Layoutsystem schließt die Größe und Position eines Elements des umgebenden Felds.  Weitere Informationen finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 `availableSize`eine beliebige Zahl von 0 (null), unendlich kann sein. Elemente angeordnet werden, gibt das Minimum zurück <xref:System.Windows.Size> erfordern, über die `availableSize` Parameter.  
  
 Wenn ein Layout zuerst instanziiert wird, erhält er immer eine <xref:System.Windows.UIElement.Measure%2A> aufrufen, bevor Sie <xref:System.Windows.UIElement.Arrange%2A>. Nach der ersten Layoutdurchlauf, es kann jedoch empfangen eine <xref:System.Windows.UIElement.Arrange%2A> aufrufen, ohne eine <xref:System.Windows.UIElement.Measure%2A>; Dies kann auftreten, wenn eine Eigenschaft, die wirkt sich nur auf <xref:System.Windows.UIElement.Arrange%2A> (z. B. Ausrichtung) geändert wird oder wenn das übergeordnete Element erhält einen <xref:System.Windows.UIElement.Arrange%2A> ohne eine <xref:System.Windows.UIElement.Measure%2A>. Ein <xref:System.Windows.UIElement.Measure%2A> Aufruf wird automatisch für ungültig zu erklären einer <xref:System.Windows.UIElement.Arrange%2A> aufrufen.  
  
 Layout-Updates erfolgen in der Regel asynchron (zu einem Zeitpunkt, die vom Layoutsystem bestimmt wird). Ein Element möglicherweise Änderungen an den Eigenschaften, die Elementgröße beeinflussen nicht sofort entsprechen (z. B. <xref:System.Windows.FrameworkElement.Width%2A>).  
  
> [!NOTE]
>  Layout Updates können erzwungen werden, mithilfe der <xref:System.Windows.UIElement.UpdateLayout%2A> Methode jedoch das Aufrufen dieser Funktion wird nicht empfohlen, da er in der Regel nicht erforderlich ist und dazu führen, eine schlechte Leistung dass kann. In vielen Situationen bei Aufrufen <xref:System.Windows.UIElement.UpdateLayout%2A> ist möglicherweise geeignet, wird das Layoutsystem wahrscheinlich bereits Updates verarbeitet werden. Das Layoutsystem kann Änderungen am Layout in einer Weise verarbeiten, die alle erforderlichen Updates, die als Teil eines Pakets optimieren können.  
  
 Das Layoutsystem verfolgt zwei separate Warteschlangen mit ungültigen Layouts für <xref:System.Windows.UIElement.Measure%2A> und eine für <xref:System.Windows.UIElement.Arrange%2A>. Die Layoutwarteschlange wird basierend auf der Reihenfolge der Elemente in der visuellen Struktur sortiert. Elemente, die weiter oben in der Struktur sind am Anfang der Warteschlange ab, um redundante Layouts durch wiederholte Änderungen an, in der übergeordneten Elemente zu vermeiden. Doppelt vorhandene Einträge werden automatisch aus der Warteschlange entfernt, und Elemente werden automatisch aus der Warteschlange entfernt, wenn sie noch gültig sind.  
  
 Beim Aktualisieren eines Layouts, das <xref:System.Windows.UIElement.Measure%2A> Warteschlange wird geleert zuerst, gefolgt von der <xref:System.Windows.UIElement.Arrange%2A> Warteschlange. Ein Element in der <xref:System.Windows.UIElement.Arrange%2A> Warteschlange wird nie angeordnet werden, wenn ein in Element der <xref:System.Windows.UIElement.Measure%2A> Warteschlange.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected virtual void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Der letzte Bereich im übergeordneten Element, den das Element verwenden soll, um sich selbst und seine untergeordneten Elemente anzuordnen.</param>
        <summary>Definiert die Vorlage für die Definition zum Anordnen des Layouts auf der WPF-Kernebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Überschreiben diese Methode ist nur geeignet, wenn Sie auf die WPF-Kernebenen ableiten, und Sie nicht das WPF-Frameworkebene Layoutsystem verwenden und <xref:System.Windows.FrameworkElement> abgeleitete Klasse, da <xref:System.Windows.FrameworkElement> Verschlüssen <xref:System.Windows.FrameworkElement.ArrangeCore%2A>. Wenn Sie das WPF-Frameworkebene Layoutsystem verwenden, die geeignete Methode zur Überschreibung für klassenspezifische Layout anordnen Verhalten ist <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
   
  
## Examples  
 <xref:System.Windows.UIElement.ArrangeCore%2A>Implementierungen sollten die basisimplementierung zum Zurückgeben einer Größe aufrufen, rufen Sie dann die <xref:System.Windows.UIElement.Arrange%2A> Methode jedes sichtbaren untergeordneten Elements aus, und stimmen Sie die Größen von diesen zurückgegeben <xref:System.Windows.UIElement.Arrange%2A> Aufrufe mit der Größe der die grundlegende Implementierung. Die Logik für die Abstimmung Aspekt eine <xref:System.Windows.UIElement.ArrangeCore%2A> Implementierung kann variieren, abhängig von den Layouteigenschaften des Elements. In der folgenden Beispielvorlage `VisualChildren` ist eine hypothetische Eigenschaft, die möglicherweise das Element definiert, um seinen Inhalt zu enumerieren <xref:System.Windows.UIElement> Content-Sammlungen definiert keinen auf dieser Ebene die WPF-Frameworkebene Architektur inhaltsverhalten um abgeleitete Elemente wie z. B. bestimmte Steuerelemente oder Basisklassen Steuerelement verzögert.  
  
 [!code-csharp[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementarrangeoverride)]
 [!code-vb[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementarrangeoverride)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie Elemente in den WPF-Kernebene entwickeln, sollten Sie überschreiben diese Methode, um die WPF-Kernebenen-Element ein einzigartiges anordnen Layoutverhalten oder richtige Layout zu Entscheidungen über die untergeordneten Elemente des Ihre Elemente. Eine Außerkraftsetzung ist möglicherweise erforderlich, wenn dieser untergeordneten Elemente wie z. B. nicht in einem definierten Muster erkennbar sind ein <see cref="T:System.Windows.Controls.ItemCollection" />.  
  
 Ein übergeordnetes Element muss das klassenspezifische Aufrufen <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> für jedes untergeordnete Element ist, andernfalls dieser untergeordneten Elemente werden nicht gerendert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft, die als Bezeichner für eine Abhängigkeitseigenschaft angegeben ist.</param>
        <param name="animation">Die Zeitachse der Animation starten.</param>
        <summary>Startet eine Animation für eine angegebene animierten Eigenschaft für dieses Element an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie überprüfen, ob eine Eigenschaft animiert wird, beachten Sie, dass die Animation wird gestartet, und berücksichtigt werden animiert wird, wenn der erste Frame hinter nicht animiert Ausgangspunkt gerendert wird.  
  
 Wenn die <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> für `animation` ist `null`, klicken Sie dann alle aktuellen Animationen entfernt, und der aktuelle Wert der Eigenschaft aufrechterhalten wird.  
  
 Wenn die gesamte `animation` Wert `null`, werden alle Animationen aus der Eigenschaft entfernt, und der Eigenschaftswert wird auf den Basiswert zurückgesetzt. Die ursprünglich zugeordnete Animationszeitachse wird jedoch nicht beendet. Alle anderen dieser Zeitachse zugewiesenen Animationen werden weiterhin ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Animation, zugewiesen, und ruft dann <xref:System.Windows.UIElement.BeginAnimation%2A> , ihn zu starten.  
  
 [!code-csharp[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#beginanimation)]
 [!code-vb[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#beginanimation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft, die als Bezeichner für die Abhängigkeitseigenschaft angegeben ist.</param>
        <param name="animation">Die Zeitachse der Animation angewendet werden.</param>
        <param name="handoffBehavior">Der Wert der Enumeration, die angibt, wie die neue Animation mit aktuellen (ausgeführten) Animationen interagiert, die bereits den Wert der Eigenschaft begegnen können.</param>
        <summary>Startet eine spezifische Animation für eine angegebene animierten Eigenschaft für dieses Element, mit der Option zum angeben, was geschieht, wenn die Eigenschaft bereits eine laufende Animation aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie überprüfen, ob eine Eigenschaft animiert wird, beachten Sie, dass die Animation wird gestartet, und berücksichtigt werden animiert wird, wenn der erste Frame hinter nicht animiert Ausgangspunkt gerendert wird.  
  
 Wenn die <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> für `animation` ist `null`, klicken Sie dann alle aktuellen Animationen entfernt, und der aktuelle Wert der Eigenschaft aufrechterhalten wird.  
  
 Wenn die gesamte `animation` Wert `null`, werden alle Animationen aus der Eigenschaft entfernt, und der Eigenschaftswert wird auf den Basiswert zurückgesetzt. Die ursprünglich zugeordnete Animationszeitachse wird jedoch nicht beendet. Alle anderen dieser Zeitachse zugewiesenen Animationen werden weiterhin ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der eine vorhandene Animation aus einer Ressource durch und ruft anschließend erhält <xref:System.Windows.UIElement.BeginAnimation%2A> mit einem bestimmten Übergabeverhalten.  
  
 [!code-csharp[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/csharp/VS_Snippets_Wpf/BrushesIntroduction/CSharp/SampleViewer.xaml.cs#beginanimationhandoff)]
 [!code-vb[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BrushesIntroduction/visualbasic/sampleviewer.xaml.vb#beginanimationhandoff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Bitmapeffekt ab, der direkt auf den gerenderten Inhalt dieses Elements angewendet wird, bzw. legt diesen fest.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Der anzuwendende Bitmapeffekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Effects.BitmapEffect>ein abstrakter Typ, daher ist die [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] erfordert die Verwendung eine implementierte abgeleitete Klasse von <xref:System.Windows.Media.Effects.BitmapEffect>, wie z. B. <xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>. Beachten Sie, dass eine implementierte Klasse abgeleitet ist, die Sie angeben, mehr als eine sequenzielle ermöglicht Auflistungstyp <xref:System.Windows.Media.Effects.BitmapEffect>, mit einer geschachtelten Tagsyntax.  
  
 Keine vorhandene abgeleitete Klasse von <xref:System.Windows.Media.Effects.BitmapEffect> unterstützt einen Typkonverter, sodass der [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax, mit denen Sie für diese Eigenschaft ist im Allgemeinen Eigenschaftenelementsyntax.  
  
<a name="dependencyPropertyInfo_BitmapEffect"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.BitmapEffectProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Bitmap mithilfe <xref:System.Windows.Media.Effects.BlurBitmapEffect>.  
  
 [!code-csharp[EffectsGallery_snip#CodeBehindBlurCodeBehindExampleInline](~/samples/snippets/csharp/VS_Snippets_Wpf/EffectsGallery_snip/CSharp/blurcodebehindexample.xaml.cs#codebehindblurcodebehindexampleinline)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eingabequelle des Bitmapeffekts ab, der direkt auf den gerenderten Inhalt dieses Elements angewendet wird, bzw. legt diese fest.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Die Quelle für Bitmapeffekte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_BitmapEffectInput"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.BitmapEffectInputProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInputProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectInputProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectInputProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.BitmapEffectInput" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.BitmapEffect" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt eine zwischengespeicherte Repräsentation der <see cref="T:System.Windows.UIElement" />.</summary>
        <value>Ein <see cref="T:System.Windows.Media.CacheMode" /> , enthält eine zwischengespeicherte Repräsentation der <see cref="T:System.Windows.UIElement" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.Windows.UIElement.CacheMode%2A> Eigenschaft, wenn Sie müssen zum Erhöhen der Leistung für Inhalte, die zum Rendern sehr zeitaufwändig ist. Weitere Informationen finden Sie unter <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.CacheModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.CacheMode" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureMouse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, das Erfassen der Maus für dieses Element zu erzwingen.</summary>
        <returns>
          <see langword="true" />Wenn die Maus erfolgreich erfasst wird; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um erfasst werden, muss ein Element aktiviert sein. Überprüfen Sie, ob <xref:System.Windows.UIElement.IsEnabled%2A> ist `true` vor dem Aufruf <xref:System.Windows.UIElement.CaptureMouse%2A>.  
  
 Wenn der Aufruf <xref:System.Windows.UIElement.CaptureMouse%2A> gibt `true`, klicken Sie dann <xref:System.Windows.UIElement.IsMouseCaptured%2A> ist auch `true`.  
  
 Beim Aufrufen <xref:System.Windows.UIElement.CaptureMouse%2A> gibt `true`, die <xref:System.Windows.UIElement.GotMouseCapture> und <xref:System.Windows.UIElement.IsMouseCapturedChanged> Ereignisse ausgelöst werden, mit <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> Daten in den Ereignisdaten gemeldet haben, als das Element, in dem die <xref:System.Windows.UIElement.CaptureMouse%2A> Methode wird aufgerufen. Wenn Sie die Aufzeichnung erzwingen, können Sie vorhandene Erfassungen beeinträchtigen, insbesondere bei Erfassungen, die mit Drag & Drop mit der Maus in Zusammenhang stehen.  
  
 Rufen Sie zum Löschen von Mauseingaben aufzufangen aus allen Elementen <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> mit der `element` -Parameter als `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel implementiert ein Paar der Handler für die Maus- und Eingabe Tastenkombination, die die Maus erfassen (und Hostschlüssel) und eine spezielle mausmodus für die Anzeige von einem 3D-Modell zu aktivieren.  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureStylus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, die Erfassung der Tablettstift für dieses Element zu erzwingen.</summary>
        <returns>
          <see langword="true" />Wenn der Tablettstift erfolgreich erfasst wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die standardmäßige Implementierung basierend auf dem zugrunde liegenden Tablettstift Standardgerät immer `true`. Wenn Sie die Eingabe Geräte, die die Geräte-Implementierung für der Eingabesystem bereitstellen erweitern, ist es jedoch möglich, ein System mit einer Implementierung der alternativen Tablettstift-Gerät zu erstellen, die möglicherweise andere Ergebnisse zurückgeben.  
  
 Wenn ein Element die Stiftauswahl erhält, erhält sie Stifteingabe, selbst wenn der Tablettstift außerhalb seiner Grenzen befindet. Der Tablettstift wird in der Regel nur während der Drag-and-Drop-Vorgänge erfasst.  
  
 Beim Aufrufen dieser Methode ruft eine zugrunde liegende statische <xref:System.Windows.Input.Stylus> Methode <xref:System.Windows.Input.Stylus.Capture%2A>. Die tatsächlich verwendeten Verhalten wird von der aktiven Implementierung des Tablettstiftgeräts implementiert.  
  
 Um erfasst werden, muss ein Element aktiviert sein. Überprüfen Sie, ob <xref:System.Windows.UIElement.IsEnabled%2A> ist `true` vor dem Aufruf zurückgegeben <xref:System.Windows.UIElement.CaptureStylus%2A>.  
  
 Wenn der Aufruf <xref:System.Windows.UIElement.CaptureStylus%2A> gibt `true`, <xref:System.Windows.UIElement.IsStylusCaptured%2A> ist auch `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">Das Gerät zu erfassen.</param>
        <summary>Versucht, die Erfassung von Fingereingabe auf dieses Element zu erzwingen.</summary>
        <returns>
          <see langword="true" />Wenn die angegebene Fingereingabe auf dieses Element erfasst wird andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.CaptureTouch%2A>Gibt zurück, `false` Wenn die <xref:System.Windows.Input.TouchDevice> zurzeit zu einem anderen Element aufgezeichnet wird.  
  
 Wenn <xref:System.Windows.UIElement.CaptureTouch%2A> gibt `true`, und klicken Sie dann die <xref:System.Windows.UIElement.GotTouchCapture> Ereignis wird ausgelöst.  
  
 Um die Erfassung einer einzelnen Fingereingabe aus diesem Element freizugeben, verwenden die <xref:System.Windows.UIElement.ReleaseTouchCapture%2A> Methode, und geben Sie die Touch-Geräte freigeben. Um alle Fingereingaben für dieses Element freizugeben, verwenden Sie die <xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Geometrie ab, die zum Definieren der Gliederung des Inhalts eines Elements verwendet wird, oder legt sie fest.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Die Geometrie, die zur Größenanpassung des Clippingbereichs verwendet werden soll. Der Standardwert ist eine <see cref="T:System.Windows.Media.Geometry" /> von 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elemente außerhalb der Geometrie werden im gerenderten Layout visuell abgeschnitten. Die Geometrie braucht nicht rechteckig sein.  
  
<a name="dependencyPropertyInfo_Clip"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ClipProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 In diesem Beispiel wird gezeigt, wie ein Framework-Element definieren <xref:System.Windows.UIElement.Clip%2A> Region. Verwenden Sie zum Definieren eines Clips eine <xref:System.Windows.Media.Geometry> (z. B. ein <xref:System.Windows.Media.EllipseGeometry> des Elements festgelegt <xref:System.Windows.UIElement.Clip%2A> Eigenschaft. Nur der Bereich, der innerhalb des Bereichs der Geometry-Instanz ist sichtbar.  
  
 Das folgende Beispiel zeigt eine <xref:System.Windows.Controls.Image> -Element ohne einen definierten Clip-Bereich. Da keine Clip-Bereich definiert ist, wird das gesamte Bild angezeigt.  
  
 [!code-xaml[ClipPathExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#2)]  
  
 ![Ein Objekt vor dem Anwenden eines Clippingbereichs](~/add/media/mil-task-clip-region-noclip.png "einem Objekt vor dem Anwenden eines Clippingbereichs")  
Bild mit keine Clip-Bereich  
  
 Im nächsten Beispiel wird ein identischer Abbild erstellt, mit der Ausnahme, dass es sich um einen definierten Clip-Bereich verfügt. Nur den Teil des Bilds, das innerhalb des Bereichs, wird die <xref:System.Windows.Media.EllipseGeometry> wird angezeigt.  
  
 [!code-xaml[ClipPathExample#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#4)]  
  
 ![Ein abgeschnittenes Objekt](~/add/media/mil-task-clip-region-ellispe.PNG "ein abgeschnittenes Objekt")  
Bild mit einem elliptischen Clip-Bereich  
  
 Das folgende Beispiel zeigt, wie Animieren eines Frameworkelements <xref:System.Windows.UIElement.Clip%2A> Region. In diesem Beispiel wird ein <xref:System.Windows.Media.EllipseGeometry> wird verwendet, um einen elliptischen Clip-Bereich für definieren eine <xref:System.Windows.Controls.Image> Element. Ein <xref:System.Windows.Media.Animation.PointAnimation> erstellt eine Animation des EllipseGeometry <xref:System.Windows.Media.EllipseGeometry.Center%2A> Eigenschaft von (0, 0), (200, 150). Die Animation wird gestartet, wiedergegeben werden, nachdem das Abbild geladen wird und auf unbestimmte Zeit wiederholt.  
  
 [!code-xaml[ClipPathExample#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#5)]  
  
 Das vollständige Beispiel finden Sie unter der [Clip Region Sample](http://msdn.microsoft.com/en-us/83043a0b-f824-445f-9675-103280c5ca67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.Clip" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipToBounds">
      <MemberSignature Language="C#" Value="public bool ClipToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipToBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.ClipToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt einen Wert fest, der angibt, ob der Inhalt dieses Elements (oder Inhalt aus seinen untergeordneten Elementen) abgeschnitten wird, sodass er in das enthaltende Element passt.   Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />, wenn der Inhalt abgeschnitten werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für untergeordnete Elemente <xref:System.Windows.UIElement.ClipToBounds%2A> verfügt über unterschiedliche Auswirkungen Layout-Verhalten, je nachdem, ob die Höhe und Breite des übergeordneten Elements von bestimmt wird <xref:System.Windows.FrameworkElement.Height%2A>  /  <xref:System.Windows.FrameworkElement.Width%2A> oder <xref:System.Windows.FrameworkElement.MaxHeight%2A>  /  <xref:System.Windows.FrameworkElement.MaxWidth%2A>. <xref:System.Windows.FrameworkElement.MaxHeight%2A> / <xref:System.Windows.FrameworkElement.MaxWidth%2A>des übergeordneten Elements werden immer berücksichtigt, unabhängig vom Wert der <xref:System.Windows.UIElement.ClipToBounds%2A> und effektive Clipping wird immer den Inhalt basierend auf diese Maximalwerte. Des übergeordnetes <xref:System.Windows.FrameworkElement.Height%2A>  /  <xref:System.Windows.FrameworkElement.Width%2A> Einstellungen werden den Inhalt nicht beschnitten beim <xref:System.Windows.UIElement.ClipToBounds%2A> ist `false`, jedoch wird die Inhalt If clip <xref:System.Windows.UIElement.ClipToBounds%2A> ist `true`.  
  
 Beachten Sie, dass der Standardwert `false` ist das allgemeine Verhalten wie in implementiert die <xref:System.Windows.UIElement> Klasse. Es ist möglich, dass alle angegebenen Elemente, die abgeleitet <xref:System.Windows.UIElement> Überschreiben der Eigenschaft abhängigkeitsmetadaten für diese Eigenschaft in dieser Instanz standardmäßig `true` stattdessen. Mehrere vorhandene abgeleitete Klassen überschreiben diese Metadaten und/oder passen Standardwert der Abhängigkeitseigenschaft.  
  
 <xref:System.Windows.Controls.InkCanvas>, <xref:System.Windows.Controls.InkPresenter>, und <xref:System.Windows.Controls.Primitives.Popup> bei jedem Überschreiben wird den Standardwert, werden `true`.  
  
 <xref:System.Windows.FrameworkElement>überschreibt die Metadaten für diese Abhängigkeitseigenschaft. Insbesondere <xref:System.Windows.FrameworkElement> bestimmt diese Eigenschaft, um die Vererbung von Eigenschaftenwerten zulassen (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> ist `true` in Metadaten). Die Vererbung von Eigenschaftswerten in diesem Kontext bedeutet, dass, wenn kein anderer Wert für untergeordnete Elemente vorhanden sind <xref:System.Windows.UIElement.ClipToBounds%2A> über die lokalen Werte oder Formate den Wert des nächsten übergeordneten Elements mit diesem Wert zugewiesen (erneut aus, entweder in Stilen, standardmäßig zugewiesen Werte, oder einen lokalen Wert), und klicken Sie dann der Wert aus dem übergeordneten Element für alle nicht zugewiesenen untergeordneten Elemente vom Eigenschaftensystem zugewiesen werden. In der Praxis Dies bedeutet, dass können Sie angeben, ob im Stammelement Clip Grenzen zulassen, dass der Wert für alle untergeordneten Elemente weitergegeben wird, die nicht speziell verfügen, die zugewiesen werden, als `false`.  
  
<a name="dependencyPropertyInfo_ClipToBounds"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ClipToBoundsProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipToBoundsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipToBoundsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipToBoundsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.ClipToBounds" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.Input.CommandBinding" /> Objekte mit diesem Element zugeordnet sind. Ein <see cref="T:System.Windows.Input.CommandBinding" /> ermöglicht die befehlsverarbeitung für dieses Element und deklariert die Verknüpfung zwischen einem Befehl, der Ereignisse und die Ereignishandler, die von diesem Element zugeordnet.</summary>
        <value>Die Auflistung aller <see cref="T:System.Windows.Input.CommandBinding" /> Objekte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine weitere Möglichkeit zum Auffüllen der <xref:System.Windows.UIElement.CommandBindings%2A> Auflistung ist die Verwendung <xref:System.Windows.Input.CommandManager> Methoden programmgesteuert.  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  
  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreCommandBindings*  
 Eine oder mehrere <xref:System.Windows.Input.CommandBinding> Elemente. Jede dieser müssen eine <xref:System.Windows.Input.CommandBinding.Command%2A> -Attribut auf einen bekannten Befehl festgelegt, und legen Sie die Attribute für die <xref:System.Windows.Input.CommandBinding.CanExecute> und <xref:System.Windows.Input.CommandBinding.Executed> Handlerimplementierungen. Weitere Informationen finden Sie unter <xref:System.Windows.Input.CommandBinding>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Input.CommandBinding> für ein Fenster mit dem Markup. Beachten Sie, dass in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.Input.CommandBindingCollection> ist nicht im Markup als Element; deklariert das Collection-Objekt wird durch den Typ, der die Eigenschaft akzeptiert abgeleitet, und füllen Sie die Property-Element mit einem oder mehreren <xref:System.Windows.Input.CommandBinding> Elemente:  
  
 [!code-xaml[commandWithHandler#CommandHandlerCommandBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml#commandhandlercommandbinding)]  
  
 Weitere Informationen zu den [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax für Auflistungen, finden Sie unter [XAML-Syntax im Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  
  
 Im folgende Beispiel wird im Wesentlichen die gleiche Botschaft Code:  
  
 [!code-csharp[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandHandlerProcedural/CSharp/Window1.xaml.cs#commandhandlerbindinginit)]
 [!code-vb[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandHandlerProcedural/visualbasic/window1.xaml.vb#commandhandlerbindinginit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesiredSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size DesiredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size DesiredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.DesiredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe ab, die dieses Element während des Messdurchgangs im Layoutprozess berechnet hat.</summary>
        <value>Die berechnete Größe, die die gewünschte Größe für den Anordnungsdurchgang wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert wird nur ein gültiges Maß sichtbar, wenn der Wert von der <xref:System.Windows.UIElement.IsMeasureValid%2A> Eigenschaft ist `true`.  
  
 <xref:System.Windows.UIElement.DesiredSize%2A>wird in der Regel überprüft, wie eine Messung Faktoren bei der Implementierung Layoutverhalten wie z. B. Außerkraftsetzungen <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>, <xref:System.Windows.FrameworkElement.MeasureOverride%2A>, oder <xref:System.Windows.UIElement.OnRender%2A> (in der <xref:System.Windows.UIElement.OnRender%2A> Groß-/Kleinschreibung, überprüfen Sie <xref:System.Windows.UIElement.RenderSize%2A> stattdessen Dies hängt jedoch von Ihrer Implementierung). Abhängig vom jeweiligen Szenario <xref:System.Windows.UIElement.DesiredSize%2A> möglicherweise vollständig eingehalten wird, werden durch die Implementierungslogik Einschränkungen auf <xref:System.Windows.UIElement.DesiredSize%2A> angewendet werden, und solchen Einschränkungen können auch andere Eigenschaften des übergeordneten Elements oder ein untergeordnetes Element ändern. Z. B. vergleichen ein Steuerelements, das bildlauffähigen Bereiche unterstützt (aber nicht von der WPF-Frameworkebene Steuerelemente abgeleitet werden, die bereits bildlauffähigen Bereiche ermöglichen), verfügbare Größe, <xref:System.Windows.UIElement.DesiredSize%2A>. Das Steuerelement anschließend einen internen Zustand, der Bildlaufleisten in aktiviert legen die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] für dieses Steuerelement. Oder, <xref:System.Windows.UIElement.DesiredSize%2A> möglicherweise auch in bestimmten Szenarien ignoriert werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Windows.UIElement.DesiredSize%2A> als Teil einer <xref:System.Windows.FrameworkElement.MeasureOverride%2A> Implementierung. Beachten Sie, dass wie <xref:System.Windows.UIElement.Measure%2A> wird aufgerufen, direkt vor dem Abrufen von <xref:System.Windows.UIElement.DesiredSize%2A>. Dadurch wird sichergestellt, dass <xref:System.Windows.UIElement.DesiredSize%2A> legitimen Wert enthält.  
  
 [!code-cpp[PlotPanel#2](~/samples/snippets/cpp/VS_Snippets_Wpf/PlotPanel/CPP/PlotPanel.cpp#2)]
 [!code-csharp[PlotPanel#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PlotPanel/CSharp/PlotPanel.cs#2)]
 [!code-vb[PlotPanel#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PlotPanel/VisualBasic/PlotPanel.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag-Ereignis mit diesem Element als Drag-Ziel meldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.DragEnter?displayProperty=nameWithType> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.DragEnter> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.DragEnterEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewDragEnter>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnDragEnter%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.DragEnter" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag-Ereignis mit diesem Element als Drag-Quelle meldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.DragLeave?displayProperty=nameWithType> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.DragLeave> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.DragLeaveEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.DragDrop.PreviewDragLeave>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnDragLeave%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.DragLeave" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag-Ereignis mit diesem Element als potenzielles Drop-Ziel meldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, auch wenn das Ziehen der Elementgrenzen stammen. Wenn der Ziehvorgang gestartet wurde außerhalb des gültigen Bereichs und verschiebt dann, dieses Ereignis wird auch ausgelöst, als auch <xref:System.Windows.UIElement.DragEnter> und Vorschauereignisse beziehen.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.DragOver?displayProperty=nameWithType> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.DragOver> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.DragOverEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.DragDrop.PreviewDragOver>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnDragOver%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.DragOver" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.Drop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drop-Ereignis meldet, das dieses Element als Drop-Ziel aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.Drop?displayProperty=nameWithType> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.Drop> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.DropEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewDrop>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnDrop%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.Drop" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Bitmapeffekt ab, die zum Anwenden der <see cref="T:System.Windows.UIElement" />. Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Ein <see cref="T:System.Windows.Media.Effects.Effect" /> , der den Bitmapeffekt darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.UIElement.Effect%2A> Eigenschaft einen Bitmapeffekt zum Anwenden einer <xref:System.Windows.UIElement>.  
  
<a name="dependencyPropertyInfo_Effect"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.EffectProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Der folgende XAML-Code wird gezeigt, wie das Zuweisen ein benutzerdefinierten <xref:System.Windows.Media.Effects.ShaderEffect> auf die <xref:System.Windows.UIElement.Effect%2A> Eigenschaft.  
  
 [!code-xaml[System.Windows.Media.Effects.ShaderEffect#1000](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Window1.xaml#1000)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.EffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.Effect" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, den Fokus auf dieses Element festzulegen.</summary>
        <returns>
          <see langword="true" />Wenn Sie über den Tastaturfokus und den logischen Fokus auf dieses Element festgelegt wurden. <see langword="false" /> Wenn nur der logische Fokus auf dieses Element festgelegt wurde, oder wenn der Aufruf dieser Methode zwingen nicht den Fokus zu ändern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den Fokus erhalten kann, werden <xref:System.Windows.UIElement.Focusable%2A> und <xref:System.Windows.UIElement.IsEnabled%2A> müssen sowohl `true`.  
  
 Auch wenn ein Element den Fokus erhalten kann, und aktiviert ist, Ereignisbehandlung in einer bestimmten Struktur ist, (z. B. für ein zusammengesetztes Steuerelement) wird, dass es den Fokus auf die Vorschau Fokusereignisse reagieren möglicherweise, daher diese Methode würde zurück `false`.  
  
 Fokus wird im Allgemeinen durch zwei separaten Konzepten gesteuert: den Tastaturfokus und den logischen Fokus, die nicht immer identisch sind.  Weitere Informationen finden Sie unter [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) oder [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Wenn der Aufruf <xref:System.Windows.UIElement.Focus%2A> gibt `true`, <xref:System.Windows.UIElement.IsKeyboardFocused%2A> und <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> sind auch `true`.  
  
 Wenn die verwandten Eigenschaften nicht bereits sind `true`, beim Aufrufen von <xref:System.Windows.UIElement.Focus%2A>, eine oder mehrere der folgenden Ereignisse werden in der folgenden Reihenfolge ausgelöst: <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>, <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> (Quelle ist das neue Fokusziel), <xref:System.Windows.UIElement.IsKeyboardFocusedChanged>, <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.UIElement.LostKeyboardFocus>, <xref:System.Windows.UIElement.GotKeyboardFocus> (Quelle ist das neue Fokusziel).  
  
 In der Reihenfolge, damit dieser Aufruf erfolgreich ist, muss ein anderes Element in der Anwendung erforderlich, um zuvor den Fokus besitzen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Fokus auf ein <xref:System.Windows.Controls.TextBox> verwiesen wird, indem Sie <xref:System.Windows.FrameworkElement.Name%2A>, und klicken Sie dann passt die Position des Cursors innerhalb der <xref:System.Windows.Controls.TextBox>.  
  
 [!code-csharp[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBox_CursorToEnd/CSharp/Window1.xaml.cs#uielementfocus)]
 [!code-vb[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBox_CursorToEnd/VisualBasic/Window1.xaml.vb#uielementfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Focusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt einen Wert fest, der angibt, ob das Element den Fokus erhalten kann.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Element den Fokus erhalten kann; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur die Fokuselement empfängt Tastatureingaben.  
  
 <xref:System.Windows.UIElement.Focusable%2A>ist die [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] Eigenschaftenaccessor für was in Wirklichkeit eine Abhängigkeitseigenschaft ist. Diese bestimmte Abhängigkeitseigenschaft verfügt relativ häufig einen offensichtlich "Default"-Wert, der in abgeleiteten Elementklassen, insbesondere in Steuerelementen festgelegt. Dieser Fehler tritt häufig in einer von zwei Methoden:  
  
-   Die Abhängigkeitseigenschaft wird von einer bestimmten abgeleiteten Klasse geerbt, sondern ein, die abgeleitete Klasse überschreibt der Metadaten der Abhängigkeitseigenschaft ändert den Standard-Eigenschaftswert.  
  
-   Eines Stils oder einer Vorlage wird auf ein Element angewendet, dem Wert dieser Abhängigkeitseigenschaft anders festgelegt.  
  
 Z. B. die offensichtlichen "Default" der <xref:System.Windows.UIElement.Focusable%2A> für eine <xref:System.Windows.Controls.Button> Steuerelement `true`, obwohl <xref:System.Windows.Controls.Button> erbt <xref:System.Windows.UIElement.Focusable%2A> als eine [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Eigenschaft direkt aus <xref:System.Windows.UIElement>. Dies ist, da der angewendete Metadatenwert für die <xref:System.Windows.UIElement.Focusable%2A> im statischen Konstruktor der Abhängigkeitseigenschaft überschrieben wurde die <xref:System.Windows.Controls.Control> Basisklasse zwischen befindet <xref:System.Windows.Controls.Button> und <xref:System.Windows.UIElement> in der Klassenhierarchie.  
  
 Wenn von geerbt <xref:System.Windows.Controls.Control> oder seinen abgeleiteten Klassen <xref:System.Windows.Controls.Control> definiert den Standardwert dieser Eigenschaft werden `true`.  
  
 Beim von geerbten <xref:System.Windows.Controls.Label> (also eine <xref:System.Windows.Controls.Control> abgeleitete Klasse), der Standardwert ist erneut Klase werden `false`.  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.FocusableProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Der folgende Beispielcode veranschaulicht eine Steuerelementvorlage für ein bestimmtes benutzerdefiniertes Steuerelement, das festlegt <xref:System.Windows.UIElement.Focusable%2A> `false` auf eines der Elemente in der Vorlage.  
  
 [!code-xaml[RichTextBox_NoScrollViewer#_ControlTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBox_NoScrollViewer/CS/window1.xaml#_controltemplate)]
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Ableiten von <see cref="T:System.Windows.UIElement" /> direkt (im Gegensatz zur Verwendung von <see cref="T:System.Windows.Controls.Control" />), überlegen Sie, ob Sie möchten, dass das Element den Fokus erhalten kann, werden, weil standardmäßig das Element nicht den Fokus erhalten kann. Wenn Sie das Element den Fokus erhalten kann sein möchten, überschreiben Sie die Metadaten für diese Eigenschaft im statischen Konstruktor des Typs wie folgt:  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 wobei <paramref name="myElement" /> muss der Klassenname des Typs, die Sie auf den Metadatenwert überschreiben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.FocusableChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Wert der <see cref="P:System.Windows.UIElement.Focusable" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.Focusable" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu überprüfende Abhängigkeitseigenschaft.</param>
        <summary>Gibt den Wert der Basiseigenschaft für die angegebene Eigenschaft dieses Elements zurück, wobei alle möglichen animierten Werte aus einer ausgeführten oder beendeten Animation nicht berücksichtigt werden.</summary>
        <returns>Der Eigenschaftswert, bei dem keine Animationen an die angegebene Abhängigkeitseigenschaft angefügt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Animationen an die Eigenschaft angefügt werden und dann die <xref:System.Windows.UIElement.GetAnimationBaseValue%2A> Rückgabewert ist immer identisch mit der <xref:System.Windows.DependencyObject.GetValue%2A> Rückgabewert. Wenn Animationen angefügt sind, klicken Sie dann alle möglichen abgeleiteten Animationswerte einschließlich Anfangs- und Stop-Werte werden ignoriert und den Wert der Eigenschaft wird basierend auf alle möglichen Eingaben bestimmt. Weitere Informationen finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der den Basiswert einer animierten meldet <xref:System.Windows.FrameworkElement.Width%2A> Eigenschaft auf einen <xref:System.Windows.Controls.Button>, sowie den Basiswert einer Transformation.  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalue)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Die vom Element bereitgestellte verfügbare Größe.</param>
        <summary>Gibt eine alternative Clippinggeometrie zurück, die den Bereich darstellt, der abgeschnitten werden würde <see cref="P:System.Windows.UIElement.ClipToBounds" /> festgelegt <see langword="true" />.</summary>
        <returns>Die mögliche Clippinggeometrie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung der legitime Wert zurückgegeben, verwendet jedoch nicht die `layoutSlotSize` Parameter in den Berechnungen. Stattdessen verwendet er den Wert des <xref:System.Windows.UIElement.RenderSize%2A>.  
  
 Diese Methode wird im Wesentlichen überschrieben von sofort abgeleiteten <xref:System.Windows.FrameworkElement> -Klasse, und die <xref:System.Windows.FrameworkElement> Außerkraftsetzung erzeugt ein komplexeres Verhalten für allgemeine WPF-Frameworkebene Elemente. Ausführliche Informationen finden Sie unter <xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetUIParentCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse gibt eine Alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] übergeordnete für dieses Element, wenn kein visuelles übergeordnetes Element vorhanden ist.</summary>
        <returns>Ein Objekt, wenn die Implementierung einer abgeleiteten Klasse eine alternative übergeordnete Verbindung melden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die standardmäßige virtuelle Implementierung dieser Methode `null`. <xref:System.Windows.FrameworkElement>Stellt eine praktische Implementierung.  
  
 Alternative übergeordnete Elemente werden verwendet, für das Ereignisrouting in Fällen, in dem ein Element eine alternative übergeordnete Struktur erstellt so, dass die Ereignisse weitergeleitet werden, mit denen aus die Standardmuster Routing aufwärts in der visuellen Struktur mit dem standard übergeordneten-Dienstkontos, oder nach unten in der routing-Strategie in der Vorschau anzeigen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag &amp; Drop-Ereignis meldet, das dieses Element betrifft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.GiveFeedback> -Ereignisses kann die Quelle des Drag-Ereignis, um die Darstellung des Mauszeigers zu ändern, um dem Benutzer während eines Drag & Drop-Vorgangs ein visuelles Feedback. Visuelle Feedback darauf hingewiesen, dass es sich bei ein Drag & Drop-Vorgang ausgeführt wird.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.GiveFeedback> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.GiveFeedback> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.GiveFeedbackEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewGiveFeedback>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnGiveFeedback%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.GiveFeedback" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element den logischen Fokus erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der logische Fokus unterscheidet sich vom Tastaturfokus, wenn der Fokus absichtlich durch einen Methodenaufruf erzwungen wird, aber der vorherige Tastaturfokus in einem anderen Gültigkeitsbereich vorhanden ist. In diesem Fall über den Tastaturfokus bleibt, wo sie ist und das Element, in dem eine <xref:System.Windows.UIElement.Focus%2A> Methode wird immer noch ruft der logische Fokus aufgerufen.  
  
 Eine genauere Interpretation dieses Ereignisses ist, dass die It ausgelöst wird, wenn der Wert des der <xref:System.Windows.UIElement.IsFocused%2A> Eigenschaft eines Elements in der Route von geändert wird `false` auf `true`.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das Fokus erhält möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus erhalten hat.  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.GotFocusEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   Es ist keine entsprechende Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnGotFocus%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.GotFocus" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Fokus der Tastatur auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged>ist ein ähnliches Ereignis, das ändert sich in einer Eigenschaft nachverfolgt, die nach einem Element des Fokuszustands verwaltet. die <xref:System.Windows.UIElement.GotKeyboardFocus> Ereignis in vielen unter denselben Umständen ausgelöst wird.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das Fokus besitzt möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus besitzt.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.GotKeyboardFocus> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.GotKeyboardFocus> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.GotKeyboardFocusEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewGotKeyboardFocus>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnGotKeyboardFocus%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.GotKeyboardFocus" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element die Mausauswahl erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst hat, erhält sie Mauseingaben, selbst wenn der Mauszeiger sich außerhalb der Begrenzungen ist. Die Maus ist in der Regel nur während der Drag-and-Drop-Vorgänge erfasst und erfassten bleibt, bis die Drop-Aktion des Drag & Drop-Vorgangs ausgeführt wird.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das erfasst wird möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> im Ereignis erfassen von Daten an das aktuelle Element zu bestimmen, die Maus verfügt.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.GotMouseCapture> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.GotMouseCapture> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.GotMouseCaptureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Es gibt keine definiertes entsprechendes Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnGotMouseCapture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.GotMouseCapture" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element die Stiftauswahl erhält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Stiftauswahl erhält, erhält sie Stifteingabe, selbst wenn der Mauszeiger sich außerhalb der Begrenzungen befindet. Der Tablettstift in der Regel nur während der Drag-and-Drop-Vorgänge aufgezeichnet wird und behält die Aufzeichnung, bis die Drop-Aktion den Drag & Drop-Vorgang auftritt.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das erfasst wird möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die erfasst wird.  
  
 Dieses Ereignis erstellt einen Alias für das angefügte Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.GotStylusCapture> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.GotStylusCapture> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.GotStylusCaptureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Es gibt keine definiertes entsprechendes Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnGotStylusCapture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.GotStylusCapture" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Fingereingabe für dieses Element erfasst wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.GotTouchCaptureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnGotTouchCapture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.GotTouchCapture" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob dieses Element über animierten Eigenschaften verfügt.</summary>
        <value>
          <see langword="true" />Wenn dieses Element angefügte, um alle Eigenschaften des Animationen verfügt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für permanente (nicht getaktete, immer ausgeführte) Animationen oder für Animationen, die einen bestimmten Zeitplan aufweisen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEffectiveKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual bool HasEffectiveKeyboardFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEffectiveKeyboardFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Windows.UIElement" /> den Fokus besitzt.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Windows.UIElement" /> den Fokus besitzt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterklassen können diese Eigenschaft angeben, wenn das Element den Tastaturfokus verfügt, überschreiben.  Dies ist hilfreich, wenn Ihre <xref:System.Windows.UIElement> enthält Elemente, die über den Tastaturfokus erhalten und Sie möchten, dass das Element zum Bericht, dass es den Fokus besitzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Beschreibt den durchzuführenden Treffertest, einschließlich des anfänglichen Trefferpunkts.</param>
        <summary>Implementiert <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />, um das Treffertestverhalten für Basiselemente bereitzustellen (<see cref="T:System.Windows.Media.GeometryHitTestResult" /> wird zurückgegeben).</summary>
        <returns>Die Ergebnisse des Tests, einschließlich der ausgewerteten Geometrie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter der ursprünglichen virtuellen Methode <xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType> für Informationen zu weiteren Überschreiben dieser Methode in Klassen abgeleiteten. Beachten Sie, dass mehrere bestimmter Steuerelemente (<xref:System.Windows.Controls.TextBlock>, z. B.) verfügen über unterschiedliche Implementierungen, die diese Grenze außer Kraft setzt.  
  
 Diese Methode sollte nicht vom Anwendungscode aufgerufen werden. Diese Methode unterstützt interne Treffertestverhalten, die durch verschiedene Aspekte der Eingabesystem verfügbar gemacht werden (ob der Mauszeiger über ein Element, z. B. ist).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Beschreibt den durchzuführenden Treffertest, einschließlich des anfänglichen Trefferpunkts.</param>
        <summary>Implementiert <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />, um das Treffertestverhalten für Basiselemente bereitzustellen (<see cref="T:System.Windows.Media.HitTestResult" /> wird zurückgegeben).</summary>
        <returns>Die Ergebnisse des Tests, einschließlich des ausgewerteten Punkts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter der ursprünglichen virtuellen Methode <xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType> für Informationen zu weiteren Überschreiben dieser Methode in Klassen abgeleiteten. Beachten Sie, dass mehrere bestimmter Steuerelemente (<xref:System.Windows.Controls.TextBlock>, z. B.) verfügen über unterschiedliche Implementierungen, die überschreiben <xref:System.Windows.UIElement.HitTestCore%2A> gemäß der Definition von <xref:System.Windows.UIElement>.  
  
 Diese Methode sollte nicht vom Anwendungscode aufgerufen werden. Diese Methode unterstützt interne Treffertestverhalten, die durch verschiedene Aspekte der Eingabesystem verfügbar gemacht werden (ob der Mauszeiger über ein Element, z. B. ist).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Eingabe Bindungen, die diesem Element zugeordnet.</summary>
        <value>Die Auflistung der Eingabe Bindungen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eingabe Bindungen unterstützen die Bindung von Befehlen für die Eingabe von Geräten. Beispielsweise <xref:System.Windows.Input.MouseBinding> implementiert Eingabe Bindungen, die Eigenschaften enthalten, die speziell für Mausgeräte sind.  
  
 Die Auflistung der Eingabe Bindungen umfasst sowohl Eingabe-Bindungen, die den Typ betreffen als auch Eingabe Bindungen, die auf der Instanz deklariert werden.  
  
 Eine verwandte Eigenschaft <xref:System.Windows.UIElement.CommandBindings%2A>, verwaltet eine Auflistung von befehlsbindungen. Diese unterscheiden sich von Eingabe Bindungen insofern, dass sie die nächste Ebene nach unten der befehlsverarbeitung - Aktionen darstellen, die auf bekannte Befehle gebunden sind.  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  
  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreInputBindings*  
 Eine oder mehrere <xref:System.Windows.Input.InputBinding> Elemente (in der Regel die <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding> abgeleiteten Klassen). Jedes davon wird erwartet eine <xref:System.Windows.Input.InputBinding.Command%2A> und <xref:System.Windows.Input.InputBinding.Gesture%2A> -Attribut festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird diese Eigenschaft auf einen <xref:System.Windows.Window>, mit einem einzelnen <xref:System.Windows.Input.KeyBinding>.  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Weitere Informationen zu den [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Syntax für Auflistungen, finden Sie unter [XAML-Syntax im Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputHitTest">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.IInputElement InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der Offset-Koordinaten innerhalb dieses Elements.</param>
        <summary>Gibt das input-Element innerhalb des aktuellen Elements, das an den angegebenen Koordinaten, relativ zum Ursprung des aktuellen Elements zurück.</summary>
        <returns>Das untergeordnete Element, das sich an der angegebenen Position befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IInputElement>wird als Rückgabetyp, zurückgegeben, da dieser Typ eine allgemeine Schnittstelle für beide ist <xref:System.Windows.UIElement> und <xref:System.Windows.ContentElement>. Können Sie dann den Rückgabetyp entsprechend umwandeln, oder die Schnittstelleninstanz für bestimmte Elemente, die von definiert sind die <xref:System.Windows.IInputElement> Schnittstelle.  
  
 Diese Methode wird in der Regel nicht vom Anwendungscode aufgerufen. Beim Aufrufen dieser Methode ist nur geeignet, wenn Sie beabsichtigen, eine beträchtliche Menge an die low-Level Merkmale erneut zu implementieren, die bereits vorhanden ist, z. B. Neuerstellen von Logik für das Mausgerät sind.  
  
 <xref:System.Windows.IContentHost>Verträge einer <xref:System.Windows.IContentHost.InputHitTest%2A> Methode mit der gleichen Signatur, die einige Elemente explizit implementiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateArrange">
      <MemberSignature Language="C#" Value="public void InvalidateArrange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateArrange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateArrange" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erklärt den Anordnungszustand (das Layout) des Elements für ungültig. Nach der Ungültigkeitserklärung wird das Element das zugehörige Layout aktualisiert, was asynchron erfolgt, es sei denn, die anschließend durch erzwungen haben <see cref="M:System.Windows.UIElement.UpdateLayout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Häufig Aufrufe an <xref:System.Windows.UIElement.InvalidateArrange%2A> oder insbesondere <xref:System.Windows.UIElement.UpdateLayout%2A> erheblich auf die Leistung beeinträchtigen. Vermeiden Sie daher, beim Aufrufen dieser Methode, wenn Sie absolut präzise Layout-Status für nachfolgende Aufrufe von anderen benötigen [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] im Code. Eines erweiterten Szenarios, in denen Sie möglicherweise Aufrufen <xref:System.Windows.UIElement.InvalidateArrange%2A> ist, wenn für die Erstellung einer <xref:System.Windows.PropertyChangedCallback> für eine Abhängigkeitseigenschaft, die nicht in einer <xref:System.Windows.Freezable> oder <xref:System.Windows.FrameworkElement> abgeleitete Klasse, die jedoch immer noch die anordnungsphase des Layouts beeinflusst, wenn sich ändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateMeasure">
      <MemberSignature Language="C#" Value="public void InvalidateMeasure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateMeasure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateMeasure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erklärt den Maßzustand (Layout) des Elements für ungültig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode auch Aufrufe <xref:System.Windows.UIElement.InvalidateArrange%2A> intern, besteht keine Notwendigkeit zum Aufrufen <xref:System.Windows.UIElement.InvalidateMeasure%2A> und <xref:System.Windows.UIElement.InvalidateArrange%2A> hintereinander ausgeführt. Nach der Ungültigkeitserklärung wird das Element das zugehörige Layout aktualisiert, was asynchron, es sei denn, erfolgt, haben <xref:System.Windows.UIElement.UpdateLayout%2A> wird aufgerufen, um eine synchrone layoutänderung zu erzwingen.  
  
 Das WPF-Frameworkebene Layoutsystem wird seine eigene Behandlung von Änderungen in der visuellen Struktur eines Elements und in der am häufigsten vorkommenden Layout invalidierung Fälle ist das Layoutsystem die Entsprechung dieser Methode bei Bedarf aufrufen. Sie sollten diese Methode nur aufrufen, wenn Sie eine vollständige Layout-Implementierung, erzeugt werden sich für die Bearbeitung der Elementstruktur oder ähnliche erweiterte Szenarien. Ein solches Szenario erweitertes ist, wenn Sie erstellen eine <xref:System.Windows.PropertyChangedCallback> für eine Abhängigkeitseigenschaft, die nicht in einem <xref:System.Windows.Freezable> oder <xref:System.Windows.FrameworkElement> abgeleitete Klasse, die immer noch die Messphase des Layouts beeinflusst, ändert.  
  
 Häufig Aufrufe an <xref:System.Windows.UIElement.InvalidateMeasure%2A> oder insbesondere <xref:System.Windows.UIElement.UpdateLayout%2A> erheblich auf die Leistung beeinträchtigen. Vermeiden Sie daher, beim Aufrufen dieser Methode, wenn Sie absolut präzise Layout-Status für nachfolgende Aufrufe von anderen benötigen [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] im Code.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateVisual">
      <MemberSignature Language="C#" Value="public void InvalidateVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateVisual() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateVisual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Macht das Rendern des Elements ungültig und erzwingt einen vollständig neuen Layoutdurchlauf. <see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />wird aufgerufen, nachdem der Layoutzyklus abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.Windows.UIElement.InvalidateArrange%2A> intern.  
  
 Diese Methode wird in der Regel nicht vom Anwendungscode aufgerufen. Das WPF-Frameworkebene Layoutsystem wird seine eigene Behandlung von Änderungen in der visuellen Struktur eines Elements und würde die Entsprechung dieser Methode bei Bedarf aufrufen bereits. Beim Aufrufen dieser Methode ist nur für erweiterte Szenarien erforderlich. Ein solches Szenario erweitertes ist, wenn Sie erstellen eine <xref:System.Windows.PropertyChangedCallback> für eine Abhängigkeitseigenschaft, die nicht in einem <xref:System.Windows.Freezable> oder <xref:System.Windows.FrameworkElement> abgeleitete Klasse, die immer noch das Layout wirkt sich darauf aus, wenn sich ändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArrangeValid">
      <MemberSignature Language="C#" Value="public bool IsArrangeValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArrangeValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsArrangeValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die berechnete Größe und Position von untergeordneten Elementen im Layout für dieses Element gültig sind.</summary>
        <value>
          <see langword="true" />Wenn die Größe und Position des Layouts gültig sind. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Anordnung von Aufrufen erzwingen <xref:System.Windows.UIElement.InvalidateArrange%2A> für dieses Element (oder der übergeordneten Klassen). Dies kennzeichnet das Layout für das Layoutsystem zu so lange das Layoutsystem bestimmt. Alternativ können Sie einen unmittelbaren Aufruf <xref:System.Windows.UIElement.UpdateLayout%2A> hergestellt werden konnte, dies sollte jedoch nur vorgenommen werden, wenn sicher ist, dass keine weiteren Außerkraftsetzungen aufgewendet ausstehen (eine große Anzahl von unnötigerweise erzwungene Updates hat Auswirkungen auf Leistung).  
  
 <xref:System.Windows.UIElement.IsArrangeValid%2A>nicht mit `true` , wenn <xref:System.Windows.UIElement.IsMeasureValid%2A> ist auch `true` (im Layoutprozess Anordnung nicht gültig sein, ohne Maße zuerst als gültig).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob dieses Element, in aktiviert ist der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Element aktiviert ist; andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft von Klasse-spezifische Implementierungen der beeinflusst wird <xref:System.Windows.UIElement.IsEnabledCore%2A> bei bestimmten Elementen wird häufig zur Laufzeit. Aus diesem Grund ist der Standardwert, der hier aufgeführten manchmal nicht wirksam. Z. B. eine <xref:System.Windows.Controls.Primitives.ScrollBar> werden <xref:System.Windows.UIElement.IsEnabled%2A> `false` Wenn bestimmt wird, keine Notwendigkeit zur Unterstützung einer Bildlaufleiste besteht. Versucht, diesen Wert festzulegen, wird möglicherweise auch durch den Rückgabewert von überschrieben werden <xref:System.Windows.UIElement.IsEnabledCore%2A>.  
  
 Elemente, die nicht aktiviert sind keine Teilnahme Treffertests oder den Fokus und werden daher nicht, die Quellen von Eingabeereignissen.  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsEnabledProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einem Handler für eine Schaltfläche, die bei der Ausführung <xref:System.Windows.UIElement.IsEnabled%2A> `false` auf eine andere benannte Schaltfläche `b1`.  
  
 [!code-csharp[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/CSharp/default.xaml.cs#handler)]
 [!code-vb[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/VisualBasic/default.xaml.vb#handler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsEnabledChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsEnabled" /> Eigenschaft dieses Elements ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der Rückgabewert der <see cref="P:System.Windows.UIElement.IsEnabled" /> in abgeleiteten Klassen.</summary>
        <value>
          <see langword="true" />Wenn das Element aktiviert ist; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Die standardmäßige Implementierung dieser Eigenschaft den Wert zwischengespeichert und berechnet, ob das übergeordnete Element dieses Elements aktiviert ist. (Wenn das übergeordnete Element nicht aktiviert ist, das untergeordnete Element kann nicht aktiviert werden, effektiv in praktische [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) Wenn Sie diese Implementierung überschreiben, stellen Sie sicher, dass Sie die grundlegende Implementierung, um dieses Verhalten beizubehalten aufrufen.  
  
 Die <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> -Klasse stellt eine vorhandene Außerkraftsetzung Implementierung dieser Eigenschaft. Diese Außerkraftsetzung wird bestimmt, ob der Inhalt innerhalb des Bereichs Inhalt Präsentation verfügbaren Bereich überschreitet. Wenn der Inhalt des Bereichs liegt, ist der Bildlaufleistenteil aktiviert. Andernfalls ist die Bildlaufleiste nicht aktiviert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsEnabled" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob dieses Element den logischen Fokus hat.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn dieses Element den logischen Fokus hat; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der logische Fokus unterscheiden sich vom Tastaturfokus, wenn eine Anwendung mehrere Abteilungen für den Fokus, z. B. zwischen Menüinhalt und den Rest der Anwendung. In diesem Fall über den Tastaturfokus kann nur für ein Element der Benutzeroberfläche der Anwendung vorhanden sein, jedoch möglicherweise bestimmte Elemente in anderen Abteilungen Fokus weiterhin den logischen Fokus beibehalten. Weitere Informationen über den logischen Fokus finden Sie unter [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 Sie legen Sie nicht den Fokus durch Festlegen dieser Eigenschaft (es kann nur gelesen werden). Die typische Verwendung für diese Eigenschaft ist für die Verwendung als Abhängigkeitseigenschaft für eine <xref:System.Windows.Setter> oder <xref:System.Windows.EventTrigger>. Um den Fokus programmgesteuert festzulegen, rufen <xref:System.Windows.UIElement.Focus%2A>. Fokus kann auch festgelegt werden, durch Benutzeraktionen oder von Steuerelement-Implementierungen, die Verhalten von Capture Maus möglicherweise enthalten.  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsFocusedProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Codehandler, der den Hintergrund eines Steuerelements ändert, wenn es den Fokus erhält.  
  
 [!code-csharp[PopupSimple#IsFocused](~/samples/snippets/csharp/VS_Snippets_Wpf/PopupSimple/CSharp/Window1.xaml.cs#isfocused)]  
  
 Eine andere Möglichkeit, um diesen Effekt zu erreichen ist, platziert eine <xref:System.Windows.Trigger> in den <xref:System.Windows.Style> eines Steuerelements; dieser Ansatz erfordert keine bestimmte Ereignisse mit Code-Behind-Behandlung und können Designer umfassenderen Zugriff auf den interaktiven und grafische Charakter die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Ein Beispiel finden Sie unter [Vorgehensweise: Erstellen einer äußeren Leuchteffekt](http://msdn.microsoft.com/en-us/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsFocused" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt einen Wert fest, der angibt, ob dieses Element möglicherweise als Treffertestergebnis von einem Teil des gerenderten Inhalts zurückgegeben werden kann. Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn dieses Element als Treffertestergebnis von mindestens einem Punkt zurückgegeben werden konnte; andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der effektive Wert dieser Eigenschaft wird durch die relativen Positionen von Treffertests getestet werden Elemente in der logischen Struktur beeinflusst. Z. B. wenn ein Element ein untergeordnetes Element des ist eine Element, das kein Treffertest sichtbar, bleibt der effektive Wert der Eigenschaft für das untergeordnete Element `false`, selbst wenn Sie versuchen, diesen Wert lokal festzulegen. Aus diesem Grund ist es wichtig, dass Sie nicht festlegen <xref:System.Windows.UIElement.IsHitTestVisible%2A> auf `false` für ein zusammengesetztes Steuerelement, wenn keine Eingabe werden soll oder nicht Treffertests für das Steuerelement. Weitere Informationen zu Treffertests finden Sie unter [Treffertests in der visuellen Ebene](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md).  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsHitTestVisibleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert, der die <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> -Abhängigkeitseigenschaft für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsHitTestVisible" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob ein Eingabemethodensystem wie z. B. eine [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], für die Verarbeitung von Eingaben für dieses Element aktiviert ist.</summary>
        <value>
          <see langword="true" />Wenn eine Eingabemethode aktiv ist; andernfalls <see langword="false" />. Der Standardwert der zugrunde liegenden angefügten Eigenschaft ist <see langword="true;" /> jedoch wird dies durch den tatsächlichen Zustand der Eingabemethoden zur Laufzeit beeinflusst werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den Wert, der durch die angefügte Eigenschaft zurückgegeben wird <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> für die derzeit aktivierten Eingabemethoden (Tastatur, Sprache und andere Eingabegeräte).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Element über den Tastaturfokus verfügt.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn dieses Element den Tastaturfokus verfügt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Änderungen an den festgelegten Wert dieser Eigenschaft möglicherweise von den Fokus bezogene Ereignisse begleitet.  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A>und <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> werden im Allgemeinen zum innerhalb der Klasse Ereignishandler anderen Eingabe-bezogene Ereignisse, z. B. um zu bestimmen, ob das Element bereits über den Tastaturfokus verfügt, oder zu Bestimmung, wenn die Maus und Tastaturereignisse im Zusammenhang treten.  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsKeyboardFocusedProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsKeyboardFocused" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich der Tastaturfokus innerhalb des Elements oder in seinen untergeordneten Elementen in der visuellen Struktur befindet.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn Sie über den Tastaturfokus auf das Element oder seinen untergeordneten Elementen befindet; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Änderungen des Werts dieser Eigenschaft in der Regel Auslösen der <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> Ereignis außer eine abgeleitete Klasse außer Kraft gesetzt wurde <xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A> um das Ereignis zu unterdrücken.  
  
 Diese Eigenschaft wird nicht direkt festgelegt, aber Sie können den Fokus auf ein Element festlegen, durch den Aufruf <xref:System.Windows.UIElement.Focus%2A>, oder durch Treffen einer <xref:System.Windows.UIElement.MoveFocus%2A> Anforderung. Beide Methoden rufen möglicherweise Wert dieser Eigenschaft geändert werden.  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A>und <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> dienen im Allgemeinen im Ereignishandler für die Klasse für andere Eingabe-bezogene Ereignisse können z. B. bestimmen, ob das Element bereits über den Tastaturfokus verfügt, oder zu Bestimmung, wenn die Maus und Tastaturereignisse im Zusammenhang treten.  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabled">
      <MemberSignature Language="C#" Value="public bool IsManipulationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsManipulationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsManipulationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob für dieses Manipulationsereignisse aktiviert sind <see cref="T:System.Windows.UIElement" />.</summary>
        <value>
          <see langword="true" />aktivierte Manipulationsereignisse für dieses <see cref="T:System.Windows.UIElement" />ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf "true", wenn Sie möchten die <xref:System.Windows.UIElement> zum Empfangen der <xref:System.Windows.UIElement.ManipulationStarting>, <xref:System.Windows.UIElement.ManipulationStarted>, <xref:System.Windows.UIElement.ManipulationDelta>, <xref:System.Windows.UIElement.ManipulationInertiaStarting>, <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>, und <xref:System.Windows.UIElement.ManipulationCompleted> Ereignisse. Weitere Informationen zu Manipulationen, finden Sie unter der [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Anwendung, die ein rotes Rechteck hat.  Die <xref:System.Windows.UIElement.IsManipulationEnabled%2A> Eigenschaft des Rechtecks ist auf True festgelegt und der Anwendungsverzeichnis abonniert die <xref:System.Windows.UIElement.ManipulationStarting>, <xref:System.Windows.UIElement.ManipulationDelta>, und <xref:System.Windows.UIElement.ManipulationInertiaStarting> Ereignisse. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 [!code-xaml[BasicManipulation#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsManipulationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsManipulationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsManipulationEnabled" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMeasureValid">
      <MemberSignature Language="C#" Value="public bool IsMeasureValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMeasureValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMeasureValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die aktuelle Größe von Layout Measure zurückgegebenen gültig ist.</summary>
        <value>
          <see langword="true" />Wenn der Maßübergabe des zurückgegebenen Layout Werts gültigen und aktuellen; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können erzwingen, Messung und Anordnung durch Aufrufen von <xref:System.Windows.UIElement.InvalidateMeasure%2A> für dieses Element (oder keinem übergeordneten Element der visuellen Struktur nach oben). Dies kennzeichnet das Layout für das Layoutsystem asynchron ausgeführt wird, zu einem Zeitpunkt bestimmt, die vom Layoutsystem auftritt. Alternativ können Sie direkt aufrufen <xref:System.Windows.UIElement.UpdateLayout%2A>. Sie sollten jedoch nur aufrufen, <xref:System.Windows.UIElement.UpdateLayout%2A> , wenn es wahrscheinlich ist, dass keine weiteren Außerkraftsetzungen aufgewendet ausstehen (eine große Anzahl von unnötigerweise erzwungene Updates wird die Auswirkungen auf die Leistung haben).  
  
 Wenn <xref:System.Windows.UIElement.IsMeasureValid%2A> ist `false`, <xref:System.Windows.UIElement.IsArrangeValid%2A> zudem muss `false` (gemäß der erzwungenen Logik im Layoutprozess Anordnung nicht als gültig ohne Maße zuerst als gültig).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Maus für dieses Element erfasst wird.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Element die mausaufzeichnung verfügen; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maus Aufzeichnungsstatus bezieht sich auf prozessinternen Drag & Drop-Vorgänge.  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsMouseCapturedProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Zustand der Maus Erfassung ein- oder ausschalten, abhängig davon, ob die Maus für das Element bereits erfasst wird.  
  
 Wenn die Maus erfassen werden an anderer Stelle, an dieses Element die Mausauswahl festgelegt ist. Wenn das Element die Mausauswahl hatte, durch den Aufruf deaktiviert <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> mit einer null-Eingabe.  
  
 [!code-csharp[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseSnippetSample/CSharp/Window1.xaml.cs#ismousecaptured)]
 [!code-vb[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseSnippetSample/visualbasic/window1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsMouseCaptured" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob die Mausaufzeichnung in diesem Element oder in untergeordneten Elementen in seiner visuellen Struktur enthalten ist. Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn dieses Element oder ein darin enthaltenes Element die mausaufzeichnung verfügen; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /> Änderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Position des Mauszeigers entspricht Testergebnisse, die elementzusammensetzung berücksichtigt wird.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn der Mauszeiger über demselben Elementergebnis wie ein Treffertest befindet; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Windows.UIElement.IsMouseOver%2A>, diese Eigenschaft ist nur `true` , wenn der Mauszeiger über dem literalen Element ist – wie für einen Treffertest. Wenn der Mauszeiger stattdessen über ein untergeordnetes Element ist, insbesondere über Elemente, die Teil eines Elements eine umfassendere Vorlage und Compositing, sind diese Eigenschaft werden `false`. Wenn Sie wissen, wie ein Steuerelement zusammengesetzte ist (z. B. Sie verwenden diese Eigenschaft in einer benutzerdefinierten Steuerelementvorlage für ein Steuerelement, das Sie definieren), diese Eigenschaft möglicherweise unerwartete Ergebnisse zurückgeben. Verwenden Sie für die meisten Szenarien, in denen Sie keine Steuerelemente erstellt werden, <xref:System.Windows.UIElement.IsMouseOver%2A> stattdessen.  
  
 Wenn dieses Element die Maus erfasst und diese Eigenschaft ist `true` Zeitpunkt der Erfassung weiterhin diese Eigenschaft zurückgeben `true` bis Mauseingaben aufzufangen verloren gegangen ist und der Zeiger nicht über die Grenzen ist.  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich der Mauszeiger über diesem Element (einschließlich der untergeordneten Elemente in der visuellen Struktur) befindet.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn der Mauszeiger über dem Element oder seinen untergeordneten Elementen befindet; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel sind Steuerelemente so zusammengesetzt, dass die verschiedenen Elemente innerhalb des Steuerelements (der visuellen Struktur) werden den Zustand von Mauseingaben für das enthaltende Steuerelement melden. Z. B. eine <xref:System.Windows.Controls.ListBox> Stil Steuerelement meldet <xref:System.Windows.UIElement.IsMouseOver%2A> als `true` , wenn die Maus an beliebiger Stelle über seine Geometrie befindet, einschließlich aller <xref:System.Windows.Controls.ListBoxItem>.  
  
 Obwohl eine analoge "IsMouseOverChanged"-Ereignis nicht vorhanden ist, sind mehrere ähnliche Ereignisse auf. Sie können z. B. behandeln <xref:System.Windows.UIElement.MouseEnter>, <xref:System.Windows.UIElement.MouseMove>, und <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>.  
  
 Wenn dieses Element die Maus erfasst hat, wird diese Eigenschaft bleibt `true` bis Mauseingaben aufzufangen verloren gegangen ist und der Mauszeiger den Bereich der Grenzen des Elements verlässt.  
  
 Einige Steuerelemente erfassen bewusst auf bestimmte Aktionen, die nicht direkt auf die Maus umfassen erscheinen. Dies kann zu <xref:System.Windows.UIElement.IsMouseOver%2A> wird `true` , obwohl die Maus anscheinend nicht bewegt wurde.  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsMouseOverProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgende Beispiel verweist diese Eigenschaft auf, weil der Eigenschaftentyp des eine <xref:System.Windows.Trigger>, der Teil einer \<Style.Triggers > Block. Wenn die Maus über dem Steuerelement befindet, der Steuerelementtext Blau, und der Mauszeiger als Hand angezeigt.  
  
 [!code-xaml[ListViewChkBox#Trigger](~/samples/snippets/csharp/VS_Snippets_Wpf/ListViewChkBox/CS/window1.xaml#trigger)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsMouseOver" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Tablettstift für dieses Element erfasst wird.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Element die Stiftauswahl verfügt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsStylusCapturedProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCapturedChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsStylusCaptured" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob die Tablettstifterfassung von diesem Element oder von einem Element innerhalb der Elementgrenzen und dessen visueller Struktur aufgenommen wird. Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn dieses Element oder ein darin enthaltenes Element die Stiftauswahl hat. andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Eingabe-Touch-Unterstützung in Windows Vista](http://msdn.microsoft.com/en-us/63f1d71f-03d8-4d83-a174-e3dc7c57bad0) und [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Position des Tablettstifts entspricht Testergebnisse, die elementzusammensetzung berücksichtigt wird.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn sich der Tablettstiftzeiger über demselben Elementergebnis wie ein Treffertest befindet; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Windows.UIElement.IsStylusOver%2A>, diese Eigenschaft ist nur `true` , wenn der Tablettstift über dem Element befindet. Wenn sich der Tablettstift stattdessen über ein untergeordnetes Element oder Elemente, die Teil eines Elements eine umfassendere Compositing (der visuellen Struktur) sind, wird diese Eigenschaft werden `false`.  
  
 Wenn Sie wissen, wie ein Steuerelement zusammengesetzte ist (z. B. Sie verwenden diese Eigenschaft in einer benutzerdefinierten Steuerelementvorlage für ein Steuerelement, das Sie definieren), diese Eigenschaft möglicherweise unerwartete Ergebnisse zurückgeben. Verwenden Sie für die meisten Szenarien, in denen Sie keine Steuerelemente erstellt werden, <xref:System.Windows.UIElement.IsStylusOver%2A> stattdessen.  
  
 Wenn dieses Element den Tablettstift hat und diese Eigenschaft ist `true` zum Zeitpunkt der Erfassung, diese Eigenschaft bleibt `true` bis Tablettstift verloren gegangen ist und der Stift nicht über die Grenzen ist.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob sich der Stiftcursor über diesem Element (einschließlich der untergeordneten visuellen Elemente) befindet.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn der Stiftcursor über dem Element oder seinen untergeordneten Elementen befindet; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element die Stiftauswahl verfügt, wird diese Eigenschaft zurückzugebenden fortgesetzt `true` bis Tablettstift verloren gegangen ist und der Mauszeiger befindet sich außerhalb der Grenzen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsStylusOverProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsStylusOver" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob dieses Element im sichtbar ist die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Element sichtbar ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bestimmung der <xref:System.Windows.UIElement.IsVisible%2A> Wert berücksichtigt alle Faktoren des Layouts. Im Gegensatz dazu <xref:System.Windows.UIElement.Visibility%2A>, also eine festlegbare Eigenschaft nur gibt an, dass programmgesteuert ein Element sichtbar oder unsichtbar zu machen.  
  
 Elemente, in denen <xref:System.Windows.UIElement.IsVisible%2A> ist `false` nicht teilnehmen Eingabeereignissen (oder Befehlen), führen Sie nicht beeinflussen Sie entweder das Measure oder Anordnen des Layouts, sind nicht den Fokus erhalten kann, sind nicht in einer Sequenz Registerkarte und Treffertests gemeldet werden. Im Gegensatz dazu sind Elemente, in denen <xref:System.Windows.UIElement.IsEnabled%2A> ist `false` weiterhin in der Ereignisse und Befehle und Treffertests einbezogen wird, jedoch sind ebenfalls nicht den Fokus erhalten kann.  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.IsVisibleProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Wert von der <see cref="P:System.Windows.UIElement.IsVisible" /> eigenschaftenänderungen für dieses Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird nicht ausgelöst, wenn das Element nicht vom Layoutsystem Gründen als dem der Wert des gerendert wird, wird die <xref:System.Windows.UIElement.IsVisible%2A> Eigenschaft. Beispielsweise kann das Element nicht zugeordnetes visuelles aufweisen.  
  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.IsVisible" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Taste gedrückt wird, während sich der Fokus auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schlüsselverarbeitung interagiert mit anderen Plattformfunktionen, z. B. Befehle und Text Zusammensetzung. Die <xref:System.Windows.UIElement.KeyDown> Ereignis ist eine technisch anspruchsvolle Texteingabeereignis, die nicht auf bestimmte Steuerelemente erwartungsgemäß Verhalten. Dies ist, da einige Steuerelemente verfügen über Steuerelement Compositing oder Klassenbehandlung, die eine auf höherer Ebene Version des Texts enthält Eingabe Behandlung und verknüpfte Ereignisse.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.KeyDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.KeyDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.KeyDownEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewKeyDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnKeyDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.KeyDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Taste losgelassen wird, während sich der Fokus auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.KeyUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.KeyUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.KeyUpEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewKeyUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnKeyUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.KeyUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler LayoutUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LayoutUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LayoutUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Layout der verschiedenen visuellen Elemente mit dem aktuellen zugeordnete <see cref="T:System.Windows.Threading.Dispatcher" /> ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Layoutupdate kann aufgrund der Änderung einer Eigenschaft, ein zum Ändern der Fenstergröße oder eine explizite benutzeranforderung auftreten.  
  
 Dieser Member ist ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignis, nicht für ein Routingereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element den logischen Fokus verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der logische Fokus unterscheidet sich vom Tastaturfokus, wenn der Fokus absichtlich durch einen Methodenaufruf verloren wird, der vorherige Tastaturfokus jedoch in einem anderen Gültigkeitsbereich vorhanden ist. In diesem Szenario, Tastatur Fokus bleibt, wo sie ist, und das Element, in dem eine <xref:System.Windows.UIElement.Focus%2A> Methode wird immer noch ruft der logische Fokus aufgerufen.  
  
 Eine genauere Interpretation dieses Ereignisses ist, dass die It ausgelöst wird, wenn der Wert von der <xref:System.Windows.UIElement.IsFocused%2A> Eigenschaft eines Elements in der Route ändert sich von `true` auf `false`.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das Fokus verloren hat möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus erhalten hat.  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.LostFocusEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   Es ist keine entsprechende Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnLostFocus%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.LostFocus" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Fokus der Tastatur nicht mehr auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das Fokus verloren hat möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus verloren hat.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.LostKeyboardFocus> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.LostKeyboardFocus> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.LostKeyboardFocusEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnLostKeyboardFocus%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.LostKeyboardFocus" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostMouseCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element die Mausauswahl verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst hat, erhält sie Mauseingaben, selbst wenn der Zeiger sich außerhalb der Begrenzungen. Die Maus ist in der Regel nur während der Drag-and-Drop-Vorgänge erfasst.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das die Erfassung verliert möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Erfassung verloren.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.LostMouseCapture> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.LostMouseCapture> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.LostMouseCaptureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Es gibt keine definiertes entsprechendes Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnLostMouseCapture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.LostMouseCapture" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostStylusCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element die Stiftauswahl verliert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Stiftauswahl erhält, erhält sie Stifteingabe, selbst wenn der Mauszeiger sich außerhalb der Begrenzungen befindet. Der Tablettstift wird in der Regel nur während der Drag-and-Drop-Vorgänge erfasst.  
  
 Da dieses Ereignis bubbling-routing verwendet, das Element, das Fokus verloren hat möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus verloren hat.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.LostStylusCapture> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.LostStylusCapture> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.LostStylusCaptureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Es gibt keine definiertes entsprechendes Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnLostStylusCapture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.LostStylusCapture" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostTouchCapture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element keine Fingereingaben erfasst mehr.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.LostTouchCaptureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnLostTouchCapture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.LostTouchCapture" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn es sich bei die Bearbeitung eine Grenze auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_ManipulationBoundaryFeedback"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Bearbeitung und Trägheit auf die <see cref="T:System.Windows.UIElement" /> -Objekts abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis verwenden, zum Abrufen von Informationen zu der Manipulation, wenn er abgeschlossen ist.  Beispielsweise können Sie die <xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, die Gesamtmenge der Position der Manipulation geändert.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter der [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
<a name="routedEventInfo_ManipulationCompleted"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ManipulationCompletedEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.ManipulationCompletedEventArgs>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompletedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationCompletedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationCompletedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.ManipulationCompleted" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDelta">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationDelta" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabegerät während eines Bearbeitungsvorgangs Position ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.ManipulationDelta> Ereignis tritt auf, mehrmals aus, wenn der Benutzer während eines Bearbeitungsvorgangs Finger über den Bildschirm zieht, und erneut, wenn Trägheit auftritt.  Sie können die <xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A> Eigenschaft zu überprüfen, ob das Ereignis, während der Trägheit auftritt.  
  
 Das Element auf mit <xref:System.Windows.UIElement.ManipulationDelta> Ereignis tritt auf, wird nicht in keiner Weise beeinflusst, wenn das Ereignis auftritt.  Sie müssen die Logik für das Element angeben, die bearbeitet werden.  Die <xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A> und <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> Eigenschaften, die vom Typ sind <xref:System.Windows.Input.ManipulationDelta>, enthalten Daten zu ändern, wie die Position der Manipulationen und als verschieben, Ändern der Größe oder Drehen eines Objekts interpretiert.  Sie gelten, die Informationen für das Element, das bearbeitet werden soll.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter der [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
<a name="routedEventInfo_ManipulationDelta"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ManipulationDeltaEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.ManipulationDeltaEventArgs>.|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen Ereignishandler für das <xref:System.Windows.UIElement.ManipulationDelta> Ereignis. Im Beispiel wird die <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> Eigenschaft zu verschieben, ändern Sie die Größe und drehen Sie ein <xref:System.Windows.Shapes.Rectangle>.  Im Beispiel wird auch überprüft, ob die <xref:System.Windows.UIElement.ManipulationDelta> Ereignis aufgetreten ist, während der Trägheit und gibt an, ob das Rechteck am Rand eines Fensters berührt.  Wenn die Fälle auf "true" festgelegt sind, reagiert die Anwendung die Bearbeitung, um zu verhindern, dass das Rechteck verlassen den sichtbaren Bereich der Anwendung an. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 [!code-csharp[BasicManipulation#ManipulationDelta](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationdelta)]
 [!code-vb[BasicManipulation#ManipulationDelta](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationdelta)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDeltaEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationDeltaEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationDeltaEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.ManipulationDelta" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationInertiaStarting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabegerät Kontakt mit verliert die <see cref="T:System.Windows.UIElement" /> Objekts während der Bearbeitung und Trägheit beginnt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.ManipulationInertiaStarting> Ereignis tritt auf, wenn der Benutzer alle Finger vom Bildschirm während eines Bearbeitungsvorgangs anhebt. Z. B. wenn ein Benutzer "löst" eine <xref:System.Windows.UIElement> über eine Oberfläche berührt der Benutzer die <xref:System.Windows.UIElement> um die Aktion zu beginnen, verschieben Sie den Finger auf dem Bildschirm für eine kurze Entfernung, und lassen Sie anschließend die <xref:System.Windows.UIElement>. Beginnt, sobald der Benutzer das Element freigibt, Trägheit und <xref:System.Windows.UIElement.ManipulationInertiaStarting> Ereignis auftritt.  Die <xref:System.Windows.UIElement> empfängt weiterhin <xref:System.Windows.UIElement.ManipulationDelta> Ereignisse, um anzugeben, dass Trägheit für das Element auftritt.  
  
 Sie können dieses Ereignis verwenden, um das Verhalten der Trägheit anzugeben.  Beispielsweise können Sie die ursprüngliche Geschwindigkeit festlegen, die verwendet wird, wenn Trägheit beginnt.  Sie können den Betrag der Trägheit auch durch Festlegen der gewünschten Verlangsamung oder durch Festlegen der gewünschten Position angeben.  Sie können diese Werte für jeden Typ von Manipulation (Übersetzung, Erweiterung oder Drehung) unabhängig voneinander festlegen.  Weitere Informationen finden Sie unter <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter der [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
<a name="routedEventInfo_ManipulationInertiaStarting"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>.|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.UIElement.ManipulationInertiaStarting> Ereignishandler und legt die gewünschte Verlangsamung für Übersetzung, Erweiterung und Drehung, die während der Trägheit verwendet wird. In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 [!code-csharp[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationinertiastarting)]
 [!code-vb[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationinertiastarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationInertiaStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Eingabegerät, das auf eine Manipulation beginnt die <see cref="T:System.Windows.UIElement" /> Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.ManipulationStarted> Ereignis tritt auf, nachdem die <xref:System.Windows.UIElement.ManipulationStarting> Ereignis.  Sie können Folgendes mit der <xref:System.Windows.Input.ManipulationStartedEventArgs>:  
  
-   Abrufen des Elements, das die Manipulation Position relativ zum mithilfe der <xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A> Eigenschaft.  
  
-   Rufen Sie mit der Ursprung der Manipulation der <xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A> Eigenschaft.  
  
-   Brechen Sie die Bearbeitung durch Aufrufen der <xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A> Methode.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter der [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
<a name="routedEventInfo_ManipulationStarted"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ManipulationStartedEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.ManipulationStartedEventArgs>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.ManipulationStarted" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Manipulationsprozessor zuerst erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.ManipulationStarting> Ereignis tritt auf, auf ein Element mit dem <xref:System.Windows.UIElement.IsManipulationEnabled%2A> -Eigenschaftensatz auf `true` Wenn der Benutzer einen Finger darauf legt. Standardmäßig melden nachfolgende Manipulationsereignisse die Position der Manipulation relativ zu das Element mit <xref:System.Windows.UIElement.IsManipulationEnabled%2A> festgelegt `true`.  Sie können angeben, dass die Position relativ zu einem anderen Element, durch Festlegen sein soll der <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> Eigenschaft. Beispielsweise können Sie die Manipulation relativ zu das übergeordnete Element des Elements vornehmen.  
  
 Sie können auch folgendermaßen vorgehen in einem Ereignishandler für <xref:System.Windows.UIElement.ManipulationStarting>:  
  
-   Gibt an, ob der Benutzer mehr als ein Finger benötigt auszuführenden die Manipulationen durch Festlegen der <xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Angeben, welche Typen von Manipulation aktiviert sind, durch Festlegen der <xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType> Eigenschaft, um eine <xref:System.Windows.Input.ManipulationModes> Enumeration.  
  
-   Geben Sie den Mittelpunkt der einem einzelnen Finger Drehung durch Festlegen der <xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Brechen Sie die Bearbeitung durch Aufrufen der <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType> Methode.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter der [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
<a name="routedEventInfo_ManipulationStarting"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.ManipulationStartingEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.ManipulationStartingEventArgs>.|  
  
   
  
## Examples  
 Im folgenden Beispiel wird des ereignishandlers für das <xref:System.Windows.UIElement.ManipulationStarting> Ereignis und legt die <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> zum übergeordneten Element, das die Manipulationsereignisse empfängt, sodass die Koordinaten der Manipulation relativ zum übergeordneten Element sind.  In diesem Beispiel ist Teil eines umfangreicheren Beispiels in [Exemplarische Vorgehensweise: Erstellen Ihrer ersten Touch Application](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 [!code-csharp[BasicManipulation#ManipulationStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationstarting)]
 [!code-vb[BasicManipulation#ManipulationStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationstarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.ManipulationStarting" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Measure">
      <MemberSignature Language="C#" Value="public void Measure (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Measure(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Der verfügbare Speicherplatz, den ein übergeordnetes Element für ein untergeordnetes Element reservieren kann. Ein untergeordnetes Element kann mehr Speicherplatz erfordern, als verfügbar ist. Die angegebene Größe kann zugewiesen werden, wenn für das aktuelle Element im Inhaltsmodell Bildlaufvorgänge möglich sind.</param>
        <summary>Updates der <see cref="P:System.Windows.UIElement.DesiredSize" /> von einem <see cref="T:System.Windows.UIElement" />. Übergeordnete Elemente rufen diese Methode aus ihren eigenen <see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /> Implementierungen, um eine rekursive layoutaktualisierung zu aktualisieren. Das Aufrufen dieser Methode stellt die erste Übergabe (die "Maßübergabe") einer Layoutaktualisierung dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnung des layoutpositionierung [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] besteht aus einem <xref:System.Windows.UIElement.Measure%2A> aufrufen und eine <xref:System.Windows.UIElement.Arrange%2A> aufrufen. Während der <xref:System.Windows.UIElement.Measure%2A> Aufruf, der ein Element bestimmt die Größe mithilfe einer `availableSize` Eingabe. Während der <xref:System.Windows.UIElement.Arrange%2A> der Elementgröße-Aufruf abgeschlossen ist.  
  
 `availableSize`eine beliebige Zahl von 0 (null), unendlich kann sein. Elemente eines Layouts sollte das Minimum zurückgeben <xref:System.Windows.Size> sie benötigen für einen angegebenen `availableSize`.  
  
 Wenn ein Layout zuerst instanziiert wird, erhält er immer eine <xref:System.Windows.UIElement.Measure%2A> aufrufen, bevor Sie <xref:System.Windows.UIElement.Arrange%2A>. Nach der ersten Layoutdurchlauf, es kann jedoch empfangen eine <xref:System.Windows.UIElement.Arrange%2A> aufrufen, ohne eine <xref:System.Windows.UIElement.Measure%2A>; Dies kann auftreten, wenn eine Eigenschaft, die wirkt sich nur auf <xref:System.Windows.UIElement.Arrange%2A> (z. B. Ausrichtung) geändert wird oder wenn das übergeordnete Element erhält einen <xref:System.Windows.UIElement.Arrange%2A> ohne eine <xref:System.Windows.UIElement.Measure%2A>. Ein <xref:System.Windows.UIElement.Measure%2A> Aufruf wird automatisch für ungültig zu erklären einer <xref:System.Windows.UIElement.Arrange%2A> aufrufen.  
  
 Layout Updates erfolgen asynchron auf, so, dass der Haupt-Thread nicht jede mögliche layoutänderung wartet. Abfragen eines Elements über Code-Behind-Überprüfung der Eigenschaftswerte entsprechen möglicherweise nicht sofort Änderungen an den Eigenschaften, die Interaktion mit die Größe oder dem Layout-Eigenschaften (die <xref:System.Windows.FrameworkElement.Width%2A> z. B.-Eigenschaft).  
  
> [!NOTE]
>  Layout Updates können erzwungen werden, mithilfe der <xref:System.Windows.UIElement.UpdateLayout%2A> Methode. Allerdings wird beim Aufrufen dieser Methode ist normalerweise nicht erforderlich und kann dazu führen, dass eine schlechte Leistung.  
  
 Das Layoutsystem verfolgt zwei separate Warteschlangen mit ungültigen Layouts für <xref:System.Windows.UIElement.Measure%2A> und eine für <xref:System.Windows.UIElement.Arrange%2A>. Die Layoutwarteschlange wird basierend auf der Reihenfolge der Elemente in der visuellen Struktur des Elementlayouts sortiert ist. Elemente, die weiter oben in der Struktur sind am Anfang der Warteschlange, um redundante Layouts durch wiederholte Änderungen an, in der übergeordneten Elemente zu vermeiden. Doppelt vorhandene Einträge werden automatisch aus der Warteschlange entfernt, und Elemente werden automatisch aus der Warteschlange entfernt, wenn sie bereits Layout überprüft werden.  
  
 Beim Aktualisieren eines Layouts, das <xref:System.Windows.UIElement.Measure%2A> Warteschlange wird geleert zuerst, gefolgt von der <xref:System.Windows.UIElement.Arrange%2A> Warteschlange. Ein Element in der <xref:System.Windows.UIElement.Arrange%2A> Warteschlange wird nie angeordnet werden, wenn ein in Element der <xref:System.Windows.UIElement.Measure%2A> Warteschlange.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Die verfügbare Größe, die das übergeordnete Element des untergeordneten Elements zugewiesen werden kann.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse eine Messung-Logik zum Anpassen von diesem Elements ordnungsgemäß mit Berücksichtigung der Größe der untergeordneten Inhalt bereitstellt.</summary>
        <returns>Die gewünschte Größe dieses Elements im Layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist eher üblich, leiten Sie ein Element aus <xref:System.Windows.FrameworkElement> statt <xref:System.Windows.UIElement>. Wenn beim Ableiten von <xref:System.Windows.FrameworkElement>, beachten Sie, dass eine Überschreibung der <xref:System.Windows.UIElement.MeasureCore%2A> auf <xref:System.Windows.FrameworkElement> versiegelt die <xref:System.Windows.UIElement.MeasureCore%2A> Methode. Daher nur überschreiben <xref:System.Windows.UIElement.MeasureCore%2A> als Mittel zum Layouteigenschaften-Measure zu ändern, wenn Sie von ableiten <xref:System.Windows.UIElement> über eine Vererbung, die keine enthalten <xref:System.Windows.FrameworkElement>. Dies kann der Fall sein, wenn Sie versuchen, eine eigene Implementierung erstellen, auf die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Hauptebenen-. Andernfalls, wenn beim Ableiten von <xref:System.Windows.FrameworkElement>, und klicken Sie dann die Implementierungsvorlage für Measure Verhalten ist das <xref:System.Windows.FrameworkElement> Implementierung der.<xref:System.Windows.FrameworkElement.MeasureOverride%2A>.  
  
 Ein übergeordnetes Element mit untergeordneten Elementen muss Aufrufen <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element andernfalls diese untergeordneten Elemente sind keine Größe oder angeordnet und effektiv aus dem Layout entfernt wird.  
  
   
  
## Examples  
 Eine typische Überschreibung <xref:System.Windows.UIElement.MeasureCore%2A> folgt diesem Muster ungefähre (es ist keine integrierte Auflistung aufgerufen `VisualChildren`; `VisualChildren` ist ein Platzhalter, die die untergeordnete Auflistung darstellt, das Element verwaltet).  
  
 [!code-csharp[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementmeasureoverride)]
 [!code-vb[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementmeasureoverride)]  
  
-   Rufen Sie <xref:System.Windows.UIElement.Measure%2A> für jedes untergeordnete Element.  
  
-   Im Allgemeinen sollten Ihre Implementierung Messung Informationen zwischen Zwischenspeichern der <xref:System.Windows.UIElement.MeasureCore%2A> und <xref:System.Windows.UIElement.ArrangeCore%2A> Methodenaufrufe in demselben Element.  
  
-   Aufrufen von Basis Implementierungen von <xref:System.Windows.UIElement.MeasureCore%2A> ist nicht erforderlich, aber möglicherweise angemessen, wenn die grundlegende Implementierung einer gewünschten Layout bietet.  
  
-   Aufrufe von <xref:System.Windows.UIElement.Measure%2A> für untergeordnete Elemente sollten übergeben Sie entweder den gleichen `availableSize` als das übergeordnete Element oder eine Teilmenge des Bereichs, abhängig vom Layout des übergeordneten Elements unterstützt. Beispielsweise wäre es zulässig, den Bereich für ein elementspezifischen Rahmen, Abstand, eine Bildlaufleiste oder ein benutzerdefiniertes Steuerelement zu entfernen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Implementierungen müssen in der Lage, einen Wertanbieter für verarbeiten <paramref name="availableSize" /> , unendlich ist. Ein unendlichen Wert gibt keine angeforderten Einschränkungen und effektiv verzögert Messung Wahl zum übergeordneten Element, über rekursiver Measure aufruft.  
  
 Implementierungen können die Wertanbieter für berücksichtigen <paramref name="availableSize" /> eine leichte Einschränkung sein. Das untergeordnete Element kann eine größere Größe angeben, selbst wenn andere Aspekte der Anwendungscode die aktuelle tatsächliche Größe des übergeordneten Elements bestimmen können. Die Groß-Anforderung ist eine Konvention, die angibt, dass das untergeordnete Element abgefragt wird, ob das übergeordnete Element Inhalt Bildlauf innerhalb einer Region Inhaltsanzeige unterstützen kann.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste gedrückt wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.MouseDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.MouseDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Die <xref:System.Windows.UIElement.MouseDown> Ereignis wird häufig zusammen mit entweder <xref:System.Windows.UIElement.MouseLeftButtonDown> oder <xref:System.Windows.UIElement.MouseRightButtonDown>, das Drücken einer der beiden standard Maustasten entsprechen. <xref:System.Windows.UIElement.MouseLeftButtonDown>und <xref:System.Windows.UIElement.MouseRightButtonDown> sind auch Routingereignisse, aber sie sind direkte Routingereignisse und die entsprechende Schaltfläche-spezifische-Ereignis wird ausgelöst, wenn die <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> -Ereignis dieses Element auf der Ereignisroute erreicht. Finden Sie unter "Hinweise" für <xref:System.Windows.UIElement.MouseLeftButtonDown> oder <xref:System.Windows.UIElement.MouseRightButtonDown>.  
  
> [!IMPORTANT]
>  Einige Steuerelemente möglicherweise inhärente Klassenbehandlung für Mausereignisse-Schaltfläche. Die linke Maustaste ausgelöste Ereignis ist das wahrscheinlichste Ereignis Klassenbehandlung in einem Steuerelement aufweisen. Die Klassenbehandlung häufig kennzeichnet die zugrunde liegende <xref:System.Windows.Input.Mouse> Klassenereignis als behandelt. Nachdem das Ereignis als behandelt markiert ist, werden andere Instanzhandler, die diesem Element zugeordnet sind, nicht in der Regel ausgelöst. Andere Klasse oder Instanz Handler, die auf Elemente in der bubbling-Richtung zum Stamm in der Benutzeroberflächenautomatisierungs-Struktur angefügt werden, werden auch nicht in der Regel ausgelöst.  
  
 Können Sie beheben Sie das Problem, das in der vorherigen wichtig beschrieben wird und weiterhin <xref:System.Windows.UIElement.MouseDown> Ereignisse für die linke Maustaste unten Ereignisse in einer abgeleiteten Klasse, die eine Klassenbehandlung mithilfe einer dieser Lösungen verfügt:  
  
-   Fügen Sie Handler für das <xref:System.Windows.UIElement.PreviewMouseDown> -Ereignis, das nicht von den Steuerelementen als behandelt markiert ist. Beachten Sie, da dies eine Vorschauereignis ist, die Route am Stamm beginnt und auf das Steuerelement tunnelt.  
  
-   Registrieren Sie einen Handler für das Steuerelement prozeduralen durch Aufrufen von <xref:System.Windows.UIElement.AddHandler%2A> und wählen Sie die Option für die Signatur, die es ermöglicht die Ereignishandler für Ereignisse überwacht werden soll, selbst wenn sie bereits in die gerouteten Ereignisdaten als behandelt markiert sind.  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseDownEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewMouseDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger in den Bereich dieses Elements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseEnter>ist eine, die Routingstrategie für direkte Ereignisbehandlung verwendet. Direkte Routingereignisse werden nicht auf einer Route ausgelöst. Stattdessen werden diese in demselben Element behandelt, in dem sie ausgelöst werden. Aktivieren sie jedoch andere Aspekte der Routingereignis-Verhalten, z. B. in Formaten-Ereignis ausgelöst.  
  
 Obwohl <xref:System.Windows.UIElement.MouseEnter> verfolgt nach, wenn der Mauszeiger die Grenzen eines Elements dieses Weitere Ereignis eintritt buchstäblich angibt, welches die <xref:System.Windows.UIElement.IsMouseOver%2A> Eigenschaftswert geändert hat `false` auf `true` für dieses Element.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.MouseEnter> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.MouseEnter> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Ein <xref:System.Windows.Controls.Button> (oder eine beliebige <xref:System.Windows.Controls.Primitives.ButtonBase> abgeleitete Klasse) verfügt über einheitlichen Behandlung für eine <xref:System.Windows.UIElement.KeyDown> Ereignis, wenn die Schaltfläche "" den Fokus hat und die gedrückte Taste die LEERTASTE wird. Der einheitlichen Behandlung löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis mit der Schaltfläche "" als Quelle, und auch die Maus erfasst, auch wenn der Mauszeiger nicht angezeigt wird, verschieben. Durch das Erfassen von Mauseingaben ein <xref:System.Windows.UIElement.MouseEnter> Ereignis wird auch mit der Schaltfläche "" als Quelle. Im Allgemeinen gilt: Wenn ein Element die Maus erfasst, die dann <xref:System.Windows.UIElement.MouseEnter> ausgelöst wird, sowie <xref:System.Windows.UIElement.GotMouseCapture> und möglicherweise andere steuerelementspezifische Ereignisse.  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseEnterEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseEnter%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseEnter" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger den Bereich dieses Elements verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeave>ist eine, die Routingstrategie für direkte Ereignisbehandlung verwendet. Direkte Routingereignisse werden nicht auf einer Route ausgelöst. Stattdessen werden diese in demselben Element behandelt, in dem sie ausgelöst werden. Aktivieren sie jedoch andere Aspekte der Routingereignis-Verhalten, z. B. in Formaten-Ereignis ausgelöst.  
  
 Obwohl <xref:System.Windows.UIElement.MouseLeave> verfolgt nach, wann die Maus ein Element, das dieses Ereignis verlässt buchstäblich angibt, welches die <xref:System.Windows.UIElement.IsMouseOver%2A> Eigenschaftswert geändert hat `true` auf `false` für dieses Element.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.MouseLeave> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.MouseLeave> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseLeaveEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseLeave%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseLeave" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die linke Maustaste gedrückt wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine bubbling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.MouseLeftButtonDown> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse. Dazu zählen möglicherweise Klassenhandler generierte Ereignisse wie <xref:System.Windows.Controls.Control.MouseDoubleClick>.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
> [!IMPORTANT]
>  Einige Klassen Control möglicherweise inhärente Klassenbehandlung für Mausereignisse-Schaltfläche. Die linke Maustaste ausgelöste Ereignis ist das wahrscheinlichste Ereignis Klassenbehandlung in einem Steuerelement aufweisen. Die Klassenbehandlung häufig kennzeichnet die zugrunde liegende <xref:System.Windows.Input.Mouse> Klassenereignis als behandelt. Nachdem das Ereignis als behandelt markiert ist, werden andere Instanzhandler, die diesem Element zugeordnet sind, nicht in der Regel ausgelöst. Andere Klasse oder Instanz Handler, die auf Elemente in der bubbling-Richtung zum Stamm in der Benutzeroberflächenautomatisierungs-Struktur angefügt werden, werden auch nicht in der Regel ausgelöst.  
  
 Können Sie beheben Sie das Problem, das in der vorherigen wichtig beschrieben wird und weiterhin <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignisse für die linke Maustaste unten Ereignisse in einer abgeleiteten Klasse, die eine Klassenbehandlung mithilfe einer dieser Lösungen verfügt:  
  
-   Fügen Sie Handler für das <xref:System.Windows.UIElement.PreviewMouseDown> -Ereignis, das nicht von den Steuerelementen als behandelt markiert ist. Beachten Sie, da dies eine Vorschauereignis ist, die Route am Stamm beginnt und auf das Steuerelement tunnelt.  
  
-   Registrieren Sie einen Handler für das Steuerelement prozeduralen durch Aufrufen von <xref:System.Windows.UIElement.AddHandler%2A> und wählen Sie die Option für die Signatur, die es ermöglicht die Ereignishandler für Ereignisse überwacht werden soll, selbst wenn sie bereits in die gerouteten Ereignisdaten als behandelt markiert sind.  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseLeftButtonDownEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die linke Maustaste losgelassen wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine bubbling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.MouseLeftButtonUp> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseLeftButtonUpEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger bewegt wird, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.MouseMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.MouseMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseMoveEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewMouseMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseMove" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die rechte Maustaste gedrückt wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine bubbling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.MouseRightButtonDown> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse. Dazu zählen möglicherweise Klassenhandler generierte Ereignisse wie <xref:System.Windows.Controls.Control.MouseDoubleClick>.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
 Mausereignisse rechten Schaltfläche weisen systemeigene Behandlung häufig in Anwendungsszenarien. Z. B. möglicherweise eine rechten Maustaste ein Kontextmenü angezeigt. Finden Sie unter [Übersicht über die ContextMenu](~/docs/framework/wpf/controls/contextmenu-overview.md).  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseRightButtonDownEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseRightButtonDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die rechte Maustaste losgelassen wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine bubbling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.MouseRightButtonUp> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseRightButtonUpEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseRightButtonUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseRightButtonUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste über diesem Element losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.MouseUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.MouseUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Die <xref:System.Windows.UIElement.MouseUp> Ereignis wird häufig zusammen mit entweder <xref:System.Windows.UIElement.MouseLeftButtonUp> oder <xref:System.Windows.UIElement.MouseRightButtonUp>, die für eine Version eines der beiden standard Maustasten entsprechen. <xref:System.Windows.UIElement.MouseLeftButtonUp>und <xref:System.Windows.UIElement.MouseRightButtonUp> sind auch Routingereignisse, aber sie sind direkte Routingereignisse und die entsprechende Schaltfläche-spezifische-Ereignis wird ausgelöst, wenn die <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> -Ereignis dieses Element auf der Ereignisroute erreicht. Finden Sie unter "Hinweise" für <xref:System.Windows.UIElement.MouseLeftButtonUp> oder <xref:System.Windows.UIElement.MouseRightButtonUp>.  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseUpEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewMouseUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Benutzer das Mausrad dreht, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fokus oder die Maus erfasst haben Vorrang vor, in dem der Mauszeiger befindet; aus diesem Grund erhalten Sie die <xref:System.Windows.UIElement.MouseWheel> Ereignis von einem Element mit Fokus oder aufgezeichnet, der Mauszeiger möglicherweise nicht über ein anderes Element.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.MouseWheel> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.MouseWheel> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.MouseWheelEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewMouseWheel>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnMouseWheel%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.MouseWheel" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Ein Durchlauf-Anforderung, die enthält einer Eigenschaft, die entweder ein Hinweis darauf einen Modus für die in vorhandenen Aktivierreihenfolge oder eine Richtung visuell verschieben zu durchlaufen.</param>
        <summary>Versucht, den Fokus auf ein anderes Element aus diesem Element zu verschieben. Die Richtung zum Verschieben des Fokus ist durch eine Richtung Anleitung angegeben, die innerhalb der Organisation für das visuelle übergeordnete Element für dieses Element interpretiert wird.</summary>
        <returns>
          <see langword="true" />Wenn der angeforderte Durchlauf ausgeführt wurde. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stellen Sie sicher, dass Sie überprüfen, dass den Rückgabewert dieser Methode. Ein Rückgabewert von `false` kann zurückgegeben werden, wenn Durchlauf ausgeführt wird, in einen Tabstopp, die durch die Zusammensetzung eines Steuerelements definiert ist, und die Anforderung Durchlauf umschließen nicht angefordert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Ereignisdaten an das Access-Key-Ereignis. Die Daten Ereignisberichte, welcher Schlüssel wurde aufgerufen, und angeben, ob die <see cref="T:System.Windows.Input.AccessKeyManager" /> Objekt, das Senden dieser Ereignisse steuert, diesen Access Key Aufruf auch auf andere Elemente gesendet.</param>
        <summary>Stellt eine Klassenbehandlung für eine Tastenkombination, die Bedeutung für dieses Element sind aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist keine tatsächliche AccessKey-Ereignis in der <xref:System.Windows.UIElement> -Klasse, oder an anderer Stelle, die auslösen oder Handler für anfügen können. Stattdessen wird das Ereignis ausgelöst wurde über eine dedizierte Managerklasse <xref:System.Windows.Input.AccessKeyManager>, welche Prozesse nach der alle Eingaben Zugriffstasten gesucht, die für das gesamte Eingabemodell gelten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die standardmäßige Implementierung dieser Methode in <see cref="T:System.Windows.UIElement" /> legt den Fokus auf dieses Element-Tastatur (durch Aufrufen von <see cref="M:System.Windows.UIElement.Focus" />). Implementierungen sollten dieses Verhalten Ereignisroute weitergegeben, wenn sie den Fokus erhalten kann, sind, da es sich um ein erwartetes Verhalten für Eingabehilfenszenarien handelt. Beachten Sie, dass die grundlegende Implementierung mit den übergebenen Ereignisdaten nichts und keine weiteren Ereignis löst; Es setzt nur den Fokus.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Das untergeordnete Element, das Größe angepasst wird.</param>
        <summary>Unterstützt beim Ändern der Größe eines untergeordneten Elements Layoutverhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel nicht vom Anwendungscode aufgerufen. Sie wird verfügbar gemacht, damit dieses abgeleiteten Elements, Klassen Weitere vornehmen, können, auf ihren eigenen Layoutzustand möglicherweise ungültige überprüft. Klassen könnte auch versuchen für Optimierungen aus, um die Verarbeitungszeit für einen Layoutdurchlauf basierend auf die Fenstergröße ändert die untergeordneten Elemente zu minimieren. Ein Beispiel für abgeleitete Elementklasse, die implementiert <xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A> ist die <xref:System.Windows.Controls.Grid> Steuerelement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die <see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /> Methode verfügt über die standardmäßige Implementierung des Aufrufs <see cref="M:System.Windows.UIElement.InvalidateMeasure" /> auf sich selbst. Eine typische Implementierung wäre: Führen Sie die Optimierung Ihrer eigenen Element unterstützt, und klicken Sie dann in der Regel rufen Basis <see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /> aus mindestens einer der codeverzweigungen (derjenige, der "unsaubere" Status pro eigene cacheprogrammierlogik Measure angezeigt).  
  
 Diese Methode wird nur aufgerufen, in der Layout-Verarbeitung war dies das untergeordnete Element selbst, das die größenveränderung der stammt. Wenn das übergeordnete Element initiiert wird, andernfalls der <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> übergeben, gemäß den Regeln des Layout-System, das übergeordnete Element ist Neuberechnen Layout bereits. Das Layoutsystem Layout in der Reihenfolge der untergeordneten zum übergeordneten verarbeitet, damit keine zurück zum übergeordneten Element Sizing aus den untergeordneten Element Layout aufrufen erforderlich ist.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnCreateAutomationPeer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die klassenspezifische <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> Implementierungen für die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Infrastruktur.</summary>
        <returns>Die typspezifische <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />-Implementierung.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Die Implementierung dieser Methode wird in der Regel Aufruf des Konstruktors einer bestimmten <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> -Implementierung erstellt und als Rückgabewert zurückgegeben.  
  
 Alle <see cref="T:System.Windows.UIElement" /> abgeleitete Klassen sollten diese Methode implementieren, um ihre eigenen spezifischen bieten <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> Implementierungen, um die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Infrastruktur. Ausführliche Informationen dazu, dieses Muster implementieren, finden Sie unter <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.DragEnter" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.DragLeave" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.DragOver" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.DragEnter" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.GiveFeedbackEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.GiveFeedback" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.RoutedEventArgs" /> , das Ereignisdaten enthält. Diese Ereignisdaten müssen des Bezeichner für die <see cref="E:System.Windows.UIElement.GotFocus" /> Ereignis.</param>
        <summary>Löst das <see cref="E:System.Windows.UIElement.GotFocus" /> Routingereignis mithilfe der bereitgestellten Ereignisdaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist auch virtuell sein, eine Standardimplementierung auf, die das Ereignis auslöst.  
  
 Dies auf * methodenimplementierung dient zum Auslösen des Ereignisses, und diese dieselbe methodenimplementierung wird intern zum Auslösen des Ereignisses aufgerufen bei der <xref:System.Windows.UIElement.IsFocused%2A> Eigenschaftswert ändert. Die <xref:System.Windows.UIElement.OnGotFocus%2A> Implementierung unterscheidet sich von einem anderen [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] auf * Implementierungen, die nur eine einfache Möglichkeit, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen bieten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie eine absichtliche und ungewöhnliche nicht den Fokusereignisse auslösen, müssen, stellen Sie sicher, dass Ihre Implementierung die basisimplementierung aufgerufen. Andernfalls die <see cref="E:System.Windows.UIElement.GotFocus" /> Ereignis wird nicht ausgelöst, während der Benutzer normalerweise-Vorgänge, die normalerweise den Fokus auf dieses Element festgelegt. Wenn Sie nicht, dass das Element den Fokus erhalten kann sein beabsichtigen, Sie können verhindern, das Element den Fokus erhalten kann durch Festlegen von <see cref="P:System.Windows.UIElement.Focusable" /> auf <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.GotTouchCapture" /> Routingereignis, das auftritt, wenn eine Fingereingabe für dieses Element erfasst wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnGotTouchCapture%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnGotTouchCapture%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.GotTouchCapture> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnGotTouchCapture%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert von der <xref:System.Windows.UIElement.IsKeyboardFocused%2A> -Abhängigkeitseigenschaft. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass die <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> Ereignis ist für ein Routingereignis nicht. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, kurz vor dem Ausführen der <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> -Ereignis von diesem Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert von der <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> -Abhängigkeitseigenschaft. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass die <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> Ereignis ist für ein Routingereignis nicht. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert des der <xref:System.Windows.UIElement.IsMouseCaptured%2A> Abhängigkeitseigenschaft geändert wird. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsMouseCapturedChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass die <xref:System.Windows.UIElement.IsMouseCapturedChanged> Ereignis ist kein Routingereignis; Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Dieser virtuellen Methode ausgelöst, wenn der Wert des der <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> Abhängigkeitseigenschaft geändert wird. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass das Ereignis ein Routingereignis nicht ist. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert des der <xref:System.Windows.UIElement.IsMouseDirectlyOver%2A> Abhängigkeitseigenschaft geändert wird. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass die <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> Ereignis ist für ein Routingereignis nicht. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert des der <xref:System.Windows.UIElement.IsStylusCaptured%2A> Abhängigkeitseigenschaft geändert wird. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsStylusCapturedChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass das Ereignis ein Routingereignis nicht ist. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert des der <xref:System.Windows.UIElement.IsStylusCaptureWithin%2A> Abhängigkeitseigenschaft geändert wird. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsStylusCaptureWithinChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass das Ereignis ein Routingereignis nicht ist. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser virtuellen Methode ausgelöst, wenn der Wert des der <xref:System.Windows.UIElement.IsStylusDirectlyOver%2A> Abhängigkeitseigenschaft geändert wird. Die virtuelle Methode wird zuerst ausgelöst und kann die Daten für das Ereignis nach Bedarf bearbeiten. Die <xref:System.Windows.UIElement.IsStylusDirectlyOverChanged> Ereignis mit diesem gleichen Ereignisdateninstanz ausgelöst. Beachten Sie, dass das Ereignis ein Routingereignis nicht ist. Es kann nicht aus diesem Grund kennzeichnen, wie in der Klassenhandler behandelt.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.KeyDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tastatureingaben werden von einem dedizierten Eingabe-Manager verarbeitet. Andere Programmierfunktionen, die Tastatureingaben, z. B. Eingabe- und Befehl Bindungen benötigen möglicherweise die Tastatureingabe behandeln, bevor es als eine allgemeine Tastatureingabe verfügbar gemacht wird. Wenn diese Eingabedateien Systemfunktionen markieren das Ereignis als behandelt, klicken Sie dann <xref:System.Windows.UIElement.OnKeyDown%2A> wird nicht aufgerufen.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.KeyUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tastatureingaben werden von einem dedizierten Eingabe-Manager verarbeitet. Andere Programmierfunktionen, die Tastatureingaben, z. B. Eingabe- und Befehl Bindungen benötigen möglicherweise die Tastatureingabe behandeln, bevor es als eine allgemeine Tastatureingabe verfügbar gemacht wird. Wenn diese Eingabedateien Systemfunktionen markieren das Ereignis als behandelt, klicken Sie dann <xref:System.Windows.UIElement.OnKeyUp%2A> wird nicht aufgerufen.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.RoutedEventArgs" /> , das Ereignisdaten enthält. Diese Ereignisdaten müssen des Bezeichner für die <see cref="E:System.Windows.UIElement.LostFocus" /> Ereignis.</param>
        <summary>Löst das <see cref="E:System.Windows.UIElement.LostFocus" /> Routingereignis mithilfe der Ereignisdaten, die bereitgestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist auch virtuell sein, eine Standardimplementierung auf, die das Ereignis auslöst.  
  
 Dies auf * methodenimplementierung dient zum Auslösen des Ereignisses, und diese dieselbe methodenimplementierung wird intern zum Auslösen des Ereignisses aufgerufen bei der <xref:System.Windows.UIElement.IsFocused%2A> Eigenschaftswert ändert. Diese Implementierung unterscheidet sich von einem anderen [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] auf * Implementierungen, die nur eine einfache Möglichkeit, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen bieten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie eine absichtliche und ungewöhnliche nicht den Fokusereignisse auslösen, müssen, stellen Sie sicher, dass Ihre Implementierung die basisimplementierung aufgerufen. Andernfalls die <see cref="E:System.Windows.UIElement.LostFocus" /> Ereignis wird nicht ausgelöst, während der Benutzer normalerweise-Vorgänge, die normalerweise den Fokus auf dieses Element festgelegt. Wenn Sie nicht, dass das Element den Fokus erhalten kann sein beabsichtigen, Sie können verhindern, das Element den Fokus erhalten kann durch Festlegen von <see cref="P:System.Windows.UIElement.Focusable" /> auf <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> , das Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Windows.Input.MouseEventArgs" /> , das Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die <see cref="T:System.Windows.Input.StylusEventArgs" /> , das Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.LostTouchCapture" /> Routingereignis, das auftritt, wenn dieses Element keine Fingereingaben erfasst mehr.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnLostTouchCapture%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnLostTouchCapture%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.LostTouchCapture> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnLostTouchCapture%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> Ereignis auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> Ereignis. Aufrufen der <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> -Methode der Basisklasse, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> Ereignis auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnManipulationCompleted%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnManipulationCompleted%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.ManipulationCompleted> Ereignis. Aufrufen der <xref:System.Windows.UIElement.OnManipulationCompleted%2A> -Methode der Basisklasse, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.UIElement.ManipulationDelta" /> Ereignis auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnManipulationDelta%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnManipulationDelta%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.ManipulationDelta> Ereignis. Aufrufen der <xref:System.Windows.UIElement.OnManipulationDelta%2A> -Methode der Basisklasse, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> Ereignis auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.ManipulationInertiaStarting> Ereignis. Aufrufen der <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> -Methode der Basisklasse, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarted (System.Windows.Input.ManipulationStartedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarted(class System.Windows.Input.ManipulationStartedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Die Daten für das Ereignis.</param>
        <summary>Wird aufgerufen, wenn die <see cref="E:System.Windows.UIElement.ManipulationStarted" /> Ereignis auftritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnManipulationStarted%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnManipulationStarted%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.ManipulationStarted> Ereignis. Aufrufen der <xref:System.Windows.UIElement.OnManipulationStarted%2A> -Methode der Basisklasse, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.ManipulationStartingEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.ManipulationStarting" /> Routingereignis, das tritt auf, wenn der Manipulationsprozessor wird erstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnManipulationStarting%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnManipulationStarting%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.ManipulationStarting> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnManipulationStarting%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Diese Ereignisdaten melden Details zur Maustaste, die gedrückt wurde, und zum behandelten Zustand.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.MouseDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schaltfläche Mausaktionen werden auch von einem dedizierten Eingabe-Manager behandelt. Andere Programmierfunktionen, die Schaltfläche Mausaktionen, z. B. Eingabe abhängig ist, und jeder Befehl von Bindungen, möglicherweise Handler für die Aktion aufrufen, bevor es als eine allgemeine Schaltfläche Mausaktion verfügbar gemacht wird. Wenn Sie diese markieren Eingabedateien der <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> Ereignis als behandelt, <xref:System.Windows.UIElement.OnMouseDown%2A> wird nicht aufgerufen.  
  
 Wenn Sie den Klassenhandler für diese verwenden, um das Ereignis als behandelt markiert werden, Sie möglicherweise Auswirkungen auf die folgenden Ereignisse: <xref:System.Windows.UIElement.MouseLeftButtonDown> und <xref:System.Windows.UIElement.MouseRightButtonDown>. Eines dieser Ereignisse kann ausgelöst werden, auf dem empfangenden Element beim <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> empfangen wird.  
  
 Wenn Sie dieses Ereignis in eine Klassenbehandlung als behandelt markiert haben, werden dennoch Unterereignisse ausgelöst. Sie kann jedoch zum behandelten Zustand in den Ereignisdaten übergeben werden. Wenn das Ereignis in der Klassenbehandlung behandelt wird, Instanzhandler für die Unterereignisse werden nicht aufgerufen, wenn Sie explizit verwenden <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` `true` um Handler anfügen. Klassenhandler werden ebenfalls nicht aufgerufen, wenn diese Klassenhandler registriert wurden die <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur mit `handledEventsToo` `true`. Durch Verarbeiten <xref:System.Windows.UIElement.OnMouseDown%2A>, Sie sind, dass die Klassenbehandlung für alle möglichen Aktionen mit gedrückter Gleichzeichen. Dieses Verhalten kann unerwünscht sein. Daher vorsichtig, wenn Sie dieser virtuellen Methode verwenden, um die Ereignisse als behandelt markiert.  
  
 Jedes der direkten Schaltfläche-spezifische Ereignisse verfügt auch über ein virtuelles auf *-Methode. Berücksichtigen Sie, ob überschreiben diese Schaltfläche-spezifische Klassenhandler besser geeignet sein kann.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis mit einer direkten routing-Strategie. Das Ereignis als behandelt markiert ist immer noch nützlich, damit verhindern den Standard-Handler (diejenigen, die keinen angeben `handledEventsToo`) aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> -Ereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis mit einer direkten routing-Strategie. Das Ereignis als behandelt markiert ist immer noch nützlich, damit verhindern den Standard-Handler (diejenigen, die keinen angeben `handledEventsToo`) aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die linke Maustaste gedrückt wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> Routingereignis für dieses Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis angezeigt wird, eine bubbling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>ist das zugrunde liegende Ereignis, das Blasendiagramm weitergeleitet wird, und jedes <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.MouseLeftButtonDown>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.MouseLeftButtonDown> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>.  
  
 Alternativ können Sie diese Methode überschreiben, um Ereignisbehandlung für einen bestimmten Maus Status zu ändern. Egal, ob Sie die basisimplementierung aufgerufen werden, hängt von Ihrem Szenario ab. Standardbehandlung Eingabe für dieses Mausereignis auf den Vorgängerklassen, die auch zum Aufrufen erwarten Basis aufgerufen deaktiviert <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>. Sie können z. B. Ableiten von <xref:System.Windows.Controls.Button> und überschreiben <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> in die abgeleitete Klasse ohne Aufrufen der basisimplementierung; allerdings überschreiben dies deaktiviert den <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die linke Maustaste losgelassen wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignis angezeigt wird, eine bubbling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>ist das zugrunde liegende Ereignis, das Blasendiagramm weitergeleitet wird, und jedes <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.MouseLeftButtonUp>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.MouseMove" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die rechte Maustaste gedrückt wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.MouseRightButtonDown> Ereignis angezeigt wird, eine bubbling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>ist das zugrunde liegende Ereignis, das Blasendiagramm weitergeleitet wird, und jedes <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.MouseRightButtonDown>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.MouseRightButtonDown> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>.  
  
 Alternativ können Sie diese Methode überschreiben, um Ereignisbehandlung für einen bestimmten Maus Status zu ändern. Egal, ob Sie die basisimplementierung aufgerufen werden, hängt von Ihrem Szenario ab. Standardbehandlung Eingabe für dieses Mausereignis auf den Vorgängerklassen, die auch zum Aufrufen erwarten Basis aufgerufen deaktiviert <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>. Sie können z. B. Ableiten von <xref:System.Windows.Controls.Control> und überschreiben <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A> in die abgeleitete Klasse, ohne dass Base aufgerufen; deaktiviert diese Außerkraftsetzung jedoch den Kontext im Menü Dienste auf steuern können, die Teil sind von der <xref:System.Windows.Controls.Control> Standardverhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die rechte Maustaste losgelassen wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.MouseRightButtonUp> Ereignis angezeigt wird, eine bubbling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>ist das zugrunde liegende Ereignis, das Blasendiagramm weitergeleitet wird, und jedes <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.MouseRightButtonUp>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.MouseRightButtonUp> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die Maustaste losgelassen wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.Input.Mouse.MouseUp" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schaltfläche Mausaktionen werden auch von einem dedizierten Eingabe-Manager behandelt. Andere Programmierfunktionen, die Schaltfläche Mausaktionen, z. B. Eingabe abhängig ist, und jeder Befehl von Bindungen, möglicherweise Handler für die Aktion aufrufen, bevor es als eine allgemeine Schaltfläche Mausaktion verfügbar gemacht wird. Wenn Sie diese markieren Eingabedateien der <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> Ereignis als behandelt, <xref:System.Windows.UIElement.OnMouseUp%2A> wird nicht aufgerufen.  
  
 Wenn Sie den Klassenhandler für diese verwenden, um das Ereignis als behandelt markiert werden, Sie möglicherweise Auswirkungen auf die folgenden Ereignisse: <xref:System.Windows.UIElement.MouseLeftButtonUp> und <xref:System.Windows.UIElement.MouseRightButtonUp>. Eines dieser Ereignisse können für das empfangende Element ausgelöst werden beim <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> empfangen wird.  
  
 Wenn Sie dieses Ereignis in eine Klassenbehandlung als behandelt markiert haben, werden dennoch Unterereignisse ausgelöst. Sie kann jedoch zum behandelten Zustand in den Ereignisdaten übergeben werden. Wenn das Ereignis in der Klassenbehandlung behandelt wird, Instanzhandler für die Unterereignisse werden nicht aufgerufen, wenn Sie explizit verwenden <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` `true` um Handler anfügen. Klassenhandler werden ebenfalls nicht aufgerufen, wenn diese Klassenhandler registriert wurden die <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur mit `handledEventsToo` `true`. Durch Verarbeiten <xref:System.Windows.UIElement.OnMouseUp%2A>, Sie sind, dass die Klassenbehandlung für alle möglichen Aktionen Gleichzeichen. Dieses Verhalten kann unerwünscht sein. Daher vorsichtig, wenn Sie dieser virtuellen Methode verwenden, um die Ereignisse als behandelt markiert.  
  
 Jedes der direkten Schaltfläche-spezifische Ereignisse verfügt auch über ein virtuelles auf *-Methode. Berücksichtigen Sie, ob überschreiben diese Schaltfläche-spezifische Klassenhandler besser geeignet sein kann.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseWheelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.MouseWheel" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.PreviewDragEnter" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.PreviewDragLeave" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.PreviewDragOver" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.DragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.PreviewDrop" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.GiveFeedbackEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass eine oder mehrere Maustasten gedrückt wurden.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> angefügten Routingereignis ein Element von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schaltfläche Mausaktionen werden auch von einem dedizierten Eingabe-Manager behandelt. Andere Programmierfunktionen, die Schaltfläche Mausaktionen, z. B. Eingabe abhängig ist, und jeder Befehl von Bindungen, möglicherweise Handler für die Aktion aufrufen, bevor es als eine allgemeine Schaltfläche Mausaktion verfügbar gemacht wird. Wenn Sie diese markieren Eingabedateien der <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> Ereignis als behandelt, <xref:System.Windows.UIElement.OnPreviewMouseDown%2A> wird nicht aufgerufen.  
  
 Wenn Sie den Klassenhandler für diese verwenden, um das Ereignis als behandelt markiert werden, Sie möglicherweise Auswirkungen auf die folgenden Ereignisse: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> und <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>. Eines dieser Ereignisse kann ausgelöst werden, auf dem empfangenden Element beim <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> empfangen wird.  
  
 Wenn Sie dieses Ereignis in eine Klassenbehandlung als behandelt markiert haben, werden dennoch Unterereignisse ausgelöst. Sie kann jedoch zum behandelten Zustand in den Ereignisdaten übergeben werden. Wenn das Ereignis in der Klassenbehandlung behandelt wird, Instanzhandler für die Unterereignisse werden nicht aufgerufen, wenn Sie explizit verwenden <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` `true` um Handler anfügen. Klassenhandler werden ebenfalls nicht aufgerufen, wenn diese Klassenhandler registriert wurden die <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur mit `handledEventsToo` `true`. Durch Verarbeiten <xref:System.Windows.UIElement.OnPreviewMouseDown%2A>, Sie sind, dass die Klassenbehandlung für alle möglichen Aktionen mit gedrückter Gleichzeichen. Dieses Verhalten kann unerwünscht sein. Daher vorsichtig, wenn Sie dieser virtuellen Methode verwenden, um die Ereignisse als behandelt markiert.  
  
 Jedes der direkten Schaltfläche-spezifische Ereignisse verfügt auch über ein virtuelles auf *-Methode. Berücksichtigen Sie, ob überschreiben diese Schaltfläche-spezifische Klassenhandler besser geeignet sein kann.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die linke Maustaste gedrückt wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignis angezeigt wird, eine Tunneling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>ist der zugrunde liegenden Ereignis, Tunnel weitergeleitet, und jede <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>.  
  
 Alternativ können Sie diese Methode überschreiben, um Ereignisbehandlung für einen bestimmten Maus Status zu ändern. Egal, ob Sie die basisimplementierung aufgerufen werden, hängt von Ihrem Szenario ab. Standardbehandlung Eingabe für dieses Mausereignis auf den Vorgängerklassen, die auch zum Aufrufen erwarten Basis aufgerufen deaktiviert <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>. Sie können z. B. Ableiten von <xref:System.Windows.Controls.Button> und überschreiben <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> in die abgeleitete Klasse ohne Aufrufen der basisimplementierung; allerdings überschreiben dies deaktiviert den <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die linke Maustaste losgelassen wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> Ereignis angezeigt wird, eine Tunneling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>ist der zugrunde liegenden Ereignis, Tunnel weitergeleitet, und jede <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die rechte Maustaste gedrückt wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> Ereignis angezeigt wird, eine Tunneling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>ist der zugrunde liegenden Ereignis, Tunnel weitergeleitet, und jede <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.MouseRightButtonDown>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>.  
  
 Alternativ können Sie diese Methode überschreiben, um Ereignisbehandlung für einen bestimmten Maus Status zu ändern. Egal, ob Sie die basisimplementierung aufgerufen werden, hängt von Ihrem Szenario ab. Standardbehandlung Eingabe für dieses Mausereignis auf den Vorgängerklassen, die auch zum Aufrufen erwarten Basis aufgerufen deaktiviert <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>. Sie können z. B. Ableiten von <xref:System.Windows.Controls.Control> und überschreiben <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A> in die abgeleitete Klasse, ohne dass Base aufgerufen; deaktiviert diese Außerkraftsetzung jedoch den Kontext im Menü Dienste auf steuern können, die Teil sind von der <xref:System.Windows.Controls.Control> Standardverhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass die rechte Maustaste losgelassen wurde.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> Routingereignis ein Element in der von dieser Klasse abgeleitetes ist erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> Ereignis angezeigt wird, eine Tunneling-Route zu folgen, durchläuft jedoch tatsächlich eine indirekte Möglichkeit. <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>ist der zugrunde liegenden Ereignis, Tunnel weitergeleitet, und jede <xref:System.Windows.UIElement> entlang des Ereignisses Route durchläuft das direkte Routingereignis auslösen <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>. Obwohl Sie markieren können die <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> Ereignis für dieses Element als behandelt, zum behandelte Zustand ist nicht Ereignisroute weitergegeben auf andere Elemente auf der Ereignisroute. Allerdings kann es sinnvoll sein, das Ereignis als behandelt, um zu verhindern, dass allgemeine Instanzhandler zu markieren (solche, die keine Berechnung angegeben `handledEventsToo`) aus aufgerufen wurde.  
  
 Die Standardimplementierung für allgemeine Maus Ereignisbehandlung in <xref:System.Windows.UIElement> überwacht <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> und konvertiert ihn in ein entsprechendes lokales Ereignis. Wenn Sie diese Logik überschreiben möchten, müssen Sie eine abgeleitete Klasse erstellen. Registrieren Sie im statischen Konstruktor der abgeleiteten Klasse einen alternativen Klassenhandler für <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>. Die Behandlung von Verhalten der Maus kann nicht geändert werden <xref:System.Windows.UIElement> durch Außerkraftsetzen von <xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, das die Ereignisdaten enthält. Die Ereignisdaten melden, dass eine oder mehrere Maustasten losgelassen wurden.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schaltfläche Mausaktionen werden auch von einem dedizierten Eingabe-Manager behandelt. Andere Programmierfunktionen, die Schaltfläche Mausaktionen, z. B. Eingabe abhängig ist, und jeder Befehl von Bindungen, möglicherweise Handler für die Aktion aufrufen, bevor es als eine allgemeine Schaltfläche Mausaktion verfügbar gemacht wird. Wenn Sie diese markieren Eingabedateien der <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> Ereignis als behandelt, <xref:System.Windows.UIElement.OnPreviewMouseUp%2A> wird nicht aufgerufen.  
  
 Wenn Sie den Klassenhandler für diese verwenden, um das Ereignis als behandelt markiert werden, Sie möglicherweise Auswirkungen auf die folgenden Ereignisse: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> und <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>. Eines dieser Ereignisse können für das empfangende Element ausgelöst werden beim <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> empfangen wird.  
  
 Wenn Sie dieses Ereignis in eine Klassenbehandlung als behandelt markiert haben, werden dennoch Unterereignisse ausgelöst. Sie kann jedoch zum behandelten Zustand in den Ereignisdaten übergeben werden. Wenn das Ereignis in der Klassenbehandlung behandelt wird, Instanzhandler für die Unterereignisse werden nicht aufgerufen, wenn Sie explizit verwenden <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> mit `handledEventsToo` `true` um Handler anfügen. Klassenhandler werden ebenfalls nicht aufgerufen, wenn diese Klassenhandler registriert wurden die <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur mit `handledEventsToo` `true`. Durch Verarbeiten <xref:System.Windows.UIElement.OnPreviewMouseUp%2A>, Sie sind, dass die Klassenbehandlung für alle möglichen Aktionen Gleichzeichen. Dieses Verhalten kann unerwünscht sein. Daher vorsichtig, wenn Sie dieser virtuellen Methode verwenden, um die Ereignisse als behandelt markiert.  
  
 Jedes der direkten Schaltfläche-spezifische Ereignisse verfügt auch über ein virtuelles auf *-Methode. Berücksichtigen Sie, ob überschreiben diese Schaltfläche-spezifische Klassenhandler besser geeignet sein kann.  
  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.MouseWheelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.QueryContinueDragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusDownEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.TextCompositionEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert. Ein weiteres Szenario, das speziell für die Preview-Ereignisse werden kennzeichnen behandelt, sodass die übereinstimmenden bubbling Klassenhandler nicht aufgerufen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> Routingereignis, das auftritt, wenn eine Fingereingabe auf dieses Element erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.PreviewTouchDown> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> Routingereignis, das auftritt, wenn eine Fingereingabe innerhalb dieses Elements bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.PreviewTouchMove> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> Routingereignis, das auftritt, wenn eine Fingereingabe innerhalb dieses Elements losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.PreviewTouchUp> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.QueryContinueDragEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.DragDrop.QueryContinueDrag" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.QueryCursorEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Mouse.QueryCursor" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected virtual void OnRender (System.Windows.Media.DrawingContext drawingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRender(class System.Windows.Media.DrawingContext drawingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="drawingContext">Die Zeichnung Anweisungen für ein bestimmtes Element. Dieser Kontext wird für das Layoutsystem bereitgestellt.</param>
        <summary>Beteiligt sich beim Überschreiben in einer abgeleiteten Klasse an Rendervorgängen, die vom Layoutsystem gesteuert werden. Die Renderinganweisungen für dieses Element sind nicht direkt bei dieser Methode aufgerufen wird, verwendet und stattdessen für spätere asynchrone Layout-und Zeichnung beibehalten werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung der <xref:System.Windows.UIElement> Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt eine mögliche Implementierung für eine abgeleitete Panel-Klasse.  
  
 [!code-csharp[LightWeightCustomPanel#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LightWeightCustomPanel/CSharp/OffsetPanel.cs#1)]
 [!code-vb[LightWeightCustomPanel#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LightWeightCustomPanel/visualbasic/offsetpanel.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die <see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /> Methode kann überschrieben werden, um weitere grafische Elemente, die (zuvor nicht in einer logischen Struktur definiert) hinzufügen zu einer gerenderten Elements, z. B. Effekte oder Adorner. Ein <see cref="T:System.Windows.Media.DrawingContext" /> Objekt als Argument, das Methoden zum Zeichnen von Formen, Text, Bilder oder Videos von Ereignissen übergeben.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRenderSizeChanged (System.Windows.SizeChangedInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="info">Die Paketparameter (<see cref="T:System.Windows.SizeChangedInfo" />), inklusive der alte und neue Größen und die dimension, die tatsächlich ändert.</param>
        <summary>Beteiligt sich beim Überschreiben in einer abgeleiteten Klasse an Rendervorgängen, die vom Layoutsystem gesteuert werden. Diese Methode wird nach der Aktualisierung des Layouts und vor dem Rendern aufgerufen, wenn des Elements <see cref="P:System.Windows.UIElement.RenderSize" /> aufgrund einer layoutaktualisierung geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Ein typisches WPF-Frameworkebene-Element verwendet die Implementierung der Außerkraftsetzung von <xref:System.Windows.FrameworkElement>. Die <xref:System.Windows.FrameworkElement> Implementierung erklärt die <xref:System.Windows.FrameworkElement.Width%2A> und <xref:System.Windows.FrameworkElement.Height%2A> Eigenschaften und behandelt die Grundlagen der das Layout erneut zu erstellen. Überschreiben <xref:System.Windows.UIElement.OnRenderSizeChanged%2A> an die <xref:System.Windows.UIElement> Ebene impliziert, dass die Element-Implementierung der WPF-Frameworkebene vorgenommene Implementierung nicht absichtlich verwendet, und das Element Sie daher Layoutlogik mehr direkt in der Regel durch Schreiben behandeln muss einer Layoutsystem Ersatz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusDownEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusDown" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> -Ereignis von diesem Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 Der Zweck dieser Methode ähnelt [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Ereignis als behandelt markiert ist immer noch nützlich für typische Instanzhandler verhindert (diejenigen, die keinen angeben `handledEventsToo`) aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusInRange" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> -Ereignis von diesem Element ausgelöst wird. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen. Sie können Basis entweder vor oder nach Ihrem besondere Behandlung, je nach Ihren Anforderungen aufgerufen werden.  
  
 Der Zweck dieser Methode ähnelt [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Ereignis als behandelt markiert ist immer noch nützlich für typische Instanzhandler verhindert (diejenigen, die keinen angeben `handledEventsToo`) aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusMove" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.StylusEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.Stylus.StylusUp" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Windows.Input.TextCompositionEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Wird aufgerufen, wenn ein nicht behandeltes, angefügtes <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" />-Ereignis beim Durchlauf ein von dieser Klasse abgeleitetes Element erreicht. Implementieren Sie diese Methode, um eine Klassenbehandlung für dieses Ereignis hinzuzufügen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat keine Standardimplementierung. Da eine Zwischenklasse in der Vererbung diese Methode implementiert wird kann, wird empfohlen, dass Sie in Ihrer Implementierung die basisimplementierung aufrufen.  
  
 Der Zweck dieser Methode ähnelt der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Ereignismuster auf * Methoden: Diese Methode bietet die Möglichkeit, das übereinstimmende Ereignis von abgeleiteten Klassen durch die Einrichtung von eines Klassenhandler statt einem Instanzhandler behandeln. In diesem Fall wird das übereinstimmende Ereignis ein Routingereignis. Das Implementierungsmuster der On * Methoden unterscheidet sich für Routingereignisse, da ein Routingereignis von einem untergeordneten Element ausgelöst werden kann, die nicht unbedingt das Element, mit das Handler aufgerufen wird. Daher muss Ihre Implementierung die Datenquelleneigenschaften der Ereignisdaten zu untersuchen. Sie sollten nicht versuchen, auf das Ereignis in den meisten Fällen ausgelöst werden.  
  
 Durch diese Methode überschreiben oder durch Registrieren mit Klassenhandler <xref:System.Windows.EventManager.RegisterClassHandler%2A>, abgeleitete Klassen von <xref:System.Windows.UIElement> können Ereignishandlermethoden private Klasse aufrufen, wenn das Ereignis auf der Ereignisroute empfangen wird. Ein Szenario, in dem Klassenbehandlung geeignet ist, wird zum Bearbeiten von Daten für das Ereignis und das Routingereignis als behandelt markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.TouchDown" /> Routingereignis, das auftritt, wenn eine Fingereingabe innerhalb dieses Element erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnTouchDown%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnTouchDown%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.TouchDown> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnTouchDown%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.TouchEnter" /> Routingereignis, das auftritt, wenn eine Fingereingabe verliert außerhalb nach innerhalb der Grenzen dieses Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnTouchEnter%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnTouchEnter%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.TouchEnter> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnTouchEnter%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.TouchLeave" /> Routingereignis, das auftritt, wenn eine Fingereingabe verliert innerhalb nach außerhalb der Grenzen dieses <see cref="T:System.Windows.UIElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnTouchLeave%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnTouchLeave%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.TouchLeave> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnTouchLeave%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.TouchMove" /> Routingereignis, das auftritt, wenn eine Fingereingabe innerhalb dieses Elements bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnTouchMove%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnTouchMove%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.TouchMove> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnTouchMove%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.Input.TouchEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Stellt eine Klassenbehandlung für das <see cref="E:System.Windows.UIElement.TouchUp" /> Routingereignis, das auftritt, wenn eine Fingereingabe innerhalb dieses Elements losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.OnTouchUp%2A> Methode hat keine Standardimplementierung. Überschreiben Sie <xref:System.Windows.UIElement.OnTouchUp%2A> in einer abgeleiteten Klasse zum Behandeln der <xref:System.Windows.UIElement.TouchUp> Ereignis. Achten Sie darauf, dass Sie der Basisklasse aufgerufen <xref:System.Windows.UIElement.OnTouchUp%2A> Methode, damit die Basisklassen das Ereignis empfangen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Das vorherige übergeordnete Element. Dies kann bereitgestellt werden, als <see langword="null" /> Wenn die <see cref="T:System.Windows.DependencyObject" /> verfügte nicht bereits über ein übergeordnetes Element.</param>
        <summary>Wird aufgerufen, wenn das übergeordnete Element dieses <see cref="T:System.Windows.UIElement" /> meldet eine Änderung an der zugrunde liegenden visuelles übergeordnetes Element.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie diese Methode überschreiben, rufen Sie immer die grundlegende Implementierung. Die grundlegende Implementierung der Standardeinstellung wird einige interne Reverse geerbte Eigenschaft Status. Die basisimplementierung aufgerufen, wird diesem Zustand ungültig.  
  
 Diese Methode überschreibt <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />. <see cref="T:System.Windows.FrameworkElement" />und <see cref="T:System.Windows.Window" /> sowohl überschreiben auch die <see cref="T:System.Windows.UIElement" /> Implementierung von <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />, und <see cref="T:System.Windows.Window" /> versiegelt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Deckkraftfaktor angewendet, auf die gesamte <see cref="T:System.Windows.UIElement" /> beim Rendern das [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Der Deckkraftfaktor. Die Standarddeckkraft ist 1,0. Erwartete Werte liegen zwischen 0,0 und 1,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert 1,0 wird standardmäßig mit den anfänglichen Metadaten dieser Abhängigkeitseigenschaft auf die <xref:System.Windows.UIElement> Klasse. Andere abgeleitete Klassen können potenziell dieser Standardwert ändern, durch Überschreiben der Metadaten aus, deren Klassenkonstruktor.  
  
 Der Wert der <xref:System.Windows.UIElement.Opacity%2A> wird nicht auf tatsächliche Layout angewendet werden, es sei denn, das Element auch sichtbar ist (<xref:System.Windows.UIElement.IsVisible%2A> ist `true`).  
  
 <xref:System.Windows.UIElement.Opacity%2A>wird von übergeordneten Elementen angewendet Elementstruktur untergeordnete Elemente, aber die sichtbaren Auswirkungen der geschachtelten Deckkraft, Einstellungen im Wert Eigenschaft für die einzelnen untergeordneten Elemente angegeben werden nicht. Für die Instanz, wenn eine Liste eine Durchlässigkeit von 50 % (0,5 hat) und eines seiner Listenelemente die Durchlässigkeit auf 20 % (0,2) festgelegt wurde, die net Durchlässigkeit wird gerendert werden als handele es sich um 10 % (0,1), aber der Wert der Eigenschaft des Listenelements <xref:System.Windows.UIElement.Opacity%2A> -Eigenschaft würde weiterhin sein.  0,2, wenn die Abfrage.  
  
 Auch wenn die deklarierte oder ausgewertete Deckkraft 0 ist, ein Element noch beteiligt, Eingabeereignisse und Befehle, und möglicherweise den Fokus erhalten kann. Dieser Aspekt kann hilfreich sein, z. B. ein Deckkraft NULL-Objekt (z. B. eine Form ") verwenden können, zum Maskieren der zugrunde liegenden Objekte mit transparenten Elementen. Die Deckkraft NULL-Objekt können Sie alle für einen zugrunde liegenden Bereich Verarbeitung Eingabeereignis behandeln. Allerdings die `Background` oder `Fill` des Objekts oder der Form "sollte festgelegt werden, mit einem Wert selbst wird jedoch <xref:System.Windows.Media.Brushes.Transparent%2A>Treffertests andernfalls nicht aktiviert ist und keine Ereignisse empfangen werden.  
  
<a name="dependencyPropertyInfo_Opacity"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.OpacityProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt eine Deckkraftmaske als eine <see cref="T:System.Windows.Media.Brush" /> Implementierung, die auf alle Alphakanalmasken für den gerenderten Inhalt dieses Elements angewendet wird.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Der für die Deckkraftmaskierung zu verwendende Pinsel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verwendet nur nach Belieben alpha-Kanal für die angegebene Wert <xref:System.Windows.Media.Brush>. Die anderen Kanäle des der <xref:System.Windows.Media.Brush>gerenderten Inhalts (Rot, Grün und Blau) werden ignoriert.  
  
 Die häufigsten <xref:System.Windows.Media.Brush> für diesen Zweck ist ein <xref:System.Windows.Media.ImageBrush>, die für eine Vielzahl von Techniken, wie z. B. eine Vignette maskiert Foto verwendet werden können. Aber alle definierten <xref:System.Windows.Media.Brush> (z. B. <xref:System.Windows.Media.LinearGradientBrush>) kann verwendet werden.  
  
 In [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], Wert dieser Eigenschaft können eine Inlinesyntax, die spezifisch für jede Implementierung von ist das <xref:System.Windows.Media.Brush> abstrakte Klasse. Weitere Informationen finden Sie unter [Zeichnen mit Volltonfarben und Farbverläufen (Übersicht)](~/docs/framework/wpf/graphics-multimedia/painting-with-solid-colors-and-gradients-overview.md).  
  
<a name="dependencyPropertyInfo_OpacityMask"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.OpacityMaskProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Markup-Beispiel zeigt eine <xref:System.Windows.Media.ImageBrush> Deckkraftmaske angewendet auf einen anderen <xref:System.Windows.Controls.Image>.  
  
 [!code-xaml[OpacityMasksSnippet#UIElementOpacityMask](~/samples/snippets/csharp/VS_Snippets_Wpf/OpacityMasksSnippet/CS/ImageBrushExample.xaml#uielementopacitymask)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityMaskProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityMaskProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityMaskProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityMaskProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.OpacityMask" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.Opacity" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistId">
      <MemberSignature Language="C#" Value="public int PersistId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PersistId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.PersistId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der dieses Element eindeutig identifiziert.</summary>
        <value>Der eindeutige Bezeichner für dieses Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PersistId%2A>zur eindeutigen Identifizierung jedes Element ein. Ein Element behält die gleiche <xref:System.Windows.UIElement.PersistId%2A> jedes Mal, wenn die gleiche [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] (einschließlich binär) geladen wird. Dieser Bezeichner wird für interne laden, analysiert und Serialisierung-Anforderungen verwendet. Es ist nicht für die Verwendung von Anwendungscode vorgesehen.  
  
 Diese Eigenschaft hat keine Beziehung zu den <xref:System.Object.GetHashCode%2A> Ergebnis für eine bestimmte Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Die Richtung des Fokusdurchlaufs angeforderte.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse gibt das Element, das Fokus für eine angegebene Fokus Durchlauf Richtung erhalten würde, ohne tatsächlich den Fokus auf dieses Element verschieben.</summary>
        <returns>Das Element, das Fokus erhält, wenn <see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> tatsächlich aufgerufen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung dieser Methode in dieser Klasse ist unvollständig, und gibt immer `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag-Ereignis mit diesem Element als Drag-Ziel meldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewDragEnter> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewDragEnter> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewDragEnterEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.DragEnter>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewDragEnter%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewDragEnter" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag-Ereignis mit diesem Element als Drag-Quelle meldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewDragLeave> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewDragLeave> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewDragLeaveEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.DragLeave>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewDragLeave%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewDragLeave" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragOver" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drag-Ereignis mit diesem Element als potenzielles Drop-Ziel meldet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewDragOver> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewDragOver> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewDragOverEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.DragOver>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewDragOver%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewDragOver" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDrop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn das Eingabesystem ein zugrunde liegendes Drop-Ereignis meldet, das dieses Element als Drop-Ziel aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewDrop> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewDrop> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewDropEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.Drop>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewDrop%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewDrop" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGiveFeedback" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Drag &amp; Drop-Vorgang gestartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewGiveFeedback> Ereignis ermöglicht die Quelle des Drag-Ereignis, um die Darstellung des Mauszeigers zu ändern, um dem Benutzer während eines Drag & Drop-Vorgangs ein visuelles Feedback.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewGiveFeedback> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewGiveFeedback> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.GiveFeedback>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewGiveFeedback" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Fokus der Tastatur auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da dieses Ereignis Tunnel verwendet, routing, das Element, das Fokus besitzt möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus besitzt.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.GotKeyboardFocus>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Taste gedrückt wird, während sich der Fokus auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schlüsselverarbeitung interagiert mit anderen Plattformfunktionen, z. B. Befehle und Text Zusammensetzung. Die <xref:System.Windows.UIElement.KeyDown> Ereignis ist eine technisch anspruchsvolle Texteingabeereignis, die nicht auf bestimmte Steuerelemente erwartungsgemäß Verhalten. Dies ist, da einige Steuerelemente verfügen über Steuerelement Compositing oder Klassenbehandlung, die eine auf höherer Ebene Version des Texts enthält Eingabe Behandlung und verknüpfte Ereignisse.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewKeyDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewKeyDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewKeyDownEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.KeyDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewKeyDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewKeyDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Taste losgelassen wird, während sich der Fokus auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Schlüsselverarbeitung interagiert mit anderen Plattformfunktionen, z. B. Befehle und Text Zusammensetzung. Die <xref:System.Windows.UIElement.KeyUp> Ereignis ist eine technisch anspruchsvolle Texteingabeereignis, die nicht auf bestimmte Steuerelemente erwartungsgemäß Verhalten. Dies ist, da einige Steuerelemente verfügen über Steuerelement Compositing oder Klassenbehandlung, die eine auf höherer Ebene Version des Texts enthält Eingabe Behandlung und verknüpfte Ereignisse. Informationen entnehmen Sie der Dokumentation für einzelne Steuerelemente.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewKeyUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewKeyUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewKeyUpEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.KeyUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewKeyUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewKeyUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Fokus der Tastatur nicht mehr auf diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da dieses Ereignis Tunnel verwendet, routing, das Element, das Fokus verloren hat möglicherweise ein untergeordnetes Element anstatt des Elements, dem der Ereignishandler tatsächlich angefügt. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in die Ereignisdaten an das aktuelle Element zu bestimmen, die Fokus verloren hat.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewLostKeyboardFocus> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewLostKeyboardFocus> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.LostKeyboardFocus>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste gedrückt wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewMouseDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewMouseDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Die <xref:System.Windows.UIElement.PreviewMouseDown> Ereignis wird häufig zusammen mit entweder <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> oder <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>, das Drücken einer der beiden standard Maustasten entsprechen. <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>und <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> sind auch Routingereignisse, aber sie sind direkte Routingereignisse und die entsprechende Schaltfläche-spezifische-Ereignis wird ausgelöst, wenn die <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> -Ereignis dieses Element auf der Ereignisroute erreicht. Finden Sie unter "Hinweise" für <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> oder <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>.  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseDownEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.MouseDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die linke Maustaste gedrückt wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine Tunneling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse. Dazu zählen möglicherweise Klassenhandler generierte Ereignisse wie <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die linke Maustaste losgelassen wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine Tunneling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger bewegt wird, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, wenn der Mauszeiger in der Elementgrenzen weitergegeben werden und auch wenn der Mauszeiger bewegt wird während des Bestehens der immer noch innerhalb der Grenzen des Elements.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewMouseMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewMouseMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseMoveEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.MouseMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseMove" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die rechte Maustaste gedrückt wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine Tunneling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse. Dazu zählen möglicherweise Klassenhandler generierte Ereignisse wie <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die rechte Maustaste losgelassen wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl dies scheint eine Tunneling-Route durch eine Elementstruktur befolgen, ist es tatsächlich eine direkte Routingereignis, das ausgelöst wird, und die Elementstruktur nach jedem erneut <xref:System.Windows.UIElement>.  
  
 Dieses Ereignis ist eine der mehrere verwandte Ereignisse, die die Schaltflächen Einzelheiten einer zugrunde liegenden Bericht <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> Ereignis, das ein angefügtes Ereignis handelt, die von jedem Element ein Ereignisroute verarbeitet wird.  
  
 Die Ereignisdaten dieses Ereignisses verfügbar macht, das die Ereignisdaten des zugrunde liegenden <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> Ereignis. Wenn das Ereignis als behandelt der Ereignisroute markiert ist, werden die Maustaste los spezifischen Ereignisse dennoch ausgelöst; Allerdings müssen Handler bestimmter Ereignisse an die Schaltflächen hinzugefügt werden, durch explizites Aufrufen <xref:System.Windows.UIElement.AddHandler%2A>, mit der Option zum Behandeln von Ereignissen, die bereits als behandelt markiert werden, damit Listener des Ereignisses ist. Wenn Sie kennzeichnen <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> behandelt, Sie sind im Wesentlichen markieren <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> für alle weiteren Listener entlang der Route als behandelt und auf allen verknüpfte Ereignisse.  
  
 Konzeptionell kann dieses Ereignis (und andere los Ereignisse auf <xref:System.Windows.UIElement>) eine Maus "Service" sein (mit der Definition des Diensts bereitgestellt werden, indem die <xref:System.Windows.Input.Mouse> Klasse). Das Ereignis fügt den Komfort, überprüfen Sie die Maus Schaltflächenzuständen (linke Ecke, nach oben und unten) von der ursprünglichen Mausereignisse in Daten für das Ereignis nicht belegen. Erweiterte Szenarien, z. B. das Überprüfen von Zuständen von nicht standardmäßigen Schaltflächen, müssen Sie möglicherweise mit der [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] auf die <xref:System.Windows.Input.Mouse> -Klasse anstelle der für <xref:System.Windows.UIElement>.  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste losgelassen wird, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewMouseUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewMouseUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Die <xref:System.Windows.UIElement.PreviewMouseUp> Ereignis wird häufig zusammen mit entweder <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> oder <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>, das Drücken einer der beiden standard Maustasten entsprechen. <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>und <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> sind auch Routingereignisse, aber sie sind direkte Routingereignisse und die entsprechende Schaltfläche-spezifische-Ereignis wird ausgelöst, wenn die <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> -Ereignis dieses Element auf der Ereignisroute erreicht. Finden Sie unter "Hinweise" für <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> oder <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>.  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseUpEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.MouseUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Benutzer das Mausrad dreht, während sich der Mauszeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fokus oder die Maus erfasst haben Vorrang vor, in dem der Mauszeiger befindet; Deshalb, wenn Sie dieses Ereignis von einem Element fokussierte oder erfasste erhalten, möglicherweise der Mauszeiger über einem anderen Element nicht.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewMouseMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewMouseMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewMouseWheelEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.MouseWheel>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewMouseWheel%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewMouseWheel" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Status der Tastatur oder der Maustaste während eines Drag &amp; Drop-Vorgangs ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewQueryContinueDrag> Ereignis ermöglicht der Ziehquelle deklarieren, ob der Drag-and-Drop-Vorgang abgebrochen werden soll.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewQueryContinueDrag> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewQueryContinueDrag> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.QueryContinueDrag>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Stifttaste gedrückt wird, während sich der Zeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusButtonDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusButtonDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Eingabe-Touch-Unterstützung in Windows Vista](http://msdn.microsoft.com/en-us/63f1d71f-03d8-4d83-a174-e3dc7c57bad0) und [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusButtonDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Stifttaste losgelassen wird, während sich der Zeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusButtonUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusButtonUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusButtonUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift den Digitizer berührt, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusDownEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift über ein Element bewegt wird, ohne tatsächlich den Digitizer zu berühren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusInAirMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusInAirMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusInAirMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Tablettstift nah genug am Digitizer befindet, um erkannt zu werden, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusInRange> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusInRange> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusInRangeEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusInRange>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusInRange%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusInRange" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Tablettstift bewegt wird, während er sich über dem Element befindet. Der Tablettstift muss während der Erkennung durch den Digitizer bewegt zum Auslösen dieses Ereignisses verschieben <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusMoveEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusMove" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Stift zu weit vom Digitizer entfernt befindet, um erkannt zu werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusOutOfRange> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusOutOfRange> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusOutOfRange>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Benutzer eine von mehreren Gesten ausführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Gesten, finden Sie unter <xref:System.Windows.Input.SystemGesture>.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusSystemGesture> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusSystemGesture> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusSystemGesture>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Benutzer den Tablettstift vom Digitizer auslöst, während sich der Stift über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewStylusDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewStylusDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewStylusUpEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.StylusUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewStylusUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewStylusUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element Text geräteunabhängig empfängt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.PreviewTextInput> Ereignis ermöglicht, eine Komponente oder Anwendung, die für die Texteingabe in einem geräteunabhängig empfängt überwachen. Die Tastatur ist das primäre Mittel <xref:System.Windows.UIElement.PreviewTextInput>; Sprache, Handschrift und andere Eingabegeräte können jedoch auch generieren <xref:System.Windows.UIElement.PreviewTextInput>.  
  
 Aufgrund von Tastenkombinationen – entweder in der Standardeinstellung Tastaturen oder über den Eingabemethoden-Editoren – mehrere wichtige Ereignisse können nur ein Text-Eingabeereignis auslösen.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.PreviewTextInput> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.PreviewTextInput> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewTextInputEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.TextInput>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTextInput%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewTextInput" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Finger den Bildschirm berührt und sich dieser über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig die <xref:System.Windows.UIElement.PreviewTouchDown> und <xref:System.Windows.UIElement.TouchDown> Ereignisse werden nicht ausgeführt, bis ein Finger den Bildschirm berührt und verschiebt. Einen Finger auf dem Bildschirm drücken und gedrückt halten, ohne diesen zu bewegen dadurch drücken Sie dann aus, und halten Sie Verhalten einer <xref:System.Windows.Input.Stylus>. Das Gedrückthalteverhalten ist gleichbedeutend mit der Maustaste.  
  
 Zu bewirken, dass die <xref:System.Windows.UIElement.PreviewTouchDown> und <xref:System.Windows.UIElement.TouchDown> Festlegen von Ereignissen, die als ein Finger den Bildschirm berührt die <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> angefügten Eigenschaft, um `false` für dieses Element.  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewTouchDownEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.TouchDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewTouchDown" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich ein Finger auf dem Bildschirm bewegt, während sich der Finger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewTouchMoveEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.TouchMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewTouchMove" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Finger vom Bildschirm genommen wird, während sich der Finger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.PreviewTouchUpEvent>|  
|Routing-Strategie|Tunneling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Das entsprechende bubbling-Ereignis ist <xref:System.Windows.UIElement.TouchUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.PreviewTouchUp" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryContinueDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich der Status der Tastatur oder der Maustaste während eines Drag &amp; Drop-Vorgangs ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.UIElement.QueryContinueDrag> Ereignis ermöglicht die Quelle des Ziehvorgangs bestimmen, ob der Drag-and-Drop-Vorgang abgebrochen werden soll.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.QueryContinueDrag> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.QueryContinueDrag> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.QueryContinueDragEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewQueryContinueDrag>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnQueryContinueDrag%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.QueryContinueDrag" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryCursor" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Anzeige des Cursors angefordert wird. Dieses Ereignis wird immer dann für ein Element ausgelöst, wenn der Mauszeiger an eine neue Position bewegt wird, d  h., das Cursorobjekt muss möglicherweise in Abhängigkeit von seiner neuen Position geändert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.QueryCursor> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.QueryCursor> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Der Cursor, die mit diesem Ereignisnamen verwiesen wird, ist nicht notwendigerweise der Textcursor (auch als Einfügemarke bezeichnet). Der Cursor in diesem Kontext wird stattdessen das Objekt, das die auf dem Bildschirm grafisch dargestellt, die im Zusammenhang mit mehreren möglichen Eingabe-bezogene Geräte oder Konzepte in deklariert [!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)] programmieren. Dieses Objekt wird dargestellt, indem die <xref:System.Windows.Input.Cursor> in Klasse [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eingabesystem ermöglicht es Ihnen, die diesen Cursor zu ändern, wenn sie die auf dem Bildschirm Position des Mauszeigers darstellt. Sie können vordefinierte Werte aus der <xref:System.Windows.Input.Cursors> -Enumeration, oder Sie können einen benutzerdefinierten Cursor als Bilddatei deklarieren.  
  
 Überwacht die <xref:System.Windows.UIElement.QueryCursor> Ereignis ist für eine effiziente Technik für die Verwaltung der Cursor nicht. Stattdessen sollten jedes Element mit einem eigenen Cursorverhalten definieren <xref:System.Windows.FrameworkContentElement.Cursor%2A> und <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>. Sie sollten nur auf verlassen <xref:System.Windows.UIElement.QueryCursor> Wenn Sie die WPF-Frameworkebene Basiselemente nicht verwenden oder in außergewöhnlicher Umstände, in dem Definieren des Cursorverhaltens regelmäßig pro Element nicht Ihren Anforderungen entspricht. Weitere Informationen zum Implementieren von Cursorverhalten als Antwort auf <xref:System.Windows.UIElement.QueryCursor>, finden Sie unter <xref:System.Windows.Input.QueryCursorEventHandler>.  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.QueryCursorEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   Es gibt keine definiertes entsprechendes Tunneling-Ereignis.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnQueryCursor%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.QueryCursor" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Windows.RoutedEventArgs" /> , das die Ereignisdaten enthält und zudem das auszulösende Ereignis angibt.</param>
        <summary>Löst ein bestimmtes Routingereignis aus. Die <see cref="T:System.Windows.RoutedEvent" /> wird identifiziert, die ausgelöst wird, werden innerhalb der <see cref="T:System.Windows.RoutedEventArgs" /> -Instanz, die bereitgestellt wird (als die <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> Eigenschaft der Ereignisdaten).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `e` Parameter typisiert ist, als das allgemeine Basistyp für alle Routingereignisdaten; allerdings sollte die Ereignisdaten zugewiesen werden, als die spezifischste Ereignis-Datentyp, der für das Ereignis ausgelöst wird, verfügbar ist, da <xref:System.Windows.RoutedEventArgs> abgeleitete Klassen enthalten die tatsächliche Daten-Eigenschaften, die vorgesehen sind, für das spezifische Ereignis, wenn es ausgelöst wird.  
  
 <xref:System.Windows.RoutedEventArgs>ist nicht nur in die Eigenschaften des Ereignisses. Außerdem ermittelt es für die Routingereignis ausgelöst werden soll. Dieses Ereignis auslösen Muster und die Routingereignisdaten unterscheiden sich von [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignisse und Klassen, die in der Regel nur die Eigenschaften enthalten, die mit dem Ereignis verknüpft sind.  
  
   
  
## Examples  
 Im folgende Beispiel Ereignisdaten erstellt, fügt den Ereignisbezeichner an die Daten und verwendet dann die Ereignisdateninstanz ein benutzerdefiniertes Routingereignis ausgelöst werden soll.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseAllTouchCaptures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle erfassten Touch-Geräte aus diesem Element frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseMouseCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Erfassen von Mauseingaben frei, wenn dieses Element die Erfassung aufrechterhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element die Sammlung nicht vorhanden war, hat das Aufrufen dieser Methode keine Auswirkung. Überprüfen Sie den Wert des <xref:System.Windows.UIElement.IsMouseCaptured%2A> vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird der parallelen Struktur zu, in dem Beispiel für <xref:System.Windows.UIElement.CaptureMouse%2A>: Los bis zur Freigabe Mauseingaben aufzufangen behandelt und verschieben die Maus wieder zu aktivieren.  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseStylusCapture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Tablettstift Gerät frei, wenn dieses Element die Erfassung aufrechterhalten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieses Element die Sammlung nicht vorhanden war, hat das Aufrufen dieser Methode keine Auswirkung. Überprüfen Sie den Wert des <xref:System.Windows.UIElement.IsStylusCaptured%2A> vor dem Aufrufen dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">Das Gerät freizugeben.</param>
        <summary>Versucht, die die angegebenen Touch-Geräte aus diesem Element freizugeben.</summary>
        <returns>
          <see langword="true" />Wenn das Gerät Touch freigegeben wird; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="touchDevice" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Der Bezeichner des Routingereignisses, dem der Ereignishandler angefügt ist.</param>
        <param name="handler">Die spezifische Handlerimplementierung, die aus der Ereignishandlerauflistung dieses Elements entfernt werden soll.</param>
        <summary>Entfernt den angegebenen Routingereignishandler aus diesem Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das häufigste Szenario für die Verwendung dieser [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] wird bei der Implementierung der [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "Wrapper"-Ereignis, das bezieht sich auf ein benutzerdefiniertes Routingereignis, insbesondere beim Implementieren der "Remove"-Logik für Handler, an die [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ebene. Das folgenden Beispiel Abschnitt veranschaulicht dieses Szenario "Hinweise".  
  
 Beim Aufrufen dieser Methode hat keine Auswirkungen, gäbe es keine Handler registriert mit Kriterien, die die Eingabeparameter für den Aufruf der Methode entspricht.  
  
 Wenn mehr als ein Ereignishandler angefügt ist, die den abonnementkriterien, nur der erste Handler im Ereignisprotokoll Handler Store entfernt wird. Dieses Verhalten ist konsistent mit [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Verhalten der `-=` Operator.  
  
 Weder `routedEvent` noch `handler` möglicherweise `null`. Bei dem Versuch, einen der Werte `null` wird eine Ausnahme ausgelöst.  
  
 Diese Methode ignoriert die `handledEventsToo` Parameterinformationen, das bereitgestellt wird, wenn der Handler wurde hinzugefügt, mit der <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur, die Handhabung von leerläufen bereits behandelt ermöglicht. Geben Sie entweder der Ereignishandler wird entfernt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.UIElement.RemoveHandler%2A> als Teil einer Ereignisdefinition für den Wrapper.  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size RenderSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size RenderSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Renderinggröße der endgültigen dieses Elements ruft (oder legt diesen fest).</summary>
        <value>Die gerenderte Größe für dieses Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Versuchen Sie nicht, legen Sie diese Eigenschaft wird entweder im [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] oder im Code, wenn das WPF-Frameworkebene Layoutsystem verwenden. Fast alle Szenarien für typische Anwendung werden diese Layoutsystem verwenden. Das Layoutsystem berücksichtigt nicht Größen, legen Sie in der <xref:System.Windows.UIElement.RenderSize%2A> -Eigenschaft direkt. Die <xref:System.Windows.UIElement.RenderSize%2A> Eigenschaft ist nur für bestimmte WPF-Kernebenen-bridging Fälle, in denen die typische Layout-Protokolle, z. B. Unterstützung für absichtlich umgehen aktivieren beschreibbaren deklariert die <xref:System.Windows.Documents.Adorner> Klasse.  
  
 Diese Eigenschaft kann verwendet werden, der entsprechenden Render-Größenwert innerhalb Layoutsystem überschreibt z. B. zur Überprüfung der <xref:System.Windows.UIElement.OnRender%2A> oder <xref:System.Windows.UIElement.GetLayoutClip%2A>.  
  
 Ein gängiges Szenario behandelt wird die <xref:System.Windows.FrameworkElement.SizeChanged> Ereignis mit dem Klassenhandler außer Kraft setzen oder die <xref:System.Windows.UIElement.OnRenderSizeChanged%2A> Ereignis.  
  
<a name="xamlTextUsage_RenderSize"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein benutzerdefinierter Adorner verwendet die <xref:System.Windows.UIElement.RenderSize%2A> Wert zum Erstellen und die Größe, die als Teil der Funktionsindikator definiert seine <xref:System.Windows.UIElement.OnRender%2A> Implementierung.  
  
 [!code-csharp[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/csharp/VS_Snippets_Wpf/AdornersMiscCode/CSharp/Window1.xaml.cs#uielementdesiredsize)]
 [!code-vb[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AdornersMiscCode/visualbasic/window1.xaml.vb#uielementdesiredsize)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform RenderTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform RenderTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Transformationsinformationen ab, die die Renderposition dieses Elements betreffen, oder legt diese fest.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Beschreibt die Einzelheiten der gewünschten Rendertransformation. Die Standardeinstellung ist <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Rendertransformation nicht erneut generieren Layoutgröße oder Größeninformationen gerendert. Rendern von Transformationen für animieren oder Anwenden eines temporären Effekts auf ein Element in der Regel vorgesehen sind. Das Element kann z. B. verkleinert, wenn mit Fokus oder über Flackern zum Zeichnen von Auge auf, dass ein Teil Laden der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].  
  
<a name="dependencyPropertyInfo_RenderTransform"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.RenderTransformProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOrigin">
      <MemberSignature Language="C#" Value="public System.Windows.Point RenderTransformOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point RenderTransformOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransformOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Mittelpunkt einer möglichen Rendertransformation deklariert, indem <see cref="P:System.Windows.UIElement.RenderTransform" />, relativ zu den Grenzen des Elements.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Der Wert, der die Rendertransformation deklariert. Der Standardwert ist eine <see cref="T:System.Windows.Point" /> mit den Koordinaten (0,0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.RenderTransformOrigin%2A>verfügt über eine etwas nicht dem Standard entsprechende Verwendung von der <xref:System.Windows.Point> Struktur auf, die <xref:System.Windows.Point> stellt keine absolute Position in einem Koordinatensystem dar. Stattdessen werden die Werte zwischen 0 und 1 als Faktor für den Bereich des aktuellen Elements in jeder x-und y-Achse interpretiert. Beispielsweise (0,5; 0,5) führt dazu, dass die Rendertransformation für das Element zentriert werden soll oder (1,1) die Rendertransformation am unteren rechten Ecke des Elements platziert. <xref:System.Double.NaN>ist kein zulässiger Wert.  
  
 Werte jenseits von 0 und 1 werden auch akzeptiert, und führt zu Transformationseffekten. Für die Instanz, wenn Sie festlegen, <xref:System.Windows.UIElement.RenderTransformOrigin%2A> (5,5), und wenden Sie dann eine <xref:System.Windows.Media.RotateTransform>, die Rotation-Point werden außerhalb der Grenzen des Elements selbst. Die Transformation wird das Element in einem großen Kreis drehen, die unterhalb der unteren rechten stammt. Der Ursprung möglicherweise an einer beliebigen Stelle in seinem übergeordneten Element und möglicherweise möglicherweise nicht genügend Frame oder einer Ansicht. Negative Werte sind ähnlich, diese werden der oberen linken Begrenzung hinausgehen.  
  
 Rendern von Transformationen wirken sich nicht auf Layout und werden in der Regel verwendet, um dem animiert werden soll, oder einen temporären Effekt auf ein Element anwenden.  
  
<a name="xamlAttributeUsage_RenderTransformOrigin"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object RenderTransformOrigin="xOrigin, yOrigin"/>  
```  
  
<a name="xamlPropertyElementUsage_RenderTransformOrigin"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.RenderTransformOrigin>  
    <Point X=" xOrigin " Y=" yOrigin "/>  
  </object.RenderTransformOrigin>  
</object>  
```  
  
<a name="xamlValues_RenderTransformOrigin"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *xOrigin*  
 Der Faktor für die horizontale Ursprung an. Dies wird in der Regel als Wert zwischen 0 und 1 angegeben. Siehe Hinweise.  
  
 *yOrigin*  
 Der Faktor für die vertikale Ursprung an. Dies wird in der Regel als Wert zwischen 0 und 1 angegeben. Siehe Hinweise.  
  
<a name="dependencyPropertyInfo_RenderTransformOrigin"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.RenderTransformOriginProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Im folgende Beispiel werden die Elemente im Code erstellt wird, gilt eine <xref:System.Windows.UIElement.RenderTransformOrigin%2A>, und wendet dann einen <xref:System.Windows.UIElement.RenderTransform%2A>.  
  
 [!code-csharp[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/csharp/VS_Snippets_Wpf/transformanimations_snip/CSharp/RotateAboutCenterExample.cs#uielementrendertransformorigin)]
 [!code-vb[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/visualbasic/VS_Snippets_Wpf/transformanimations_snip/visualbasic/rotateaboutcenterexample.vb#uielementrendertransformorigin)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOriginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformOriginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformOriginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.RenderTransformOrigin" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.RenderTransform" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeCommandBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der serialisieren sollen die <see cref="P:System.Windows.UIElement.CommandBindings" /> Eigenschaft für Instanzen dieser Klasse.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.UIElement.CommandBindings" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl zurück `true` Wenn <xref:System.Windows.UIElement.CommandBindings%2A> lokal festgelegt ist.  
  
 Dies `ShouldSerialize` Methode wird bereitgestellt, da die <xref:System.Windows.UIElement.CommandBindings%2A> Eigenschaft verfügt nicht über einen einfachen Standardwert. Diese Methode gibt an, ob die-Eigenschaft ihren Standardwert geändert hat. Diese Methode wird in der Regel aufgerufen, wenn Sie entweder einen Designer oder entwickeln eigener Steuerelement einbinden einer <xref:System.Windows.UIElement>.  
  
 Weitere Informationen finden Sie unter [Definieren von Standardwerten mit der ShouldSerialize-Methode und die Methoden zurücksetzen](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeInputBindings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob Serialisierungsprozesse den Inhalt der serialisieren sollen die <see cref="P:System.Windows.UIElement.InputBindings" /> Eigenschaft für Instanzen dieser Klasse.</summary>
        <returns>
          <see langword="true" />, wenn der <see cref="P:System.Windows.UIElement.InputBindings" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl zurück `true` Wenn <xref:System.Windows.UIElement.InputBindings%2A> lokal festgelegt ist.  
  
 Dies `ShouldSerialize` Methode wird bereitgestellt, da die <xref:System.Windows.UIElement.InputBindings%2A> Eigenschaft verfügt nicht über einen einfachen Standardwert. Diese Methode gibt an, ob die-Eigenschaft ihren Standardwert geändert hat. Diese Methode wird in der Regel aufgerufen, wenn Sie entweder einen Designer oder entwickeln eigener Steuerelement einbinden einer <xref:System.Windows.UIElement>.  
  
 Weitere Informationen finden Sie unter [Definieren von Standardwerten mit der ShouldSerialize-Methode und die Methoden zurücksetzen](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob für das Rendern dieses Elements gerätespezifische Pixelseinstellungen verwendet werden sollen, oder legt ihn fest.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>
          <see langword="true" />Wenn das Element unter Verwendung von Gerätepixeln Gerätepixeln gerendert werden soll; andernfalls <see langword="false" />. Die Standardeinstellung gemäß der Deklaration auf <see cref="T:System.Windows.UIElement" /> ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft festlegen, um `true` für Ihre Stammelement Pixel aktivieren ausgerichtet werden in der Benutzeroberfläche rendern. Für Geräte, die größer als 96 erbringen [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)], Pixel ausrichten Rendering visuelle Anti-Aliasing-Artefakten in einer einzelnen Einheit durchgezogene Linien minimieren kann.  
  
 Wenn von geerbt <xref:System.Windows.FrameworkElement> oder alle möglichen abgeleiteten Klassen, <xref:System.Windows.FrameworkElement> überschreibt die Metadaten für diese Abhängigkeitseigenschaft Festlegen der <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Metadateneigenschaft, um `true`. Wird sichergestellt, dass nur das äußerste Element in einer Teilstruktur angeben muss <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> als `true`, und klicken Sie dann alle untergeordneten Elemente des Teilstruktur meldet <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> als `true` und haben die <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> visuellen Effekts.  
  
<a name="dependencyPropertyInfo_SnapsToDevicePixels"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.SnapsToDevicePixels" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Stifttaste gedrückt wird, während sich der Zeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusButtonDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusButtonDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusButtonDownEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusButtonDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusButtonDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusButtonDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn die Stifttaste losgelassen wird, während sich der Zeiger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusButtonUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusButtonUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusButtonUpEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusButtonUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusButtonUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusButtonUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift den Digitizer berührt, während sich der Stift über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusDown> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusDown> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusDownEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusDown" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift in den Bereich dieses Elements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusEnter>ist eine, die Routingstrategie für direkte Ereignisbehandlung verwendet. Direkte Routingereignisse werden nicht auf einer Route ausgelöst. Stattdessen werden diese in demselben Element behandelt, in dem sie ausgelöst werden. Aktivieren sie jedoch andere Aspekte der Routingereignis-Verhalten, z. B. in Formaten-Ereignis ausgelöst.  
  
 Obwohl <xref:System.Windows.UIElement.StylusEnter> verfolgt nach, wenn der Stift den Bereich eines Elements, das dieses Ereignis Weitere eintritt buchstäblich angibt, welches die <xref:System.Windows.UIElement.IsStylusOver%2A> Eigenschaftswert geändert hat `false` auf `true` für dieses Element.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusEnter> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusEnter> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusEnterEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusEnter%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusEnter" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInAirMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift über ein Element bewegt wird, ohne tatsächlich den Digitizer zu berühren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusInAirMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusInAirMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusInAirMoveEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusInAirMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusInAirMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusInAirMove" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Tablettstift nah genug am Digitizer befindet, um erkannt zu werden, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusInRange> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusInRange> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusInRangeEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusInRange>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusInRange%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusInRange" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift den Bereich des Elements verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusLeave>ist eine, die Routingstrategie für direkte Ereignisbehandlung verwendet. Direkte Routingereignisse werden nicht auf einer Route ausgelöst. Stattdessen werden diese in demselben Element behandelt, in dem sie ausgelöst werden. Aktivieren sie jedoch andere Aspekte der Routingereignis-Verhalten, z. B. in Formaten-Ereignis ausgelöst.  
  
 Obwohl <xref:System.Windows.UIElement.StylusLeave> verfolgt nach, wenn der Stift den Bereich eines Elements, das dieses Ereignis mehr verlässt buchstäblich angibt, welches die <xref:System.Windows.UIElement.IsStylusOver%2A> Eigenschaftswert geändert hat `true` auf `false` für dieses Element.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusLeave> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusLeave> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusLeaveEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusLeave%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusLeave" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift über das Element bewegt wird. Zum Auslösen dieses Ereignisses muss der Stift auf dem Digitizer bewegt werden. Andernfalls <see cref="E:System.Windows.UIElement.StylusInAirMove" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusMove> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusMove> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusMoveEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusMove" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusOutOfRange" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Stift zu weit vom Digitizer entfernt ist um erkannt zu werden, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusOutOfRange> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusOutOfRange> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusOutOfRangeEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusOutOfRange>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusOutOfRange%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusOutOfRange" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPlugIns">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.StylusPlugIns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.StylusPlugInCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung aller Tablettstift-Plug-in (Anpassung) Objekte, die diesem Element zugeordnet.</summary>
        <value>Die Auflistung der Tablettstift-Plug-ins, als eine spezielle Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist ein Beispiel für ein Steuerelement, das diese Auflistung füllt <xref:System.Windows.Controls.InkCanvas>. <xref:System.Windows.Controls.InkCanvas>Fügt der <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> als Auflistungselement, wodurch die <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> zur Tablettstifteingabe Interaktion und zum Generieren eindeutigen Rendering als Antwort auf Ereignisse driven Tablettstift.  
  
 Informationen zum Erstellen von benutzerdefinierten Plug-Ins, die empfangen und Stifteingabe interpretiert werden kann, finden Sie unter [Eingabe abfangen, die vom Tablettstift](~/docs/framework/wpf/advanced/intercepting-input-from-the-stylus.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> -Instanz und fügt es der <xref:System.Windows.UIElement.StylusPlugIns%2A> Auflistung für eine benutzerdefinierte Ink Steuerelement behandeln.  
  
 [!code-csharp[StylusPluginSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StylusPluginSamples/CSharp/StylusControl.cs#3)]
 [!code-vb[StylusPluginSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StylusPluginSamples/VisualBasic/StylusControl.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusSystemGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Benutzer eine von mehreren Gesten ausführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Gesten, finden Sie unter <xref:System.Windows.Input.SystemGesture>.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusSystemGesture> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusSystemGesture> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusSystemGestureEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusSystemGesture>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusSystemGesture%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusSystemGesture" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn der Benutzer den Tablettstift vom Digitizer auslöst, während er sich über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.StylusUp> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.StylusUp> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
 Touch, Maus und Tablettstifteingabe, die in einer bestimmten Beziehung vorhanden sein. Weitere Informationen finden Sie unter [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.StylusUpEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewStylusUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnStylusUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.StylusUp" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn dieses Element Text geräteunabhängig empfängt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Dieses Ereignis möglicherweise bereits von der internen Implementierungen der zusammengesetzte Steuerelemente als behandelt markiert werden. Finden Sie unter folgenden angeführt.  
  
 Die <xref:System.Windows.UIElement.TextInput> Ereignis bereits von der internen Implementierungen der zusammengesetzte Steuerelemente als behandelt markiert werden kann. Z. B. eine <xref:System.Windows.Controls.TextBox> ist ein zusammengesetztes Steuerelement, in dem die <xref:System.Windows.UIElement.TextInput> Ereignis bereits als behandelt; innerhalb seiner Compositing markiert ist. Steuerelemente geschieht, weil das Steuerelement einige Arten von Eingaben, z. B. Pfeiltasten einstellungsproblem besondere Bedeutung für das Steuerelement zu interpretieren muss. Bei Verwendung von <xref:System.Windows.UIElement.PreviewTextInput> des Ereignisses, in dem Sie Handler für die Texteingabe anfügen, können Sie bessere Ergebnisse erhalten. Diese Technik umgeht den meisten Fällen, in dem Steuerelement Zusammensetzung wurde bereits dieses Ereignis als behandelt markiert, und verhindert, dass den Ereignishandler empfängt das Ereignis auf der Ereignisroute.  
  
 Die <xref:System.Windows.UIElement.TextInput> Ereignis ermöglicht, eine Komponente oder Anwendung, die für die Texteingabe in einem geräteunabhängig empfängt überwachen. Die Tastatur ist das primäre Mittel <xref:System.Windows.UIElement.TextInput>, jedoch die Sprache, Handschrift und andere Eingabegeräte können auch die folgenden <xref:System.Windows.UIElement.TextInput>.  
  
 Aufgrund von Tastenkombinationen – entweder in der Standardeinstellung Tastaturen oder über den Eingabemethoden-Editoren – mehrere Tastaturereignisse können nur ein Text-Eingabeereignis auslösen.  
  
 Dieses Ereignis erstellt einen Alias für die <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> angefügtes Ereignis für diese Klasse, damit <xref:System.Windows.UIElement.TextInput> ist Teil der Klasse Member aufzulisten, wenn <xref:System.Windows.UIElement> als einem Basiselement geerbt wird. Ereignishandler, die angefügt werden die <xref:System.Windows.UIElement.TextInput> Ereignis an das zugrunde liegende angefügt sind <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> angefügtes Ereignis und die gleichen Ereignisdateninstanz empfangen.  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.TextInputEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewTextInput>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnTextInput%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.TextInput" />-Routingereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bezeichner für Routingereignisse werden erstellt, wenn Routingereignisse registriert werden. Ein solcher Bezeichner enthält einen kennzeichnenden Namen, den Besitzertyp, den Handlertyp, die Routingstrategie und die Hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie können diese Bezeichner dazu verwenden, Klassenhandler hinzuzufügen.  
  
 Weitere Informationen zum Registrieren von Routingereignissen finden Sie unter <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Weitere Informationen zum Verwenden von Bezeichner für Routingereignisse, Klassenhandler hinzuzufügen, finden Sie unter <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Finger den Bildschirm berührt und sich dieser über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig die <xref:System.Windows.UIElement.PreviewTouchDown> und <xref:System.Windows.UIElement.TouchDown> Ereignisse werden nicht ausgeführt, bis ein Finger den Bildschirm berührt und verschiebt. Einen Finger auf dem Bildschirm drücken und gedrückt halten, ohne diesen zu bewegen dadurch drücken Sie dann aus, und halten Sie Verhalten einer <xref:System.Windows.Input.Stylus>. Das Gedrückthalteverhalten ist gleichbedeutend mit der Maustaste.  
  
 Zu bewirken, dass die <xref:System.Windows.UIElement.PreviewTouchDown> und <xref:System.Windows.UIElement.TouchDown> Festlegen von Ereignissen, die als ein Finger den Bildschirm berührt die <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> angefügten Eigenschaft, um `false` für dieses Element.  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.TouchDownEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewTouchDown>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnTouchDown%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.TouchDown" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchEnter" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Fingereingabe verliert außerhalb nach innerhalb der Grenzen dieses Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird immer dann ausgelöst, und zwar unabhängig davon, ob die Touch-Geräte für dieses Element erfasst wird.  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.TouchEnterEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnTouchEnter%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.TouchEnter" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Touch-Geräte, die für dieses Element erfasst werden.</summary>
        <value>Eine Enumeration von <see cref="T:System.Windows.Input.TouchDevice" /> Objekte, die für dieses Element erfasst werden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Touch-Geräte, die für dieses Element erfasst werden oder den untergeordneten Elementen in seiner visuellen Struktur an.</summary>
        <value>Eine Enumeration von <see cref="T:System.Windows.Input.TouchDevice" /> Objekte, die für dieses Element oder seine untergeordneten Elemente in seiner visuellen Struktur erfasst werden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Touch-Geräte, die sich über diesem Element befinden.</summary>
        <value>Eine Enumeration von <see cref="T:System.Windows.Input.TouchDevice" /> Objekte, die sich über diesem Element befinden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Touch-Geräte, die sich über diesem Element oder seinen untergeordneten Elementen in seiner visuellen Struktur an.</summary>
        <value>Eine Enumeration von <see cref="T:System.Windows.Input.TouchDevice" /> Objekte, die sich über diesem Element oder seine untergeordneten Elemente in seiner visuellen Struktur befinden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchLeave" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Fingereingabe verliert innerhalb nach außerhalb der Grenzen dieses Elements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird immer dann ausgelöst, und zwar unabhängig davon, ob die Touch-Geräte für dieses Element erfasst wird.  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.TouchLeaveEvent>|  
|Routing-Strategie|Direkt|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnTouchLeave%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.TouchLeave" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich ein Finger auf dem Bildschirm bewegt, während sich der Finger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.TouchMoveEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewTouchMove>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnTouchMove%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.TouchMove" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn ein Finger vom Bildschirm genommen wird, während sich der Finger über diesem Element befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.TouchUpEvent>|  
|Routing-Strategie|Bubbling|  
|Delegate|<xref:System.EventHandler%601>Der Typ <xref:System.Windows.Input.TouchEventArgs>.|  
  
-   Das entsprechende Tunneling-Ereignis ist <xref:System.Windows.UIElement.PreviewTouchUp>.  
  
-   Überschreiben Sie <xref:System.Windows.UIElement.OnTouchUp%2A> um eine Klassenbehandlung für dieses Ereignis in abgeleiteten Klassen zu implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert das <see cref="E:System.Windows.UIElement.TouchUp" />-Routingereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatePoint">
      <MemberSignature Language="C#" Value="public System.Windows.Point TranslatePoint (System.Windows.Point point, System.Windows.UIElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point TranslatePoint(valuetype System.Windows.Point point, class System.Windows.UIElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="relativeTo" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="point">Der Punktwert relativ zu diesem Element.</param>
        <param name="relativeTo">Das Element, in das der angegebene Punkt übersetzt werden soll.</param>
        <summary>Übersetzt einen Punkt relativ zu diesem Element in Koordinaten, die relativ zum angegebenen Element sind.</summary>
        <returns>Ein Punktwert, der jetzt relativ zum Zielelement anstatt zu diesem Quellelement ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Übergeben von `null` für `relativeTo` ist zulässig, und gibt an, dass Koordinaten relativ zu den Root-Element in der logischen Struktur sein sollte, zu der dieses Element gehört.  
  
 Diese Methode dient zum Übersetzen von Punktwerten Test erreicht. Beim Aufrufen dieser Methode ist vor allem relevant, wenn Sie ein Steuerelement erstellen und beim Verarbeiten der Eingabe auf einer niedrigeren Ebene müssen. Wenn Sie vorhandenen Steuerelemente verwenden, können Sie in der Regel davon ausgehen, dass abgeschlossene Steuerelemente korrekt übersetzte Treffertestergebnissen gemeldet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Uid">
      <MemberSignature Language="C#" Value="public string Uid { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Uid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Uid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Bezeichner (für Lokalisierung) für dieses Element ab oder legt diesen fest. Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Eine Zeichenfolge, die der eindeutige Bezeichner für dieses Element ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Abrufen von Designern verwendet die `x:Uid` Wert (finden Sie unter [WPF-Globalisierung und Lokalisierung (Übersicht)](~/docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md) für Weitere Informationen).  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.UidProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UidProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UidProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UidProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.UidProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.Uid" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateLayout">
      <MemberSignature Language="C#" Value="public void UpdateLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.UpdateLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass alle sichtbaren untergeordneten Elemente dieses Elements für das Layout ordnungsgemäß aktualisiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode, die Elemente mit <xref:System.Windows.UIElement.IsMeasureValid%2A> `false` oder <xref:System.Windows.UIElement.IsArrangeValid%2A> `false` angerufen elementspezifischen <xref:System.Windows.UIElement.MeasureCore%2A> und <xref:System.Windows.UIElement.ArrangeCore%2A> -Methoden, die Layout erzwingt aktualisieren, und alle berechnete Größen werden überprüft.  
  
 Beim Aufrufen dieser Methode hat keine Auswirkung, wenn das Layout nicht geändert wurden, oder Anordnung weder Messung Zustand eines Layouts ungültig ist. Jedoch, wenn das Layout ungültig, wird die <xref:System.Windows.UIElement.UpdateLayout%2A> Aufruf wird das gesamte Layout wiederholen. Aus diesem Grund sollten Sie vermeiden Sie Aufrufe <xref:System.Windows.UIElement.UpdateLayout%2A> nach jeder inkrementellen und kleinere Änderung in der Elementstruktur. Das Layoutsystem führt Elementlayouts verzögert, mithilfe eines Algorithmus, das Leistung und Währungen im Gleichgewicht sind und mit einer Gewichtung Strategie für den Änderungen an Stämme verzögern, bis alle untergeordneten Elemente gültig sind. Sie sollten nur aufrufen <xref:System.Windows.UIElement.UpdateLayout%2A> wenn unbedingt Sie aktualisierte Größen und Positionen benötigen und alle Änderungen an den Eigenschaften, dass Sie das Steuerelement, und dass Layout auswirken können nur verwendet werden, wenn Sie sicher, dass Arbeiten abgeschlossen sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] -Sichtbarkeit dieses Elements.  Hierbei handelt es sich um eine Abhängigkeitseigenschaft.</summary>
        <value>Ein Wert aus der Enumeration. Der Standardwert ist <see cref="F:System.Windows.Visibility.Visible" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wirkt sich auf den Wert der <xref:System.Windows.UIElement.IsVisible%2A>, die wiederum authentifizierungsbibliotheksmethoden der <xref:System.Windows.UIElement.IsVisibleChanged> Ereignis. Allerdings <xref:System.Windows.UIElement.IsVisible%2A> andere Faktoren, z. B. die sichtbarkeitseinstellungen der übergeordneten Elemente, die sie enthalten ist.  
  
 Elemente, in denen <xref:System.Windows.UIElement.Visibility%2A> nicht <xref:System.Windows.Visibility.Visible> keine Teilnahme Eingabeereignissen (oder Befehlen), wirken sich nicht auf das Measure oder die anordnen übergibt des Layouts, sind nicht in einer Sequenz Registerkarte und Treffertests gemeldet werden.  
  
 Wenn von geerbt <xref:System.Windows.Window> oder seinen abgeleiteten Klassen <xref:System.Windows.Window> definiert den Standardwert dieser Eigenschaft werden <xref:System.Windows.Visibility.Collapsed>. Dies hat Auswirkungen hat die Ausführung nicht auf einem anfänglich erstellten der Messphase des Layouts <xref:System.Windows.Window>, und <xref:System.Windows.UIElement.RenderSize%2A> (0,0) zurückgibt. Ausführliche Informationen finden Sie unter <xref:System.Windows.Window>. <xref:System.Windows.Controls.Primitives.Popup>definiert auch den Standardwert werden <xref:System.Windows.Visibility.Collapsed>, mit ähnlichem resultierende Verhalten für <xref:System.Windows.Controls.Primitives.Popup> und abgeleitete Klassen.  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.UIElement.VisibilityProperty>|  
|Metadaten-Eigenschaften festgelegt auf.`true`|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel implementiert einen Handler, der auf zwei unterschiedliche benannten Schaltflächen verweist, die ein sich gegenseitig ausschließende-Paar in der Benutzeroberfläche werden sollen. Vor dem Ausführen der tatsächlichen Programmlogik, die der Schaltfläche zugeordnet, die Schaltfläche "selbst" festgelegt ist, werden <xref:System.Windows.Visibility?displayProperty=nameWithType>, und legen Sie die Schaltfläche "Sonstige" im Paar ist auf <xref:System.Windows.Visibility?displayProperty=nameWithType>.  
  
 [!code-csharp[MediaElement_snip#UIElementVisibility](~/samples/snippets/csharp/VS_Snippets_Wpf/MediaElement_snip/CSharp/PlaybackExample.cs#uielementvisibility)]
 [!code-vb[MediaElement_snip#UIElementVisibility](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MediaElement_snip/VB/PlaybackExample.vb#uielementvisibility)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.UIElement.Visibility" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
