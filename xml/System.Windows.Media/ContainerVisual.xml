<Type Name="ContainerVisual" FullName="System.Windows.Media.ContainerVisual">
  <TypeSignature Language="C#" Value="public class ContainerVisual : System.Windows.Media.Visual" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerVisual extends System.Windows.Media.Visual" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.ContainerVisual" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet eine Auflistung von <see cref="T:System.Windows.Media.Visual" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.ContainerVisual> Klasse dient als Container für eine Auflistung von <xref:System.Windows.Media.Visual> Objekte. Die <xref:System.Windows.Media.DrawingVisual> Klasse leitet sich von der <xref:System.Windows.Media.ContainerVisual> -Klasse, so, dass die <xref:System.Windows.Media.DrawingVisual> Klasse kann auch eine Auflistung von visueller Objekte enthalten.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer <xref:System.Windows.Media.ContainerVisual> -Objekt, das als das übergeordnete Element, für zwei verwendet wird <xref:System.Windows.Media.DrawingVisual> Objekte. Objekte, die hinzugefügt werden, die <xref:System.Windows.Media.ContainerVisual> Objekt muss in umgekehrter Z-Reihenfolge (von unten nach oben) hinzugefügt werden, um sicherzustellen, dass sie in der richtigen Zeichnungsreihenfolge gerendert werden. In der Reihenfolge für die visuelle Struktur ordnungsgemäß aufgelistet werden sollen, bietet das Beispiel überschriebene Implementierungen von der <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> Methode und <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> Eigenschaft.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Windows.Media.ContainerVisual" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer neuen Instanz von einem <xref:System.Windows.Media.ContainerVisual> Objekt, und klicken Sie dann untergeordnete visuelle Objekte hinzugefügt.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet1)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt eine <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> Wert für die <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Der Bitmapeffekt für dieses visuelle Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt eine <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> Wert für die <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Der Bitmapeffekt Eingabewert für dieses visuelle Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt eine zwischengespeicherte Repräsentation der <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein <see cref="T:System.Windows.Media.CacheMode" /> , enthält eine zwischengespeicherte Repräsentation der <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.Windows.Media.ContainerVisual.CacheMode%2A> Eigenschaft, wenn Sie müssen zum Erhöhen der Leistung für Inhalte, die zum Rendern zeitaufwendig ist. Weitere Informationen finden Sie unter <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.VisualCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die untergeordnete Auflistung ab dem <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein <see cref="T:System.Windows.Media.VisualCollection" /> , enthält die untergeordneten Elemente der <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Abrufen der <xref:System.Windows.Media.VisualCollection> aus einem <xref:System.Windows.Media.ContainerVisual> Objekt.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet3)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Ausschneidebereich der <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Die <see cref="T:System.Windows.Media.Geometry" /> , die den Ausschneidebereich definiert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das umgebende Feld für den Inhalt der <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" /> , die das umgebende Feld angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.ContainerVisual.DescendantBounds%2A> -Eigenschaft zum Zurückgeben von der Vereinigung aller umgebenden Felder für alle Nachfolgerelemente des Inhalts einer <xref:System.Windows.Media.ContainerVisual> Objekt, aber nicht das Objekt selbst.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie das Begrenzungsrechteck der abzurufenden ein <xref:System.Windows.Media.ContainerVisual> Objekt.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect DescendantBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect DescendantBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Vereinigung aller umgebenden Felder für alle Nachfolgerelemente des Inhalts der <see cref="T:System.Windows.Media.ContainerVisual" />, aber nicht einschließlich des Inhalts des der <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" /> , die umgebende Feld angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen der <xref:System.Windows.Media.ContainerVisual.ContentBounds%2A> -Eigenschaft zum Zurückgeben der zwischengespeicherten Begrenzungsrechteck-Feld für die <xref:System.Windows.Media.ContainerVisual> selbst.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie das Begrenzungsrechteck der abzurufenden eine <xref:System.Windows.Media.ContainerVisual> Nachfolger des Objekts.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Bitmapeffekt ab, die zum Anwenden der <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein <see cref="T:System.Windows.Media.Effects.Effect" /> , der den Bitmapeffekt darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Indexwert des untergeordneten Elements darstellt <see cref="T:System.Windows.Media.Visual" />. Der Wert der <c>Index</c> muss zwischen 0 und <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> - 1.</param>
        <summary>Gibt ein angegebenes untergeordnetes <see cref="T:System.Windows.Media.Visual" /> für das übergeordnete <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <returns>Das untergeordnete Element <see cref="T:System.Windows.Media.Visual" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Windows.Media.ContainerVisual> verfügt nicht über alle untergeordneten Elemente.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer <xref:System.Windows.Media.ContainerVisual> -Objekt, das als das übergeordnete Element, für zwei verwendet wird <xref:System.Windows.Media.DrawingVisual> Objekte. Objekte, die hinzugefügt werden, die <xref:System.Windows.Media.ContainerVisual> Objekt muss in umgekehrter Z-Reihenfolge (von unten nach oben) hinzugefügt werden, um sicherzustellen, dass sie in der richtigen Zeichnungsreihenfolge gerendert werden. In der Reihenfolge für die visuelle Struktur ordnungsgemäß aufgelistet werden sollen, bietet das Beispiel überschriebene Implementierungen von der <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> Methode und <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> Eigenschaft.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Während dieses Aufrufs werden nicht die visuelle Struktur geändert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Media.HitTestResult HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.HitTestResult HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der Punktwert, für den ein Treffertest ausgeführt werden soll.</param>
        <summary>Gibt durch Angeben von <see cref="T:System.Windows.Point" /> das oberste visuelle Objekt eines Treffertests zurück.</summary>
        <returns>Das als <see cref="T:System.Windows.Media.HitTestResult" />-Typ zurückgegebene Ergebnis des Treffertests.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.HitTestResult.VisualHit%2A> Eigenschaft des Rückgabewerts stellt die <xref:System.Windows.Media.Visual> Objekt, das ermittelt wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Abrufen der <xref:System.Windows.Media.HitTestResult> Rückgabewert aus der <xref:System.Windows.Media.ContainerVisual.HitTest%2A> Methode.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet2)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public void HitTest (System.Windows.Media.HitTestFilterCallback filterCallback, System.Windows.Media.HitTestResultCallback resultCallback, System.Windows.Media.HitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HitTest(class System.Windows.Media.HitTestFilterCallback filterCallback, class System.Windows.Media.HitTestResultCallback resultCallback, class System.Windows.Media.HitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Media.HitTestFilterCallback,System.Windows.Media.HitTestResultCallback,System.Windows.Media.HitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterCallback" Type="System.Windows.Media.HitTestFilterCallback" />
        <Parameter Name="resultCallback" Type="System.Windows.Media.HitTestResultCallback" />
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.HitTestParameters" />
      </Parameters>
      <Docs>
        <param name="filterCallback">Der Delegat, der es Ihnen ermöglicht, in den Treffertestergebnissen die Teile der visuellen Struktur zu ignorieren, die nicht verarbeitet werden sollen.</param>
        <param name="resultCallback">Der Delegat, mit dem die Rückgabe der Treffertestinformationen gesteuert wird.</param>
        <param name="hitTestParameters">Definiert den Satz von Parametern für einen Treffertest.</param>
        <summary>Initiiert einen Treffertest für das <see cref="T:System.Windows.Media.ContainerVisual" /> mithilfe der <see cref="T:System.Windows.Media.HitTestFilterCallback" /> und <see cref="T:System.Windows.Media.HitTestResultCallback" /> Objekte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `filterCallback` Parameter kann null sein, in diesem Fall wird es ignoriert. Wenn `filterCallback` nicht `null`, er wird aufgerufen, bevor Sie `resultCallback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Offset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector Offset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Offsetwert der <see cref="T:System.Windows.Media.ContainerVisual" /> vom Verweis gesucht.</summary>
        <value>Ein <see cref="T:System.Windows.Vector" /> , der den Offsetwert stellt die <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Deckkraft des der <see cref="T:System.Windows.Media.ContainerVisual" />, basierend auf 0 = transparent und 1 = nicht transparent.</summary>
        <value>Ein Wert zwischen 0 und 1, der einen Bereich von vollständig transparent auf vollständig deckendes angibt. Der Wert 0 gibt an, dass die <see cref="T:System.Windows.Media.ContainerVisual" /> vollständig transparent ist, während ein Wert von 1, die die <see cref="T:System.Windows.Media.ContainerVisual" /> vollständig deckend ist. Der Wert 0,5 gibt an, 50 Prozent deckt, der Wert 0,725 gibt an, zu 72,5 Prozent deckend ist, usw.. Kleinere Werte als 0 werden als 0 behandelt, größere Werte als 1 als 1.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Pinsel, der angibt, eine möglichen Deckkraftmaske für die <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein Wert vom Typ <see cref="T:System.Windows.Media.Brush" /> , die Wert für die Deckkraft des stellt die <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deckkraftmasken können verwendet werden, erstellen Sie beispielsweise einen Effekte wie korrigieren, basierend auf den alpha-Kanal-Werten des Pinsels.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Element <see cref="T:System.Windows.Media.Visual" /> für die <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Das übergeordnete Element des visuellen Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, das dies als zurückgegeben wird <xref:System.Windows.DependencyObject>, anstatt ein raw-Objekt.  
  
 Diese Eigenschaft möglicherweise zurück `null` in einer nicht verbundenen Struktur oder wenn Sie auf den Stamm der Struktur auf der Ebene des Fensters durchlaufen haben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Transformation, die für gilt die <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Der Wert für die Zieltransformation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Transform>ist eine Basisklasse, die viele verschiedene Formen von Transformationen vereinheitlicht. Ausführliche Informationen finden Sie unter <xref:System.Windows.Media.Transform>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override sealed int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der untergeordneten Elemente für die <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Die Anzahl der untergeordneten Elemente in der <see cref="T:System.Windows.Media.VisualCollection" /> von der <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Windows.Media.ContainerVisual> verfügt nicht über alle untergeordneten Elemente.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer <xref:System.Windows.Media.ContainerVisual> -Objekt, das als das übergeordnete Element, für zwei verwendet wird <xref:System.Windows.Media.DrawingVisual> Objekte. Objekte, die hinzugefügt werden, die <xref:System.Windows.Media.ContainerVisual> Objekt muss in umgekehrter Z-Reihenfolge (von unten nach oben) hinzugefügt werden, um sicherzustellen, dass sie in der richtigen Zeichnungsreihenfolge gerendert werden. In der Reihenfolge für die visuelle Struktur ordnungsgemäß aufgelistet werden sollen, bietet das Beispiel überschriebene Implementierungen von der <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> Methode und <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> Eigenschaft.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Abgeleitete Klassen <see cref="T:System.Windows.Media.ContainerVisual" /> implementieren müssen die <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> Eigenschaft, um die untergeordneten visuellen Elemente aufzulisten. Die abgeleitete Eigenschaft muss die Anzahl der untergeordneten Elemente für Zurückgeben der <see cref="T:System.Windows.Media.ContainerVisual" />.  
  
 Während dieses Aufrufs werden nicht die visuelle Struktur geändert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection XSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection XSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die (horizontale) X-Führungslinie für das <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Die horizontale Führungslinie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Andocken von Pixel versteht man in der Inhaltslayout behoben wurde, sodass Objekt Ränder gerätespezifischen Pixel gerendert werden. Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Grafiksystem verwendet geräteunabhängige Einheiten, um die Unabhängigkeit von der Auflösung und vom Gerät zu aktivieren. Jedes geräteunabhängige Pixel skaliert automatisch mit der [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]-Einstellung des Systems. Dadurch wird die ordnungsgemäße Skalierung von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Anwendungen für unterschiedliche [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]-Einstellungen bereitgestellt, und die Anwendung ist automatisch bereit für [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Allerdings dies [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] Unabhängigkeit unregelmäßige Edge-Rendering aufgrund Anti-Aliasing erstellen kann. Diese Artefakte, die häufig als unscharf oder "soft" Kanten gesehen können auftreten, wenn ein Rand in der Mitte eines Gerätepixels und nicht zwischen Gerätepixeln liegt. Um dieses Problem zu beheben [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] bietet eine Möglichkeit für Objekt Ränder in einer visuellen Struktur "Gerätepixeln über Pixel andocken, Einrasten" Entfernen der weichen Kanten von Anti-Aliasing erzeugt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="YSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection YSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection YSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt ihn fest (vertikale) Y-Führungslinie für das <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Die vertikale Führungslinie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Andocken von Pixel versteht man in der Inhaltslayout behoben wurde, sodass Objekt Ränder gerätespezifischen Pixel gerendert werden. Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Grafiksystem verwendet geräteunabhängige Einheiten, um die Unabhängigkeit von der Auflösung und vom Gerät zu aktivieren. Jedes geräteunabhängige Pixel skaliert automatisch mit der [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]-Einstellung des Systems. Dadurch wird die ordnungsgemäße Skalierung von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Anwendungen für unterschiedliche [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]-Einstellungen bereitgestellt, und die Anwendung ist automatisch bereit für [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Allerdings dies [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] Unabhängigkeit unregelmäßige Edge-Rendering aufgrund Anti-Aliasing erstellen kann. Diese Artefakte, die häufig als unscharf oder "soft" Kanten gesehen können auftreten, wenn ein Rand in der Mitte eines Gerätepixels und nicht zwischen Gerätepixeln liegt. Um dieses Problem zu beheben [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] bietet eine Möglichkeit für Objekt Ränder in einer visuellen Struktur "Gerätepixeln über Pixel andocken, Einrasten" Entfernen der weichen Kanten von Anti-Aliasing erzeugt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
