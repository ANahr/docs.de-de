<Type Name="Expression&lt;TDelegate&gt;" FullName="System.Linq.Expressions.Expression&lt;TDelegate&gt;">
  <TypeSignature Language="C#" Value="public sealed class Expression&lt;TDelegate&gt; : System.Linq.Expressions.LambdaExpression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Expression`1&lt;TDelegate&gt; extends System.Linq.Expressions.LambdaExpression" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression`1" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TDelegate" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Linq.Expressions.LambdaExpression</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TDelegate">Der Typ des Delegaten, der <see cref="T:System.Linq.Expressions.Expression`1" /> darstellt.</typeparam>
    <summary>Stellt einen stark typisierten lambda-Ausdruck als Datenstruktur in Form einer Ausdrucksbaumstruktur dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Lambda-Ausdruck zugewiesen wird, um eine Variable, ein Feld oder Parameter, dessen Typ <xref:System.Linq.Expressions.Expression%601>, gibt der Compiler-Anweisungen, um eine Ausdrucksbaumstruktur zu erstellen.  
  
> [!NOTE]
>  Eine Konvertierung von einer Lambda-Ausdruck eingeben `Expression<D>` (`Expression(Of D)` in Visual Basic) ist vorhanden, wenn eine Konvertierung vom Lambdaausdruck in einen Delegaten vom Typ `D` vorhanden ist. Allerdings kann die Konvertierung, z. B. fehl, wenn der Text des Lambda-Ausdrucks ein Block ist. Dies bedeutet, dass Delegaten und Ausdrucksbaumstrukturen in Bezug auf die Auflösung von funktionsüberladungen auf ähnliche Weise Verhalten.  
  
 Die Ausdrucksbaumstruktur ist eine Darstellung der Daten im Arbeitsspeicher des Lambda-Ausdrucks. Die Ausdrucksbaumstruktur wird die Struktur des Lambda-Ausdrucks, transparent und explizit. Sie können mit den Daten in der Ausdrucksbaumstruktur ebenso interagieren wie Sie eine beliebige andere Datenstruktur können.  
  
 Die Fähigkeit, Ausdrücke als Datenstrukturen zu behandeln kann APIs Benutzercode in einem Format zu erhalten, die überprüft, transformiert und auf benutzerdefinierte Weise verarbeitet werden können. Z. B. die [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Data Access-Implementierung dieser Funktion verwendet, um Ausdrucksbaumstrukturen in Transact-SQL-Anweisungen zu übersetzen, die von der Datenbank ausgewertet werden kann.  
  
 Viele Standardabfrageoperatoren, die definiert, der <xref:System.Linq.Queryable> Klasse haben einen oder mehrere Parameter vom Typ <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Expressions.Expression.NodeType%2A> von einer <xref:System.Linq.Expressions.Expression%601> ist <xref:System.Linq.Expressions.ExpressionType.Lambda>.  
  
 Verwenden der <xref:System.Linq.Expressions.Expression.Lambda%60%601%28System.Linq.Expressions.Expression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.ParameterExpression%7D%29> oder <xref:System.Linq.Expressions.Expression.Lambda%60%601%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.ParameterExpression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.Expression%601> Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Lambda-Ausdruck als ausführbarer Code in Form eines Delegaten und als Daten in Form einer Ausdrucksbaumstruktur darstellen. Außerdem wird veranschaulicht, wie die Ausdrucksbaumstruktur in ausführbaren Code mithilfe von wieder aktivieren die <xref:System.Linq.Expressions.Expression%601.Compile%2A> Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/CS/ExpressionT.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/VB/ExpressionT.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected override System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public TDelegate Compile ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TDelegate Compile() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Compile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Der Lambda-Ausdruck, der die Ausdrucksbaumstruktur in ausführbaren Code kompiliert und erzeugt ein Delegat, den Lambda-Ausdruck darstellt.</summary>
        <returns>Ein Delegat des Typs <paramref name="TDelegate" /> , die den kompilierten Lambda-Ausdruck, stellt die <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression%601.Compile%2A> -Methode erstellt einen Delegaten vom Typ `TDelegate` zur Laufzeit. Wenn der Delegat ausgeführt wird, hat Sie das Verhalten beschrieben, die von der Semantik des der <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Expressions.Expression%601.Compile%2A> Methode kann verwendet werden, um den Wert einer beliebigen Ausdrucksbaumstruktur abrufen. Erstellen Sie zunächst einen Lambda-Ausdruck, der der Ausdruck als Text mit weist die <xref:System.Linq.Expressions.Expression.Lambda%2A> Methode. Rufen Sie anschließend <xref:System.Linq.Expressions.Expression%601.Compile%2A> zum Abrufen eines Delegaten und Ausführen der Delegat, der den Wert des Ausdrucks abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Expressions.Expression%601.Compile%2A> wird verwendet, um eine Ausdrucksbaumstruktur ausgeführt wird.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionT#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/CS/ExpressionT.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionT#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/VB/ExpressionT.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public TDelegate Compile (bool preferInterpretation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TDelegate Compile(bool preferInterpretation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="preferInterpretation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="preferInterpretation"><see langword="true" />, um anzugeben, dass der Ausdruck in ein interpretiertes Format kompiliert werden muss, sofern verfügbar; andernfalls <see langword="false" />.</param>
        <summary>Kompiliert die Lambdaausdrücke, die von der Ausdrucksbaumstruktur als interpretierter oder kompilierter Code beschrieben werden, und erzeugt einen Delegaten, der den Lambdaausdruck darstellt.</summary>
        <returns>Ein Delegat, der den kompilierten Lambdaausdruck darstellt, der durch das <see cref="T:System.Linq.Expressions.Expression`1" />-Objekt beschrieben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public TDelegate Compile (System.Runtime.CompilerServices.DebugInfoGenerator debugInfoGenerator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TDelegate Compile(class System.Runtime.CompilerServices.DebugInfoGenerator debugInfoGenerator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="debugInfoGenerator" Type="System.Runtime.CompilerServices.DebugInfoGenerator" />
      </Parameters>
      <Docs>
        <param name="debugInfoGenerator">Debuggen von Informationen Generator Sequenzpunkte markieren und kommentieren lokale Variablen vom Compiler verwendet.</param>
        <summary>Erstellt einen Delegaten, der Lambda-Ausdruck darstellt.</summary>
        <returns>Ein Delegat, der die kompilierte Version des Lambda-Ausdrucks enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression&lt;TDelegate&gt; Update (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression`1&lt;!TDelegate&gt; Update(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> -Eigenschaft des Ergebnisses.</param>
        <param name="parameters">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> -Eigenschaft des Ergebnisses.</param>
        <summary>Erstellt einen neuen Ausdruck, der diesem ähnelt, verwendet jedoch die angegebenen untergeordneten Elemente. Wenn alle untergeordneten Elemente identisch sind, wird dieser Ausdruck zurückgegeben.</summary>
        <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
