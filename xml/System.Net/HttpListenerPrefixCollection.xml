<Type Name="HttpListenerPrefixCollection" FullName="System.Net.HttpListenerPrefixCollection">
  <TypeSignature Language="C#" Value="public class HttpListenerPrefixCollection : System.Collections.Generic.ICollection&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;string&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpListenerPrefixCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;string&gt;, class System.Collections.Generic.IEnumerable`1&lt;string&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerPrefixCollection" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt die Auflistung zum Speichern der Uniform Resource Identifier (URI)-Präfixe für <see cref="T:System.Net.HttpListener" /> Objekte.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.Prefixes%2A> -Eigenschaft gibt Instanzen dieser Auflistung zurück.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.HttpListener> und fügt benutzerdefinierte Präfixe für seine <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Add(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Eine <see cref="T:System.String" />, die die URI-Informationen identifiziert, die in eingehenden Anforderungen verglichen werden. Das Präfix muss mit einem Schrägstrich ("/") beendet werden.</param>
        <summary>Fügt der Sammlung ein Uniform Resource Identifier-Präfix (URI) hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt einen URI-Präfix auf den Satz von Präfixen, die von der zugeordneten verwalteten <xref:System.Net.HttpListener> Objekt. Beim Überprüfen des `uriPrefix` um sicherzustellen, dass es ist zulässig, Groß-/Kleinschreibung ignoriert wird.  
  
 Eine URI-Präfix-Zeichenfolge besteht aus einem Schema (http oder Https), einem Host, einem optionalen Port und einen optionalen Pfad, z. B. "`http://www.contoso.com:8080/customerData``/`". Das Präfix muss mit einem Schrägstrich ("/") beendet werden. Die <xref:System.Net.HttpListener> mit Präfix an, das einen angeforderten URI am ehesten erfüllt die Anforderung beantwortet. Mehrere <xref:System.Net.HttpListener> Objekte können nicht das gleiche Präfix hinzugefügt. Ein <xref:System.Net.HttpListenerException> Ausnahme wird ausgelöst, wenn ein <xref:System.Net.HttpListener> Fügt ein Präfix, das bereits verwenden.  
  
 Wenn ein Port angegeben ist, kann das Hostelement mit ersetzt "`*`" gibt an, dass die <xref:System.Net.HttpListener> akzeptiert Anforderungen an den Port gesendet werden, wenn der angeforderte URI nicht mit einem anderen Präfix übereinstimmt. Beispielsweise zum Empfangen von allen Anforderungen gesendet, an Port 8080, wenn der angeforderte URI nicht durch einen anderen behandelt <xref:System.Net.HttpListener>, ist das Präfix "`http://*:8080``/`". Auf ähnliche Weise angeben, dass die <xref:System.Net.HttpListener> akzeptiert alle Anforderungen an einen Port gesendet ersetzen Sie den Hostelement mit der "`+`"Character",`https://+:8080`/". Die "`*`"und"`+`" Zeichen können in Präfixe, die Pfade enthalten vorhanden sein.  
  
 Beginnend mit .NET 4.5.3 und Windows 10, werden Platzhalter Unterdomänen in URI-Präfixe, die vom verwalteten unterstützt ein <xref:System.Net.HttpListener> Objekt. Um eine Unterdomäne Platzhalter anzugeben, verwenden die "*" Zeichen als Teil der Hostname in URI-Präfix: z. B. `http://*.foo.com/`, und übergeben Sie das als Argument an die HttpListenerPrefixCollection.Add-Methode. Dies funktioniert unter .NET 4.5.3 und Windows 10; in früheren Versionen wäre dadurch generiert eine<xref:System.Net.HttpListenerException>  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.HttpListener> und fügt benutzerdefinierte Präfixe für seine <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriPrefix" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriPrefix" /> verwendet nicht das Schema „http://“ oder „https://“. Dies sind die einzigen für <see cref="T:System.Net.HttpListener" />-Objekte unterstützten Schemas.  
  
 - oder -   
  
 <paramref name="uriPrefix" /> ist kein ordnungsgemäß formatiertes URI-Präfix. Stellen Sie sicher, dass die Zeichenfolge mit einem "/" beendet wird.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Windows-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen. Diese Ausnahme wird ausgelöst, wenn bereits ein anderer <see cref="T:System.Net.HttpListener" /> das <paramref name="uriPrefix" />-Präfix hinzugefügt hat.</exception>
        <permission cref="T:System.Net.WebPermission">Um Netzwerkverbindungen zu akzeptieren. Zugeordnete Enumeration:<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Präfixe Uniform Resource Identifier (URI) aus der Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufrufen dieser Methode kann nicht gestartet werden die zugehörigen <xref:System.Net.HttpListener> ohne Hinzufügen von neuen Präfixe; Wenn Sie versuchen, zu diesem Zweck eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel entfernt alle Präfixe in einem <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Windows-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Contains(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Ein <see cref="T:System.String" /> , enthält das Präfix Uniform Resource Identifier (URI), um zu testen.</param>
        <summary>Gibt eine <see cref="T:System.Boolean" /> Wert, der angibt, ob das angegebene Präfix in der Auflistung enthalten ist.</summary>
        <returns>
          <see langword="true" />Wenn diese Auflistung die durch angegebene Präfix enthält <paramref name="uriPrefix" />ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das angegebene Präfix muss genau einen vorhandenen Wert entsprechen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob ein benutzerdefiniertes Präfix, in der Präfix-Auflistung, der enthalten ist eine <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriPrefix" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert den Inhalt einer <see cref="T:System.Net.HttpListenerPrefixCollection" /> in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss in der Lage, Zeichenfolgen enthalten und kann nicht mehrdimensional sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Eine dimensionalen <see cref="T:System.Array" /> , die die Uniform Resource Identifier (URI) Präfixzeichenfolgen in dieser Auflistung empfängt.</param>
        <param name="offset">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert den Inhalt einer <see cref="T:System.Net.HttpListenerPrefixCollection" /> in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss in der Lage, Zeichenfolgen enthalten und kann nicht mehrdimensional sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird kopiert, die Präfixe in einem <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />verfügt über mehr als eine Dimension aus.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Diese Sammlung enthält mehr Elemente als in speicherbare <paramref name="array" /> beginnenden <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="array" />Zeichenfolgenwerte können nicht gespeichert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (string[] array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(string[] array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.String[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.String[]" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Ein eindimensionales Zeichenfolgenarray, das die Uniform Resource Identifier (URI) Präfixzeichenfolgen in dieser Auflistung empfängt.</param>
        <param name="offset">Der nullbasierte Index im <c>Array</c> an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert den Inhalt einer <see cref="T:System.Net.HttpListenerPrefixCollection" /> auf das angegebene Zeichenfolgenarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss in der Lage, Zeichenfolgen enthalten und kann nicht mehrdimensional sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird kopiert, die Präfixe in einem <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />verfügt über mehr als eine Dimension aus.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Diese Sammlung enthält mehr Elemente als in speicherbare <paramref name="array" /> beginnenden <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Präfixen, die in der Auflistung ab.</summary>
        <value>Ein <see cref="T:System.Int32" /> , enthält die Anzahl von Präfixen, die in dieser Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt die Präfixe in einer Auflistung.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;string&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;string&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</summary>
        <returns>Ein Objekt, implementiert die <see cref="T:System.Collections.IEnumerator" /> Schnittstelle und ermöglicht den Zugriff auf die Zeichenfolgen in dieser Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das von dieser Methode zurückgegeben wird, wird anfänglich vor dem ersten Element in dieser Auflistung positioniert. Rufen Sie die <xref:System.Collections.IEnumerator.MoveNext%2A> -Methode auf, bevor Sie das erste Element zugreifen können. Um das Element an der aktuellen Position zuzugreifen, rufen die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft.  
  
 Ändern Sie die Auflistung während der Verwendung des Enumerators nicht. Wenn die Auflistung geändert wird, während eines Enumerators verwenden, Fehler beim Festlegen der Position durch Aufrufen von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> bewirkt, dass ein <xref:System.InvalidOperationException>.  
  
 Eine ausführliche Beschreibung von Enumeratoren, finden Sie in der Dokumentation für die <xref:System.Collections.IEnumerator> Klasse und die <xref:System.Collections.IEnumerable.GetEnumerator%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einer Auflistung. Beachten Sie, dass die Visual Basic- und C#-Beispiele bestimmte sprachanweisungen Durchlaufen der Auflistung anstatt durch Abrufen des Enumerators.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob der Zugriff auf die Auflistung schreibgeschützt ist.</summary>
        <value>Gibt immer <see langword="false" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die Auflistung synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen auffangen, die aus von anderen Threads vorgenommenen Änderungen ergeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Remove(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Ein <see cref="T:System.String" /> , enthält das URI-Präfix zu entfernen.</param>
        <summary>Entfernt den angegebenen Uniform Resource Identifier (URI) aus der Liste der Präfixe behandelt, indem die <see cref="T:System.Net.HttpListener" /> Objekt.</summary>
        <returns>
          <see langword="true" />Wenn die <paramref name="uriPrefix" /> wurde gefunden, der <see cref="T:System.Net.HttpListenerPrefixCollection" /> und entfernt wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `uriPrefix` ist nicht in der Auflistung, wird diese Methode keine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriPrefix" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Windows-Funktionsaufruf ist ein Fehler aufgetreten. Um die Ursache der Ausnahme zu bestimmen, überprüfen Sie die Ausnahme-Fehlercode.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</summary>
        <returns>Ein Objekt, implementiert die <see cref="T:System.Collections.IEnumerator" /> Schnittstelle und ermöglicht den Zugriff auf die Zeichenfolgen in dieser Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das von dieser Methode zurückgegeben wird, wird anfänglich vor dem ersten Element in dieser Auflistung positioniert. Rufen Sie die <xref:System.Collections.IEnumerator.MoveNext%2A> -Methode auf, bevor Sie das erste Element zugreifen können. Um das Element an der aktuellen Position zuzugreifen, rufen die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft.  
  
 Ändern Sie die Auflistung während der Verwendung des Enumerators nicht. Wenn die Auflistung geändert wird, während eines Enumerators verwenden, Fehler beim Festlegen der Position durch Aufrufen von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> bewirkt, dass ein <xref:System.InvalidOperationException>.  
  
 Eine ausführliche Beschreibung von Enumeratoren, finden Sie in der Dokumentation für die <xref:System.Collections.IEnumerator> Klasse und die <xref:System.Collections.IEnumerable.GetEnumerator%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
