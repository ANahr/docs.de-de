<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Bietet Zugriff auf eine Warteschlange auf einem Message Queuing-Server an.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Message Queuing-Technologie ermöglicht Anwendungen, die zu unterschiedlichen Zeiten ausgeführt werden, kommunizieren über heterogene Netzwerke und Systeme, die möglicherweise vorübergehend offline. Anwendungen senden, empfangen und Einsehen von Nachrichten aus Warteschlangen (Lesen ohne zu entfernen). Message Queuing ist eine optionale Komponente des [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] und Windows NT, und müssen separat installiert werden.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse ist ein Wrapper für Message Queuing. Es gibt mehrere Versionen der Message Queuing und die Nutzung der <xref:System.Messaging.MessageQueue> Klasse geringfügig anderes Verhalten führen kann, verwenden Sie je nach Betriebssystem. Informationen über bestimmte Funktionen jeder Version von Message Queuing finden Sie unter dem Thema "Neuheiten Message Queuing" im Plattform-SDK in MSDN.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse stellt einen Verweis auf eine Message Queuing-Warteschlange. Sie können einen Pfad im Angeben der <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor zur Verbindung mit einer vorhandenen Ressource ist, oder Sie können eine neue Warteschlange erstellen, auf dem Server. Bevor Sie aufrufen können <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, oder <xref:System.Messaging.MessageQueue.Receive%2A>, müssen Sie die neue Instanz der Zuordnen der <xref:System.Messaging.MessageQueue> -Klasse mit einer vorhandenen Warteschlange. An diesem Punkt können Sie ändern die Eigenschaften der Warteschlange wie z. B. <xref:System.Messaging.MessageQueue.Category%2A> und <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue>unterstützt zwei Arten von Nachrichtenabruf: synchrone und asynchrone. Die synchronen Methoden <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, dazu führen, dass Prozessthreads warten ein angegebenen Zeitintervalls für eine neue Nachricht in der Warteschlange eintreffen. Die asynchronen Methoden <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A>, ermöglichen die Hauptassembly der Anwendungsaufgaben in einem separaten Thread fortgesetzt, bis eine Nachricht in der Warteschlange eingeht. Diese Methoden funktionieren mithilfe von Rückrufobjekten und Zustandsobjekte zur Übermittlung von Informationen zwischen Threads.  
  
 Eine neue Instanz der beim Erstellen der <xref:System.Messaging.MessageQueue> -Klasse, erstellen Sie keine neue Message Queuing-Warteschlange. Stattdessen können Sie die <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, und <xref:System.Messaging.MessageQueue.Purge%2A> Methoden zum Verwalten von Warteschlangen auf dem Server.  
  
 Im Gegensatz zu <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> und <xref:System.Messaging.MessageQueue.Delete%28System.String%29> sind `static` Member, damit Sie sie aufrufen können, ohne dass erstellt eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse.  
  
 Sie können festlegen, die <xref:System.Messaging.MessageQueue> des Objekts <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft mit einem der drei Namen: der angezeigte Name der <xref:System.Messaging.MessageQueue.FormatName%2A>, oder die <xref:System.Messaging.MessageQueue.Label%2A>. Der Anzeigename, der von der Warteschlange definiert ist <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften ist <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> für eine öffentliche Warteschlange und <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> für eine private Warteschlange. Die <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft ermöglicht den Offlinezugriff auf Warteschlangen. Schließlich können Sie der Warteschlange <xref:System.Messaging.MessageQueue.Label%2A> -Eigenschaft zum Festlegen der Warteschlange <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Eine Liste der anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>, finden Sie unter der <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neuer <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Pfad benennen Syntax von Typen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Im folgenden Codebeispiel wird eine Nachricht an eine Warteschlange sendet und empfängt eine Nachricht aus einer Warteschlange mit einer anwendungsspezifischen Klasse mit dem Namen `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Nur die <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> Methode ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse. Nachdem die neue Instanz der Standardkonstruktor initialisiert wird, müssen Sie festlegen, dass der Instanz <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft vor der Verwendung der Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, erstellen Sie eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse, die nicht sofort an eine Warteschlange auf dem Message Queuing-Server verbunden ist. Vor der Verwendung dieser Instanz an, Sie müssen auch Verbinden mit einer vorhandenen Message Queuing-Warteschlange durch Festlegen der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft. Sie können alternativ Festlegen der <xref:System.Messaging.MessageQueue> einen Verweis auf die <xref:System.Messaging.MessageQueue.Create%28System.String%29> Rückgabewert der Methode, wodurch eine neue Message Queuing-Warteschlange.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor instanziiert eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse werden keine neue Message Queuing-Warteschlange erstellt.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.MessagePropertyFilter> Klasse. Die Filterwerte werden festgelegt, um `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Messaging.MessageQueue" /> Klasse, die die Message Queuing-Warteschlange unter dem angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die neue einbinden möchten <xref:System.Messaging.MessageQueue> Instanz mit einer bestimmten Message Queuing-Warteschlange für das kennen Sie den Pfad, den Formatnamen oder die Bezeichnung. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, müssen Sie festlegen der <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Eigenschaft `true` oder verwenden Sie den Konstruktor, der einen Lesezugriff Einschränkungsparameter übergibt.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor instanziiert eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse werden keine neue Message Queuing-Warteschlange erstellt. Verwenden Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax der `path` Parameter hängt vom Typ der Warteschlange für diese Verweise, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben, wie in der folgenden Tabelle gezeigt.  
  
|Verweis|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:`[ *Formatnamen* ]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:`[ *Bezeichnung* ]|`Label:`TheLabel|  
  
 Um offline zu arbeiten, müssen Sie die formatnamenssyntax nicht der pfadnamensyntax des Konstruktors verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller nicht verfügbar ist, zum Auflösen des Pfads in den Formatnamen ist.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>. Diese Werte basieren auf den Eigenschaften des Message Queuing-Warteschlange mit dem Pfad, der gemäß der `path` Parameter.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn Datenschutzebene für die Message Queuing-Warteschlange "Body"; andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert des Name-Eigenschaft für die Message Queuing-Warteschlange Computer.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.MessagePropertyFilter> Klasse.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn das Message Queuing-Objekt Journal-Einstellung aktiviert ist; andernfalls `false`.|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neuer <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Pfad benennen Syntax von Typen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft ist ungültig, möglicherweise weil er nicht festgelegt wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />, erfolgen kann "." für den lokalen Computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />exklusiven Zugriff auf die erste Anwendung zu gewähren, die auf die Warteschlange zugreift; andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der dem <see cref="T:System.Messaging.MessageQueue" /> Klasse, die die Message Queuing-Warteschlange unter dem angegebenen Pfad und mit der angegebenen Lesezugriff Einschränkung verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die neue einbinden möchten <xref:System.Messaging.MessageQueue> mit einer bestimmten Message Queuing-Warteschlange für das kennen Sie den Pfad, den Formatnamen oder die Bezeichnung. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, legen Sie die `sharedModeDenyReceive` Parameter `true`. Legen Sie andernfalls `sharedModeDenyReceive` auf `false` oder verwenden Sie den Konstruktor aus, die nur eine `path` Parameter.  
  
 Festlegen von `sharedModeDenyReceive` auf `true` wirkt sich auf alle Objekte, die die Message Queuing-Warteschlange, einschließlich von anderen Anwendungen zugreifen. Die Auswirkungen des Parameters sind nicht auf diese Anwendung beschränkt.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor erstellt eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse werden keine neue Message Queuing-Warteschlange erstellt. Verwenden Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax der `path` Parameter hängt vom Typ der Warteschlange.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie den Warteschlangenpfad beschreiben die Formatnamen oder die Bezeichnung einer Message Queuing-Warteschlange.  
  
|Verweis|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:`[ *Formatnamen* ]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:`[ *Bezeichnung* ]|`Label:`TheLabel|  
  
 Um offline zu arbeiten, müssen Sie die formatnamenssyntax, anstatt die Anzeigenamen-Syntax verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller (Active Directory auf dem befindet) nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 Wenn eine <xref:System.Messaging.MessageQueue> eine Warteschlange öffnet und die `sharedModeDenyReceive` Parameter festgelegt wird, um `true`, stellen alle <xref:System.Messaging.MessageQueue> , anschließend versucht, aus der Warteschlange gelesen generiert eine <xref:System.Messaging.MessageQueueException> wegen der freigabeverletzung. Ein <xref:System.Messaging.MessageQueueException> wird auch ausgelöst, wenn eine <xref:System.Messaging.MessageQueue> versucht, die auf die Warteschlange im exklusiven Modus während eine andere <xref:System.Messaging.MessageQueue> bereits nicht exklusiven Zugriff auf die Warteschlange verfügt.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>. Diese Werte basieren auf den Eigenschaften des Message Queuing-Warteschlange mit dem Pfad, der gemäß der `path` Parameter.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn Datenschutzebene für die Message Queuing-Warteschlange "Body"; andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert des Name-Eigenschaft für die Message Queuing-Warteschlange Computer.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.MessagePropertyFilter> Klasse.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Der Wert des `sharedModeDenyReceive`-Parameters.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn das Message Queuing-Objekt Journal-Einstellung aktiviert ist; andernfalls `false`.|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff legt den Pfad und sendet eine Nachricht an die Warteschlange.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft ist ungültig, möglicherweise weil er nicht festgelegt wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />, erfolgen kann "." für den lokalen Computer.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />, erfolgen kann "." für den lokalen Computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />exklusiven Zugriff auf die erste Anwendung zu gewähren, die auf die Warteschlange zugreift; andernfalls <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" />zum Erstellen und verwenden einen Verbindungscache. andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue> mit exklusivem Lesezugriff und Zwischenspeichern von Verbindungen aktiviert.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />, erfolgen kann "." für den lokalen Computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />exklusiven Zugriff auf die erste Anwendung zu gewähren, die auf die Warteschlange zugreift; andernfalls <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" />zum Erstellen und verwenden einen Verbindungscache. andernfalls <see langword="false" />.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der den Zugriffsmodus für die Warteschlange angibt.</summary>
        <value>Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardmodus für den Zugriff für eine Warteschlange ist `QueueAccessMode.SendAndReceive`, es sei denn, Sie nichts anderes angeben, wenn der Konstruktor aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Warteschlange nur authentifizierte Nachrichten akzeptiert werden.</summary>
        <value>
          <see langword="true" />Wenn die Warteschlange nur authentifizierte Nachrichten akzeptiert; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nachrichtenauthentifizierung bietet eine Möglichkeit, um die Nachrichtenintegrität sicherzustellen und zu überprüfen, ob Absender der Nachricht. Um eine Authentifizierung anzufordern, legt die sendende Anwendung der meldungsauthentifizierungsebene fest.  
  
 Bei Festlegung <xref:System.Messaging.MessageQueue.Authenticate%2A> auf `true`, sind Sie restriktive Zugriff auf die Warteschlange auf dem Server, nicht nur auf diese <xref:System.Messaging.MessageQueue> Instanz. Alle Clients, die für die gleichen Message Queuing-Warteschlange arbeiten sind betroffen.  
  
 Eine Warteschlange, die nur authentifizierte Nachrichten akzeptiert werden, weist eine nicht authentifizierte Nachricht zurück. Benachrichtigung Nachricht Ablehnung anfordern eine sendende Anwendung festgelegt werden kann die <xref:System.Messaging.Message.AcknowledgeType%2A> -Eigenschaft der Nachricht. Da keine andere Angabe Ablehnung der Nachricht vorhanden ist, kann die sendende Anwendung die Nachricht verlieren, es sei denn, Sie fordern, dass sie an die Dead Letter-Warteschlange gesendet werden.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Authenticate%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Basispriorität, die Message Queuing verwendet, um eine öffentliche Warteschlange Nachrichten über das Netzwerk weiterzuleiten.</summary>
        <value>Die einzelnen Basispriorität für alle Nachrichten, die an die Warteschlange (öffentlich) gesendet. Der Standardwert ist null (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Nachrichtenwarteschlange Basispriorität festlegt, wie eine Meldung an, die Warteschlange behandelt wird, während der Übertragung über das Netzwerk. Sie können festlegen, die <xref:System.Messaging.MessageQueue.BasePriority%2A> Eigenschaft, um eine höhere oder niedrigere Priorität auf alle Nachrichten an die angegebene Warteschlange weichen gesendet, um andere Warteschlangen zu gewähren. Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.BasePriority%2A> bezieht sich nicht auf die <xref:System.Messaging.Message.Priority%2A> Eigenschaft einer Nachricht, die die Reihenfolge angibt, in dem eine eingehende Nachricht in der Warteschlange platziert wird.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A>gilt nur für Öffentliche Warteschlangen, deren Pfade mit dem Formatnamen angegeben werden. Die Basispriorität einer privaten Warteschlange ist immer 0 (null).  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.BasePriority%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Basispriorität, die auf einen ungültigen Wert festgelegt wurde.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert einen asynchronen Lesevorgang, der ohne Timeout. Der Vorgang ist nicht abgeschlossen werden, bis eine Nachricht in der Warteschlange verfügbar wird.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar wird.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und Ihre Ereignisdelegaten zuordnen. <xref:System.Messaging.MessageQueue.BeginPeek%2A>initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen des Ergebnisses über die <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> um einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, die im Beispiel sieht die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um eine neue asynchrone Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, der einem angegebenen Timeout an. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und Ihre Ereignisdelegaten zuordnen. <xref:System.Messaging.MessageQueue.BeginPeek%2A>initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen des Ergebnisses über die <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeoutwert an. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang, mit dem Warteschlangenpfad ". \myQueue". Erstellt einen Ereignishandler `MyPeekCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten. <xref:System.Messaging.MessageQueue.BeginPeek%2A>wird mit einem Timeout von einer Minute aufgerufen, um den asynchronen Lesevorgang initiieren. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, oder das Timeout abläuft, die Nachricht abgerufen wird, wenn eine solche vorhanden ist und Text auf dem Bildschirm ausgegeben wird. Klicken Sie dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Lesevorgang mit demselben Timeout zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <param name="stateObject">Ein Zustandsobjekt angegeben, die von der Anwendung, die den asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, der einen angegebenen Timeout und eine angegebene Zustandsobjekt, das Informationen in der gesamten Lebensdauer des Vorgangs bereitstellt. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwenden Sie diese Überladung, um den Vorgang Informationen zuzuordnen, die in der gesamten Lebensdauer des Vorgangs beibehalten werden sollen. Der Ereignishandler kann auf diese Informationen zugreifen, durch einen Blick auf die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft von der <xref:System.IAsyncResult> , die dem Vorgang zugeordnet ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und Ihre Ereignisdelegaten zuordnen. <xref:System.Messaging.MessageQueue.BeginPeek%2A>initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen des Ergebnisses über die <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>Gibt eine <xref:System.IAsyncResult> , die den asynchronen Vorgang, der die Methode gestartet identifiziert. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeout und ein Zustandsobjekt. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren. Zur Veranschaulichung dieses Szenarios finden Sie im Beispielabschnitt.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang, mit dem Warteschlangenpfad ". \myQueue". Erstellt einen Ereignishandler `MyPeekCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten. <xref:System.Messaging.MessageQueue.BeginPeek%2A>wird mit einem Timeout von einer Minute aufgerufen. Jeder Aufruf von <xref:System.Messaging.MessageQueue.BeginPeek%2A> verfügt über eine eindeutige ganze Zahl zugeordnet, die diesem bestimmten Vorgang identifiziert. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, oder das Timeout abgelaufen ist, sofern vorhanden, wird die Nachricht abgerufen und Text und der spezifische ganzzahlige Bezeichner, die auf dem Bildschirm ausgegeben werden. Klicken Sie dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Lesevorgang mit demselben Timeout und die zugehörigen ganze Zahl von zuvor abgeschlossenen Vorgangs zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <param name="stateObject">Ein Zustandsobjekt angegeben, die von der Anwendung, die den asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Die <see cref="T:System.AsyncCallback" /> , die die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, der einen angegebenen Timeout und eine angegebene Zustandsobjekt, das Informationen in der gesamten Lebensdauer des Vorgangs bereitstellt. Diese Überladung wird mitgeteilt, in einem Rückruf die Identität des ereignishandlers für den Vorgang. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, oder wenn das angegebene Zeitintervall abgelaufen ist in der Warteschlange wird; die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginPeek%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>Gibt eine <xref:System.IAsyncResult> , die den asynchronen Vorgang, der die Methode gestartet identifiziert. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, und übergeben Sie: ein Timeoutwert von zehn Sekunden, eine eindeutige ganze Zahl, die der jeweiligen Nachricht; und eine neue Instanz der identifiziert <xref:System.AsyncCallback> , identifiziert den Ereignishandler `MyPeekCompleted`. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler sieht die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" /> , mit eine bestimmte Position in der Meldungswarteschlange verwaltet.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die nächste Nachricht in der Warteschlange eingesehen.</param>
        <param name="state">Ein Zustandsobjekt angegeben, die von der Anwendung, die den asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Die <see cref="T:System.AsyncCallback" /> , die die Benachrichtigung über den Abschluss des asynchronen Vorgangs empfängt.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, die über einen angegebenen Timeout verfügt und den angegebenen Cursor, eine Suchaktion und ein Statusobjekt verwendet. Das Zustandsobjekt, das zugeordneten Informationen während der Lebensdauer des Vorgangs. Diese Überladung wird mitgeteilt, in einem Rückruf die Identität des ereignishandlers für den Vorgang. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der in den Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist. Die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginPeek%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>Gibt eine <xref:System.IAsyncResult> , die den asynchronen Vorgang gestartet, indem die Methode identifiziert. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Einen anderen Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> wurde angegeben, für die <paramref name="action" /> Parameter.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert einen asynchronen Empfangsvorgang, die ohne Timeout. Der Vorgang ist nicht abgeschlossen werden, bis eine Nachricht in der Warteschlange verfügbar wird.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht aus der Warteschlange entfernt wurde.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A>initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verkettet asynchrone Anforderungen ist. Es wird davon ausgegangen, dass eine Warteschlange auf dem lokalen Computer mit dem Namen "MyQueue". Die `Main` Funktion beginnt den asynchronen Vorgang, der vom übernommen wird die `MyReceiveCompleted` Routine. `MyReceiveCompleted`die aktuelle Nachricht verarbeitet und beginnt einen neuen asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Im folgenden Codebeispiel wird die Warteschlange gestellt asynchroner Anforderungen. Der Aufruf von <xref:System.Messaging.MessageQueue.BeginReceive%2A> verwendet die <xref:System.IAsyncResult.AsyncWaitHandle%2A> im Rückgabewert. Die `Main` Routine wartet, bis alle asynchronen Vorgänge abgeschlossen werden, vor dem Beenden.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <summary>Initiiert einen asynchronen Empfangsvorgang, die einem angegebenen Timeout. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A>initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeoutwert an. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Empfangsvorgang. Das Codebeispiel erstellt einen Ereignishandler `MyReceiveCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventhandlerdelegaten. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, und übergeben Sie einen Timeoutwert von zehn Sekunden. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> Parameter ist ungültig, möglicherweise weil es sich um eine negative Zahl darstellt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <param name="stateObject">Ein Zustandsobjekt angegeben, die von der Anwendung, die den asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert einen asynchronen Empfangsvorgang, bei dem ein angegebenes Timeout und eine angegebene Zustandsobjekt, das Informationen in der gesamten Lebensdauer des Vorgangs bereitstellt. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwenden Sie diese Überladung, um den Vorgang Informationen zuzuordnen, die in der gesamten Lebensdauer des Vorgangs beibehalten werden sollen. Der Ereignishandler kann diese Informationen erkennen, durch einen Blick auf die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft von der <xref:System.IAsyncResult> , die dem Vorgang zugeordnet ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A>initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeout und ein Zustandsobjekt. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Empfangsvorgang. Das Codebeispiel erstellt einen Ereignishandler `MyReceiveCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventhandlerdelegaten. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, und übergeben Sie einen Timeoutwert von zehn Sekunden und eine eindeutige ganze Zahl, die die jeweiligen Nachricht identifiziert. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <param name="stateObject">Ein Zustandsobjekt angegeben, die von der Anwendung, die den asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Die <see cref="T:System.AsyncCallback" /> , die die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Empfangsvorgang, bei dem ein angegebenes Timeout und eine angegebene Zustandsobjekt, das Informationen in der gesamten Lebensdauer des Vorgangs bereitstellt. Diese Überladung wird mitgeteilt, in einem Rückruf die Identität des ereignishandlers für den Vorgang. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, oder wenn das angegebene Zeitintervall abgelaufen ist in der Warteschlange wird; die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginReceive%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A>initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Empfangsvorgang. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, und übergeben Sie: ein Timeoutwert von zehn Sekunden, eine eindeutige ganze Zahl, die der jeweiligen Nachricht; und eine neue Instanz der identifiziert <xref:System.AsyncCallback> , identifiziert den Ereignishandler `MyReceiveCompleted`. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der das Zeitintervall warten, bis eine Nachricht auf das Freiwerden angibt.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" /> , mit eine bestimmte Position in der Meldungswarteschlange verwaltet.</param>
        <param name="state">Ein Zustandsobjekt angegeben, die von der Anwendung, die den asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Die <see cref="T:System.AsyncCallback" /> , die die Benachrichtigung über den Abschluss des asynchronen Vorgangs empfängt.</param>
        <summary>Initiiert einen asynchronen Empfangsvorgang, die ein angegebenen Timeout und verwendet den angegebenen Cursor und ein Statusobjekt. Das Zustandsobjekt, das zugeordneten Informationen während der Lebensdauer des Vorgangs. Diese Überladung wird mitgeteilt, in einem Rückruf die Identität des ereignishandlers für den Vorgang. Der Vorgang ist nicht abgeschlossen werden, bis entweder eine Nachricht in der Warteschlange verfügbar wird oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.IAsyncResult" /> , die die bereitgestellte asynchrone Anforderung identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, oder wenn das angegebene Zeitintervall abgelaufen ist in der Warteschlange wird; die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginReceive%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A>initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die <see cref="T:System.Messaging.MessageQueue" /> gelesen werden können.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden ist und die Anwendung aus, wie Sie dies lesen kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A>Gibt an, ob die Anwendung kann zum Einsehen oder Empfangen von Nachrichten aus der Warteschlange. Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `true`, <xref:System.Messaging.MessageQueue> können empfangen und Einsehen von Nachrichten aus der Warteschlange. Andernfalls ist es nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A>ist `false` Wenn eine Warteschlange bereits mit exklusivem Lesezugriff geöffnet ist (oder geöffnet, und dies nicht exklusiven Zugriff ist <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert), oder die Anwendung nicht über ausreichende Berechtigungen für den Zugriff darauf besitzt. Wenn die Anwendung versucht, das Lesen aus einer Warteschlange beim <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, Zugriff verweigert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CanRead%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die <see cref="T:System.Messaging.MessageQueue" /> geschrieben werden kann.</summary>
        <value>
          <see langword="true" />Wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden ist und die Anwendung das CSV schreiben kann; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>Gibt an, ob die Anwendung Nachrichten an die Warteschlange senden kann. Wenn <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `true`, <xref:System.Messaging.MessageQueue> können Nachrichten an die Warteschlange senden. Andernfalls ist es nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>ist `false` , wenn eine Warteschlange bereits mit exklusivem Schreibzugriff geöffnet wurde (oder geöffnet, und dies nicht exklusiven Zugriff ist <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert), oder die Anwendung nicht über ausreichende Berechtigungen für den Zugriff darauf besitzt. Wenn die Anwendung versucht, die an eine Warteschlange schreiben beim <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `false`, der Zugriff wurde verweigert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CanWrite%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Kategorie der Warteschlange.</summary>
        <value>Ein <see cref="T:System.Guid" /> , das die Kategorie der Warteschlange (Message Queuing-Typenbezeichner), dem eine Anwendung ihre Warteschlangen kategorisieren kann darstellt. Die Standardeinstellung ist <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kategorie der Warteschlange kann eine Anwendung ihre Warteschlangen kategorisieren. Beispielsweise können Sie alle Abrechnung Warteschlangen in einer Kategorie und alle Reihenfolge Warteschlangen in einem anderen platzieren.  
  
 Die <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft ermöglicht den Zugriff auf die Message Queuing-Typ-ID-Eigenschaft (die Lese-/Schreibzugriff aufweist), über die **Warteschlangeneigenschaften** Dialogfeld in der Computerverwaltungskonsole. Sie können eine neue Kategorie definieren. Sie können zwar <xref:System.Guid.NewGuid%2A> Kategorie erstellen, die auf allen eindeutig ist <xref:System.Guid> Werte, die Aktion ist nicht erforderlich. Der Kategoriewert muss nur aus anderen Kategorien, die nicht von allen anderen unterscheiden <xref:System.Guid> Werte. Sie können z. B. {00000000-0000-0000-0000-000000000001} zuweisen, als die <xref:System.Messaging.MessageQueue.Category%2A> für eine Gruppe von Warteschlangen und {00000000-0000-0000-0000-000000000002} als die <xref:System.Messaging.MessageQueue.Category%2A> für eine andere Gruppe.  
  
 Es ist nicht notwendig, legen Sie die <xref:System.Messaging.MessageQueue.Category%2A>. Der Wert kann `null` sein.  
  
 Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Kategorie der Warteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Verbindungscache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, die im Cache gespeicherten Formatnamen entfernt, und Handles geöffnet und im Cache gespeichert, geschlossen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> aufgerufen.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alle von belegten Ressourcen freigegeben werden, die <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A>Gibt alle zugeordneten Ressourcen frei eine <xref:System.Messaging.MessageQueue>, einschließlich der freigegebene Ressourcen bei Bedarf. Das System automatisch wieder zugewiesen diese Ressourcen stehen noch zur Verfügung, z. B. beim Aufrufen der <xref:System.Messaging.MessageQueue.Send%28System.Object%29> Methode, wie im folgenden C#-Code.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Beim Aufruf <xref:System.Messaging.MessageQueue.Close%2A>, dass alle <xref:System.Messaging.MessageQueue> Eigenschaften, die Message Queuing-Warteschlange direkt zugreifen, werden gelöscht. Die <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, und <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> alle unverändert beibehalten wurden.  
  
 <xref:System.Messaging.MessageQueue.Close%2A>nicht immer die schreibgeschützte frei und Schreibhandles an eine Warteschlange, da sie gemeinsam genutzt werden können. Sie können die folgenden Schritte aus, um sicherzustellen, dass wie <xref:System.Messaging.MessageQueue.Close%2A> der Lese- und Schreibhandles an eine Warteschlange freigegeben:  
  
-   Erstellen der <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff. Rufen Sie hierzu die <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> oder <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor, und legen die `sharedModeDenyReceive` Parameter `true`.  
  
-   Erstellen der <xref:System.Messaging.MessageQueue> mit Zwischenspeichern Verbindungen deaktiviert. Rufen Sie hierzu die <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor, und legen die `enableConnectionCache` Parameter `false`.  
  
-   Deaktivieren Sie das Zwischenspeichern Verbindungen. Legen Sie hierzu die <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> Eigenschaft `false`.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Close%2A> für eine Warteschlange, bevor Sie die Warteschlange auf dem Message Queuing-Server löschen. Andernfalls konnte an die Warteschlange gesendete Nachrichten Ausnahmen auslösen oder in die Dead Letter-Warteschlange angezeigt.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing-Warteschlange geschlossen.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <summary>Erstellt eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueue" /> , das die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine nicht transaktionale Message Queuing-Warteschlange zu erstellen.  
  
 So erstellen eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse in der Anwendung und binden es an eine vorhandene Warteschlange, verwenden Sie die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor. Rufen Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange für diese Verweise, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die öffentliche und private Warteschlangen erstellt. Sie sendet eine Nachricht an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist <see langword="null" /> oder ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der angegebene Pfad ist bereits eine Warteschlange vorhanden.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <param name="transactional">
          <see langword="true" />So erstellen Sie eine Transaktionswarteschlange; <see langword="false" /> zum Erstellen einer nicht transaktionalen Warteschlange.</param>
        <summary>Erstellt eine transaktionale oder nicht transaktional Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueue" /> , das die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Überladung verwenden, um eine Transaktionswarteschlange in Message Queuing zu erstellen. Sie können eine nicht transaktionale Warteschlange erstellen, durch Festlegen der `transactional` Parameter `false` oder durch die andere Überladung von Aufrufen <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 So erstellen eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse in der Anwendung und binden es an eine vorhandene Warteschlange, verwenden Sie die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor. Rufen Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange für diese Verweise, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird öffentliche und private transaktionale Warteschlangen erstellt. Sie sendet eine Nachricht an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist <see langword="null" /> oder ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der angegebene Pfad ist bereits eine Warteschlange vorhanden.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Messaging.Cursor" /> für die aktuelle Nachrichtenwarteschlange.</summary>
        <returns>Ein neues <see cref="T:System.Messaging.Cursor" /> für die aktuelle Nachrichtenwarteschlange. Dieser Cursor wird verwendet, um eine bestimmte Position in der Warteschlange beizubehalten, beim Lesen von Nachrichten in der Warteschlange.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Uhrzeit und Datum, die in Message Queuing-Warteschlange erstellt wurde.</summary>
        <value>Ein <see cref="T:System.DateTime" /> , darstellt, das Datum und die Uhrzeit, an dem die Warteschlange erstellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A>bezieht sich auf die Warteschlange auf dem Message Queuing-Server nicht die <xref:System.Messaging.MessageQueue> Instanz.  
  
 Wenn die Warteschlange vorhanden ist, stellt diese Eigenschaft den Zeitpunkt der Erstellung die Warteschlange angepasst an die lokale Zeit des Servers, auf dem die Warteschlange vorhanden ist, den dar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CreateTime%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ermittelt oder definiert die Nachricht Eigenschaftswerte an Standardeinstellung verwendet werden, wenn die Anwendung Nachrichten an die Warteschlange sendet.</summary>
        <value>Ein <see cref="T:System.Messaging.DefaultPropertiesToSend" /> , enthält die Message Queuing-Nachricht Standardeigenschaftswerte verwendet, wenn die Anwendung Objekte außer sendet <see cref="T:System.Messaging.Message" /> Instanzen an die Warteschlange.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Objekt, das nicht vom Typ senden <xref:System.Messaging.Message> an die Warteschlange die <xref:System.Messaging.MessageQueue> fügt das Objekt in eine Message Queuing-Nachricht. Zu diesem Zeitpunkt wird die <xref:System.Messaging.MessageQueue> gilt für die Nachricht die Eigenschaftswerte, die Sie, in angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft. Umgekehrt, wenn Sie senden eine <xref:System.Messaging.Message> an die Warteschlange diese Eigenschaften sind bereits für die Instanz angegebenen selbst, also <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> wird ignoriert, die <xref:System.Messaging.Message>.  
  
 Obwohl Sie die Eigenschaften durch Festlegen der <xref:System.Messaging.MessageQueue> -Objekt, das <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> bezieht sich auf die Eigenschaften der Nachrichten, die an die Warteschlange nicht die Warteschlange selbst gesendet werden.  
  
 In der folgenden Tabelle werden die Standardwerte für die Eigenschaften angezeigt.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Null (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Leere Zeichenfolge ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet die Priorität einer Nachricht, um Standardeigenschaften zum Senden der Meldung zu bestimmen.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Standardeigenschaften konnten nicht für die Warteschlange festgelegt werden, da eine der Eigenschaften nicht gültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange gelöscht werden soll.</param>
        <summary>Löscht eine Warteschlange auf einem Message Queuing-Server an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben.  
  
|Verweis|Syntax|  
|---------------|------------|  
|Formatname|FormatName: [ *Formatnamen* ]|  
|Bezeichnung|Bezeichnung: [ *Bezeichnung* ]|  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing-Warteschlange löscht, falls vorhanden.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Parameter ist <see langword="null" /> oder ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Syntax für die <paramref name="path" /> -Parameter ist ungültig.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob dies <see cref="T:System.Messaging.MessageQueue" /> hat exklusiven Zugriff zum Empfangen von Nachrichten vom Message Queuing-Warteschlange.</summary>
        <value>
          <see langword="true" />Wenn diese <see cref="T:System.Messaging.MessageQueue" /> exklusive Rechte zum Empfangen von Nachrichten aus der Warteschlange hat, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A>Gibt an, die im freigegebenen Modus, der auf die verwiesen wird von dieser Warteschlange <xref:System.Messaging.MessageQueue>. Legen Sie <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> auf `true` um anzugeben, dass nur diese <xref:System.Messaging.MessageQueue> zum Einsehen oder Empfangen von Nachrichten aus der Warteschlange mit dem angegebenen Zugriff haben sollten <xref:System.Messaging.MessageQueue.Path%2A>. Wenn ein anderer <xref:System.Messaging.MessageQueue> oder eine andere Anwendung die gleichen Warteschlangenressource dieser Instanz zugeordnet ist oder Anwendung zum Einsehen oder Empfangen von Nachrichten nicht möglich, kann es jedoch immer noch senden sie.  
  
 Wenn <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> ist `false`, die Warteschlange für mehrere Anwendungen zum Senden, einsehen oder Empfangen von Nachrichten verfügbar ist.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Messaging.MessageQueue" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> auf, wenn Sie <xref:System.Messaging.MessageQueue> nicht mehr benötigen. Die <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>-Methode bewirkt, dass <xref:System.Messaging.MessageQueue> nicht mehr verwendet werden kann. Nach dem Aufruf <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, müssen Sie alle Verweise auf Freigeben der <xref:System.Messaging.MessageQueue> , damit der belegte Arbeitsspeicher von der Garbagecollection wieder zugänglich gemacht werden kann.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> , bevor Sie den letzten Verweis auf Freigeben der <xref:System.Messaging.MessageQueue>. Andernfalls, die Ressourcen der <xref:System.Messaging.MessageQueue> ist mit bleiben reserviert, bis die Garbage Collection-Aufrufe der <xref:System.Messaging.MessageQueue> Destruktor des Objekts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob ein Cache von Verbindungen von der Anwendung hinweg gewährleistet werden soll.</summary>
        <value>
          <see langword="true" />zum Erstellen und verwenden einen Verbindungscache. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Verbindungscache ist eine Liste von Verweisen auf Strukturen, die enthalten lesen oder Schreiben von Handles in Warteschlangen. Wenn <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> ist `true`, <xref:System.Messaging.MessageQueue> Grunde Handles aus dem Cache verwendet, bei jedem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, oder <xref:System.Messaging.MessageQueue.Receive%2A>, anstatt neue Handles zu öffnen. Dies kann die Leistung verbessern. Verwenden einen Verbindungscache auch isoliert die <xref:System.Messaging.MessageQueue> um eventuelle Änderungen in der Topologie des Netzwerks.  
  
 Wenn Sie eine neue Verbindung mit einer Warteschlange erstellen, wenn es sich bei der Verbindungscache voll ist, wird die <xref:System.Messaging.MessageQueue> überschreibt die zuletzt am wenigsten Struktur mit der neuen Verbindung. Sie können den Cache löschen, entweder durch Aufrufen von <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, z. B. wenn die Formatnamen, der Sie arbeiten mit Warteschlangen geändert haben, damit das vorherige lesen und Schreiben von Handles sind nicht mehr gültig.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob die Warteschlange nur nicht privaten (nicht verschlüsselt) Nachrichten akzeptiert werden.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionRequired" />-Werte. Die Standardeinstellung ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie, dass die Verschlüsselung erforderlich, damit die Nachrichten an eine Warteschlange gesendet wird angeben, werden nur die Nachrichtentexte verschlüsselt. Die anderen Elemente (z. B. die <xref:System.Messaging.Message.Label%2A> und <xref:System.Messaging.Message.SenderId%2A> Eigenschaften) kann nicht verschlüsselt werden.  
  
 Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Verschlüsseln einer Nachricht wird die Nachricht in der privaten. Sie können angeben, gilt der Warteschlange werden `None`, `Body`, oder `Optional` durch Festlegen der <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> Eigenschaft entsprechend. Die <xref:System.Messaging.Message.UseEncryption%2A> Einstellung der Nachricht muss mit der Encryption-Anforderung der Warteschlange entsprechen. Wenn die Nachricht nicht verschlüsselt, aber die Warteschlange gibt `Body`, oder wenn die Nachricht verschlüsselt ist, aber die Warteschlange gibt `None`, die Nachricht wird von der Warteschlange abgelehnt. Wenn die sendende Anwendung eine negative Bestätigungsnachricht in diesem Ereignis anfordert, gibt das Message Queuing Ablehnung die Nachricht an die sendende Anwendung an. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaft `true`, eine Nachricht, die Verschlüsselung ein Fehler auftritt, wird an die Dead Letter-Warteschlange gesendet. Andernfalls ist die Nachricht verloren gehen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die <see cref="T:System.IAsyncResult" /> , das den asynchronen Lesevorgang beendet identifiziert und über das Endergebnis abgerufen.</param>
        <summary>Schließt den angegebenen asynchronen Lesevorgang.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> den abgeschlossenen asynchronen Vorgang zugeordnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> schließt den Vorgang nach der Initiierung der <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufrufen. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> sieht die Nachricht.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>festlegbaren ein Timeout, wodurch die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine in der Warteschlange Meldung. Wenn ein Timeout auftritt, ohne dass eine Meldung in der Warteschlange, ein nachfolgender Aufruf von eingehenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> löst eine Ausnahme aus.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>wird verwendet, um die Nachricht zu lesen, die aufgrund der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie zum Einsehen von Nachrichten asynchron zu fortfahren möchten, können Sie erneut aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> nach dem Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> um einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, die im Beispiel sieht die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um eine neue asynchrone Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax der <paramref name="asyncResult" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die <see cref="T:System.IAsyncResult" /> , identifiziert der asynchrone Vorgang mit Latenz beendet wird und über das Endergebnis abgerufen.</param>
        <summary>Schließt den angegebenen asynchronen Empfangsvorgang.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> den abgeschlossenen asynchronen Vorgang zugeordnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> schließt den Vorgang nach der Initiierung der <xref:System.Messaging.MessageQueue.BeginReceive%2A> aufrufen. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> empfängt die Nachricht.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>festlegbaren ein Timeout, wodurch die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine in der Warteschlange Meldung. Wenn ein Timeout auftritt, ohne dass eine Meldung in der Warteschlange, ein nachfolgender Aufruf von eingehenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> löst eine Ausnahme aus.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>Dient zum Lesen (Entfernen Sie aus der Warteschlange) der Nachrichteninhalts, die aufgrund der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie weiterhin Nachrichten asynchron empfangen möchten, können Sie erneut aufrufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nach dem Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verkettet asynchrone Anforderungen ist. Es wird davon ausgegangen, dass eine Warteschlange auf dem lokalen Computer mit dem Namen "MyQueue". Die `Main` Funktion beginnt den asynchronen Vorgang, der vom übernommen wird die `MyReceiveCompleted` Routine. `MyReceiveCompleted`die aktuelle Nachricht verarbeitet und beginnt einen neuen asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax der <paramref name="asyncResult" /> -Parameter ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange zu suchen.</param>
        <summary>Bestimmt, ob eine Message Queuing-Warteschlange unter dem angegebenen Pfad vorhanden ist.</summary>
        <returns>
          <see langword="true" />Wenn eine Warteschlange mit dem angegebenen Pfad vorhanden ist. andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Methode bestimmt, ob eine Message Queuing-Warteschlange in einem angegebenen Pfad vorhanden ist. Keine Methode ist vorhanden, um zu bestimmen, ob eine Warteschlange mit einem angegebenen Formatnamen vorhanden ist. Weitere Informationen zu den formatnamenssyntax und andere Syntaxformen, finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>ist ein teurer Vorgang. Verwenden sie nur, wenn es in der Anwendung erforderlich ist.  
  
> [!NOTE]
>  Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Methode unterstützt nicht die <xref:System.Messaging.MessageQueue.FormatName%2A> Präfix.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>kann nicht aufgerufen werden, um das Vorhandensein einer privaten Remotewarteschlange zu überprüfen.  
  
 Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben.  
  
|Verweis|Syntax|  
|---------------|------------|  
|Bezeichnung|Bezeichnung: [ `label` ]|  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob eine Message Queuing-Warteschlange vorhanden ist, und klicken Sie dann gelöscht.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" /> Syntax ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.  
  
 - oder -   
  
 Die <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> Methode auf eine private Remotewarteschlange aufgerufen wird</exception>
        <exception cref="T:System.InvalidOperationException">Die Anwendung verwendet die formatnamenssyntax, bei der Überprüfung der Warteschlange vorhanden ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Namen der Warteschlange, den zum Zeitpunkt der Erstellung der Warteschlange Message Queuing generiert werden.</summary>
        <value>Der Name für die Warteschlange, die im Netzwerk eindeutig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft enthält den Formatnamen der Warteschlange. Message Queuing verwendet den Formatnamen zum Identifizieren der Warteschlange zu öffnen und wie Sie darauf zugreifen. Im Gegensatz zu einer Warteschlange Merkmale ist der Formatnamen keine Message Queuing-Warteschlange Anwendungseigenschaft, sodass Sie über den Message Queuing-Verwaltungstool auf zugreifen zu können. Der Formatnamen ist einfach ein eindeutiger Name für die Warteschlange, die Message Queuing generiert, beim Erstellen der Warteschlange oder die Anwendung später erneut generiert wird.  
  
 Wenn Sie einen Pfad mithilfe der pfadnamensyntax angeben (z. B. `myComputer\myQueue`) statt der formatnamenssyntax beim Lesen oder in die Warteschlange schreiben, die dem primären Domänencontroller (das Active Directory verwendet) übersetzt die <xref:System.Messaging.MessageQueue.Path%2A> in der zugeordneten <xref:System.Messaging.MessageQueue.FormatName%2A> vor dem Zugriff auf die Warteschlange. Wenn Ihre Anwendung im Offlinemodus ist, müssen Sie die formatnamenssyntax verwenden; Andernfalls wird der primäre Domänencontroller zum Durchführen der Übersetzung Pfad nicht verfügbar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> ist nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Abrufen oder festlegen den Formatierer, der zum Serialisieren eines Objekts in oder Deserialisieren eines Objekts aus dem Textteil einer Nachricht gelesen oder in die Warteschlange geschrieben.</summary>
        <value>Die <see cref="T:System.Messaging.IMessageFormatter" /> , erzeugt einen Datenstrom zum Schreiben oder Lesen aus dem Nachrichtentext. Die Standardeinstellung ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft enthält eine Instanz eines Objekts Formatierer, der Nachrichten transformiert werden, wenn die Anwendung liest oder schreibt in die Warteschlange.  
  
 Wenn die Anwendung eine Nachricht an die Warteschlange sendet, wird das Formatierungsprogramm serialisiert das Objekt in einen Stream und fügt es in den Nachrichtentext. Beim Lesen aus einer Warteschlange deserialisiert der Formatierer die Nachrichtendaten in das <xref:System.Messaging.Message.Body%2A> Eigenschaft von einem <xref:System.Messaging.Message>.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher ist es nicht notwendig, dass das gleiche Objekt, das auf dem Absender und Empfänger geben Sie bei Verwendung dieses Format ist. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> Serialisieren der Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 <xref:System.Messaging.BinaryMessageFormatter>und <xref:System.Messaging.ActiveXMessageFormatter> ermöglichen einen höheren Durchsatz als die <xref:System.Messaging.XmlMessageFormatter>. Die <xref:System.Messaging.ActiveXMessageFormatter> ermöglicht die Interoperabilität mit Visual Basic 6.0-Message Queuing-Anwendungen.  
  
 Wenn die Anwendung Nachrichten an die Warteschlange sendet die <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> gilt nur für diese Nachrichten, die die Standard-Nachrichteneigenschaften verwenden <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Wenn Sie senden eine <xref:System.Messaging.Message> in die Warteschlange, Message Queuing verwendet der Formatierer, der definiert, der <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> Eigenschaft, um stattdessen den Text zu serialisieren.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse verwendet immer eine <xref:System.Messaging.Message> empfangen und Einsehen einer Nachricht aus der Warteschlange. Die Nachricht deserialisiert wird, mithilfe der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle Nachrichten, die in der Warteschlange befinden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Messaging.Message" /> , die alle Nachrichten in der Warteschlange, in der gleichen Reihenfolge darstellt, wie sie in der Message Queuing-Warteschlange angezeigt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>Gibt einen statischen Snapshot der Nachrichten in der Warteschlange, die keine dynamischen Links zu diesen Nachrichten zurück. Das Array können Sie aus diesem Grund Ändern der Nachrichten in der Warteschlange. Wenn Sie in Echtzeit, dynamische Interaktion mit der Warteschlange (z. B. die Fähigkeit, Nachrichten zu löschen) möchten, rufen Sie die <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Methode, die eine dynamische Liste der Nachrichten in der Warteschlange zurückgibt.  
  
 Da <xref:System.Messaging.MessageQueue.GetAllMessages%2A> gibt eine Kopie der Nachrichten in der Warteschlange zum Zeitpunkt die Methode aufgerufen wurde, wird das Array reflektiert keinen neuen Nachrichten, die in der Warteschlange ankommen oder Nachrichten, die aus der Warteschlange entfernt werden.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>Ruft nur die Eigenschaften, die nicht herausgefiltert, durch die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Listet die Nachrichten in einer Warteschlange. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />Stattdessen sollte verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> , der eine dynamische Verbindung mit der Nachrichten in der Warteschlange bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers mit der Warteschlange, ohne die zwei führenden umgekehrten Schrägstriche (\\\\).</param>
        <summary>Ruft den Bezeichner des Computers, auf dem die Warteschlange verwiesen, von diesem wird <see cref="T:System.Messaging.MessageQueue" /> befindet.</summary>
        <returns>Ein <see cref="T:System.Guid" /> , die einen eindeutigen Bezeichner für den Computer, auf dem sich die Warteschlange befindet, darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie einen Computer Bezeichner für zwei Zwecke, u. a.: das Computerjournal lesen und Festlegen von Sicherheitszertifikaten. Allerdings können Sie nicht aufrufen <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> für einen Remotecomputer, wenn Sie offline arbeiten, da die Anwendung den Zugriff auf den Verzeichnisdienst auf dem Domänencontroller verfügen muss.  
  
 Der Computer-ID (oder das Computer-ID) ist eine <xref:System.Guid> , die Message Queuing erstellt, wenn ein Computer für das Unternehmen hinzugefügt wird. Message Queuing kombiniert den Bezeichner für den Computer mit der `Machine` und `Journal` Schlüsselwörter für das Computerjournal Formatnamen, erstellen Sie mit der Syntax `Machine=<computeridentifier>;Journal`. Das Computerjournal, auch bekannt als der Journalwarteschlange ist eine Systemwarteschlange, die speichert Kopien der Anwendung generierte Instanznachrichten an, wenn die <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> Eigenschaft ist `true`.  
  
 Diese Syntax für die Erfassung ist nur gültig, wenn den Formatnamen der Warteschlange zu erstellen. Ist der pfadnamensyntax `MachineName` \\ `Journal$`.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> aufgerufen.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Bezeichner für den Computer konnte nicht, möglicherweise abgerufen werden, da der Verzeichnisdienst nicht verfügbar ist; beispielsweise, wenn Sie offline arbeiten.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumeratorobjekt für alle Nachrichten in der Warteschlange an. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />Stattdessen sollte verwendet werden.</summary>
        <returns>Die <see cref="T:System.Messaging.MessageEnumerator" /> halten die Nachrichten, die in der Warteschlange enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>erstellt eine dynamische Liste aller Nachrichten in einer Warteschlange. Sie können aus der Warteschlange entfernt die Nachricht an der aktuellen Position des Enumerators durch den Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zurückgibt.  
  
 Da der Cursor die dynamische Liste von Nachrichten in der Warteschlange zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an die Nachrichten in der Warteschlange wieder, ist die Meldung außerhalb der aktuellen Cursorposition bis. Der Enumerator kann z. B. automatisch ein niedrigerer Priorität-Nachricht, die außerhalb der aktuellen Cursorposition eingefügt, jedoch keine höhere Priorität-Nachricht, die vor dieser Position eingefügt zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>.  
  
 Die Reihenfolge der Nachrichten in der Enumeration widerspiegelt deren Reihenfolge in der Warteschlange, damit Nachrichten höherer Priorität vor diejenigen niedrigerer Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange statt einer dynamischen Verbindung, die sie verwenden möchten, rufen Sie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Diese Methode gibt ein Array von <xref:System.Messaging.Message> Objekte, die die Nachrichten zu dem Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Liste von Nachrichten in einer Warteschlange ruft und zählt alle Meldungen mit der <xref:System.Messaging.Message.Priority%2A> -Eigenschaftensatz auf <xref:System.Messaging.MessagePriority?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumeratorobjekt für alle Nachrichten in der Warteschlange an.</summary>
        <returns>Die <see cref="T:System.Messaging.MessageEnumerator" /> halten die Nachrichten, die in der Warteschlange enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>erstellt eine dynamische Liste aller Nachrichten in einer Warteschlange. Sie können aus der Warteschlange entfernt die Nachricht an der aktuellen Position des Enumerators durch den Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> zurückgibt.  
  
 Da der Cursor die dynamische Liste von Nachrichten in der Warteschlange zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an die Nachrichten in der Warteschlange wieder, ist die Meldung außerhalb der aktuellen Cursorposition bis. Der Enumerator kann z. B. automatisch ein niedrigerer Priorität-Nachricht, die außerhalb der aktuellen Cursorposition eingefügt, jedoch keine höhere Priorität-Nachricht, die vor dieser Position eingefügt zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>.  
  
 Die Reihenfolge der Nachrichten in der Enumeration widerspiegelt deren Reihenfolge in der Warteschlange, damit Nachrichten höherer Priorität vor diejenigen niedrigerer Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange statt einer dynamischen Verbindung, die sie verwenden möchten, rufen Sie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Diese Methode gibt ein Array von <xref:System.Messaging.Message> Objekte, die die Nachrichten zu dem Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bietet Vorwärtscursor-Semantik auf alle öffentlichen Warteschlangen im Netzwerk durchlaufen.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" /> , der eine dynamische Liste aller öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Enumeration aller öffentlichen Warteschlangen, die sich im Netzwerk befinden.  
  
 Da der Cursor eine dynamische Liste zugeordnet ist, gibt die Enumeration jede Änderung, die Sie vornehmen, um eine Liste der Warteschlangen für Warteschlangen, die außerhalb der aktuellen Cursorposition hinzugefügt oder gelöscht. Hinzufügen oder Löschen von Warteschlangen vor der aktuellen Cursorposition werden nicht berücksichtigt. Der Enumerator kann z. B. eine Warteschlange, die hinter der Cursorposition angefügt, aber keiner vor dieser Position eingefügt automatisch zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Es gibt keine festgelegte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert, z. B. nach Computer, Bezeichnung, öffentlichen oder privaten Status oder andere Kriterien zugänglich nicht.  
  
 Wenn Sie eine statische Momentaufnahme der Warteschlangen auf dem Netzwerk statt einer dynamischen Verbindung mit möchten, rufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> oder <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue> Objekte, die die Warteschlangen zum Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Meldungswarteschlangen im Netzwerk durchlaufen und untersucht den Pfad für jede Warteschlange. Schließlich wird die Anzahl von öffentlichen Warteschlangen im Netzwerk angezeigt.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" /> , die die Kriterien zum Filtern der verfügbaren Meldungswarteschlangen enthält.</param>
        <summary>Bietet Vorwärtscursor-Semantik auf alle öffentlichen Warteschlangen im Netzwerk durchlaufen, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" /> , die eine dynamische Liste der öffentlichen Meldungswarteschlangen im Netzwerk, die die vom angegebenen Einschränkungen erfüllen bietet die <paramref name="criteria" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Liste aller öffentlichen Warteschlangen im Netzwerk, die in den Anwendungskriterien definierte Kriterien erfüllen. Sie können angeben, dass die Kriterien eingeschlossen werden, z. B. erstellungs- oder Änderungsdatum Zeit, die Computernamen, Menge, Kategorie oder eine beliebige Kombination dieser Warteschlange.  
  
 Da der Cursor eine dynamische Liste zugeordnet ist, gibt die Enumeration jede Änderung, die an eine Warteschlange zu stellen, die außerhalb der aktuellen Cursorposition auftritt, wieder. Änderungen an Warteschlangen vor der aktuellen Cursorposition werden nicht berücksichtigt. Der Enumerator kann z. B. eine Warteschlange, die hinter der Cursorposition angefügt, aber keiner vor dieser Position eingefügt automatisch zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Es gibt keine festgelegte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert, z. B. nach Computer, Bezeichnung, öffentlichen oder privaten Status oder andere Kriterien zugänglich nicht.  
  
 Wenn Sie eine statische Momentaufnahme der Warteschlangen auf das Netzwerk statt einer dynamischen Verbindung möchten, geben Sie Kriterien für <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> , oder rufen Sie <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue> Objekte, die die Warteschlangen zum Zeitpunkt darstellen, die Methode wurde aufgerufen. Aufrufen von <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> bietet die gleichen Ergebnisse wie das Aufrufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> mit den Filterkriterien der <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>zugeordnet.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel durchläuft Nachrichtenwarteschlangen und zeigt den Pfad für jede Warteschlange, die in den letzten Tag erstellt wurde und vorhanden ist, auf dem Computer "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, von dem der privaten Warteschlangen abgerufen werden soll.</param>
        <summary>Ruft ab, der die privaten Warteschlangen auf dem angegebenen Computer.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" /> Objekte, die die abgerufenen privaten Warteschlangen zu verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>Ruft eine statische Momentaufnahme der Warteschlangen auf einem angegebenen Computer ab.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" /> Objekte, die die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn eine vollständige Liste aller öffentlichen Warteschlangen im Netzwerk verwendet werden soll. Wenn Sie z. B. die Liste nach bestimmten Kriterien einschränken möchten <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, oder die Uhrzeit der letzten Änderung mit einer anderen Überladung dieser Methode. (Alternativ können Sie <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" /> , die die Kriterien zum Filtern der Warteschlangen enthält.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk aus, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" /> Objekte, die die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie alle öffentlichen Warteschlangen im Netzwerk nach Bezeichnung, Kategorie oder Computername filtern möchten die <xref:System.Messaging.MessageQueue> Klasse enthält bestimmte Methoden, die diese Funktionen bereitstellen (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, und <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>bzw.). Verwenden Sie diese Überladung, um eine Liste aller öffentlichen Warteschlangen im Netzwerk abzurufen, die mehr als eine der folgenden Kriterien erfüllen (beispielsweise, wenn Sie eine Bezeichnung und eine Kategorie angeben möchten). Sie können auch filtern, indem meldungskriterien außer <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>. Beispielsweise verwenden Sie diese Überladung, um nach der Uhrzeit der letzten Änderung einer Warteschlange zu filtern. Erstellen Sie einfach eine neue Instanz der dem <xref:System.Messaging.MessageQueueCriteria> Klasse, legen Sie die entsprechenden Eigenschaften in der Instanz, und übergeben Sie die Instanz als der `criteria` Parameter.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Ein <see cref="T:System.Guid" /> , die Gruppen des Satz von Warteschlangen abgerufen werden sollen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk aus, die der angegebenen Kategorie angehören.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" /> Objekte, die die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um öffentlichen Warteschlangen nach Kategorie filtern. Die <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft ermöglicht den Zugriff auf die Message Queuing-Typ ID-Eigenschaft (also Lese-/Schreibzugriff) einer bestimmten Warteschlange. Sie können zwar <xref:System.Guid.NewGuid%2A> Kategorie erstellen, die auf allen eindeutig ist <xref:System.Guid> Werte, es ist nicht erforderlich. Der Kategoriewert muss nur aus anderen Kategorien, die nicht von allen anderen unterscheiden <xref:System.Guid> Werte. Sie können z. B. {00000000-0000-0000-0000-000000000001} zuweisen, als die <xref:System.Messaging.MessageQueue.Category%2A> für eine Gruppe von Warteschlangen und {00000000-0000-0000-0000-000000000002} als die <xref:System.Messaging.MessageQueue.Category%2A> für eine andere Gruppe.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie können die Kategorie angeben, als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Eine Bezeichnung, die Gruppen den Satz von Warteschlangen abgerufen werden sollen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk aus, die die angegebene Bezeichnung enthalten.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" /> Objekte, die die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die öffentliche Warteschlangen Bezeichnung zu filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Geben Sie die Bezeichnung als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers, der den Satz von öffentlichen Warteschlangen abgerufen werden sollen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen, die auf dem angegebenen Computer befinden.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" /> -Objekten, die die öffentlichen Warteschlangen auf dem Computer verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um öffentlichen Warteschlangen nach Computer filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie können den Computernamen angeben, als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="machineName" /> Parameter hat eine falsche Syntax.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Sicherheitskontext an, dem der aktuelle Benutzer (Threadidentität) MSMQ, zum Zeitpunkt des Aufrufs zuordnet ab.</summary>
        <returns>Ein <see cref="T:System.Messaging.SecurityContext" /> Objekt, das den Sicherheitskontext enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Bezeichner der Message Queuing der Warteschlange ab.</summary>
        <value>Ein <see cref="P:System.Messaging.MessageQueue.Id" /> , die von der Message Queuing-Anwendung generierten Nachrichten-ID darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing-legt die <xref:System.Messaging.MessageQueue.Id%2A> Eigenschaft bei der Erstellung der Warteschlangenobjekts. Diese Eigenschaft ist nur für Öffentliche Warteschlangen verfügbar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Id%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass keine Einschränkung für die Größe für eine Warteschlange vorhanden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Element wird häufig verwendet, der zum Einstellen <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> oder <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.MessageQueue.InfiniteQueueSize> Member.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass kein Timeout für Methoden, die zum Einsehen oder Empfangen von Nachrichten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue>unterstützt zwei Arten von Nachrichtenabruf: synchrone und asynchrone. Die synchronen Methoden <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, dazu führen, dass Prozessthreads warten ein angegebenen Zeitintervalls für eine neue Nachricht in der Warteschlange eintreffen. Wenn das angegebene Zeitintervall ist <xref:System.Messaging.MessageQueue.InfiniteTimeout>, Prozessthreads bleibt blockiert, bis eine neue Nachricht verfügbar ist. Andererseits, <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A> (die asynchronen Methoden), ermöglichen die Hauptassembly der Anwendungsaufgaben in einem separaten Thread fortgesetzt, bis eine Nachricht in der Warteschlange eingeht.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.MessageQueue.InfiniteTimeout> Member.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, oder die warteschlangenbeschreibung festgelegt.</summary>
        <value>Die Bezeichnung für die Nachrichtenwarteschlange. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Länge für die Bezeichnung einer Warteschlange beträgt 124 Zeichen.  
  
 Die <xref:System.Messaging.MessageQueue.Label%2A> Eigenschaft muss nicht für alle Warteschlangen eindeutig sein. Jedoch, wenn mehrere Warteschlangen desselben Anzeigestatus <xref:System.Messaging.MessageQueue.Label%2A>, können Sie keine der <xref:System.Messaging.MessageQueue.Send%28System.Object%29> Methode, um eine Nachricht an alle übertragen. Bei Verwendung der Syntax der Volumebezeichnung für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft beim Senden der Nachricht, eine Ausnahme wird ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> ist nicht eindeutig.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Label%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Bezeichnung wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, Zeitpunkt der letzten der Eigenschaften einer Warteschlange Änderung.</summary>
        <value>Ein <see cref="T:System.DateTime" /> , der angibt, wann die Eigenschaften der Warteschlange zuletzt geändert wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeitpunkt der letzten Änderung enthält, wenn die Warteschlange erstellt wurde und ein beliebiger <xref:System.Messaging.MessageQueue> -Eigenschaft, die die Message Queuing-Warteschlange, wie z. B. ändert <xref:System.Messaging.MessageQueue.BasePriority%2A>. Der Wert, der die <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft darstellt, die Systemzeit des lokalen Computers.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Refresh%2A> vor dem Abrufen der <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft; andernfalls, der Zeitpunkt der Änderung zugeordnet <xref:System.Messaging.MessageQueue> möglicherweise nicht auf dem neuesten Stand.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Namen des Computers, auf dem Message Queuing-Warteschlange befindet.</summary>
        <value>Der Name des Computers, auf dem sich die Warteschlange befindet. Der Message Queuing-Standardwert ist ".", dem lokalen Computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A> ist ein Bestandteil der Syntax für den angezeigten Namen der Warteschlange <xref:System.Messaging.MessageQueue.Path%2A>. Die folgende Tabelle zeigt die Syntax, die Sie für eine Warteschlange eines bestimmten Typs verwenden soll, wenn der Pfad der Warteschlange über den Anzeigenamen angegeben werden sollen.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden "." für den lokalen Computer bei der Angabe der <xref:System.Messaging.MessageQueue.MachineName%2A>. Nur der Computernamen ist für diese Eigenschaft wird erkannt, z. B. `Server0`. Die <xref:System.Messaging.MessageQueue.MachineName%2A> -Eigenschaft das Format der IP-Adresse nicht unterstützt.  
  
 Wenn Sie definieren die <xref:System.Messaging.MessageQueue.Path%2A> im Sinne von der <xref:System.Messaging.MessageQueue.MachineName%2A>, die Anwendung löst eine Ausnahme aus, wenn Sie offline arbeiten, da der Domänencontroller für die Übersetzung des Pfads erforderlich ist. Deshalb müssen Sie verwenden die <xref:System.Messaging.MessageQueue.FormatName%2A> für die <xref:System.Messaging.MessageQueue.Path%2A> Syntax, wenn Sie offline arbeiten.  
  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften beziehen. Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A> bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A> zu ändernden Eigenschaft. Er wird erstellt, aus dem neuen <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A>. Ändern der <xref:System.Messaging.MessageQueue.Path%2A> (z. B. mit der formatnamenssyntax) setzt die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zum Verweisen auf die neue Warteschlange. Wenn die <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft leer ist, ist die <xref:System.Messaging.MessageQueue.Path%2A> festgelegt ist, in die Journalwarteschlange des Computers, die Sie angeben.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MachineName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name des Computers ist ungültig, möglicherweise weil die Syntax falsch ist.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die maximale Größe der Journalwarteschlange.</summary>
        <value>Die maximale Größe der Journalwarteschlange in Kilobyte. Der Message Queuing-Standard gibt an, dass kein Grenzwert vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>bietet Zugriff auf die Speicherobergrenze für Message Queuing-Journal. Es ist nur relevant, wenn <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> ist `true`. Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind  
  
 Wenn Sie Nachrichten in einer Journalwarteschlange oder Dead Letter-Warteschlange gespeichert werden, sollten Sie in regelmäßigen Abständen deaktivieren die Warteschlange, um Nachrichten zu entfernen, die nicht mehr benötigt werden. Nachrichten in eine solche Warteschlange angerechnet Kontingent für die für den Computer, auf dem sich die Warteschlange befindet. (Der Administrator wird das Computerkontingent.)  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe der Journalwarteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die maximale Größe der Warteschlange.</summary>
        <value>Die maximale Größe in Kilobyte, der die Warteschlange. Der Message Queuing-Standard gibt an, dass kein Grenzwert vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> ermöglicht den Zugriff auf die Message Queuing-Nachricht Speicherlimit überschritten, die getrennt von dem Computer das Kontingent für der Administrator definiert sind. Weitere Informationen zu den Nachrichtenkontingent, finden Sie unter <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind  
  
 Wenn versucht wird, überschreitet die maximale Warteschlangengröße oder das Kontingent für die Computer, möglicherweise Nachrichten verloren gehen. Wenn das Warteschlangenkontingent erreicht wird, benachrichtigt Message Queuing die Verwaltungswarteschlange, die von der sendenden Anwendung aus, um anzugeben, dass die Warteschlange voll ist, wird durch eine negative Bestätigungsnachricht zurückgeben. Message Queuing wird fortgesetzt, negative Bestätigungen zu senden, bis die Gesamtgröße der Nachrichten in der Warteschlange unter dem Limit liegt.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Warteschlangengröße enthält einen negativen Wert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt die Eigenschaftenfilter für das empfangen oder Einsehen von Nachrichten.</summary>
        <value>Die <see cref="T:System.Messaging.MessagePropertyFilter" /> von der Warteschlange verwendet wird, um den Satz von Eigenschaften zu filtern, eingehen oder für jede Nachricht liest.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Filter ist ein Satz von booleschen Werten, die die Nachrichteneigenschaften einschränken, die die <xref:System.Messaging.MessageQueue> empfängt oder einsieht. Wenn die <xref:System.Messaging.MessageQueue> empfängt oder sieht eine Nachricht aus der Serverwarteschlange abgerufen, nur die Eigenschaften für die die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Wert ist `true`.  
  
 Im folgenden werden die anfänglichen Eigenschaftenwerte für die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft. Diese Einstellungen sind identisch mit einem Aufruf <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> auf eine <xref:System.Messaging.MessagePropertyFilter>.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> beschränken Sie die Eigenschaften der Nachricht empfangen.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Filter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>In MSMQ 3.0 eingeführt. Ruft ab, oder der Warteschlange zugeordnete Multicastadresse festgelegt.</summary>
        <value>Ein <see cref="T:System.String" /> , enthält eine gültige Multicastadresse (im unten gezeigten Formular) oder <see langword="null" />, was bedeutet, dass die Warteschlange nicht mit einer Multicastadresse verknüpft ist.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Eigenschaft wird verwendet, um eine nicht transaktionale Warteschlange mit einer Multicastadresse zuordnen, die beim Senden von Nachrichten verwendet werden kann. Eine transaktionale Warteschlange nicht mit einer Multicastadresse zugeordnet werden. Wenn die sendende Anwendung Nachrichten an eine Multicastadresse sendet, sendet Message Queuing eine Kopie der Nachricht zu jedem dieser Adresse zugeordnete Warteschlange.  
  
 Multicast-IP-Adressen muss im Bereich Klasse D von 224.0.0.0 bis 239.255.255.255 an, die die ersten vier höherwertigen Bits 1110 gleich Einstellung entspricht. Nur bestimmte Bereiche von Adressen in diesem Bereich sind jedoch nicht reserviert und für das Senden von Multicastnachrichten verfügbar. Die aktuelle Liste der reservierten Multicastadressen, finden Sie unter der [Internet Assigned Number Authority (IANA) Internet Multicastadressen](http://go.microsoft.com/fwlink/?linkid=3859) Webseite. Es gibt keine Einschränkungen auf die Portnummer an.  
  
 Wenn mehrere Quellcomputern multicast-Nachrichten senden, und Sie eine bestimmte Warteschlange zum Empfangen von Nachrichten aus nur einem Quellcomputer möchten, muss jede Quellcomputer Nachrichten an eine andere Kombination aus IP-Adresse und Port senden.  
  
 Um eine Warteschlange zu einer Multicastadresse trennen möchten, legen Sie die <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Eigenschaft, um eine Zeichenfolge der Länge 0 (null). Legen Sie sie nicht auf `null`, wie dies führt eine <xref:System.ArgumentNullException>.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Pfad der Warteschlange. Festlegen der <see cref="P:System.Messaging.MessageQueue.Path" /> bewirkt, dass die <see cref="T:System.Messaging.MessageQueue" /> auf eine neue Warteschlange verweisen.</summary>
        <value>Die Warteschlange, die verweist die <see cref="T:System.Messaging.MessageQueue" />. Der Standardwert hängt von der <see cref="M:System.Messaging.MessageQueue.#ctor" /> Konstruktor Sie; er ist entweder <see langword="null" /> oder wird angegeben, indem des Konstruktors <paramref name="path" /> Parameter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft hängt vom Typ der Warteschlange es zeigt an, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden "." auf den lokalen Computer darzustellen.  
  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften beziehen. Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A> bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A> zu ändernden Eigenschaft. Er wird erstellt, aus dem neuen <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A>. Ändern der <xref:System.Messaging.MessageQueue.Path%2A> (z. B. mit der formatnamenssyntax) setzt die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zum Verweisen auf die neue Warteschlange.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben, wie in der folgenden Tabelle gezeigt.  
  
|Verweis|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:`[ *Formatnamen* ]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Bezeichnung|`Label:`[ *Bezeichnung* ]|`Label:`TheLabel|  
  
 Bei Verwendung der Syntax der Volumebezeichnung für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft beim Senden der Nachricht, eine Ausnahme wird ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> ist nicht eindeutig.  
  
 Um offline zu arbeiten, müssen Sie die Syntax der Anzeigename, anstatt die formatnamenssyntax in der ersten Tabelle verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller (Active Directory auf dem befindet) nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 Festlegen eines neuen Pfads schließt die Nachrichtenwarteschlange und alle Handles frei.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
> [!NOTE]
>  Im Arbeitsgruppenmodus können Sie nur die private Warteschlangen verwenden. Geben Sie den Pfad mit der Syntax für die private Warteschlange `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neuer <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Pfad benennen Syntax von Typen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist möglicherweise nicht gültig, da die Syntax ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ohne zu entfernen (einzusehen) die erste Nachricht in der Warteschlange auf die von diesem <see cref="T:System.Messaging.MessageQueue" />. Die <see cref="M:System.Messaging.MessageQueue.Peek" /> Methode ist synchron, damit er den aktuellen Thread blockiert, bis eine Nachricht verfügbar ist.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , die die erste Nachricht in die Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung aus, um eine Warteschlange einsehen oder warten, bis eine Nachricht in die Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, jedoch nicht entfernt, die erste Nachricht aus der Warteschlange. Aus diesem Grund wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Peek%2A> dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode, andererseits, liest und die erste Nachricht aus der Warteschlange entfernt. Wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A>, daher verschiedene Nachrichten zurückzugeben.  
  
 Message Queuing ordnet die Nachrichten in der Warteschlange nach Priorität und der Ankunft. Eine neuere Nachricht wird vor einer älteren platziert werden, nur, wenn sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Da diese Überladung ein Timeouts nicht angegeben ist, kann die Anwendung unbegrenzt warten. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode. Alternativ können Sie angeben, einen Timeout für eine Nachricht in der Warteschlange eintrifft, mit der Überladung der <xref:System.Messaging.MessageQueue.Peek%2A> , einen Timeout angibt.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Die folgenden Beispiele verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode in einer Warteschlange.  
  
 Im ersten Beispiel wartet die Anwendung eine Nachricht in der Warteschlange verfügbar wird. Beachten Sie, dass im erste Beispiel nicht geht die Nachricht zugreifen. Es wird lediglich angehalten, verarbeitet werden, bevor eine Nachricht eingeht. Wenn eine Nachricht in die Warteschlange bereits vorhanden ist, wird sofort zurückgegeben.  
  
 Im zweiten Beispiel, eine Nachricht mit einem anwendungsdefinierten `Order` Klasse ist an die Warteschlange gesendet und anschließend aus der Warteschlange eingesehen.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der die maximale Zeit, die für die Warteschlange eine Nachricht enthält warten angibt.</param>
        <summary>Gibt ohne zu entfernen (einzusehen) die erste Nachricht in der Warteschlange auf die von diesem <see cref="T:System.Messaging.MessageQueue" />. Die <see cref="M:System.Messaging.MessageQueue.Peek" /> Methode ist synchron, damit er den aktuellen Thread, blockiert bis eine Nachricht verfügbar wird oder das angegebene Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , die die erste Nachricht in die Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, können Sie eine Warteschlange einsehen und warten Sie einen angegebenen Zeitraum, bis eine Nachricht in die Warteschlange vorhanden ist. Die Methode gibt sofort zurück, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, jedoch nicht entfernt, die erste Nachricht aus der Warteschlange. Aus diesem Grund wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Peek%2A> dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode, andererseits, liest und die erste Nachricht aus der Warteschlange entfernt. Wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A>, daher verschiedene Nachrichten zurückzugeben.  
  
 Message Queuing ordnet die Nachrichten in der Warteschlange nach Priorität und der Ankunft. Eine neuere Nachricht wird vor einer älteren platziert werden, nur, wenn sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread bis zum angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Messaging.MessageQueue.Peek%2A> Methode mit einem Timeoutwert von 0 (null), um zu überprüfen, ob die Warteschlange leer ist.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , der die maximale Zeit, die für die Warteschlange eine Nachricht enthält warten angibt.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" /> , mit eine bestimmte Position in der Meldungswarteschlange verwaltet.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die nächste Nachricht in der Warteschlange eingesehen.</param>
        <summary>Gibt zurück, ohne dass (einzusehen), die aktuelle oder die nächste Nachricht in der Warteschlange, die mithilfe des angegebenen Cursors entfernt. Die <see cref="M:System.Messaging.MessageQueue.Peek" /> Methode ist synchron, damit er den aktuellen Thread, blockiert bis eine Nachricht verfügbar wird oder das angegebene Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , eine Nachricht in die Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, können Sie eine Warteschlange einsehen und warten Sie einen angegebenen Zeitraum, bis eine Nachricht in die Warteschlange vorhanden ist. Die Methode gibt sofort zurück, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, jedoch nicht entfernt, eine Nachricht aus der Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode, andererseits, liest und eine Nachricht aus der Warteschlange entfernt.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread blockiert, bis zu den angegebenen Zeitraum Zeit oder unbegrenzt haben Sie <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Einen anderen Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> wurde angegeben, für die <paramref name="action" /> Parameter.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig. Möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht einsehen.</param>
        <summary>Sieht die Meldung, die den angegebenen Korrelations-ID und sofort löst eine Ausnahme aus, wenn derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange vorhanden ist.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht einsehen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <summary>Sieht die Meldung, die den angegebenen Korrelations-ID und wartet, bis eine Nachricht mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter und keine neue Nachricht geht in der Warteschlange innerhalb des Zeitraums gemäß der `timeout` Parameter, es wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> in der Warteschlange nicht vorhanden und nicht vor Ablauf des Timeoutintervalls eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor dem abgelaufenen Timeoutintervall eine Nachricht nicht eingegangen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht einsehen.</param>
        <summary>Sieht die Nachricht, deren Nachrichten-ID entspricht, der <paramref name="id" /> Parameter.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> zu lesen, ohne dass aus der Warteschlange entfernt, eine Nachricht, die über eine bekannte Nachrichten-ID verfügt. Der Bezeichner einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange zurzeit nicht die Nachricht enthält.  
  
 Zwei weitere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Nachricht in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, den Bericht oder die Anwendung generierte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Keine Meldung mit dem angegebenen <paramref name="id" /> vorhanden ist.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht einsehen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <summary>Sieht die Nachricht, deren Nachrichten-ID entspricht, der <paramref name="id" /> Parameter. Wartet, bis die Meldung wird, in der Warteschlange angezeigt oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> zu lesen, ohne dass aus der Warteschlange entfernt, eine Nachricht, die über eine bekannte Nachrichten-ID verfügt. Der Bezeichner einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange derzeit keine Nachricht enthält und eine neue Nachricht kommen nicht, bevor das Timeout auftritt.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Zwei weitere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Nachricht in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, den Bericht oder die Anwendung generierte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="id" /> in der Warteschlange nicht vorhanden und nicht vor dem Punkt gemäß eingegangen der <paramref name="timeout" /> Parameter abgelaufen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der Nachricht einsehen.</param>
        <summary>In MSMQ 3.0 eingeführt. Sieht die Nachricht, die der angegebenen Nachschlage-ID aus einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.LookupId" /> Eigenschaft entspricht der <paramref name="lookupId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bestimmten Suchbezeichner zu lesen, ohne es zu entfernen aus der Warteschlange an. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Verwenden Sie zum Lesen einer Nachricht mit der angegebenen Nachschlage-ID und aus der Warteschlange zu entfernen, die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="lookupId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Eines der <see cref="T:System.Messaging.MessageLookupAction" /> Werte, der angibt, wie die Nachricht in der Warteschlange gelesen wird. Geben Sie einen der folgenden:  
  
 <see langword="MessageLookupAction.Current" />: Sieht die Nachricht gemäß <c>LookupId</c>.  
  
 <see langword="MessageLookupAction.Next" />: Sieht die Nachricht, die von angegebene Nachricht folgt <c>LookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" />: Sieht die Nachricht die Nachricht gemäß <c>LookupId</c>.  
  
 <see langword="MessageLookupAction.First" />: Sieht die erste Nachricht in der Warteschlange. Die <c>LookupId</c> -Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Sieht die letzte Nachricht in der Warteschlange. Die <c>LookupId</c> -Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der Nachricht zum Einsehen oder 0. 0 wird verwendet, wenn die erste oder letzte Nachricht in der Warteschlange zugreifen.</param>
        <summary>In MSMQ 3.0 eingeführt. Sieht eine bestimmte Nachricht aus der Warteschlange. Die Nachricht kann durch eine Nachschlage-ID oder anhand seiner Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> gemäß der <paramref name="action" /> und <paramref name="lookupId" /> übergeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bestimmten Suchbezeichner zu lesen, ohne es zu entfernen aus der Warteschlange an. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Verwenden Sie zum Lesen einer Nachricht mit einem angegebenen Bezeichner und aus der Warteschlange zu entfernen, die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="lookupId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="action" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageLookupAction" /> Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Nachricht gelesen wird, ohne die aus der Warteschlange entfernt wird. Dies ist das Ergebnis des asynchronen Vorgangs, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>wird verwendet, bei der asynchronen Verarbeitung zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>Dient zum Abschließen des Vorgangs, der durch einen Aufruf initiiert <xref:System.Messaging.MessageQueue.BeginPeek%2A> und die Nachricht bei der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst.  
  
 Beim Erstellen eines <xref:System.Messaging.PeekCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu Ereignishandlerdelegaten, finden Sie unter [NIB: Ereignisse und Delegaten](http://msdn.microsoft.com/en-us/d98fd58b-fa4f-4598-8378-addf4355a115).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> um einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, die im Beispiel sieht die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um eine neue asynchronen Lesevorgang initiieren  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Nachrichten, die in der Warteschlange enthalten sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löschen der Warteschlangenobjekts bewirkt, dass Message Queuing zum fest, wodurch die wirkt sich auf die <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft. Nachrichten, die aus der Warteschlange gelöscht werden, gehen verloren; Sie werden nicht an die Dead Letter-Warteschlange oder Journalwarteschlange gesendet.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt den Anzeigenamen für die Warteschlange.</summary>
        <value>Der Name zum Identifizieren der Warteschlange, auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />. Der Wert darf nicht <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie kombinieren können die <xref:System.Messaging.MessageQueue.QueueName%2A> mit der <xref:System.Messaging.MessageQueue.MachineName%2A> So erstellen einen aussagekräftigen <xref:System.Messaging.MessageQueue.Path%2A> Namen für die Warteschlange. Die Syntax für den Anzeigenamen des der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft hängt vom Typ der Warteschlange, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Verwenden "." auf den lokalen Computer darzustellen.  
  
 Ändern der <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft wirkt sich auf die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft. Wenn Sie festlegen, die <xref:System.Messaging.MessageQueue.QueueName%2A> festlegen, ohne die <xref:System.Messaging.MessageQueue.MachineName%2A> -Eigenschaft, die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.\\ `QueueName`. Andernfalls die <xref:System.Messaging.MessageQueue.Path%2A> wird `MachineName` \\ `QueueName`.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Warteschlangenname ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle verwendet, um Nachrichten aus der Warteschlange zu lesen.</summary>
        <value>Ein Handle für das systemeigene Queue-Objekt, mit denen Sie für den Empfang und Empfangen von Nachrichten aus der Warteschlange.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.ReadHandle%2A> bietet eine systemeigene Windows-Handle für das Message Queue-Objekt, das für den Empfang und Empfangen von Nachrichten aus der Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange zu ändern, wird durch einen neuen Wert das Handle geschlossen und erneut geöffnet.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empfängt die erste Nachricht in der Warteschlange verweist die <see cref="T:System.Messaging.MessageQueue" />. Dieser Aufruf erfolgt synchron, und blockiert den aktuellen Ausführungsthread, bis eine Nachricht verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Warteschlange empfangen, oder warten Sie, bis die Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> gibt zurück, die Nachrichten, die in der Warteschlange oder neuer, Nachrichten mit höhere Priorität folgen.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da dieser Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unbegrenztes Timeout an, die Anwendung möglicherweise unbegrenzt warten. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht aus einer Warteschlange empfängt und gibt Informationen über diese Meldung auf dem Bildschirm.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste Nachricht zur Verfügung, in die Transaktionswarteschlange, verweist der <see cref="T:System.Messaging.MessageQueue" />. Dieser Aufruf erfolgt synchron, und blockiert den aktuellen Ausführungsthread, bis eine Nachricht verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht von einer Transaktionswarteschlange mit den internen bereits verwendeten Transaktionskontext durch definiert die `transaction` -Parameters an, oder warten Sie, bis die Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da dieser Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unbegrenztes Timeout an, die Anwendung möglicherweise unbegrenzt warten. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer transaktionalen Warteschlange auf dem lokalen Computer her, und sendet eine Nachricht an die Warteschlange. Anschließend wird die Nachricht mit einer Bestellung empfangen. Wenn sie eine nicht transaktionale Warteschlange auftritt, löst sie Ausnahme ausgegeben und ein Rollback der Transaktion.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Empfängt die erste Nachricht in der Warteschlange verweist die <see cref="T:System.Messaging.MessageQueue" />. Dieser Aufruf erfolgt synchron, und blockiert den aktuellen Ausführungsthread, bis eine Nachricht verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` -Parameters an, oder warten Sie, bis die Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da dieser Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unbegrenztes Timeout an, die Anwendung möglicherweise unbegrenzt warten. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <summary>Empfängt die erste Nachricht in der Warteschlange verweist die <see cref="T:System.Messaging.MessageQueue" /> und wartet, bis eine Nachricht in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht empfangen und in einen angegebenen Zeitraum zurückgeben, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> gibt zurück, die Nachrichten, die in der Warteschlange oder neuer, Nachrichten mit höhere Priorität folgen.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht aus einer Warteschlange empfängt und gibt Informationen über diese Meldung auf dem Bildschirm. Im Beispiel hält die Ausführung bis zu fünf Sekunden warten, in der Warteschlange eingehen einer Nachricht.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht nicht in der Warteschlange eingehen, bevor das Timeout abgelaufen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" /> , mit eine bestimmte Position in der Meldungswarteschlange verwaltet.</param>
        <summary>Empfängt die aktuelle Nachricht in der Warteschlange, die mit den angegebenen Cursor. Wenn keine Nachricht verfügbar ist, wartet diese Methode, bis eine Nachricht verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht nicht in der Warteschlange eingehen, bevor das Timeout abgelaufen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode  
  
 Verwenden Sie diese Überladung, um eine Nachricht empfangen und in einen angegebenen Zeitraum zurückgeben, wenn keine Nachrichten in der Warteschlange vorhanden sind.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste Nachricht zur Verfügung, in die Transaktionswarteschlange, verweist der <see cref="T:System.Messaging.MessageQueue" /> und wartet, bis eine Nachricht in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht von einer Transaktionswarteschlange mit den internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter und Rückgabetypen innerhalb einer festgelegten Zeitspanne Wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht nicht in der Warteschlange eingehen, bevor das Timeout abgelaufen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Empfängt die erste Nachricht in der Warteschlange verweist die <see cref="T:System.Messaging.MessageQueue" />. Dieser Aufruf erfolgt synchron, und wartet, bis eine Nachricht in der Warteschlange verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf die erste Nachricht in der Warteschlange verfügbar verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter und der Rückgabewert in einer angegebenen Zeitspanne, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht nicht in der Warteschlange eingehen, bevor das Timeout abgelaufen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" /> , mit eine bestimmte Position in der Meldungswarteschlange verwaltet.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die aktuelle Nachricht in der Warteschlange, die mit den angegebenen Cursor. Wenn keine Nachricht verfügbar ist, wartet diese Methode, bis eine Nachricht verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf eine Nachricht in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht von einer Transaktionswarteschlange mit den internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter und Rückgabetypen innerhalb einer festgelegten Zeitspanne Wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Verwenden Sie zum Lesen einer Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, die Nachrichten in die Warteschlange verfügt, gibt es keine durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread ist für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig. Möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht nicht in der Warteschlange eingehen, bevor das Timeout abgelaufen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" /> , mit eine bestimmte Position in der Meldungswarteschlange verwaltet.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, die den Typ des bereits verwendeten Transaktionskontext zugeordnet, die Nachricht beschreibt.</param>
        <summary>Empfängt die aktuelle Nachricht in der Warteschlange, die mit den angegebenen Cursor. Wenn keine Nachricht verfügbar ist, wartet diese Methode, bis eine Nachricht verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Ein <see cref="T:System.Messaging.Message" /> , die auf eine Nachricht in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter und der Rückgabewert in einer angegebenen Zeitspanne, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Verwenden Sie zum Lesen einer Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, die Nachrichten in die Warteschlange verfügt, gibt es keine durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread ist für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig. Möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht nicht in der Warteschlange eingehen, bevor das Timeout abgelaufen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht zu empfangen.</param>
        <summary>Empfängt die Nachricht, die die angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionalen Warteschlange verweist die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst. Andernfalls wird die Nachricht aus der Warteschlange entfernt und an die Anwendung zurückgegeben.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode ruft eine Meldung ab, durch den eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht zu empfangen.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Nachricht, die die angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in die Transaktionswarteschlange, verweist der <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst. Andernfalls die Nachricht aus der Warteschlange entfernt und zurückgegeben, die in der Anwendung mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht zu empfangen.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Empfängt die Nachricht, die die angegebenen Korrelations-ID und sofort löst eine Ausnahme aus, wenn derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange vorhanden ist.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst. Andernfalls die Nachricht aus der Warteschlange entfernt und zurückgegeben, die in der Anwendung mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht zu empfangen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <summary>Empfängt die Nachricht, die die angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Nachricht mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionalen Warteschlange verweist die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> in der Warteschlange nicht vorhanden und nicht vor Ablauf des Timeoutintervalls eingegangen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht zu empfangen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Nachricht, die die angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Nachricht mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in die Transaktionswarteschlange, verweist der <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange, die mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> in der Warteschlange nicht vorhanden und nicht vor Ablauf des Timeoutintervalls eingegangen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der Nachricht zu empfangen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Empfängt die Nachricht, die die angegebenen Korrelations-ID und wartet, bis eine Nachricht mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist, oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.CorrelationId" /> entspricht der <paramref name="correlationId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transactionType` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter. Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Nachricht mit dem angegebenen <paramref name="correlationId" /> in der Warteschlange nicht vorhanden und nicht vor Ablauf des Timeoutintervalls eingegangen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht zu empfangen.</param>
        <summary>Empfängt die Nachricht, die der angegebenen ID aus einer nicht transaktionalen Warteschlange und löst sofort eine Ausnahme aus, wenn derzeit keine Meldung mit dem angegebenen Bezeichner in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="id" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht zu empfangen.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Nachricht, die der angegebenen ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn derzeit keine Meldung mit dem angegebenen Bezeichner in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und entfernen es aus der Warteschlange, die mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="id" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht zu empfangen.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Empfängt die Nachricht, die der angegebenen ID und löst sofort eine Ausnahme aus, wenn derzeit keine Meldung mit dem angegebenen Bezeichner in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist. Andernfalls die Nachricht aus der Warteschlange entfernt und zurückgegeben, die in der Anwendung mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Wenn die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange als dem zugeordneten <xref:System.Messaging.MessageQueue> Instanz, die Nachricht wird nicht gefunden werden.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="id" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht zu empfangen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <summary>Empfängt die Nachricht, die der angegebenen ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Nachricht mit dem angegebenen Bezeichner in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode kehrt sofort zurück, wenn die Nachricht mit dem Bezeichner, wird angegeben die `id` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Wenn eine für den aktuellen Thread blockiert wird, als neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß akzeptabel ist die `timeout` Parameter. Der Thread blockiert werden für mindestens im angegebenen Zeitraum Zeit oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht mit dem angegebenen <paramref name="id" /> nicht in der Warteschlange eingehen, bevor das Timeout ist abgelaufen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht zu empfangen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Nachricht, die der angegebenen ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Nachricht mit dem angegebenen Bezeichner in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und entfernen es aus der Warteschlange, die mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit dem Bezeichner, wird angegeben die `id` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Wenn eine für den aktuellen Thread blockiert wird, als neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß akzeptabel ist die `timeout` Parameter. Der Thread blockiert werden für mindestens im angegebenen Zeitraum Zeit oder unbegrenzt, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Zeitlimits gemäß der `timeout` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht mit dem angegebenen <paramref name="id" /> nicht in der Warteschlange eingehen, bevor das Timeout ist abgelaufen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der Nachricht zu empfangen.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" /> , die angibt, dass der Zeit zum Warten, bis eine neue Nachricht für die Überprüfung verfügbar ist.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Empfängt die Nachricht, die der angegebenen ID und wartet, bis eine Nachricht mit dem angegebenen Bezeichner in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.Id" /> Eigenschaft entspricht der <paramref name="id" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode kehrt sofort zurück, wenn die Nachricht mit dem Bezeichner, wird angegeben die `id` Parameter ist in der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transactionType` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Wenn die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange als dem zugeordneten <xref:System.Messaging.MessageQueue> Instanz, die Nachricht wird nicht gefunden werden.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Wenn eine für den aktuellen Thread blockiert wird, als neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß akzeptabel ist die `timeout` Parameter. Der Thread blockiert werden für mindestens im angegebenen Zeitraum Zeit oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Wert für die <paramref name="timeout" /> -Parameter ist ungültig, möglicherweise <paramref name="timeout" /> ist kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Nachricht mit dem angegebenen <paramref name="id" /> nicht in der Warteschlange eingehen, bevor das Timeout ist abgelaufen.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der Nachricht zu empfangen.</param>
        <summary>In MSMQ 3.0 eingeführt. Empfängt die Nachricht, die der angegebenen Nachschlage-ID aus einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> , deren <see cref="P:System.Messaging.Message.LookupId" /> Eigenschaft entspricht der <paramref name="lookupId" /> übergebene Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bestimmten Suchbezeichner lesen und aus der Warteschlange zu entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Um eine Nachricht mit der angegebenen Nachschlage-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="lookupId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Eines der <see cref="T:System.Messaging.MessageLookupAction" /> Werte, der angibt, wie die Nachricht in der Warteschlange gelesen wird. Geben Sie einen der folgenden:  
  
 <see langword="MessageLookupAction.Current" />: Empfängt die Nachricht gemäß <c>LookupId</c> und aus der Warteschlange entfernt wird.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Nachricht, die von angegebene Nachricht folgt <c>LookupId</c> und aus der Warteschlange entfernt wird.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Nachricht die Nachricht gemäß <c>LookupId</c> und aus der Warteschlange entfernt wird.  
  
 <see langword="MessageLookupAction.First" />: Die erste Nachricht in die Warteschlange empfängt, und entfernt sie aus der Warteschlange. Die <c>LookupId</c> -Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Die letzte Meldung in die Warteschlange empfängt, und entfernt sie aus der Warteschlange. Die <c>LookupId</c> -Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der Nachricht empfangen oder 0. 0 wird verwendet, wenn die erste oder letzte Nachricht in der Warteschlange zugreifen.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>In MSMQ 3.0 eingeführt. Eine bestimmte Nachricht empfängt von einer Transaktionswarteschlange. Die Nachricht kann durch eine Nachschlage-ID oder anhand seiner Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> gemäß der <paramref name="lookupId" /> und <paramref name="action" /> übergeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem bestimmten Suchbezeichner und entfernen es aus der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transaction` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nicht entfernen, werden alle Nachrichten aus der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="lookupId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="action" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageLookupAction" /> Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Eines der <see cref="T:System.Messaging.MessageLookupAction" /> Werte, der angibt, wie die Nachricht in der Warteschlange gelesen wird. Geben Sie einen der folgenden:  
  
 <see langword="MessageLookupAction.Current" />: Empfängt die Nachricht gemäß <c>LookupId</c> und aus der Warteschlange entfernt wird.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Nachricht, die von angegebene Nachricht folgt <c>LookupId</c> und aus der Warteschlange entfernt wird.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Nachricht die Nachricht gemäß <c>LookupId</c> und aus der Warteschlange entfernt wird.  
  
 <see langword="MessageLookupAction.First" />: Die erste Nachricht in die Warteschlange empfängt, und entfernt sie aus der Warteschlange. Die <c>LookupId</c> -Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Die letzte Meldung in die Warteschlange empfängt, und entfernt sie aus der Warteschlange. Die <c>LookupId</c> -Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der Nachricht empfangen oder 0. 0 wird verwendet, wenn die erste oder letzte Nachricht in der Warteschlange zugreifen.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>In MSMQ 3.0 eingeführt. Eine bestimmte Nachricht empfängt aus der Warteschlange, die mit der angegebenen bereits verwendeten Transaktionskontext. Die Nachricht kann durch eine Nachschlage-ID oder anhand seiner Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" /> gemäß der <paramref name="action" /> und <paramref name="lookupId" /> übergeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem bestimmten Suchbezeichner und entfernen es aus der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transactionType` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nicht entfernen, werden alle Nachrichten aus der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Nachricht mit dem angegebenen <paramref name="lookupId" /> konnte nicht gefunden werden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="action" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageLookupAction" /> Elemente.  
  
 - oder -   
  
 Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Nachricht aus der Warteschlange entfernt wurde. Dieses Ereignis wird durch den asynchronen Vorgang <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>wird verwendet, bei der asynchronen Verarbeitung zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>Dient zum Abschließen des Vorgangs, der durch einen Aufruf initiiert <xref:System.Messaging.MessageQueue.BeginReceive%2A> und die Nachricht bei der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst.  
  
 Beim Erstellen eines <xref:System.Messaging.ReceiveCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu Ereignishandlerdelegaten, finden Sie unter [NIB: Ereignisse und Delegaten](http://msdn.microsoft.com/en-us/d98fd58b-fa4f-4598-8378-addf4355a115).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyReceiveCompleted`, fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang in der Warteschlange, die im Pfad ist ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst, die im Beispiel empfängt die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut aus, um ein neues initiieren asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert die Eigenschaften angezeigt, die durch die <see cref="T:System.Messaging.MessageQueue" /> entsprechend den aktuellen Zustand der Ressource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A>synchronisiert die Eigenschaften einer <xref:System.Messaging.MessageQueue> mit ihrer zugeordneten Message Queuing-Server-Ressource. Wenn eine Eigenschaft, z. B. <xref:System.Messaging.MessageQueue.Label%2A> oder <xref:System.Messaging.MessageQueue.Category%2A>, auf dem Server geändert wurde, seit dem Zeitpunkt der <xref:System.Messaging.MessageQueue> erstellt wurde, <xref:System.Messaging.MessageQueue.Refresh%2A> Updates der <xref:System.Messaging.MessageQueue> mit den neuen Informationen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Die Berechtigungsliste zurückgesetzt auf Standardwerte des Betriebssystems. Entfernt alle Berechtigungen der Warteschlange, die Sie an die Standardliste angefügt haben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, Sie die Berechtigungsliste auf ihre Standardwerte zurück. Im Allgemeinen dies Ersteller der Warteschlange alle Berechtigungen und gibt der Gruppe "Jeder" die folgenden Rechte:  
  
-   Rufen Sie die Eigenschaften der Warteschlange an.  
  
-   Rufen Sie die Berechtigungen der Warteschlange.  
  
-   Schreiben Sie in die Warteschlange.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das an die Warteschlange zu senden.</param>
        <summary>Sendet ein Objekt an nicht transaktionale Warteschlange gesendet, auf die verwiesen wird von diesem <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange, verweist der <xref:System.Messaging.MessageQueue>. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine transaktionale Warteschlange verwenden, wird die Nachricht an die Dead Letter-Warteschlange gesendet werden. Wenn Sie möchten die Nachricht als Teil einer Transaktion, die andere Meldungen enthält, verwenden Sie eine Überladung mit einem <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer Nachrichtenwarteschlange her und sendet eine Nachricht an die Warteschlange.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Im folgenden Codebeispiel sendet eine anwendungsdefinierte `Order` Klasse an eine Warteschlange, und klicken Sie dann eine Nachricht aus der Warteschlange empfängt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft nicht festgelegt wurde.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das an die Warteschlange zu senden.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange von diesem <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die transaktionale Warteschlange die <xref:System.Messaging.MessageQueue>, mit einer internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine nicht transaktionale Warteschlange verwenden, kann die Nachricht an die Dead Letter-Warteschlange gesendet werden, ohne eine Ausnahme auszulösen.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 <xref:System.Messaging.MessageQueueTransaction>Apartmentthreading fähig ist, wenn der Apartmentzustand `STA`, die Transaktion in mehreren Threads nicht verwendet werden können. Visual Basic legt den Zustand des Hauptthreads auf `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Zeichenfolge an eine transaktionale Warteschlange gesendet, und klicken Sie dann eine Nachricht aus der Warteschlange empfängt.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft nicht festgelegt wurde.  
  
 - oder -   
  
 Die Message Queuing-Anwendung angegebenen eine falsche Verwendung der Transaktion.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das an die Warteschlange zu senden.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange von diesem <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange verweist die <xref:System.Messaging.MessageQueue>, verwenden einen bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter. Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, der zum Senden der Nachricht verwendet werden sollen. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion gesendet werden soll. Sie können angeben, `None` , wenn eine transaktionale Nachricht an einen nicht transaktionalen Thread gesendet werden soll.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft nicht festgelegt wurde.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das an die Warteschlange zu senden.</param>
        <param name="label">Die Bezeichnung der Nachricht.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange von diesem <see cref="T:System.Messaging.MessageQueue" /> und gibt eine Bezeichnung für die Nachricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange, verweist der <xref:System.Messaging.MessageQueue>. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Meldung identifiziert. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message>, eine Struktur, ein Datenobjekt oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing erben.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine transaktionale Warteschlange verwenden, wird die Nachricht an die Dead Letter-Warteschlange gesendet werden. Wenn Sie möchten die Nachricht als Teil einer Transaktion, die andere Meldungen enthält, verwenden Sie eine Überladung mit einem <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter.  
  
 Die <xref:System.Messaging.MessageQueue.Path%2A> für diese Eigenschaft <xref:System.Messaging.MessageQueue> Instanz muss angegeben werden, bevor die Nachricht zu senden. Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft nicht festgelegt wurde.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das an die Warteschlange zu senden.</param>
        <param name="label">Die Bezeichnung der Nachricht.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange von diesem <see cref="T:System.Messaging.MessageQueue" /> und gibt eine Bezeichnung für die Nachricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die transaktionale Warteschlange die <xref:System.Messaging.MessageQueue>, mit einer internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Meldung identifiziert. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message>, eine Struktur, ein Datenobjekt oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing erben.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine nicht transaktionale Warteschlange verwenden, kann die Nachricht an die Dead Letter-Warteschlange gesendet werden, ohne eine Ausnahme auszulösen.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft  
  
 <xref:System.Messaging.MessageQueueTransaction>Apartmentthreading fähig ist, wenn der Apartmentzustand `STA`, die Transaktion in mehreren Threads nicht verwendet werden können. Visual Basic legt den Zustand des Hauptthreads auf `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft nicht festgelegt wurde.  
  
 - oder -   
  
 Die Message Queuing-Anwendung angegebenen eine falsche Verwendung der Transaktion.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das an die Warteschlange zu senden.</param>
        <param name="label">Die Bezeichnung der Nachricht.</param>
        <param name="transactionType">Eines der <see cref="T:System.Messaging.MessageQueueTransactionType" /> Werte, der beschreibt des Typs des bereits verwendeten Transaktionskontext der Nachricht zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange von diesem <see cref="T:System.Messaging.MessageQueue" /> und gibt eine Bezeichnung für die Nachricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange verweist die <xref:System.Messaging.MessageQueue>, verwenden einen bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter. Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, der zum Senden der Nachricht verwendet werden sollen. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion gesendet werden soll. Sie können angeben, `None` , wenn eine transaktionale Nachricht an einen nicht transaktionalen Thread gesendet werden soll.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Meldung identifiziert.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing erben.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Die Message Queuing-Anwendung angegebenen eine falsche Verwendung der Transaktion.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die <paramref name="transactionType" /> Parameter ist nicht die <see cref="T:System.Messaging.MessageQueueTransactionType" /> Elemente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" /> Eigenschaft nicht festgelegt wurde.  
  
 - oder -   
  
 Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Ein <see cref="T:System.Messaging.AccessControlList" /> , enthält eine oder mehrere Zugriffssteuerungseinträgen, die dem Vertrauensnehmer und die zu erteilenden Berechtigungen angeben.</param>
        <summary>Weist die Zugriffsrechte an die Warteschlange basierend auf den Inhalt der Access Control List.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zu erteilen, verweigern oder widerrufen Rechte, indem Sie eine Auflistung von Zugriffssteuerungseinträgen Vertrauensnehmer und Berechtigungen angeben. Dies ist z. B. verwendet zum Gewähren von Berechtigungen für mehrere Benutzer gleichzeitig.  
  
 Der Vertrauensnehmer, die Sie angeben, bei der Erstellung der `ace` Parameter kann ein einzelner Benutzer, eine Benutzergruppe oder ein Computer sein. Wenn die Vertrauensnehmer einer Person ist, verwenden Sie das Format `DOMAIN` \\ `user`. Sie können angeben, "." für den Vertrauensnehmer auf den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Bei der Erstellung der `dacl` Parameter, Sie fügen <xref:System.Messaging.AccessControlEntry> -Instanzen Ihrer <xref:System.Messaging.AccessControlList> Auflistung. Beim Erstellen jedes Zugriffssteuerungseintrag können Sie generische oder "standard" Zugriffsrechte angeben. Die Rechte für eine Warteschlange können eine beliebige Kombination der folgenden sein:  
  
-   Löschen  
  
-   Sicherheit lesen  
  
-   Schreiben Sie die Sicherheit  
  
-   Synchronisieren  
  
-   Besitzer ändern  
  
-   Lesen  
  
-   Write  
  
-   Ausführen  
  
-   Erforderlich  
  
-   Alle  
  
-   Keine  
  
 Diese Rechte sind ein Satz von Bitflags, die Sie mit dem bitweisen OR-Operator kombinieren können.  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Ein <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> , die einem Benutzer, einen Zugriffstyp und einen Berechtigungstyp angibt.</param>
        <summary>Weist der an die Warteschlange basierend auf den Inhalt eines Zugriffssteuerungseintrags Zugriffsrechte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung erteilen, verweigern oder widerrufen Rechte, indem Sie mit einem Zugriffssteuerungseintrag Vertrauensnehmer und Rechte angeben.  
  
 Der Vertrauensnehmer, die Sie angeben, bei der Erstellung der `ace` Parameter kann ein einzelner Benutzer, eine Benutzergruppe oder ein Computer sein. Wenn die Vertrauensnehmer einer Person ist, verwenden Sie das Format `DOMAIN` \\ `user`. Sie können angeben, "." für den Vertrauensnehmer auf den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Die Rechte für eine Warteschlange, die Sie, in angeben der `rights` Parameter beim Erstellen Ihrer <xref:System.Messaging.MessageQueueAccessControlEntry>, eine beliebige Kombination der folgenden Werte ist möglich:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die `rights` Parameter, die Sie, in der Konstruktor für angeben die `ace` Parameter ist ein Flag, der die <xref:System.Messaging.MessageQueueAccessRights> Enumeration. Er stellt einen Satz von Bitflags, die Sie kombinieren können mit dem bitweisen Operator oder bei der Erstellung der `rights` Parameter.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Die einzelnen Gruppe oder Computer, die zusätzliche Rechte an die Warteschlange abruft.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" /> , der den Satz von Rechten an die Warteschlange, die Message Queuing zuweist angibt der <c>Benutzer</c> übergeben.</param>
        <summary>Erhalten einen Computer, der Gruppe oder der Benutzer die angegebenen Zugriffsrechten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung angegebene Berechtigungen für einen einzelnen Benutzer zu gewähren. Der Benutzer kann es sich um eine beliebige gültige Vertrauensnehmer, die einzelne Benutzer, Gruppen von Benutzern oder einen Computer umfasst. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN` \\ `user` für die `user` Parameter. Sie können angeben, "." für die `user` Parameter, um den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Die Rechte für eine Warteschlange, angegeben der `rights` -Parameter kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die <xref:System.Messaging.MessageQueueAccessRights> -Enumeration stellt einen Satz von Bitflags, die Sie kombinieren können mit dem bitweisen Operator oder zum Erstellen der `rights` Parameter.  
  
 Mit dieser Überladung können Sie nur die Berechtigungen gewähren; Sie können nicht widerrufen oder verweigern. Sie müssen eine andere Überladung verwenden, um explizit alle gewähren <xref:System.Messaging.AccessControlEntryType> außer `Allow`.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Die einzelnen Gruppe oder Computer, die zusätzliche Rechte an die Warteschlange abruft.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" /> , der den Satz von Rechten an die Warteschlange, die Message Queuing zuweist angibt der <c>Benutzer</c> übergeben.</param>
        <param name="entryType">Ein <see cref="T:System.Messaging.AccessControlEntryType" /> die angibt, ob erteilen, verweigern oder widerrufen Sie die Berechtigungen, die gemäß der <c>Rechte</c> Parameter.</param>
        <summary>Gibt einen Computer, der Gruppe oder der Benutzer die angegebenen Zugriffsrechten mit dem angegebenen Zugriffssteuerungstyp (gewähren, verweigern, widerrufen oder festgelegt).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung erteilen, verweigern oder widerrufen angegebenen Rechte für einen einzelnen Benutzer. Der Benutzer kann es sich um eine beliebige gültige Vertrauensnehmer, die einzelne Benutzer, Gruppen von Benutzern oder einen Computer umfasst. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN` \\ `user` für die `user` Parameter. Sie können angeben, "." für die `user` Parameter, um den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Die Rechte für eine Warteschlange, angegeben der `rights` -Parameter kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die <xref:System.Messaging.MessageQueueAccessRights> -Enumeration stellt einen Satz von Bitflags, die Sie kombinieren können mit dem bitweisen Operator oder zum Erstellen der `rights` Parameter.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt das Objekt, das die Ereignishandler-Aufruf aufgrund marshallt eine <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> oder <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> Ereignis.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt darstellt, die aus dem resultierende Ereignishandler-Aufruf marshallt eine <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> oder <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> Ereignis. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> oder <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis tritt auf, aus einer <xref:System.Messaging.MessageQueue.BeginReceive%2A> oder <xref:System.Messaging.MessageQueue.BeginPeek%2A> -Anforderung für einen bestimmten Thread. In der Regel die <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> wird festgelegt, wenn die zugehörige Komponente in einem Steuerelement oder einem Formular befindet, da diese Komponenten an einen bestimmten Thread gebunden sind.  
  
 Das Synchronisieren von Objekt marshallt in der Regel den Aufruf einer Methode in einem einzelnen Thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der angibt, ob die Warteschlange nur Transaktionen akzeptiert.</summary>
        <value>
          <see langword="true" />Wenn der Warteschlange akzeptiert nur Nachrichten, die als Teil einer Transaktion gesendet werden; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transaktionales messaging verweist auf die Kopplung mehrere zusammengehöriger Nachrichten in einer einzelnen Transaktion. Senden von Nachrichten als Teil einer Transaktion wird sichergestellt, dass die Nachrichten in der Reihenfolge zugestellt werden nur einmal übermittelt und aus ihrer Zielwarteschlange erfolgreich abgerufen.  
  
 Wenn eine Warteschlange transaktional ist, akzeptiert er nur Nachrichten, die im Rahmen einer Transaktion gesendet werden. Jedoch eine nicht transaktionale Meldung gesendet oder empfangen aus einer lokalen Transaktionswarteschlange ohne explizit transaktional sein kann <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, und <xref:System.Messaging.MessageQueueTransaction.Abort%2A> Syntax. Wenn eine nicht transaktionale Meldung an eine transaktionale Warteschlange gesendet wird, erstellt diese Komponente eine Transaktion Einzelnachrichten, außer bei Verweisen auf eine Warteschlange auf einem Remotecomputer befindet, die mit einem direkten Formatnamen. In diesem Fall, wenn Sie einen bereits verwendeten Transaktionskontext beim Senden einer Nachricht nicht angeben, wird eine nicht für Sie erstellt und die Nachricht wird an die Dead Letter-Warteschlange gesendet werden.  
  
 Wenn Sie eine nicht transaktionale Meldung an eine transaktionale Warteschlange senden, werden Sie kein Rollback der Nachricht im Falle einer Ausnahme sein.  
  
 <xref:System.Messaging.MessageQueueTransaction>Apartmentthreading fähig ist, wenn der Apartmentzustand `STA`, die Transaktion in mehreren Threads nicht verwendet werden können. Visual Basic legt den Zustand des Hauptthreads auf `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Transactional%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, ob empfangene Nachrichten in die Journalwarteschlange kopiert werden.</summary>
        <value>
          <see langword="true" />Wenn Nachrichten aus der Warteschlange in die Journalwarteschlange kopiert werden; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Message Queuing-Anwendung eine neue Anwendungswarteschlange erstellt, erstellt er automatisch eine zugeordnete Journalwarteschlange am gleichen Speicherort. Journalwarteschlange dient zum Nachverfolgen von Nachrichten aus einer Warteschlange entfernt. Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Journalwarteschlange verfolgt keine Nachrichten aus der Warteschlange entfernt werden, denn ihre Zeit auf den Empfang der Zeitgeber ist abgelaufen, und verfolgt Nachrichten aus der Warteschlange gelöscht werden, mithilfe einen Message Queuing-Verzeichnisdienst (Informationsspeicher oder Active Directory).  
  
 Anwendungen können nicht zum Senden von Nachrichten an Journalwarteschlangen führen; Sie sind mit nur-Lese Zugriff auf diese Warteschlangen beschränkt. Darüber hinaus entfernt Message Queuing nie Nachrichten aus Journalwarteschlangen. Die Anwendung über die Warteschlange muss diese Nachrichten empfangen werden oder durch Löschen der Warteschlangenobjekts löschen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugreifen auf eine Message Queuing-Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle zum Senden von Nachrichten an die Nachrichtenwarteschlange verwendet.</summary>
        <value>Ein Handle für das systemeigene Queue-Objekt, das Sie zum Senden von Nachrichten an die Warteschlange verwenden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.WriteHandle%2A> bietet eine systemeigene Windows-Handle für das Message Queue-Objekt, das zum Senden von Nachrichten an die Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange zu ändern, wird durch einen neuen Wert das Handle geschlossen und erneut geöffnet.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Die Nachrichtenwarteschlange ist nicht für das Schreiben von verfügbar.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
