---
title: Richtlinien für das Formatieren von Code (F#)
description: Erfahren Sie, Richtlinien für Fehlercodes Einzug Formatierung für die Programmiersprache für die Lesbarkeit, Ästhetik, Standardisierung und Kompilierung f#.
ms.date: 05/16/2016
ms.openlocfilehash: 5bb1f9958a21beb795f9174e44f24c7194453fc3
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
ms.locfileid: "33564829"
---
# <a name="code-formatting-guidelines"></a><span data-ttu-id="19825-103">Richtlinien für das Formatieren von Code</span><span class="sxs-lookup"><span data-stu-id="19825-103">Code Formatting Guidelines</span></span>

<span data-ttu-id="19825-104">In diesem Thema werden Richtlinien für Fehlercodes für Einzüge für f# zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="19825-104">This topic summarizes code indentation guidelines for F#.</span></span> <span data-ttu-id="19825-105">Da die Programmiersprache f# empfindlich gegenüber Zeilenumbrüche und Einzüge ist, ist es nicht nur ein Problem Lesbarkeit, Layoutgründen Problem oder Standardisierung Codierungsproblem zur ordnungsgemäßen Formatierung von Code.</span><span class="sxs-lookup"><span data-stu-id="19825-105">Because the F# language is sensitive to line breaks and indentation, it is not just a readability issue, aesthetic issue, or coding standardization issue to format your code correctly.</span></span> <span data-ttu-id="19825-106">Sie müssen den Code für die er ordnungsgemäß kompiliert formatieren.</span><span class="sxs-lookup"><span data-stu-id="19825-106">You must format your code correctly for it to compile correctly.</span></span>


## <a name="general-rules-for-indentation"></a><span data-ttu-id="19825-107">Allgemeine Regeln für den Einzug</span><span class="sxs-lookup"><span data-stu-id="19825-107">General Rules for Indentation</span></span>
<span data-ttu-id="19825-108">Wenn Einzug erforderlich ist, müssen Sie Leerzeichen, nicht-Registerkarten verwenden.</span><span class="sxs-lookup"><span data-stu-id="19825-108">When indentation is required, you must use spaces, not tabs.</span></span> <span data-ttu-id="19825-109">Mindestens eine Leerstelle ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="19825-109">At least one space is required.</span></span> <span data-ttu-id="19825-110">Ihre Organisation kann Codierungsstandards zum Angeben der Anzahl von Leerzeichen zum einrücken verwendet erstellen; drei oder vier Speicherplätzen Einzugsebene an jede Einzugsebene entspricht den Erwartungen.</span><span class="sxs-lookup"><span data-stu-id="19825-110">Your organization can create coding standards to specify the number of spaces to use for indentation; three or four spaces of indentation at each level where indentation occurs is typical.</span></span> <span data-ttu-id="19825-111">Können Sie entsprechend Ihrer Organisation Einzugsstandards durch Ändern der Optionen in Visual Studio Konfigurieren der `Options` (Dialogfeld), in der `Tools` Menü.</span><span class="sxs-lookup"><span data-stu-id="19825-111">You can configure Visual Studio to match your organization's indentation standards by changing the options in the `Options` dialog box, which is available from the `Tools` menu.</span></span> <span data-ttu-id="19825-112">In der `Text Editor` Knoten erweitern `F#` , und klicken Sie dann auf `Tabs`.</span><span class="sxs-lookup"><span data-stu-id="19825-112">In the `Text Editor` node, expand `F#` and then click `Tabs`.</span></span> <span data-ttu-id="19825-113">Eine Beschreibung der verfügbaren Optionen finden Sie in [Optionen, Text-Editor, alle Sprachen, Registerkarten](https://msdn.microsoft.com/library/7sffa753.aspx).</span><span class="sxs-lookup"><span data-stu-id="19825-113">For a description of the available options, see [Options, Text Editor, All Languages, Tabs](https://msdn.microsoft.com/library/7sffa753.aspx).</span></span>

<span data-ttu-id="19825-114">Wenn der Compiler Code analysiert wird, behält es im Allgemeinen einen internen Stapel, der die aktuelle Ebene der Schachtelung angibt.</span><span class="sxs-lookup"><span data-stu-id="19825-114">In general, when the compiler parses your code, it maintains an internal stack that indicates the current level of nesting.</span></span> <span data-ttu-id="19825-115">Wenn Code eingezogen wird, wird keine neue Ebene der Schachtelung erstellt oder auf dem internen Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="19825-115">When code is indented, a new level of nesting is created, or pushed onto this internal stack.</span></span> <span data-ttu-id="19825-116">Wenn ein Konstrukt beendet wird, wird die Ebene per pop ausgelesen.</span><span class="sxs-lookup"><span data-stu-id="19825-116">When a construct ends, the level is popped.</span></span> <span data-ttu-id="19825-117">Der Einzug ist eine Möglichkeit, signalisiert das Ende einer Ebene und im internen Stapel pop, bestimmte Token verursacht jedoch auch die Ebene, z. B. per pop ausgelesen werden die `end` -Schlüsselwort, oder eine schließende geschweifte Klammer oder Klammer.</span><span class="sxs-lookup"><span data-stu-id="19825-117">Indentation is one way to signal the end of a level and pop the internal stack, but certain tokens also cause the level to be popped, such as the `end` keyword, or a closing brace or parenthesis.</span></span>

<span data-ttu-id="19825-118">Code in einem mehrzeiligen Konstrukt, z. B. eine Typdefinition Funktionsdefinition `try...with` -Konstrukt und Schleifenkonstrukte, relativ zur ersten Zeile des Konstrukts eingezogen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="19825-118">Code in a multiline construct, such as a type definition, function definition, `try...with` construct, and looping constructs, must be indented relative to the opening line of the construct.</span></span> <span data-ttu-id="19825-119">Die erste Zeile eingezogene stellt eine Spaltenposition für nachfolgenden Code in dasselbe Konstrukt her.</span><span class="sxs-lookup"><span data-stu-id="19825-119">The first indented line establishes a column position for subsequent code in the same construct.</span></span> <span data-ttu-id="19825-120">Die Einzugsebene wird aufgerufen, eine *Kontext*.</span><span class="sxs-lookup"><span data-stu-id="19825-120">The indentation level is called a *context*.</span></span> <span data-ttu-id="19825-121">Die Spaltenposition legt eine minimale Spalte als bezeichnet ein *Einrückungsgrenze*, für nachfolgende Codezeilen, die sich in demselben Kontext befinden.</span><span class="sxs-lookup"><span data-stu-id="19825-121">The column position sets a minimum column, referred to as an *offside line*, for subsequent lines of code that are in the same context.</span></span> <span data-ttu-id="19825-122">Beim Auftreten einer Codezeile, die kleiner als die festgelegte Spaltenposition eingezogen wird, nimmt der Compiler an, dass der Kontext beendet wurde und jetzt auf der Ebene, in den vorherigen Kontext Codierung.</span><span class="sxs-lookup"><span data-stu-id="19825-122">When a line of code is encountered that is indented less than this established column position, the compiler assumes that the context has ended and that you are now coding at the next level up, in the previous context.</span></span> <span data-ttu-id="19825-123">Der Begriff *Einrückungsende* wird verwendet, um die Bedingung zu beschreiben, in der eine Codezeile löst das Ende eines Konstrukts, da sie nicht weit genug eingezogen ist.</span><span class="sxs-lookup"><span data-stu-id="19825-123">The term *offside* is used to describe the condition in which a line of code triggers the end of a construct because it is not indented far enough.</span></span> <span data-ttu-id="19825-124">Anders ausgedrückt, ist Code auf der linken Seite des Einrückungsgrenze Einrückungsende.</span><span class="sxs-lookup"><span data-stu-id="19825-124">In other words, code to the left of an offside line is offside.</span></span> <span data-ttu-id="19825-125">Im ordnungsgemäß eingezogen Code nutzen Sie das Einrückungsende um das Ende von Konstrukten skizziert.</span><span class="sxs-lookup"><span data-stu-id="19825-125">In correctly indented code, you take advantage of the offside rule in order to delineate the end of constructs.</span></span> <span data-ttu-id="19825-126">Wenn Sie den Einzug nicht ordnungsgemäß verwenden, kann Einrückungsende kann bewirken, dass der Compiler eine Warnung ausgeben oder zu einem falschen Interpretationen des Codes.</span><span class="sxs-lookup"><span data-stu-id="19825-126">If you use indentation improperly, an offside condition can cause the compiler to issue a warning or can lead to the incorrect interpretation of your code.</span></span>

<span data-ttu-id="19825-127">Einrückungsgrenzen werden wie folgt bestimmt.</span><span class="sxs-lookup"><span data-stu-id="19825-127">Offside lines are determined as follows.</span></span>


- <span data-ttu-id="19825-128">Ein `=` zugeordnete Sperrtoken eine `let` eine Einrückungsgrenze in der Spalte der ersten Token nach der `=` anmelden.</span><span class="sxs-lookup"><span data-stu-id="19825-128">An `=` token associated with a `let` introduces an offside line at the column of the first token after the `=` sign.</span></span>


- <span data-ttu-id="19825-129">In einer `if...then...else` Ausdruck, der die Spaltenposition des ersten Tokens nach der `then` Schlüsselwort oder der `else` Schlüsselwort eine Einrückungsgrenze.</span><span class="sxs-lookup"><span data-stu-id="19825-129">In an `if...then...else` expression, the column position of the first token after the `then` keyword or the `else` keyword introduces an offside line.</span></span>


- <span data-ttu-id="19825-130">In einem `try...with` Ausdruck, der das erste Token nach `try` eine Einrückungsgrenze.</span><span class="sxs-lookup"><span data-stu-id="19825-130">In a `try...with` expression, the first token after `try` introduces an offside line.</span></span>


- <span data-ttu-id="19825-131">In einem `match` Ausdruck, der das erste Token nach `with` und dem ersten Token nach jedem `->` Einrückungsgrenzen.</span><span class="sxs-lookup"><span data-stu-id="19825-131">In a `match` expression, the first token after `with` and the first token after each `->` introduce offside lines.</span></span>


- <span data-ttu-id="19825-132">Das erste Token nach `with` in einem Typ Erweiterung eine Einrückungsgrenze.</span><span class="sxs-lookup"><span data-stu-id="19825-132">The first token after `with` in a type extension introduces an offside line.</span></span>


- <span data-ttu-id="19825-133">Das erste Token nach einer öffnenden geschweiften Klammer oder Klammer oder nach dem `begin` Schlüsselwort eine Einrückungsgrenze.</span><span class="sxs-lookup"><span data-stu-id="19825-133">The first token after an opening brace or parenthesis, or after the `begin` keyword, introduces an offside line.</span></span>


- <span data-ttu-id="19825-134">Das erste Zeichen in den Schlüsselwörtern `let`, `if`, und `module` Einrückungsgrenzen.</span><span class="sxs-lookup"><span data-stu-id="19825-134">The first character in the keywords `let`, `if`, and `module` introduce offside lines.</span></span>


<span data-ttu-id="19825-135">Die folgenden Codebeispiele veranschaulichen die Einzugsregeln.</span><span class="sxs-lookup"><span data-stu-id="19825-135">The following code examples illustrate the indentation rules.</span></span> <span data-ttu-id="19825-136">Die print-Anweisungen abhängig hier Einzug, um sie mit den entsprechenden Kontext zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="19825-136">Here, the print statements rely on indentation to associate them with the appropriate context.</span></span> <span data-ttu-id="19825-137">Jedes Mal, wenn der Einzug geändert wird, wird der Kontext per pop ausgelesen wird und in den vorherigen Kontext zurück.</span><span class="sxs-lookup"><span data-stu-id="19825-137">Every time the indentation shifts, the context is popped and returns to the previous context.</span></span> <span data-ttu-id="19825-138">Aus diesem Grund wird ein Leerzeichen am Ende jeder Iteration ausgegeben. "Fertig"!</span><span class="sxs-lookup"><span data-stu-id="19825-138">Therefore, a space is printed at the end of each iteration; "Done!"</span></span> <span data-ttu-id="19825-139">einmal wird nur ausgegeben werden, da die Einrückungsendes, dass er nicht Teil der Schleife ist.</span><span class="sxs-lookup"><span data-stu-id="19825-139">is only printed one time because the offside indentation establishes that it is not part of the loop.</span></span> <span data-ttu-id="19825-140">Das Drucken der Zeichenfolge "Der obersten Ebene Kontext" ist nicht Teil der Funktion.</span><span class="sxs-lookup"><span data-stu-id="19825-140">The printing of the string "Top-level context" is not part of the function.</span></span> <span data-ttu-id="19825-141">Aus diesem Grund ist es zunächst während der statischen Initialisierung gedruckt, bevor die Funktion aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="19825-141">Therefore, it is printed first, during the static initialization, before the function is called.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet1.fs)]

<span data-ttu-id="19825-142">Die Ausgabe lautet wie folgt.</span><span class="sxs-lookup"><span data-stu-id="19825-142">The output is as follows.</span></span>

```
Top-level context

(Negative number) Zero 1 2 3 Done!
```

<span data-ttu-id="19825-143">Wenn Sie lange Zeilen aufheben, muss die Fortsetzung der Zeile weiter das einschließende Konstrukt eingezogen werden.</span><span class="sxs-lookup"><span data-stu-id="19825-143">When you break long lines, the continuation of the line must be indented farther than the enclosing construct.</span></span> <span data-ttu-id="19825-144">Beispielsweise müssen Funktionsargumente weiter das erste Zeichen des Funktionsnamens, eingezogen werden, wie im folgenden Code gezeigt.</span><span class="sxs-lookup"><span data-stu-id="19825-144">For example, function arguments must be indented farther than the first character of the function name, as shown in the following code.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet2.fs)]

<span data-ttu-id="19825-145">Es sind Ausnahmen von diesen Regeln, wie im nächsten Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="19825-145">There are exceptions to these rules, as described in the next section.</span></span>


## <a name="indentation-in-modules"></a><span data-ttu-id="19825-146">Einzug in Modulen</span><span class="sxs-lookup"><span data-stu-id="19825-146">Indentation in Modules</span></span>
<span data-ttu-id="19825-147">Code in einem lokalen Modul muss relativ zum Modul eingezogen werden, Code in einem Modul der obersten Ebene weist jedoch keine eingezogen werden.</span><span class="sxs-lookup"><span data-stu-id="19825-147">Code in a local module must be indented relative to the module, but code in a top-level module does not have to be indented.</span></span> <span data-ttu-id="19825-148">Namespace-Elemente müssen nicht mit Einzug dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="19825-148">Namespace elements do not have to be indented.</span></span>

<span data-ttu-id="19825-149">Die folgenden Codebeispiele veranschaulichen dies.</span><span class="sxs-lookup"><span data-stu-id="19825-149">The following code examples illustrate this.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet3.fs)]
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet4.fs)]

<span data-ttu-id="19825-150">Weitere Informationen finden Sie unter [Module](modules.md).</span><span class="sxs-lookup"><span data-stu-id="19825-150">For more information, see [Modules](modules.md).</span></span>


## <a name="exceptions-to-the-basic-indentation-rules"></a><span data-ttu-id="19825-151">Ausnahmen von den Einzugsregeln für die grundlegende</span><span class="sxs-lookup"><span data-stu-id="19825-151">Exceptions to the Basic Indentation Rules</span></span>
<span data-ttu-id="19825-152">Als allgemeine Regel, ist wie im vorherigen Abschnitt beschrieben Code in mehrzeiligen Konstrukten relativ zu den Einzug der ersten Zeile des Konstrukts eingezogen werden muss, dass das Ende des Konstrukts tritt das erste Einrückungsgrenze bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="19825-152">The general rule, as described in the previous section, is that code in multiline constructs must be indented relative to the indentation of the first line of the construct, and that the end of the construct is determined by when the first offside line occurs.</span></span> <span data-ttu-id="19825-153">Eine Ausnahme von der Regel Informationen zu den beim Kontexten-End-Konstrukte, wie z. B. die `try...with` Ausdruck, der `if...then...else` Ausdruck und die Verwendung von `and` Syntax zum Deklarieren von wechselseitig rekursive Funktionen oder Typen, bestehen aus mehreren Teilen.</span><span class="sxs-lookup"><span data-stu-id="19825-153">An exception to the rule about when contexts end is that some constructs, such as the `try...with` expression, the `if...then...else` expression, and the use of `and` syntax for declaring mutually recursive functions or types, have multiple parts.</span></span> <span data-ttu-id="19825-154">Die weiter unten befindlichen Teile, z. B. Einzug `then` und `else` in ein `if...then...else` Ausdruck, auf der gleichen Ebene wie das Token, der den Ausdruck beginnt, aber statt, der angibt, eine End-to-Kontext, den nächsten Teil desselben Kontexts dar.</span><span class="sxs-lookup"><span data-stu-id="19825-154">You indent the later parts, such as `then` and `else` in an `if...then...else` expression, at the same level as the token that starts the expression, but instead of indicating an end to the context, it represents the next part of the same context.</span></span> <span data-ttu-id="19825-155">Aus diesem Grund eine `if...then...else` Ausdruck geschrieben werden kann, wie im folgenden Codebeispiel dargestellt.</span><span class="sxs-lookup"><span data-stu-id="19825-155">Therefore, an `if...then...else` expression can be written as in the following code example.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet5.fs)]

<span data-ttu-id="19825-156">Die Ausnahme das Einrückungsende gilt nur für die `then` und `else` Schlüsselwörter.</span><span class="sxs-lookup"><span data-stu-id="19825-156">The exception to the offside rule applies only to the `then` and `else` keywords.</span></span> <span data-ttu-id="19825-157">Aus diesem Grund zwar kein Fehler für den Einzug der `then` und `else` darüber hinaus nicht Einzug von Codezeilen in eine `then` Block wird eine Warnung erzeugt.</span><span class="sxs-lookup"><span data-stu-id="19825-157">Therefore, although it is not an error to indent the `then` and `else` further, failing to indent the lines of code in a `then` block produces a warning.</span></span> <span data-ttu-id="19825-158">Dies wird in den folgenden Codezeilen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="19825-158">This is illustrated in the following lines of code.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet6.fs)]
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet7.fs)]

<span data-ttu-id="19825-159">Für Code in eine `else` Block, eine zusätzliche spezielle Regel gilt.</span><span class="sxs-lookup"><span data-stu-id="19825-159">For code in an `else` block, an additional special rule applies.</span></span> <span data-ttu-id="19825-160">Die Warnung im vorherigen Beispiel tritt nur für den Code in der `then` Block nicht auf den Code in der `else` Block.</span><span class="sxs-lookup"><span data-stu-id="19825-160">The warning in the previous example occurs only on the code in the `then` block, not on the code in the `else` block.</span></span> <span data-ttu-id="19825-161">Dadurch können Sie Code schreiben, der für verschiedene Bedingungen am Anfang einer Funktion überprüft werden, ohne dass der Rest des Codes für die Funktion, die möglicherweise in einem `else` Block, um mit Einzug dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="19825-161">This allows you to write code that checks for various conditions at the beginning of a function without forcing the rest of the code for the function, which might be in an `else` block, to be indented.</span></span> <span data-ttu-id="19825-162">Daher können Sie Folgendes schreiben, ohne dass eine Warnung erstellt.</span><span class="sxs-lookup"><span data-stu-id="19825-162">Thus, you can write the following without producing a warning.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet8.fs)]

<span data-ttu-id="19825-163">Eine andere Ausnahme zur Regel, die Kontexte enden, wenn eine Zeile nicht eingezogen wird, soweit Infixoperatoren, z. B. keiner vorherige Zeile ist `+` und `|>`.</span><span class="sxs-lookup"><span data-stu-id="19825-163">Another exception to the rule that contexts end when a line is not indented as far as a previous line is for infix operators, such as `+` and `|>`.</span></span> <span data-ttu-id="19825-164">Zeilen, die mit Infixoperatoren beginnen sind zulässig, um zu beginnen `(1 + oplength)` Spalten vor der normalen Position, ohne dass ein Ende an den Kontext, in dem `oplength` ist die Anzahl der Zeichen, die der Operator bilden.</span><span class="sxs-lookup"><span data-stu-id="19825-164">Lines that start with infix operators are permitted to begin `(1 + oplength)` columns before the normal position without triggering an end to the context, where `oplength` is the number of characters that make up the operator.</span></span> <span data-ttu-id="19825-165">Dies bewirkt, dass das erste Token nach dem Operator an der vorherigen Zeile aus.</span><span class="sxs-lookup"><span data-stu-id="19825-165">This causes the first token after the operator to align with the previous line.</span></span>

<span data-ttu-id="19825-166">Im folgenden Code wird z. B. die `+` Symbol eingezogen zwei Spalten, die kleiner als die vorherige Zeile werden darf.</span><span class="sxs-lookup"><span data-stu-id="19825-166">For example, in the following code, the `+` symbol is permitted to be indented two columns less than the previous line.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet9.fs)]

<span data-ttu-id="19825-167">Obwohl Einzug in der Regel erhöht wird, wenn der Schachtelungsebene höher ist, stehen verschiedene Konstrukte in denen der Compiler Sie den Einzug auf eine niedrigere Spaltenposition zurücksetzen kann.</span><span class="sxs-lookup"><span data-stu-id="19825-167">Although indentation usually increases as the level of nesting becomes higher, there are several constructs in which the compiler allows you to reset the indentation to a lower column position.</span></span>

<span data-ttu-id="19825-168">Die Konstrukte, mit denen ein Zurücksetzen der Spaltenposition lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="19825-168">The constructs that permit a reset of column position are as follows:</span></span>


- <span data-ttu-id="19825-169">Die Texte der anonyme Funktionen.</span><span class="sxs-lookup"><span data-stu-id="19825-169">Bodies of anonymous functions.</span></span> <span data-ttu-id="19825-170">Im folgenden Code startet der print-Ausdruck an einer Position der Spalte, die auf der linken Seite als desto ist die `fun` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="19825-170">In the following code, the print expression starts at a column position that is farther to the left than the `fun` keyword.</span></span> <span data-ttu-id="19825-171">Die Zeile muss jedoch nicht gestartet, in eine Spalte auf der linken Seite des Beginns des vorherigen Einzugs (d. h. links neben der `L` in `List`).</span><span class="sxs-lookup"><span data-stu-id="19825-171">However, the line must not start at a column to the left of the start of the previous indentation level (that is, to the left of the `L` in `List`).</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet10.fs)]

- <span data-ttu-id="19825-172">Konstrukte eingeschlossen, durch Klammern oder durch `begin` und `end` in einem `then` oder `else` -Block ein `if...then...else` Ausdruck, sofern der Einzug nicht kleiner als die Spaltenposition des der `if` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="19825-172">Constructs enclosed by parentheses or by `begin` and `end` in a `then` or `else` block of an `if...then...else` expression, provided the indentation is no less than the column position of the `if` keyword.</span></span> <span data-ttu-id="19825-173">Diese Ausnahme ermöglicht es, einen Codierungsstil, in dem eine öffnende Klammer oder `begin` wird am Ende einer Zeile nach verwendet `then` oder `else`.</span><span class="sxs-lookup"><span data-stu-id="19825-173">This exception allows for a coding style in which an opening parenthesis or `begin` is used at the end of a line after `then` or `else`.</span></span>


- <span data-ttu-id="19825-174">Texte der Module, Klassen, Schnittstellen und Strukturen, getrennt durch `begin...end`, `{...}`, `class...end`, oder `interface...end`.</span><span class="sxs-lookup"><span data-stu-id="19825-174">Bodies of modules, classes, interfaces, and structures delimited by `begin...end`, `{...}`, `class...end`, or `interface...end`.</span></span> <span data-ttu-id="19825-175">Dies ermöglicht eine Formatvorlage, die in der das Schlüsselwort Öffnen einer Typdefinition auf derselben Zeile wie der Typname werden kann, ohne das Erzwingen des gesamten Text mehr als das öffnende Schlüsselwort eingezogen werden.</span><span class="sxs-lookup"><span data-stu-id="19825-175">This allows for a style in which the opening keyword of a type definition can be on the same line as the type name without forcing the whole body to be indented farther than the opening keyword.</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/code-formatting/snippet13.fs)]


## <a name="see-also"></a><span data-ttu-id="19825-176">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="19825-176">See Also</span></span>
[<span data-ttu-id="19825-177">F#-Sprachreferenz</span><span class="sxs-lookup"><span data-stu-id="19825-177">F# Language Reference</span></span>](index.md)
