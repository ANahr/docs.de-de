---
title: Klassen (F#)
description: "Erfahren Sie, wie Klassen F#-Typen sind, die Objekte darstellen, die Eigenschaften, Methoden und Ereignisse aufweisen können."
keywords: Visual F#, F#, funktionale Programmierung
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: d58679d5-7753-4b3b-a12f-6e9f00ed5ba3
ms.openlocfilehash: 2a73baba1f7c1b0d3bd09d22c9d6d9f0524daef3
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="classes"></a><span data-ttu-id="0c7b5-104">Klassen</span><span class="sxs-lookup"><span data-stu-id="0c7b5-104">Classes</span></span>

<span data-ttu-id="0c7b5-105">*Klassen* sind Typen, die Objekte darstellen, die Eigenschaften, Methoden und Ereignisse aufweisen können.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-105">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="0c7b5-106">Syntax</span><span class="sxs-lookup"><span data-stu-id="0c7b5-106">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="0c7b5-107">Hinweise</span><span class="sxs-lookup"><span data-stu-id="0c7b5-107">Remarks</span></span>
<span data-ttu-id="0c7b5-108">Klassen stellen die grundlegende Beschreibung des .NET Objekttypen; die Klasse ist der primäre Typkonzept, das objektorientierte Programmierung in f# unterstützt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-108">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="0c7b5-109">In der vorherigen Syntax der `type-name` ist gültiger Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-109">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="0c7b5-110">Die `type-params` beschreibt optionale generische Typparameter.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-110">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="0c7b5-111">Er besteht aus Typparameternamen und Einschränkungen, die in spitzen Klammern eingeschlossen (`<` und `>`).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-111">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="0c7b5-112">Weitere Informationen finden Sie unter [Generika](generics/index.md) und [Einschränkungen](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-112">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="0c7b5-113">Die `parameter-list` beschreibt Konstruktorparameter.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-113">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="0c7b5-114">Der erste Zugriffsmodifizierer bezieht sich auf den Typ; die zweite bezieht sich auf den primären Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-114">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="0c7b5-115">In beiden Fällen ist die Standardeinstellung `public`.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-115">In both cases, the default is `public`.</span></span>

<span data-ttu-id="0c7b5-116">Sie geben die Basisklasse für eine Klasse mit dem `inherit` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-116">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="0c7b5-117">Sie müssen die Argumente in Klammern ein, für den Konstruktor der Basisklasse angeben.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-117">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="0c7b5-118">Deklarieren Sie Felder oder Werte, die lokal auf die Klasse mithilfe von Funktion `let` Bindungen, und Sie müssen die allgemeinen Regeln für folgen `let` Bindungen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-118">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="0c7b5-119">Die `do-bindings` Abschnitt enthält Code, der bei der objekterstellung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-119">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="0c7b5-120">Die `member-list` besteht aus zusätzliche Konstruktoren, Instanz und statische Methodendeklarationen Schnittstellendeklarationen, abstrakte Bindungen und -Eigenschaft und Ereignis-Deklarationen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-120">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="0c7b5-121">Diese Angaben werden in [Elemente](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-121">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="0c7b5-122">Die `identifier` wird, mit dem optionalen `as` Schlüsselwort weist einen Namen der Instanzvariablen oder Selbstbezeichner, die in der Typdefinition verwendet werden kann, um auf die Instanz des Typs verweisen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-122">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="0c7b5-123">Weitere Informationen finden Sie unter dem Abschnitt Selbstbezeichner weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-123">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="0c7b5-124">Die Schlüsselwörter `class` und `end` , die markiert des Beginns und Ende der Definition sind optional.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-124">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="0c7b5-125">Wechselseitig rekursive-Typen, die Typen, die aufeinander verweisen sind, werden zusammen mit verknüpft die `and` Schlüsselwort ebenso wie wechselseitig rekursive Funktionen sind.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-125">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="0c7b5-126">Ein Beispiel finden Sie im Abschnitt Wechselseitig Rekursive Typen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-126">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="0c7b5-127">Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="0c7b5-127">Constructors</span></span>
<span data-ttu-id="0c7b5-128">Der Konstruktor ist Code, der eine Instanz des Klassentyps erstellt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-128">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="0c7b5-129">Konstruktoren für Klassen funktioniert etwas anders in f# als in anderen Sprachen .NET ausführen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-129">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="0c7b5-130">In einer F#-Klasse, ist immer ein primärer Konstruktor, dessen Argumente sind in beschrieben, die `parameter-list` , folgt den vollständigen Typnamen sowie besteht, dessen Text den `let` (und `let rec`) Bindungen am Anfang der Klassendeklaration, und die `do`Bindungen, die folgen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-130">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="0c7b5-131">Die Argumente des Konstruktors primären sind im Gültigkeitsbereich der Klassendeklaration.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-131">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="0c7b5-132">Sie können zusätzliche Konstruktoren hinzufügen, indem Sie mit der `new` Schlüsselwort, um ein Element wie folgt hinzufügen:</span><span class="sxs-lookup"><span data-stu-id="0c7b5-132">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="0c7b5-133">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="0c7b5-133">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="0c7b5-134">Der Hauptteil der neue Konstruktor muss den primären Konstruktor aufrufen, der am oberen Rand der Klassendeklaration angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-134">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="0c7b5-135">Das folgende Beispiel veranschaulicht dieses Konzept.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-135">The following example illustrates this concept.</span></span> <span data-ttu-id="0c7b5-136">Im folgenden Code `MyClass` verfügt über zwei Konstruktoren, ein primärer Konstruktor, der zwei Argumente und einen anderen Konstruktor, die akzeptiert akzeptiert keine Argumente.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-136">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="0c7b5-137">Teilen Sie und do-Bindungen</span><span class="sxs-lookup"><span data-stu-id="0c7b5-137">let and do Bindings</span></span>

<span data-ttu-id="0c7b5-138">Die `let` und `do` Bindungen in einer Klassendefinition bilden den Hauptteil der primären Klassenkonstruktor, und daher ausgeführt, wenn eine Instanz der Klasse erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-138">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="0c7b5-139">Wenn eine `let` Bindung ist eine Funktion, und klicken Sie dann in einen Member kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-139">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="0c7b5-140">Wenn die `let` Bindung ist ein Wert, der nicht in einer Funktion oder Member verwendet wird, und klicken Sie dann in eine Variable, die lokal an den Konstruktor kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-140">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="0c7b5-141">Andernfalls wird es in ein Feld der Klasse kompiliert.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-141">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="0c7b5-142">Die `do` Ausdrücke, die folgen, werden in den primären Konstruktor kompiliert, und führen Sie Initialisierungscode für jede Instanz.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-142">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="0c7b5-143">Da keine zusätzlichen Konstruktoren immer den primären Konstruktor aufrufen der `let` Bindungen und `do` Bindungen immer ausgeführt, unabhängig davon, welche Konstruktor aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-143">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="0c7b5-144">Durch die erstellte Felder `let` Bindungen in den Methoden und Eigenschaften der Klasse zugegriffen werden können; allerdings sie können nicht zugegriffen werden statische Methoden, auch wenn die statische Methoden eine Instanzvariablen als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-144">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="0c7b5-145">Darauf können nicht zugegriffen werden mithilfe des Selbstbezeichners, falls vorhanden.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-145">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="0c7b5-146">Selbstbezeichner</span><span class="sxs-lookup"><span data-stu-id="0c7b5-146">Self Identifiers</span></span>

<span data-ttu-id="0c7b5-147">Ein *Selbstbezeichner* ist ein Name, der die aktuelle Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-147">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="0c7b5-148">Selbstbezeichner ähneln den `this` -Schlüsselwort in c# oder C++ oder `Me` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-148">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="0c7b5-149">Sie können einen Selbstbezeichner definieren, auf zwei unterschiedliche Arten, je nachdem, ob den Selbstbezeichner im Bereich für die gesamte Klassendefinition oder nur für eine einzelne Methode werden soll.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-149">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="0c7b5-150">Um einen Selbstbezeichner für die gesamte Klasse zu definieren, verwenden die `as` Schlüsselwort nach der schließenden Klammer des Konstruktorparameters aus, und geben Sie den Namen des Bezeichners.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-150">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="0c7b5-151">Geben Sie einen Selbstbezeichner für nur eine Methode definieren, des Selbstbezeichners in der Memberdeklaration unmittelbar vor dem Methodennamen und einen Punkt (.) als Trennzeichen ein.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-151">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="0c7b5-152">Im folgenden Codebeispiel wird veranschaulicht, die zwei Möglichkeiten, einen Selbstbezeichner zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-152">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="0c7b5-153">In der ersten Zeile der `as` Schlüsselwort wird verwendet, um der Selbstbezeichner definieren.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-153">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="0c7b5-154">In der fünften Zeile wird der Bezeichner `this` wird verwendet, um einen Selbstbezeichner definieren, deren Bereich beschränkt auf die Methode ist `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-154">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="0c7b5-155">Im Gegensatz zu können in anderen .NET-Sprachen Sie den Selbstbezeichner name beliebig; Sie sind nicht eingeschränkten Namen wie z. B. `self`, `Me`, oder `this`.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-155">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="0c7b5-156">Der Selbstbezeichner, die mit deklariert wird die `as` Schlüsselwort wird nicht initialisiert, bis nach der `let` Bindungen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-156">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="0c7b5-157">Es kann nicht aus diesem Grund verwendet werden, der `let` Bindungen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-157">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="0c7b5-158">Sie können den Selbstbezeichner in der `do` im Abschnitt über Bindungen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-158">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="0c7b5-159">Generische Typparameter</span><span class="sxs-lookup"><span data-stu-id="0c7b5-159">Generic Type Parameters</span></span>

<span data-ttu-id="0c7b5-160">Generische Typparameter in spitzen Klammern angegeben werden (`<` und `>`), in Form eines einfachen Anführungszeichens gefolgt von einem Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-160">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="0c7b5-161">Mehrere generischen Typparameter sind durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-161">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="0c7b5-162">Der generische Typparameter ist der Gültigkeitsbereich der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-162">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="0c7b5-163">Im folgenden Codebeispiel wird veranschaulicht, wie an generischer Typparameter.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-163">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="0c7b5-164">Typargumente werden hergeleitet, wenn der Typ verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-164">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="0c7b5-165">Im folgenden Code ist der abgeleitete Typ eine Sequenz von Tupeln.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-165">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="0c7b5-166">Angeben von Vererbung</span><span class="sxs-lookup"><span data-stu-id="0c7b5-166">Specifying Inheritance</span></span>

<span data-ttu-id="0c7b5-167">Die `inherit` -Klausel kennzeichnet die direkte Basisklasse aus, sofern vorhanden.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-167">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="0c7b5-168">In F# erläutert werden ist nur eine direkte Basisklasse zulässig.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-168">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="0c7b5-169">Schnittstellen, die eine Klasse implementiert, werden die Basisklassen nicht berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-169">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="0c7b5-170">Schnittstellen werden in erläutert die [Schnittstellen](Interfaces.md) Thema.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-170">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="0c7b5-171">Sie können die Methoden und Eigenschaften der Basisklasse der abgeleiteten Klasse zugreifen, mit dem Programmiersprachen-Schlüsselwort `base` als Bezeichner an, gefolgt von einem Punkt (.) und den Namen des Elements.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-171">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="0c7b5-172">Weitere Informationen finden Sie unter [Vererbung](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-172">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="0c7b5-173">Abschnitt "Mitglieder"</span><span class="sxs-lookup"><span data-stu-id="0c7b5-173">Members Section</span></span>
<span data-ttu-id="0c7b5-174">In diesem Abschnitt können Sie statische oder Instanzmethoden, Eigenschaften, schnittstellenimplementierungen, abstrakte Member, Ereignisdeklarationen und zusätzliche Konstruktoren definieren.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-174">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="0c7b5-175">Können, und führen Sie Bindungen darf nicht in diesem Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-175">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="0c7b5-176">Da eine Vielzahl von f#-Typen, zusätzlich zu den Klassen Elemente hinzugefügt werden können, diese in einem separaten Thema behandelt [Elemente](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-176">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="0c7b5-177">Wechselseitig rekursive Typen</span><span class="sxs-lookup"><span data-stu-id="0c7b5-177">Mutually Recursive Types</span></span>
<span data-ttu-id="0c7b5-178">Wenn Sie Typen, die miteinander in einer kreisförmigen Weise verweisen definieren, Sie Zeichenfolge zusammen die Typdefinitionen unter Verwendung der `and` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-178">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="0c7b5-179">Die `and` -Schlüsselwort ersetzt die `type` Schlüsselwort für alle außer der ersten Definition wie folgt.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-179">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="0c7b5-180">Die Ausgabe ist eine Liste aller Dateien im aktuellen Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-180">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="0c7b5-181">Verwenden von Klassen, Unions, Datensätze und Strukturen</span><span class="sxs-lookup"><span data-stu-id="0c7b5-181">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="0c7b5-182">Angesichts der Vielzahl von Typen zur Auswahl, müssen Sie genau verstehen, was für jeden Typ entwickelt wurde, um den geeigneten Typ für eine bestimmte Situation auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-182">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="0c7b5-183">Klassen sind für die Verwendung in objektorientierten Programmierung Kontexten vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-183">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="0c7b5-184">Objektorientierte Programmierung ist der bestimmende Paradigma in Anwendungen, die für .NET Framework geschrieben wurden verwendet.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-184">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="0c7b5-185">Wenn der f#-Code hat enge Zusammenarbeit mit .NET Framework oder einer anderen objektorientierten Bibliothek ermöglicht und besonders, wenn Sie z. B. eine UI-Bibliothek eine objektorientierte Typsystem erweitern müssen, Klassen eignen sich wahrscheinlich.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-185">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="0c7b5-186">Wenn Sie nicht eng mit dem objektorientierten Code Zusammenwirken mit sind oder wenn Sie Code schreiben, die eigenständig und daher über häufige Interaktion mit Code mit dem objektorientierten geschützt ist, Sie sollten erwägen, Datensätze und Unterscheidungs-Unions.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-186">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="0c7b5-187">Eine einzelne, gut, um herauszufinden,: Out Unterscheidungs-Union, zusammen mit den entsprechenden Code für den Musterabgleich häufig als eine einfachere Alternative zu einer Objekthierarchie verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-187">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="0c7b5-188">Weitere Informationen zu Unterscheidungs-Unions, finden Sie unter [Unterscheidungs-Unions](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-188">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="0c7b5-189">Datensätze haben den Vorteil, dass er einfacher als Klassen allerdings Datensätze sind nicht geeignet, wenn die Anforderungen eines Typs überschreiten, was mit ihren Einfachheit erreicht werden kann.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-189">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="0c7b5-190">Datensätze sind im Grunde einfache Aggregate für Werte ohne separate Konstruktoren, die benutzerdefinierte Aktionen ausführen können, ohne ausgeblendete Felder und ohne Vererbung oder schnittstellenimplementierungen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-190">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="0c7b5-191">Auch Elemente wie z. B. Eigenschaften und Methoden auf Datensätze, deren Verhalten zu komplizieren hinzugefügt werden können, werden die Felder in einem Datensatz gespeichert nach wie vor ein einfaches Aggregat von Werten.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-191">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="0c7b5-192">Weitere Informationen zu Datensätzen finden Sie unter [Datensätze](records.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-192">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="0c7b5-193">Strukturen sind auch nützlich für kleine Datenaggregate, aber sie unterscheiden sich von Klassen und Datensätzen insofern, dass sie .NET Werttypen sind.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-193">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="0c7b5-194">Klassen und Datensätzen sind .NET Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-194">Classes and records are .NET reference types.</span></span> <span data-ttu-id="0c7b5-195">Die Semantik von Werttypen und Verweistypen unterscheiden sich insofern, dass Werttypen als Wert übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-195">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="0c7b5-196">Dies bedeutet, dass sie kopiert werden bit für Bit, wenn sie als Parameter übergeben oder von einer Funktion zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-196">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="0c7b5-197">Sie werden auch auf dem Stapel gespeichert oder, wenn sie als ein Feld, in das übergeordnete Objekt anstelle von eingebetteten verwendet werden, die in eigenen Position auf dem Heap gespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-197">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="0c7b5-198">Strukturen sind deshalb für häufig verwendete Daten geeignet, wenn der Aufwand für den Zugriff auf den Heap ein Problem aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="0c7b5-198">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="0c7b5-199">Weitere Informationen über Strukturen finden Sie unter [Strukturen](structures.md).</span><span class="sxs-lookup"><span data-stu-id="0c7b5-199">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="0c7b5-200">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="0c7b5-200">See Also</span></span>
[<span data-ttu-id="0c7b5-201">F#-Sprachreferenz</span><span class="sxs-lookup"><span data-stu-id="0c7b5-201">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="0c7b5-202">Mitglieder</span><span class="sxs-lookup"><span data-stu-id="0c7b5-202">Members</span></span>](members/index.md)

[<span data-ttu-id="0c7b5-203">Vererbung</span><span class="sxs-lookup"><span data-stu-id="0c7b5-203">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="0c7b5-204">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="0c7b5-204">Interfaces</span></span>](interfaces.md)

