---
title: Überblick [F#]
description: Untersuchen Sie in dieser Tour mithilfe von Codebeispielen einige der wichtigsten Funktionen der Programmiersprache F#.
ms.date: 02/28/2018
ms.openlocfilehash: 63c38d59376a148c439482fcf47488fc72b7b8aa
ms.sourcegitcommit: d8bf4976eafe3289275be3811e7cb721bfff7e1e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/04/2018
ms.locfileid: "34753486"
---
# <a name="tour-of-f"></a><span data-ttu-id="02a02-103">Überblick [F#]</span><span class="sxs-lookup"><span data-stu-id="02a02-103">Tour of F#</span></span> #

<span data-ttu-id="02a02-104">Der beste Weg zum Kennenlernen von F# besteht darin, F#-Code zu lesen und zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="02a02-104">The best way to learn about F# is to read and write F# code.</span></span>  <span data-ttu-id="02a02-105">Dieser Artikel bietet eine Tour durch einige der wichtigsten Funktionen der Programmiersprache F# und stellt einige Codebeispiele bereit, die Sie selbst ausführen können.</span><span class="sxs-lookup"><span data-stu-id="02a02-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span>  <span data-ttu-id="02a02-106">Weitere Informationen zum Einrichten einer Entwicklungsumgebung finden Sie unter [Erste Schritte](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="02a02-106">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="02a02-107">Es gibt zwei primäre Konzepte in F#: Funktionen und Typen. </span><span class="sxs-lookup"><span data-stu-id="02a02-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="02a02-108">In dieser Tour werden Features der Sprache vorgestellt, die unter diese beiden Konzepte fallen.</span><span class="sxs-lookup"><span data-stu-id="02a02-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="02a02-109">Funktionen und Module</span><span class="sxs-lookup"><span data-stu-id="02a02-109">Functions and Modules</span></span>

<span data-ttu-id="02a02-110">Die wesentlichen Bausteine eines F#-Programms sind ***Funktionen***, die in ***Modulen*** organisiert sind.</span><span class="sxs-lookup"><span data-stu-id="02a02-110">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="02a02-111">[Funktionen](language-reference/functions/index.md) arbeiten mit Eingaben, um Ausgaben zu erzeugen, und sie werden in [Modulen](language-reference/modules.md) organisiert – der primären Form der Gruppierung in F#.</span><span class="sxs-lookup"><span data-stu-id="02a02-111">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="02a02-112">Die Module werden mithilfe der [`let`-Bindung](language-reference/functions/let-bindings.md) definiert, die die Funktion benennt und ihre Argumente definiert.</span><span class="sxs-lookup"><span data-stu-id="02a02-112">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="02a02-113">`let` Bindungen sind auch an, wie Sie einen Wert an einen ähnlichen Namen, einer Variablen in anderen Sprachen wie binden.</span><span class="sxs-lookup"><span data-stu-id="02a02-113">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="02a02-114">`let` Bindungen sind ***unveränderlichen*** standardmäßig, d. h., sobald ein Wert oder eine Funktion mit einem Namen gebunden wird, es geändert werden kann direkte.</span><span class="sxs-lookup"><span data-stu-id="02a02-114">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="02a02-115">Dies steht im Gegensatz zu Variablen in anderen Sprachen, von denen sind ***änderbare***, d. h., deren Werte kann geändert werden zu einem beliebigen Zeitpunkt zeitlich.</span><span class="sxs-lookup"><span data-stu-id="02a02-115">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="02a02-116">Wenn Sie eine änderbare Bindung benötigen, können Sie `let mutable ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="02a02-116">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="02a02-117">Zahlen, boolesche Werte und Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="02a02-117">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="02a02-118">Als eine .NET-Sprache unterstützt F# die gleichen zugrunde liegenden [primitiven Typen](language-reference/primitive-types.md).</span><span class="sxs-lookup"><span data-stu-id="02a02-118">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="02a02-119">So werden die verschiedenen numerischen Datentypen in F# dargestellt:</span><span class="sxs-lookup"><span data-stu-id="02a02-119">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="02a02-120">Und so sehen boolesche Werte und die grundlegende bedingte Logik aus:</span><span class="sxs-lookup"><span data-stu-id="02a02-120">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="02a02-121">Eine grundlegende Manipulation von [Zeichenfolgen](language-reference/strings.md) sieht wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="02a02-121">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="02a02-122">Tupel</span><span class="sxs-lookup"><span data-stu-id="02a02-122">Tuples</span></span>

<span data-ttu-id="02a02-123">[Tupel](language-reference/tuples.md) sind ein großes Thema in F#.</span><span class="sxs-lookup"><span data-stu-id="02a02-123">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="02a02-124">Bei Tupeln handelt sich um eine Gruppe von unbenannten, jedoch sortierten Werten, die als eigenständige Werte betrachten werden können.</span><span class="sxs-lookup"><span data-stu-id="02a02-124">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="02a02-125">Stellen Sie sich Werte vor, die aus anderen Werten aggregiert werden.</span><span class="sxs-lookup"><span data-stu-id="02a02-125">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="02a02-126">Sie können vielseitig eingesetzt werden, z.B. für ein bequemes Zurückgeben mehrerer Werte aus einer Funktion oder zur Vereinfachung in einer Ad-hoc-Gruppierung.</span><span class="sxs-lookup"><span data-stu-id="02a02-126">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="02a02-127">Ab F# 4.1 können Sie auch `struct`-Tupel erstellen.</span><span class="sxs-lookup"><span data-stu-id="02a02-127">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="02a02-128">Diese bieten vollständige Interoperabilität mit Tupeln aus C# 7/Visual Basic 15, bei denen es sich ebenfalls um `struct`-Tupel handelt:</span><span class="sxs-lookup"><span data-stu-id="02a02-128">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="02a02-129">Folgendes muss jedoch beachtet werden: `struct`-Tupel sind keine Werttypen, deshalb können sie nicht implizit in Referenz-Tupel konvertiert werden oder umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="02a02-129">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="02a02-130">Sie müssen eine explizite Konvertierung zwischen Referenz-Tupel und Struktur-Tupel durchführen.</span><span class="sxs-lookup"><span data-stu-id="02a02-130">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="02a02-131">Pipelines und Komposition</span><span class="sxs-lookup"><span data-stu-id="02a02-131">Pipelines and Composition</span></span>

<span data-ttu-id="02a02-132">Leiten Sie Operatoren wie z. B. `|>` werden ausgiebig bei der Verarbeitung von Daten in f# verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="02a02-132">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="02a02-133">Diese Operatoren sind Funktionen, die Sie zum Einrichten von "Pipelines" Funktionen in flexibel zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="02a02-133">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="02a02-134">Im folgenden Beispiel wird exemplarisch davon ab, wie Sie diese Operatoren zum Erstellen einer einfachen funktionale Pipeline nutzen können:</span><span class="sxs-lookup"><span data-stu-id="02a02-134">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="02a02-135">Im vorherigen Beispiel vorgenommen Verwendung vieler Funktionen von f#, einschließlich der Liste Verarbeitungsfunktionen, erstklassige Funktionen und [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="02a02-135">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="02a02-136">Obwohl ein umfassendes Verständnis all dieser Konzepte einer weiterführenden Erläuterung bedarf, sollte klar geworden sein, wie einfach Funktionen beim Erstellen von Pipelines zum Verarbeiten von Daten verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="02a02-136">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="02a02-137">Listen, Arrays und Sequenzen</span><span class="sxs-lookup"><span data-stu-id="02a02-137">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="02a02-138">Listen, Arrays und Sequenzen sind drei primäre Sammlungstypen in f#-Kernbibliothek.</span><span class="sxs-lookup"><span data-stu-id="02a02-138">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="02a02-139">[Listet](language-reference/lists.md) sind geordnete, unveränderliche Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="02a02-139">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="02a02-140">Sie sind einfach verknüpfte Listen, was bedeutet, dass sie für die Enumeration, aber eine schlechte Wahl für wahlfreien Zugriff und Verkettungen vorgesehen sind, sollten sie sich bei großen.</span><span class="sxs-lookup"><span data-stu-id="02a02-140">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="02a02-141">Diese im Gegensatz zu Listen in anderen gängigen Sprachen, die zur Darstellung von Listen in der Regel keine einfach verknüpfte Liste verwenden.</span><span class="sxs-lookup"><span data-stu-id="02a02-141">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="02a02-142">[Arrays](language-reference/arrays.md) fester Größe, werden *änderbare* Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="02a02-142">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="02a02-143">Sie unterstützt den schnellen zufälligen Zugriff von Elementen und sind schneller als ein F#-werden aufgeführt, da sie nur zusammenhängenden Speicherblöcke sind.</span><span class="sxs-lookup"><span data-stu-id="02a02-143">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="02a02-144">[Sequenzen](language-reference/sequences.md) sind eine logische Reihe von Elementen, alle den gleichen Typ aufweisen.</span><span class="sxs-lookup"><span data-stu-id="02a02-144">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="02a02-145">Hierbei handelt es sich um einen allgemeineren Typ als die "View" in jeder logische Reihe von Elementen, die Arrays und Listen.</span><span class="sxs-lookup"><span data-stu-id="02a02-145">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="02a02-146">Auch hervorzuheben, da sie stehen ***lazy***, was bedeutet, dass die Elemente berechnet werden können, nur, wenn sie benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="02a02-146">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="02a02-147">Rekursive Funktionen</span><span class="sxs-lookup"><span data-stu-id="02a02-147">Recursive Functions</span></span>

<span data-ttu-id="02a02-148">Verarbeiten von Auflistungen oder Elementsequenzen erfolgt in der Regel mit [Rekursion](language-reference/functions/index.md#recursive-functions) in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="02a02-148">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="02a02-149">Zwar f# unterstützt für Schleifen und imperativen Programmierung, ist Rekursion bevorzugte, da sie einfacher sicherstellen Richtigkeit ist.</span><span class="sxs-lookup"><span data-stu-id="02a02-149">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

>[!NOTE]
<span data-ttu-id="02a02-150">Das folgende Beispiel verwendet die Mustervergleich über die `match` Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="02a02-150">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="02a02-151">Dieses grundlegende Konstrukt wird weiter unten in diesem Artikel behandelt.</span><span class="sxs-lookup"><span data-stu-id="02a02-151">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="02a02-152">F# bietet auch vollständige Unterstützung für Tail aufrufen Optimierung, dies ist eine Methode für die rekursive Aufrufe zu optimieren, sodass sie nur so schnell wie eine Schleifenkonstruktion sind.</span><span class="sxs-lookup"><span data-stu-id="02a02-152">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="02a02-153">Datensatz- und diskriminierte Union-Typen</span><span class="sxs-lookup"><span data-stu-id="02a02-153">Record and Discriminated Union Types</span></span>

<span data-ttu-id="02a02-154">Datensatz und Union-Typen sind zwei grundlegende Datentypen, die in f#-Code verwendet und sind in der Regel die beste Möglichkeit zum Darstellen der Daten in einem f#-Programm.</span><span class="sxs-lookup"><span data-stu-id="02a02-154">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="02a02-155">Obwohl dadurch diese Klassen ähnlich wie in anderen Sprachen wird, ist eine der ihre wichtigsten Unterschiede Strukturgleichheit Semantik besitzen.</span><span class="sxs-lookup"><span data-stu-id="02a02-155">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="02a02-156">Dies bedeutet, dass sie "systemintern" vergleichbar sein, und auf Gleichheit einfach ist – nur überprüft, ob eine gleich dem anderem ist.</span><span class="sxs-lookup"><span data-stu-id="02a02-156">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="02a02-157">[Datensätze](language-reference/records.md) sind ein Aggregat benannter Werte, mit optionalen Elementen (z. B. Methoden).</span><span class="sxs-lookup"><span data-stu-id="02a02-157">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="02a02-158">Wenn Sie mit c# oder Java vertraut sind, sollte dann diese ähnlich POCOs oder POJOs - nur bei der strukturellen gleichheitsüberprüfung und weniger Zeremonie können.</span><span class="sxs-lookup"><span data-stu-id="02a02-158">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="02a02-159">Ab f# 4.1, kann auch Datensätze gleichzeitig als repräsentieren `struct`s.</span><span class="sxs-lookup"><span data-stu-id="02a02-159">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="02a02-160">Dies erfolgt mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="02a02-160">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="02a02-161">[Unterscheidungs-Unions (Verteilungseinheiten)](language-reference/discriminated-unions.md) sind Werte, die eine Anzahl von benannten Formulare oder Fälle werden konnte.</span><span class="sxs-lookup"><span data-stu-id="02a02-161">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="02a02-162">Geben Sie im gespeicherten Daten von mehreren unterschiedlichen Werten sind möglich.</span><span class="sxs-lookup"><span data-stu-id="02a02-162">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="02a02-163">Sie können auch als Verteilungseinheiten *einzelnen Fall Unterscheidungs-Unions*, damit die mit der Domäne Modellieren von primitiven Typen.</span><span class="sxs-lookup"><span data-stu-id="02a02-163">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="02a02-164">Oft, Zeichenfolgen und anderen primitiven Typen werden verwendet, um etwas darstellen und werden daher eine bestimmte Bedeutung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="02a02-164">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="02a02-165">Allerdings kann nur die primitiven Darstellung der Daten dazu führen, Zuweisen von versehentlich ein falscher Wert!</span><span class="sxs-lookup"><span data-stu-id="02a02-165">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="02a02-166">Jede Art von Informationen wie eine unterschiedliche einzelnen Fall Union darstellt, kann Richtigkeit in diesem Szenario erzwingen.</span><span class="sxs-lookup"><span data-stu-id="02a02-166">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="02a02-167">Wie im obigen Beispiel wird veranschaulicht, um den zugrunde liegenden Wert in einen einzelnen Fall Unterscheidungs-Union, zu erhalten, müssen Sie explizit entpacken.</span><span class="sxs-lookup"><span data-stu-id="02a02-167">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="02a02-168">Darüber hinaus unterstützen Verteilungseinheiten auch rekursive Definitionen, sodass Sie problemlos Strukturen als auch grundsätzlich rekursive Daten darzustellen.</span><span class="sxs-lookup"><span data-stu-id="02a02-168">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="02a02-169">Beispielsweise sieht wie Sie mit einer binären Suchstruktur darstellen können `exists` und `insert` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="02a02-169">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="02a02-170">Da Verteilungseinheiten Sie zur Darstellung der rekursive Struktur der Struktur in den Datentyp ermöglichen, Vorgänge für diese rekursive Struktur ist einfach und Korrektheit gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="02a02-170">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="02a02-171">Es wird auch in einem Mustervergleich müssen unterstützt, wie unten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="02a02-171">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="02a02-172">Sie können darüber hinaus Verteilungseinheiten als darstellen `struct`s mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="02a02-172">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="02a02-173">Es gibt jedoch zwei wichtige Dinge zu bedenken, wenn dies zu erheblichen:</span><span class="sxs-lookup"><span data-stu-id="02a02-173">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="02a02-174">Eine Struktur DU kann nicht rekursiv definiert werden.</span><span class="sxs-lookup"><span data-stu-id="02a02-174">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="02a02-175">Eine Struktur DU muss eindeutige Namen für jeden der Fälle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="02a02-175">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="02a02-176">Oben genannten Kriterien nicht einhalten, führt zu einem Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="02a02-176">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="02a02-177">Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="02a02-177">Pattern Matching</span></span>

<span data-ttu-id="02a02-178">[Übereinstimmende Muster](language-reference/pattern-matching.md) ist die F#-Sprache-Funktion die Richtigkeit für Vorgänge für f#-Typen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="02a02-178">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="02a02-179">In den obigen Beispielen werden Sie möglicherweise bemerkt, dass relativ viel `match x with ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="02a02-179">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="02a02-180">Dieses Konstrukt kann den Compiler, der weiß, die "Shape" Datentypen, zwingen Sie beim Verwenden eines Datentyp durch was bekannt ist als vollständig Mustervergleich aller möglichen Fälle berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="02a02-180">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="02a02-181">Dies ist äußerst leistungsfähigen auf Richtigkeit, und zum "lift", was normalerweise Besorgnis Runtime in Kompilierung wäre raffinierter verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="02a02-181">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L739)]

<span data-ttu-id="02a02-182">Sie können auch die Kurzform `function` Konstrukt, die für den Mustervergleich, nützlich, ist Wenn Sie schreiben gerade, Funktionen, die Stellen nutzen [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments):</span><span class="sxs-lookup"><span data-stu-id="02a02-182">You can also use the shorthand `function` construct for pattern matching, which is useful when you're writing functions which make use of [Partial Application](language-reference/functions/index.md#partial-application-of-arguments):</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L741-L759)]

<span data-ttu-id="02a02-183">Etwas Ihnen möglicherweise aufgefallen ist die Verwendung von der `_` Muster.</span><span class="sxs-lookup"><span data-stu-id="02a02-183">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="02a02-184">Dies bezeichnet man die [Platzhaltermuster](language-reference/pattern-matching.md#wildcard-pattern), dies ist eine Möglichkeit, dies zu sagen "Ich kümmern sich nicht darum was etwas ist".</span><span class="sxs-lookup"><span data-stu-id="02a02-184">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="02a02-185">Obwohl es bequem erscheint, können Sie versehentlich umgehen vollständig Mustervergleich und nicht mehr vom Zeitpunkt der Kompilierung Erzwingungen profitieren, wenn Sie nicht mit Bedacht vorgehen `_`.</span><span class="sxs-lookup"><span data-stu-id="02a02-185">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="02a02-186">Es wird am besten verwendet, wenn Sie bestimmte Teile eines Typs zerlegten interessieren nicht wenn Muster entsprechen, oder der abschließenden Klausel, wenn Sie alle sinnvollen Fälle in einem Mustervergleichsausdruck aufgezählt haben.</span><span class="sxs-lookup"><span data-stu-id="02a02-186">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="02a02-187">[Aktive Muster](language-reference/active-patterns.md) anderes leistungsfähiges Instrument, mit dem Mustervergleich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="02a02-187">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="02a02-188">Dateien können Sie die Eingabedaten in benutzerdefinierte Formulare, Zerlegen von an der Aufrufsite für Muster Übereinstimmung zu partitionieren.</span><span class="sxs-lookup"><span data-stu-id="02a02-188">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="02a02-189">Sie können auch parametrisiert werden somit auf die Partition als Funktion definiert.</span><span class="sxs-lookup"><span data-stu-id="02a02-189">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="02a02-190">Erweitern im vorherige Beispiel zur Unterstützung von aktive Muster sieht ungefähr so aus:</span><span class="sxs-lookup"><span data-stu-id="02a02-190">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L761-L783)]

## <a name="optional-types"></a><span data-ttu-id="02a02-191">Optionale Typen</span><span class="sxs-lookup"><span data-stu-id="02a02-191">Optional Types</span></span>

<span data-ttu-id="02a02-192">Ein Sonderfall des Unterscheidungs-Union-Typen wird der Optionstyp der eignet sich daher, dass es ein Teil der f#-Kernbibliothek handelt.</span><span class="sxs-lookup"><span data-stu-id="02a02-192">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="02a02-193">[Der Optionstyp](language-reference/options.md) ist ein Typ, der eine der beiden Fälle darstellt: ein Wert oder nichts überhaupt.</span><span class="sxs-lookup"><span data-stu-id="02a02-193">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="02a02-194">Es wird in jedem Szenario verwendet, in dem ein Wert kann oder möglicherweise nicht von einem bestimmten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="02a02-194">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="02a02-195">Dies erzwingt dann für beide Fälle Besorgnis Kompilierzeit statt Besorgnis Runtime somit berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="02a02-195">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="02a02-196">Diese werden häufig in APIs verwendet, in denen `null` wird verwendet, um "nichts" stattdessen darstellen somit Dadurch entfällt die Notwendigkeit kümmern `NullReferenceException` in vielen Fällen.</span><span class="sxs-lookup"><span data-stu-id="02a02-196">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L791-L811)]

## <a name="units-of-measure"></a><span data-ttu-id="02a02-197">Maßeinheiten</span><span class="sxs-lookup"><span data-stu-id="02a02-197">Units of Measure</span></span>

<span data-ttu-id="02a02-198">Eine einzigartige Funktion des # des Typsystems ist die Möglichkeit, den Kontext für numerische Literale über Einheiten festzulegen.</span><span class="sxs-lookup"><span data-stu-id="02a02-198">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="02a02-199">[Maßeinheiten](language-reference/units-of-measure.md) ermöglichen es Ihnen, einen numerischen Typ mit einer Einheit, z. B. Meter, zuordnen und haben Funktionen ausführen können numerische Literale, anstatt Einheiten.</span><span class="sxs-lookup"><span data-stu-id="02a02-199">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="02a02-200">Dadurch kann der Compiler, stellen Sie sicher, dass die Typen von numerischen Literalen übergebene sinnvoll unter einem bestimmten Kontext, somit-Runtime-Fehler dieser Art von Arbeit zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="02a02-200">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L818-L839)]

<span data-ttu-id="02a02-201">Die f#-Kernbibliothek definiert viele SI Einheitentypen und einheitenkonvertierungen.</span><span class="sxs-lookup"><span data-stu-id="02a02-201">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="02a02-202">Um mehr zu erfahren, sehen Sie sich die [Microsoft.FSharp.Data.UnitSystems.SI-Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="02a02-202">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="02a02-203">Klassen und Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="02a02-203">Classes and Interfaces</span></span>

<span data-ttu-id="02a02-204">F# bietet auch vollständige Unterstützung für .NET-Klassen, [Schnittstellen](language-reference/interfaces.md), [abstrakte Klassen](language-reference/abstract-classes.md), [Vererbung](language-reference/inheritance.md)und so weiter.</span><span class="sxs-lookup"><span data-stu-id="02a02-204">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="02a02-205">[Klassen](language-reference/classes.md) sind Typen, die .NET-Objekten darstellen wofür können Eigenschaften, Methoden und Ereignisse als seine [Elemente](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="02a02-205">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L848-L877)]

<span data-ttu-id="02a02-206">Definieren von generischen Klassen ist sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="02a02-206">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L884-L905)]

<span data-ttu-id="02a02-207">Um eine Schnittstelle zu implementieren, verwenden Sie entweder `interface ... with` Syntax oder einer [Objektausdruck](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="02a02-207">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L912-L931)]

## <a name="which-types-to-use"></a><span data-ttu-id="02a02-208">Welche Typen zu verwenden</span><span class="sxs-lookup"><span data-stu-id="02a02-208">Which Types to Use</span></span>

<span data-ttu-id="02a02-209">Das Vorhandensein von Klassen, Datensätze und Unterscheidungs-Unions, Tupeln führt zu einer Kernfrage: welches sollten Sie verwenden?</span><span class="sxs-lookup"><span data-stu-id="02a02-209">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="02a02-210">Wie die meisten alles im Leben hängt Ihre Situation die Antwort.</span><span class="sxs-lookup"><span data-stu-id="02a02-210">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="02a02-211">Tupel sind hervorragend für mehrere Werte aus einer Funktion zurückgeben, und verwenden ein Ad-hoc-Aggregat von Werten als Wert selbst.</span><span class="sxs-lookup"><span data-stu-id="02a02-211">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="02a02-212">Eine "Step up" aus Tupeln, dass mit dem Namen Bezeichnungen und Unterstützung für optionale Elemente sind Datensätze.</span><span class="sxs-lookup"><span data-stu-id="02a02-212">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="02a02-213">Sie sind hervorragend für eine niedrige Zeremonie-Darstellung der Daten in Transit über das Programm.</span><span class="sxs-lookup"><span data-stu-id="02a02-213">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="02a02-214">Da sie Strukturgleichheit aufweisen, sind sie einfach zu verwenden, mit dem Vergleich.</span><span class="sxs-lookup"><span data-stu-id="02a02-214">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="02a02-215">Unterscheidungs-Unions sind vielseitig verwendbar, aber die Core Vorteil besteht darin, nutzen Sie diese in Verbindung mit dem Mustervergleich zum Konto für alle möglichen "Shapes", die über Daten verfügen können.</span><span class="sxs-lookup"><span data-stu-id="02a02-215">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="02a02-216">Klassen sind hervorragend für eine Vielzahl von Gründen, z. B. Wenn Sie Informationen darstellen, und binden auch diese Informationen, um Funktionen müssen.</span><span class="sxs-lookup"><span data-stu-id="02a02-216">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="02a02-217">Als Faustregel gilt Wenn Sie Funktionen haben grundsätzlich auf einige Daten gebunden ist wird mithilfe von Klassen und die Prinzipien des objektorientiertes Programmieren ein großer Vorteil.</span><span class="sxs-lookup"><span data-stu-id="02a02-217">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="02a02-218">Klassen sind auch der bevorzugte Datentyp bei der Interaktion mit c# und Visual Basic, wie diese Sprachen für nahezu alles Klassen verwenden.</span><span class="sxs-lookup"><span data-stu-id="02a02-218">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="02a02-219">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="02a02-219">Next Steps</span></span>

<span data-ttu-id="02a02-220">Nun, dass Sie einige der wichtigsten Features der Programmiersprache gesehen haben, sollten Sie zum Schreiben Ihrer ersten F#-Programs bereit sein!</span><span class="sxs-lookup"><span data-stu-id="02a02-220">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="02a02-221">Auschecken [Einstieg](tutorials/getting-started/index.md) erhalten Sie Informationen zum Einrichten Ihrer Entwicklungsumgebung und Code schreiben.</span><span class="sxs-lookup"><span data-stu-id="02a02-221">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="02a02-222">Die nächsten Schritte für weitere kann einen beliebigen Namen, aber es wird empfohlen [Funktionen als erstrangige Werte](introduction-to-functional-programming/functions-as-first-class-values.md) <!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> abzurufenden mit Kernkonzepte funktionale Programmierung vertraut.</span><span class="sxs-lookup"><span data-stu-id="02a02-222">The next steps for learning more can be whatever you like, but we recommend [Functions as First-Class Values](introduction-to-functional-programming/functions-as-first-class-values.md)<!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="02a02-223">Diese werden bei der Erstellung robuster ' Software ' in f# unentbehrlich.</span><span class="sxs-lookup"><span data-stu-id="02a02-223">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="02a02-224">Darüber hinaus sehen Sie sich die [f#-Sprachreferenz](language-reference/index.md) einem umfassenden Sortiment von konzeptuellen Inhalt in f# zu sehen.</span><span class="sxs-lookup"><span data-stu-id="02a02-224">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
