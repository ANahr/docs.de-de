---
title: "Überblick [F#]"
description: Untersuchen Sie einige der wichtigsten Funktionen der Programmiersprache in dieser Tour mit Codebeispielen f#.
keywords: Visual f#, f#, funktionalen Programmierung, .NET tour
author: cartermp
ms.author: phcart
ms.date: 02/28/2018
ms.topic: article
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 49775139-082e-442f-b5a2-dd402399b5d2
ms.openlocfilehash: 7327573a25aa62af28570b4a8662235f3e41a972
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/15/2018
---
# <a name="tour-of-f"></a><span data-ttu-id="12a04-104">Überblick [F#]</span><span class="sxs-lookup"><span data-stu-id="12a04-104">Tour of F#</span></span> #

<span data-ttu-id="12a04-105">Die beste Möglichkeit, Weitere Informationen zu f# wird zum Lesen und Schreiben von f#-Code.</span><span class="sxs-lookup"><span data-stu-id="12a04-105">The best way to learn about F# is to read and write F# code.</span></span>  <span data-ttu-id="12a04-106">In diesem Artikel wird als eine Tour durch einige der wichtigsten Funktionen der Programmiersprache f# fungieren und bieten Ihnen einige Codeausschnitte, die auf dem Computer ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="12a04-106">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span>  <span data-ttu-id="12a04-107">Weitere Informationen zum Einrichten einer Entwicklungsumgebung, sehen Sie sich [Einstieg](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="12a04-107">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="12a04-108">Werden zwei primäre Begriffe in F# erläutert werden: Funktionen und Typen.</span><span class="sxs-lookup"><span data-stu-id="12a04-108">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="12a04-109">Diese Tour werden Funktionen der Sprache hervorzuheben, die in diesen beiden Konzepten fallen.</span><span class="sxs-lookup"><span data-stu-id="12a04-109">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="12a04-110">Funktionen und Module</span><span class="sxs-lookup"><span data-stu-id="12a04-110">Functions and Modules</span></span>

<span data-ttu-id="12a04-111">Sind die grundlegenden Teile eines F#-Programms ***Funktionen*** organisierte ***Module***.</span><span class="sxs-lookup"><span data-stu-id="12a04-111">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="12a04-112">[Funktionen](language-reference/functions/index.md) Arbeit auf Eingaben, Ausgaben erzeugen auszuführen, und sie werden unter organisiert [Module](language-reference/modules.md), der die primäre Methode, die Sie gruppieren Punkte in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-112">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="12a04-113">Sie definiert sind, mithilfe der [ `let` Bindung](language-reference/functions/let-bindings.md), dem Benennen Sie der Funktion und ihre Argumente zu definieren.</span><span class="sxs-lookup"><span data-stu-id="12a04-113">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="12a04-114">`let` Bindungen sind auch an, wie Sie einen Wert an einen ähnlichen Namen, einer Variablen in anderen Sprachen wie binden.</span><span class="sxs-lookup"><span data-stu-id="12a04-114">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="12a04-115">`let` Bindungen sind ***unveränderlichen*** standardmäßig, d. h., sobald ein Wert oder eine Funktion mit einem Namen gebunden wird, es geändert werden kann direkte.</span><span class="sxs-lookup"><span data-stu-id="12a04-115">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="12a04-116">Dies steht im Gegensatz zu Variablen in anderen Sprachen, von denen sind ***änderbare***, d. h., deren Werte kann geändert werden zu einem beliebigen Zeitpunkt zeitlich.</span><span class="sxs-lookup"><span data-stu-id="12a04-116">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="12a04-117">Wenn Sie eine änderbare Bindung benötigen, können Sie `let mutable ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="12a04-117">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="12a04-118">Zahlen, boolesche Werte und Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="12a04-118">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="12a04-119">Als Sprache .NET f# unterstützt das gleiche zugrunde liegende [Grundtypen](language-reference/primitive-types.md) , die in .NET vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="12a04-119">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="12a04-120">Dies ist die Verwendung verschiedener numerische Datentypen in f# dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="12a04-120">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="12a04-121">Hier ist welche boolesche Werte und grundlegende bedingten Logik ausführen, sieht wie folgt:</span><span class="sxs-lookup"><span data-stu-id="12a04-121">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="12a04-122">Und hier ist welche Basic [Zeichenfolge](language-reference/strings.md) Manipulation sieht wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="12a04-122">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="12a04-123">Tupel</span><span class="sxs-lookup"><span data-stu-id="12a04-123">Tuples</span></span>

<span data-ttu-id="12a04-124">[Tupel](language-reference/tuples.md) kein großes Problem in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-124">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="12a04-125">Es handelt sich um eine Gruppierung von unbenannten, jedoch sortierte Werte, die Werte selbst behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="12a04-125">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="12a04-126">Betrachten sie als Werte, die aus anderen Werten aggregiert werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-126">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="12a04-127">Sie verfügen über viele Verwendungsmöglichkeiten, z. B. bequem zurückgeben mehrerer Werte aus einer Funktion oder Werte für gewisse Vereinfachung für Ad-hoc-Gruppierung.</span><span class="sxs-lookup"><span data-stu-id="12a04-127">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="12a04-128">Sie können auch erstellen, zum Zeitpunkt der F#-4.1, `struct` Tupel.</span><span class="sxs-lookup"><span data-stu-id="12a04-128">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="12a04-129">Diese auch Interoperabilität vollständig mit C# 7/Visual Basic 15 Tupeln, die ebenfalls sind `struct` Tupeln:</span><span class="sxs-lookup"><span data-stu-id="12a04-129">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="12a04-130">Es ist wichtig, da beachten, dass `struct` Tupel sind Werttypen, sie können nicht implizit konvertiert Tupel verweisen oder umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="12a04-130">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="12a04-131">Sie müssen explizit zwischen ein Tupel Verweis und Struktur konvertieren.</span><span class="sxs-lookup"><span data-stu-id="12a04-131">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="12a04-132">Pipelines und dem Kompositionsthread</span><span class="sxs-lookup"><span data-stu-id="12a04-132">Pipelines and Composition</span></span>

<span data-ttu-id="12a04-133">Übergeben von Operatoren (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) und Zusammensetzung Operatoren (`>>` und `<<`) werden ausgiebig bei der Verarbeitung von Daten in f# verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-133">Pipe operators (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) and composition operators (`>>` and `<<`) are used extensively when processing data in F#.</span></span>  <span data-ttu-id="12a04-134">Diese Operatoren sind Funktionen, die Ihnen ermöglichen, "Pipelines" Funktionen auf flexible Weise einrichten.</span><span class="sxs-lookup"><span data-stu-id="12a04-134">These operators are functions which allow you to establish "pipelines" of functions in a flexible manner.</span></span>  <span data-ttu-id="12a04-135">Im folgende Beispiel führt Sie durch wie Sie diese Operatoren zum Erstellen einer einfachen funktionale Pipeline nutzen können.</span><span class="sxs-lookup"><span data-stu-id="12a04-135">The following example walks through how you could take advantage of these operators to build a simple functional pipeline.</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L300)]

<span data-ttu-id="12a04-136">Im obigen Beispiel vorgenommen Verwendung vieler Funktionen von f#, einschließlich der Liste Verarbeitungsfunktionen, erstklassige Funktionen und [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="12a04-136">The above sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span>  <span data-ttu-id="12a04-137">Obwohl ein tiefgreifendes Verständnis des aller diese Konzepte etwas erweitert werden kann, sollte klar sein, wie einfache Funktionen zum Verarbeiten von Daten beim Erstellen von Pipelines verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="12a04-137">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="12a04-138">Listen, Arrays und Sequenzen</span><span class="sxs-lookup"><span data-stu-id="12a04-138">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="12a04-139">Listen, Arrays und Sequenzen sind drei primäre Sammlungstypen in f#-Kernbibliothek.</span><span class="sxs-lookup"><span data-stu-id="12a04-139">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="12a04-140">[Listet](language-reference/lists.md) sind geordnete, unveränderliche Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="12a04-140">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="12a04-141">Sie sind einfach verknüpfte Listen, was bedeutet, dass sie für die Enumeration, aber eine schlechte Wahl für wahlfreien Zugriff und Verkettungen vorgesehen sind, sollten sie sich bei großen.</span><span class="sxs-lookup"><span data-stu-id="12a04-141">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="12a04-142">Diese im Gegensatz zu Listen in anderen gängigen Sprachen, die zur Darstellung von Listen in der Regel keine einfach verknüpfte Liste verwenden.</span><span class="sxs-lookup"><span data-stu-id="12a04-142">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="12a04-143">[Arrays](language-reference/arrays.md) fester Größe, werden *änderbare* Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="12a04-143">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="12a04-144">Sie unterstützt den schnellen zufälligen Zugriff von Elementen und sind schneller als ein F#-werden aufgeführt, da sie nur zusammenhängenden Speicherblöcke sind.</span><span class="sxs-lookup"><span data-stu-id="12a04-144">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="12a04-145">[Sequenzen](language-reference/sequences.md) sind eine logische Reihe von Elementen, alle den gleichen Typ aufweisen.</span><span class="sxs-lookup"><span data-stu-id="12a04-145">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="12a04-146">Hierbei handelt es sich um einen allgemeineren Typ als die "View" in jeder logische Reihe von Elementen, die Arrays und Listen.</span><span class="sxs-lookup"><span data-stu-id="12a04-146">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="12a04-147">Auch hervorzuheben, da sie stehen ***lazy***, was bedeutet, dass die Elemente berechnet werden können, nur, wenn sie benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-147">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="12a04-148">Rekursive Funktionen</span><span class="sxs-lookup"><span data-stu-id="12a04-148">Recursive Functions</span></span>

<span data-ttu-id="12a04-149">Verarbeiten von Auflistungen oder Elementsequenzen erfolgt in der Regel mit [Rekursion](language-reference/functions/index.md#recursive-functions) in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-149">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="12a04-150">Zwar f# unterstützt für Schleifen und imperativen Programmierung, ist Rekursion bevorzugte, da sie einfacher sicherstellen Richtigkeit ist.</span><span class="sxs-lookup"><span data-stu-id="12a04-150">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

>[!NOTE]
<span data-ttu-id="12a04-151">Das folgende Beispiel verwendet die Mustervergleich über die `match` Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="12a04-151">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="12a04-152">Dieses grundlegende Konstrukt wird weiter unten in diesem Artikel behandelt.</span><span class="sxs-lookup"><span data-stu-id="12a04-152">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="12a04-153">F# bietet auch vollständige Unterstützung für Tail aufrufen Optimierung, dies ist eine Methode für die rekursive Aufrufe zu optimieren, sodass sie nur so schnell wie eine Schleifenkonstruktion sind.</span><span class="sxs-lookup"><span data-stu-id="12a04-153">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="12a04-154">Datensatz- und diskriminierte Union-Typen</span><span class="sxs-lookup"><span data-stu-id="12a04-154">Record and Discriminated Union Types</span></span>

<span data-ttu-id="12a04-155">Datensatz und Union-Typen sind zwei grundlegende Datentypen, die in f#-Code verwendet und sind in der Regel die beste Möglichkeit zum Darstellen der Daten in einem f#-Programm.</span><span class="sxs-lookup"><span data-stu-id="12a04-155">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="12a04-156">Obwohl dadurch diese Klassen ähnlich wie in anderen Sprachen wird, ist eine der ihre wichtigsten Unterschiede Strukturgleichheit Semantik besitzen.</span><span class="sxs-lookup"><span data-stu-id="12a04-156">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="12a04-157">Dies bedeutet, dass sie "systemintern" vergleichbar sein, und auf Gleichheit einfach ist – nur überprüft, ob eine gleich dem anderem ist.</span><span class="sxs-lookup"><span data-stu-id="12a04-157">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="12a04-158">[Datensätze](language-reference/records.md) sind ein Aggregat benannter Werte, mit optionalen Elementen (z. B. Methoden).</span><span class="sxs-lookup"><span data-stu-id="12a04-158">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="12a04-159">Wenn Sie mit c# oder Java vertraut sind, sollte dann diese ähnlich POCOs oder POJOs - nur bei der strukturellen gleichheitsüberprüfung und weniger Zeremonie können.</span><span class="sxs-lookup"><span data-stu-id="12a04-159">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="12a04-160">Ab f# 4.1, kann auch Datensätze gleichzeitig als repräsentieren `struct`s.</span><span class="sxs-lookup"><span data-stu-id="12a04-160">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="12a04-161">Dies erfolgt mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="12a04-161">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="12a04-162">[Unterscheidungs-Unions (Verteilungseinheiten)](language-reference/discriminated-unions.md) sind Werte, die eine Anzahl von benannten Formulare oder Fälle werden konnte.</span><span class="sxs-lookup"><span data-stu-id="12a04-162">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="12a04-163">Geben Sie im gespeicherten Daten von mehreren unterschiedlichen Werten sind möglich.</span><span class="sxs-lookup"><span data-stu-id="12a04-163">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="12a04-164">Sie können auch als Verteilungseinheiten *einzelnen Fall Unterscheidungs-Unions*, damit die mit der Domäne Modellieren von primitiven Typen.</span><span class="sxs-lookup"><span data-stu-id="12a04-164">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="12a04-165">Oft, Zeichenfolgen und anderen primitiven Typen werden verwendet, um etwas darstellen und werden daher eine bestimmte Bedeutung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="12a04-165">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="12a04-166">Allerdings kann nur die primitiven Darstellung der Daten dazu führen, Zuweisen von versehentlich ein falscher Wert!</span><span class="sxs-lookup"><span data-stu-id="12a04-166">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="12a04-167">Jede Art von Informationen wie eine unterschiedliche einzelnen Fall Union darstellt, kann Richtigkeit in diesem Szenario erzwingen.</span><span class="sxs-lookup"><span data-stu-id="12a04-167">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="12a04-168">Wie im obigen Beispiel wird veranschaulicht, um den zugrunde liegenden Wert in einen einzelnen Fall Unterscheidungs-Union, zu erhalten, müssen Sie explizit entpacken.</span><span class="sxs-lookup"><span data-stu-id="12a04-168">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="12a04-169">Darüber hinaus unterstützen Verteilungseinheiten auch rekursive Definitionen, sodass Sie problemlos Strukturen als auch grundsätzlich rekursive Daten darzustellen.</span><span class="sxs-lookup"><span data-stu-id="12a04-169">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="12a04-170">Beispielsweise sieht wie Sie mit einer binären Suchstruktur darstellen können `exists` und `insert` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="12a04-170">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="12a04-171">Da Verteilungseinheiten Sie zur Darstellung der rekursive Struktur der Struktur in den Datentyp ermöglichen, Vorgänge für diese rekursive Struktur ist einfach und Korrektheit gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="12a04-171">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="12a04-172">Es wird auch in einem Mustervergleich müssen unterstützt, wie unten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="12a04-172">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="12a04-173">Sie können darüber hinaus Verteilungseinheiten als darstellen `struct`s mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="12a04-173">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="12a04-174">Es gibt jedoch zwei wichtige Dinge zu bedenken, wenn dies zu erheblichen:</span><span class="sxs-lookup"><span data-stu-id="12a04-174">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="12a04-175">Eine Struktur DU kann nicht rekursiv definiert werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-175">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="12a04-176">Eine Struktur DU muss eindeutige Namen für jeden der Fälle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="12a04-176">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="12a04-177">Oben genannten Kriterien nicht einhalten, führt zu einem Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="12a04-177">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="12a04-178">Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="12a04-178">Pattern Matching</span></span>

<span data-ttu-id="12a04-179">[Übereinstimmende Muster](language-reference/pattern-matching.md) ist die F#-Sprache-Funktion die Richtigkeit für Vorgänge für f#-Typen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="12a04-179">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="12a04-180">In den obigen Beispielen werden Sie möglicherweise bemerkt, dass relativ viel `match x with ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="12a04-180">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="12a04-181">Dieses Konstrukt kann den Compiler, der weiß, die "Shape" Datentypen, zwingen Sie beim Verwenden eines Datentyp durch was bekannt ist als vollständig Mustervergleich aller möglichen Fälle berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="12a04-181">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="12a04-182">Dies ist äußerst leistungsfähigen auf Richtigkeit, und zum "lift", was normalerweise Besorgnis Runtime in Kompilierung wäre raffinierter verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="12a04-182">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L739)]

<span data-ttu-id="12a04-183">Sie können auch die Kurzform `function` Konstrukt, die für den Mustervergleich, nützlich, ist Wenn Sie schreiben gerade, Funktionen, die Stellen nutzen [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments):</span><span class="sxs-lookup"><span data-stu-id="12a04-183">You can also use the shorthand `function` construct for pattern matching, which is useful when you're writing functions which make use of [Partial Application](language-reference/functions/index.md#partial-application-of-arguments):</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L741-L759)]

<span data-ttu-id="12a04-184">Etwas Ihnen möglicherweise aufgefallen ist die Verwendung von der `_` Muster.</span><span class="sxs-lookup"><span data-stu-id="12a04-184">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="12a04-185">Dies bezeichnet man die [Platzhaltermuster](language-reference/pattern-matching.md#wildcard-pattern), dies ist eine Möglichkeit, dies zu sagen "Ich kümmern sich nicht darum was etwas ist".</span><span class="sxs-lookup"><span data-stu-id="12a04-185">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="12a04-186">Obwohl es bequem erscheint, können Sie versehentlich umgehen vollständig Mustervergleich und nicht mehr vom Zeitpunkt der Kompilierung Erzwingungen profitieren, wenn Sie nicht mit Bedacht vorgehen `_`.</span><span class="sxs-lookup"><span data-stu-id="12a04-186">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="12a04-187">Es wird am besten verwendet, wenn Sie bestimmte Teile eines Typs zerlegten interessieren nicht wenn Muster entsprechen, oder der abschließenden Klausel, wenn Sie alle sinnvollen Fälle in einem Mustervergleichsausdruck aufgezählt haben.</span><span class="sxs-lookup"><span data-stu-id="12a04-187">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="12a04-188">[Aktive Muster](language-reference/active-patterns.md) anderes leistungsfähiges Instrument, mit dem Mustervergleich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="12a04-188">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="12a04-189">Dateien können Sie die Eingabedaten in benutzerdefinierte Formulare, Zerlegen von an der Aufrufsite für Muster Übereinstimmung zu partitionieren.</span><span class="sxs-lookup"><span data-stu-id="12a04-189">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="12a04-190">Sie können auch parametrisiert werden somit auf die Partition als Funktion definiert.</span><span class="sxs-lookup"><span data-stu-id="12a04-190">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="12a04-191">Erweitern im vorherige Beispiel zur Unterstützung von aktive Muster sieht ungefähr so aus:</span><span class="sxs-lookup"><span data-stu-id="12a04-191">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L761-L783)]

## <a name="optional-types"></a><span data-ttu-id="12a04-192">Optionale Typen</span><span class="sxs-lookup"><span data-stu-id="12a04-192">Optional Types</span></span>

<span data-ttu-id="12a04-193">Ein Sonderfall des Unterscheidungs-Union-Typen wird der Optionstyp der eignet sich daher, dass es ein Teil der f#-Kernbibliothek handelt.</span><span class="sxs-lookup"><span data-stu-id="12a04-193">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="12a04-194">[Der Optionstyp](language-reference/options.md) ist ein Typ, der eine der beiden Fälle darstellt: ein Wert oder nichts überhaupt.</span><span class="sxs-lookup"><span data-stu-id="12a04-194">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="12a04-195">Es wird in jedem Szenario verwendet, in dem ein Wert kann oder möglicherweise nicht von einem bestimmten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="12a04-195">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="12a04-196">Dies erzwingt dann für beide Fälle Besorgnis Kompilierzeit statt Besorgnis Runtime somit berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="12a04-196">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="12a04-197">Diese werden häufig in APIs verwendet, in denen `null` wird verwendet, um "nichts" stattdessen darstellen somit Dadurch entfällt die Notwendigkeit kümmern `NullReferenceException` in vielen Fällen.</span><span class="sxs-lookup"><span data-stu-id="12a04-197">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L791-L811)]

## <a name="units-of-measure"></a><span data-ttu-id="12a04-198">Maßeinheiten</span><span class="sxs-lookup"><span data-stu-id="12a04-198">Units of Measure</span></span>

<span data-ttu-id="12a04-199">Eine einzigartige Funktion des # des Typsystems ist die Möglichkeit, den Kontext für numerische Literale über Einheiten festzulegen.</span><span class="sxs-lookup"><span data-stu-id="12a04-199">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="12a04-200">[Maßeinheiten](language-reference/units-of-measure.md) ermöglichen es Ihnen, einen numerischen Typ mit einer Einheit, z. B. Meter, zuordnen und haben Funktionen ausführen können numerische Literale, anstatt Einheiten.</span><span class="sxs-lookup"><span data-stu-id="12a04-200">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="12a04-201">Dadurch kann der Compiler, stellen Sie sicher, dass die Typen von numerischen Literalen übergebene sinnvoll unter einem bestimmten Kontext, somit-Runtime-Fehler dieser Art von Arbeit zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="12a04-201">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L818-L839)]

<span data-ttu-id="12a04-202">Die f#-Kernbibliothek definiert viele SI Einheitentypen und einheitenkonvertierungen.</span><span class="sxs-lookup"><span data-stu-id="12a04-202">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="12a04-203">Um mehr zu erfahren, sehen Sie sich die [Microsoft.FSharp.Data.UnitSystems.SI-Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="12a04-203">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="12a04-204">Klassen und Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="12a04-204">Classes and Interfaces</span></span>

<span data-ttu-id="12a04-205">F# bietet auch vollständige Unterstützung für .NET-Klassen, [Schnittstellen](language-reference/interfaces.md), [abstrakte Klassen](language-reference/abstract-classes.md), [Vererbung](language-reference/inheritance.md)und so weiter.</span><span class="sxs-lookup"><span data-stu-id="12a04-205">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="12a04-206">[Klassen](language-reference/classes.md) sind Typen, die .NET-Objekten darstellen wofür können Eigenschaften, Methoden und Ereignisse als seine [Elemente](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="12a04-206">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L848-L877)]

<span data-ttu-id="12a04-207">Definieren von generischen Klassen ist sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="12a04-207">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L884-L905)]

<span data-ttu-id="12a04-208">Um eine Schnittstelle zu implementieren, verwenden Sie entweder `interface ... with` Syntax oder einer [Objektausdruck](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="12a04-208">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L912-L931)]

## <a name="which-types-to-use"></a><span data-ttu-id="12a04-209">Welche Typen zu verwenden</span><span class="sxs-lookup"><span data-stu-id="12a04-209">Which Types to Use</span></span>

<span data-ttu-id="12a04-210">Das Vorhandensein von Klassen, Datensätze und Unterscheidungs-Unions, Tupeln führt zu einer Kernfrage: welches sollten Sie verwenden?</span><span class="sxs-lookup"><span data-stu-id="12a04-210">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="12a04-211">Wie die meisten alles im Leben hängt Ihre Situation die Antwort.</span><span class="sxs-lookup"><span data-stu-id="12a04-211">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="12a04-212">Tupel sind hervorragend für mehrere Werte aus einer Funktion zurückgeben, und verwenden ein Ad-hoc-Aggregat von Werten als Wert selbst.</span><span class="sxs-lookup"><span data-stu-id="12a04-212">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="12a04-213">Eine "Step up" aus Tupeln, dass mit dem Namen Bezeichnungen und Unterstützung für optionale Elemente sind Datensätze.</span><span class="sxs-lookup"><span data-stu-id="12a04-213">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="12a04-214">Sie sind hervorragend für eine niedrige Zeremonie-Darstellung der Daten in Transit über das Programm.</span><span class="sxs-lookup"><span data-stu-id="12a04-214">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="12a04-215">Da sie Strukturgleichheit aufweisen, sind sie einfach zu verwenden, mit dem Vergleich.</span><span class="sxs-lookup"><span data-stu-id="12a04-215">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="12a04-216">Unterscheidungs-Unions sind vielseitig verwendbar, aber die Core Vorteil besteht darin, nutzen Sie diese in Verbindung mit dem Mustervergleich zum Konto für alle möglichen "Shapes", die über Daten verfügen können.</span><span class="sxs-lookup"><span data-stu-id="12a04-216">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="12a04-217">Klassen sind hervorragend für eine Vielzahl von Gründen, z. B. Wenn Sie Informationen darstellen, und binden auch diese Informationen, um Funktionen müssen.</span><span class="sxs-lookup"><span data-stu-id="12a04-217">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="12a04-218">Als Faustregel gilt Wenn Sie Funktionen haben grundsätzlich auf einige Daten gebunden ist wird mithilfe von Klassen und die Prinzipien des objektorientiertes Programmieren ein großer Vorteil.</span><span class="sxs-lookup"><span data-stu-id="12a04-218">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="12a04-219">Klassen sind auch der bevorzugte Datentyp bei der Interaktion mit c# und Visual Basic, wie diese Sprachen für nahezu alles Klassen verwenden.</span><span class="sxs-lookup"><span data-stu-id="12a04-219">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="12a04-220">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="12a04-220">Next Steps</span></span>

<span data-ttu-id="12a04-221">Nun, dass Sie einige der wichtigsten Features der Programmiersprache gesehen haben, sollten Sie zum Schreiben Ihrer ersten F#-Programs bereit sein!</span><span class="sxs-lookup"><span data-stu-id="12a04-221">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="12a04-222">Auschecken [Einstieg](tutorials/getting-started/index.md) erhalten Sie Informationen zum Einrichten Ihrer Entwicklungsumgebung und Code schreiben.</span><span class="sxs-lookup"><span data-stu-id="12a04-222">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="12a04-223">Die nächsten Schritte für weitere kann einen beliebigen Namen, aber es wird empfohlen [Funktionen als erstrangige Werte](introduction-to-functional-programming/functions-as-first-class-values.md) <!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> abzurufenden mit Kernkonzepte funktionale Programmierung vertraut.</span><span class="sxs-lookup"><span data-stu-id="12a04-223">The next steps for learning more can be whatever you like, but we recommend [Functions as First-Class Values](introduction-to-functional-programming/functions-as-first-class-values.md)<!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="12a04-224">Diese werden bei der Erstellung robuster ' Software ' in f# unentbehrlich.</span><span class="sxs-lookup"><span data-stu-id="12a04-224">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="12a04-225">Darüber hinaus sehen Sie sich die [f#-Sprachreferenz](language-reference/index.md) einem umfassenden Sortiment von konzeptuellen Inhalt in f# zu sehen.</span><span class="sxs-lookup"><span data-stu-id="12a04-225">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
