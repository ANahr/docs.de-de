---
title: "Überblick [F#]"
description: Untersuchen Sie einige der wichtigsten Funktionen der Programmiersprache in dieser Tour mit Codebeispielen f#.
keywords: Visual f#, f#, funktionalen Programmierung, .NET tour
author: cartermp
ms.author: phcart
ms.date: 01/24/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 49775139-082e-442f-b5a2-dd402399b5d2
ms.openlocfilehash: c027e6b71f35fc3b58750eb164124de145244825
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="tour-of-f"></a><span data-ttu-id="d48db-104">Überblick [F#]</span><span class="sxs-lookup"><span data-stu-id="d48db-104">Tour of F#</span></span> #

<span data-ttu-id="d48db-105">Die beste Möglichkeit, Weitere Informationen zu f# wird zum Lesen und Schreiben von f#-Code.</span><span class="sxs-lookup"><span data-stu-id="d48db-105">The best way to learn about F# is to read and write F# code.</span></span>  <span data-ttu-id="d48db-106">In diesem Artikel wird als eine Tour durch einige der wichtigsten Funktionen der Programmiersprache f# fungieren und bieten Ihnen einige Codeausschnitte, die auf dem Computer ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d48db-106">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span>  <span data-ttu-id="d48db-107">Weitere Informationen zum Einrichten einer Entwicklungsumgebung, sehen Sie sich [Einstieg](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="d48db-107">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="d48db-108">Werden zwei primäre Begriffe in F# erläutert werden: Funktionen und Typen.</span><span class="sxs-lookup"><span data-stu-id="d48db-108">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="d48db-109">Diese Tour werden Funktionen der Sprache hervorzuheben, die in diesen beiden Konzepten fallen.</span><span class="sxs-lookup"><span data-stu-id="d48db-109">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="d48db-110">Gewusst wie: Ausführen der Codebeispiele</span><span class="sxs-lookup"><span data-stu-id="d48db-110">How to Run the Code Samples</span></span>

>[!NOTE]
<span data-ttu-id="d48db-111">Werden zwei Optionen zum Ausführen der Codebeispiele [wiederholen Sie den F#-](http://www.tryfsharp.org/Create) (erfordert Silverlight) und [f# für Azure-Notebooks](https://notebooks.azure.com/Microsoft/libraries/fsharp/html/FSharp%20for%20Azure%20Notebooks.ipynb) in Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="d48db-111">Two options for running the code samples are [Try F#](http://www.tryfsharp.org/Create) (requires Silverlight) and [F# for Azure Notebooks](https://notebooks.azure.com/Microsoft/libraries/fsharp/html/FSharp%20for%20Azure%20Notebooks.ipynb) on Microsoft Azure.</span></span>

<span data-ttu-id="d48db-112">Führen Sie diese Codebeispiele am schnellsten ist die Verwendung [f# Interactive](tutorials/fsharp-interactive/index.md).</span><span class="sxs-lookup"><span data-stu-id="d48db-112">The quickest way to run these code samples is to use [F# Interactive](tutorials/fsharp-interactive/index.md).</span></span>  <span data-ttu-id="d48db-113">Einfach in den Codebeispielen, kopieren und einfügen, und führen sie es.</span><span class="sxs-lookup"><span data-stu-id="d48db-113">Just copy/paste the code samples and run them there.</span></span>  <span data-ttu-id="d48db-114">Alternativ können Sie ein Projekt zu kompilieren und führen Sie den Code als Konsolenanwendung einrichten.</span><span class="sxs-lookup"><span data-stu-id="d48db-114">Alternatively you can set up a project to compile and run the code as a Console Application.</span></span>  <span data-ttu-id="d48db-115">Finden Sie unter der [Einstieg in die](./get-started/index.md) Abschnitt, um mehr zu erfahren.</span><span class="sxs-lookup"><span data-stu-id="d48db-115">See the [Get Started](./get-started/index.md) section to learn more.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="d48db-116">Funktionen und Module</span><span class="sxs-lookup"><span data-stu-id="d48db-116">Functions and Modules</span></span>

<span data-ttu-id="d48db-117">Sind die grundlegenden Teile eines F#-Programms ***Funktionen*** organisierte ***Module***.</span><span class="sxs-lookup"><span data-stu-id="d48db-117">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="d48db-118">[Funktionen](language-reference/functions/index.md) Arbeit auf Eingaben, Ausgaben erzeugen auszuführen, und sie werden unter organisiert [Module](language-reference/modules.md), der die primäre Methode, die Sie gruppieren Punkte in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-118">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="d48db-119">Sie definiert sind, mithilfe der [ `let` Bindung](language-reference/functions/let-bindings.md), dem Benennen Sie der Funktion und ihre Argumente zu definieren.</span><span class="sxs-lookup"><span data-stu-id="d48db-119">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="d48db-120">`let`Bindungen sind auch an, wie Sie einen Wert an einen ähnlichen Namen, einer Variablen in anderen Sprachen wie binden.</span><span class="sxs-lookup"><span data-stu-id="d48db-120">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="d48db-121">`let`Bindungen sind ***unveränderlichen*** standardmäßig, d. h., sobald ein Wert oder eine Funktion mit einem Namen gebunden wird, es geändert werden kann direkte.</span><span class="sxs-lookup"><span data-stu-id="d48db-121">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="d48db-122">Dies steht im Gegensatz zu Variablen in anderen Sprachen, von denen sind ***änderbare***, d. h., deren Werte kann geändert werden zu einem beliebigen Zeitpunkt zeitlich.</span><span class="sxs-lookup"><span data-stu-id="d48db-122">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="d48db-123">Wenn Sie eine änderbare Bindung benötigen, können Sie `let mutable ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="d48db-123">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="d48db-124">Zahlen, boolesche Werte und Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="d48db-124">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="d48db-125">Als Sprache .NET f# unterstützt das gleiche zugrunde liegende [Grundtypen](language-reference/primitive-types.md) , die in .NET vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d48db-125">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="d48db-126">Dies ist die Verwendung verschiedener numerische Datentypen in f# dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="d48db-126">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="d48db-127">Hier ist welche boolesche Werte und grundlegende bedingten Logik ausführen, sieht wie folgt:</span><span class="sxs-lookup"><span data-stu-id="d48db-127">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="d48db-128">Und hier ist welche Basic [Zeichenfolge](language-reference/strings.md) Manipulation sieht wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="d48db-128">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="d48db-129">Tupel</span><span class="sxs-lookup"><span data-stu-id="d48db-129">Tuples</span></span>

<span data-ttu-id="d48db-130">[Tupel](language-reference/tuples.md) kein großes Problem in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-130">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="d48db-131">Es handelt sich um eine Gruppierung von unbenannten, jedoch sortierte Werte, die Werte selbst behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d48db-131">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="d48db-132">Betrachten sie als Werte, die aus anderen Werten aggregiert werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-132">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="d48db-133">Sie verfügen über viele Verwendungsmöglichkeiten, z. B. bequem zurückgeben mehrerer Werte aus einer Funktion oder Werte für gewisse Vereinfachung für Ad-hoc-Gruppierung.</span><span class="sxs-lookup"><span data-stu-id="d48db-133">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="d48db-134">Sie können auch erstellen, zum Zeitpunkt der F#-4.1, `struct` Tupel.</span><span class="sxs-lookup"><span data-stu-id="d48db-134">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="d48db-135">Diese auch Interoperabilität vollständig mit C# 7/Visual Basic 15 Tupeln, die ebenfalls sind `struct` Tupeln:</span><span class="sxs-lookup"><span data-stu-id="d48db-135">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="d48db-136">Es ist wichtig, da beachten, dass `struct` Tupel sind Werttypen, sie können nicht implizit konvertiert Tupel verweisen oder umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="d48db-136">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="d48db-137">Sie müssen explizit zwischen ein Tupel Verweis und Struktur konvertieren.</span><span class="sxs-lookup"><span data-stu-id="d48db-137">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="d48db-138">Pipelines und dem Kompositionsthread</span><span class="sxs-lookup"><span data-stu-id="d48db-138">Pipelines and Composition</span></span>

<span data-ttu-id="d48db-139">Übergeben von Operatoren (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) und Zusammensetzung Operatoren (`>>` und `<<`) werden ausgiebig bei der Verarbeitung von Daten in f# verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-139">Pipe operators (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) and composition operators (`>>` and `<<`) are used extensively when processing data in F#.</span></span>  <span data-ttu-id="d48db-140">Diese Operatoren sind Funktionen, die Ihnen ermöglichen, "Pipelines" Funktionen auf flexible Weise einrichten.</span><span class="sxs-lookup"><span data-stu-id="d48db-140">These operators are functions which allow you to establish "pipelines" of functions in a flexible manner.</span></span>  <span data-ttu-id="d48db-141">Im folgende Beispiel führt Sie durch wie Sie diese Operatoren zum Erstellen einer einfachen funktionale Pipeline nutzen können.</span><span class="sxs-lookup"><span data-stu-id="d48db-141">The following example walks through how you could take advantage of these operators to build a simple functional pipeline.</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L300)]

<span data-ttu-id="d48db-142">Im obigen Beispiel vorgenommen Verwendung vieler Funktionen von f#, einschließlich der Liste Verarbeitungsfunktionen, erstklassige Funktionen und [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="d48db-142">The above sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span>  <span data-ttu-id="d48db-143">Obwohl ein tiefgreifendes Verständnis des aller diese Konzepte etwas erweitert werden kann, sollte klar sein, wie einfache Funktionen zum Verarbeiten von Daten beim Erstellen von Pipelines verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="d48db-143">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="d48db-144">Listen, Arrays und Sequenzen</span><span class="sxs-lookup"><span data-stu-id="d48db-144">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="d48db-145">Listen, Arrays und Sequenzen sind drei primäre Sammlungstypen in f#-Kernbibliothek.</span><span class="sxs-lookup"><span data-stu-id="d48db-145">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="d48db-146">[Listet](language-reference/lists.md) sind geordnete, unveränderliche Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="d48db-146">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="d48db-147">Sie sind einfach verknüpfte Listen, was bedeutet, dass sie für die Enumeration, aber eine schlechte Wahl für wahlfreien Zugriff und Verkettungen vorgesehen sind, sollten sie sich bei großen.</span><span class="sxs-lookup"><span data-stu-id="d48db-147">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="d48db-148">Diese im Gegensatz zu Listen in anderen gängigen Sprachen, die zur Darstellung von Listen in der Regel keine einfach verknüpfte Liste verwenden.</span><span class="sxs-lookup"><span data-stu-id="d48db-148">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="d48db-149">[Arrays](language-reference/arrays.md) fester Größe, werden *änderbare* Auflistungen von Elementen des gleichen Typs.</span><span class="sxs-lookup"><span data-stu-id="d48db-149">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="d48db-150">Sie unterstützt den schnellen zufälligen Zugriff von Elementen und sind schneller als ein F#-werden aufgeführt, da sie nur zusammenhängenden Speicherblöcke sind.</span><span class="sxs-lookup"><span data-stu-id="d48db-150">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="d48db-151">[Sequenzen](language-reference/sequences.md) sind eine logische Reihe von Elementen, alle den gleichen Typ aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d48db-151">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="d48db-152">Hierbei handelt es sich um einen allgemeineren Typ als die "View" in jeder logische Reihe von Elementen, die Arrays und Listen.</span><span class="sxs-lookup"><span data-stu-id="d48db-152">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="d48db-153">Auch hervorzuheben, da sie stehen ***lazy***, was bedeutet, dass die Elemente berechnet werden können, nur, wenn sie benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-153">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="d48db-154">Rekursive Funktionen</span><span class="sxs-lookup"><span data-stu-id="d48db-154">Recursive Functions</span></span>

<span data-ttu-id="d48db-155">Verarbeiten von Auflistungen oder Elementsequenzen erfolgt in der Regel mit [Rekursion](language-reference/functions/index.md#recursive-functions) in F# erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-155">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="d48db-156">Zwar f# unterstützt für Schleifen und imperativen Programmierung, ist Rekursion bevorzugte, da sie einfacher sicherstellen Richtigkeit ist.</span><span class="sxs-lookup"><span data-stu-id="d48db-156">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

>[!NOTE]
<span data-ttu-id="d48db-157">Das folgende Beispiel verwendet die Mustervergleich über die `match` Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="d48db-157">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="d48db-158">Dieses grundlegende Konstrukt wird weiter unten in diesem Artikel behandelt.</span><span class="sxs-lookup"><span data-stu-id="d48db-158">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="d48db-159">F# bietet auch vollständige Unterstützung für Tail aufrufen Optimierung, dies ist eine Methode für die rekursive Aufrufe zu optimieren, sodass sie nur so schnell wie eine Schleifenkonstruktion sind.</span><span class="sxs-lookup"><span data-stu-id="d48db-159">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="d48db-160">Datensatz- und diskriminierte Union-Typen</span><span class="sxs-lookup"><span data-stu-id="d48db-160">Record and Discriminated Union Types</span></span>

<span data-ttu-id="d48db-161">Datensatz und Union-Typen sind zwei grundlegende Datentypen, die in f#-Code verwendet und sind in der Regel die beste Möglichkeit zum Darstellen der Daten in einem f#-Programm.</span><span class="sxs-lookup"><span data-stu-id="d48db-161">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="d48db-162">Obwohl dadurch diese Klassen ähnlich wie in anderen Sprachen wird, ist eine der ihre wichtigsten Unterschiede Strukturgleichheit Semantik besitzen.</span><span class="sxs-lookup"><span data-stu-id="d48db-162">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="d48db-163">Dies bedeutet, dass sie "systemintern" vergleichbar sein, und auf Gleichheit einfach ist – nur überprüft, ob eine gleich dem anderem ist.</span><span class="sxs-lookup"><span data-stu-id="d48db-163">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="d48db-164">[Datensätze](language-reference/records.md) sind ein Aggregat benannter Werte, mit optionalen Elementen (z. B. Methoden).</span><span class="sxs-lookup"><span data-stu-id="d48db-164">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="d48db-165">Wenn Sie mit c# oder Java vertraut sind, sollte dann diese ähnlich POCOs oder POJOs - nur bei der strukturellen gleichheitsüberprüfung und weniger Zeremonie können.</span><span class="sxs-lookup"><span data-stu-id="d48db-165">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="d48db-166">Ab f# 4.1, kann auch Datensätze gleichzeitig als repräsentieren `struct`s.</span><span class="sxs-lookup"><span data-stu-id="d48db-166">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="d48db-167">Dies erfolgt mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="d48db-167">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="d48db-168">[Unterscheidungs-Unions (Verteilungseinheiten)](language-reference/discriminated-unions.md) sind Werte, die eine Anzahl von benannten Formulare oder Fälle werden konnte.</span><span class="sxs-lookup"><span data-stu-id="d48db-168">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="d48db-169">Geben Sie im gespeicherten Daten von mehreren unterschiedlichen Werten sind möglich.</span><span class="sxs-lookup"><span data-stu-id="d48db-169">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="d48db-170">Sie können auch als Verteilungseinheiten *einzelnen Fall Unterscheidungs-Unions*, damit die mit der Domäne Modellieren von primitiven Typen.</span><span class="sxs-lookup"><span data-stu-id="d48db-170">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="d48db-171">Oft, Zeichenfolgen und anderen primitiven Typen werden verwendet, um etwas darstellen und werden daher eine bestimmte Bedeutung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="d48db-171">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="d48db-172">Allerdings kann nur die primitiven Darstellung der Daten dazu führen, Zuweisen von versehentlich ein falscher Wert!</span><span class="sxs-lookup"><span data-stu-id="d48db-172">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="d48db-173">Jede Art von Informationen wie eine unterschiedliche einzelnen Fall Union darstellt, kann Richtigkeit in diesem Szenario erzwingen.</span><span class="sxs-lookup"><span data-stu-id="d48db-173">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="d48db-174">Wie im obigen Beispiel wird veranschaulicht, um den zugrunde liegenden Wert in einen einzelnen Fall Unterscheidungs-Union, zu erhalten, müssen Sie explizit entpacken.</span><span class="sxs-lookup"><span data-stu-id="d48db-174">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="d48db-175">Darüber hinaus unterstützen Verteilungseinheiten auch rekursive Definitionen, sodass Sie problemlos Strukturen als auch grundsätzlich rekursive Daten darzustellen.</span><span class="sxs-lookup"><span data-stu-id="d48db-175">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="d48db-176">Beispielsweise sieht wie Sie mit einer binären Suchstruktur darstellen können `exists` und `insert` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d48db-176">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="d48db-177">Da Verteilungseinheiten Sie zur Darstellung der rekursive Struktur der Struktur in den Datentyp ermöglichen, Vorgänge für diese rekursive Struktur ist einfach und Korrektheit gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="d48db-177">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="d48db-178">Es wird auch in einem Mustervergleich müssen unterstützt, wie unten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="d48db-178">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="d48db-179">Sie können darüber hinaus Verteilungseinheiten als darstellen `struct`s mit der `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="d48db-179">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="d48db-180">Es gibt jedoch zwei wichtige Dinge zu bedenken, wenn dies zu erheblichen:</span><span class="sxs-lookup"><span data-stu-id="d48db-180">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="d48db-181">Eine Struktur DU kann nicht rekursiv definiert werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-181">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="d48db-182">Eine Struktur DU muss eindeutige Namen für jeden der Fälle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d48db-182">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="d48db-183">Oben genannten Kriterien nicht einhalten, führt zu einem Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="d48db-183">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="d48db-184">Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="d48db-184">Pattern Matching</span></span>

<span data-ttu-id="d48db-185">[Übereinstimmende Muster](language-reference/pattern-matching.md) ist die F#-Sprache-Funktion die Richtigkeit für Vorgänge für f#-Typen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="d48db-185">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="d48db-186">In den obigen Beispielen werden Sie möglicherweise bemerkt, dass relativ viel `match x with ...` Syntax.</span><span class="sxs-lookup"><span data-stu-id="d48db-186">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="d48db-187">Dieses Konstrukt kann den Compiler, der weiß, die "Shape" Datentypen, zwingen Sie beim Verwenden eines Datentyp durch was bekannt ist als vollständig Mustervergleich aller möglichen Fälle berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="d48db-187">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="d48db-188">Dies ist äußerst leistungsfähigen auf Richtigkeit, und zum "lift", was normalerweise Besorgnis Runtime in Kompilierung wäre raffinierter verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d48db-188">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L739)]

<span data-ttu-id="d48db-189">Sie können auch die Kurzform `function` Konstrukt, die für den Mustervergleich, nützlich, ist Wenn Sie schreiben gerade, Funktionen, die Stellen nutzen [teilweise Anwendung](language-reference/functions/index.md#partial-application-of-arguments):</span><span class="sxs-lookup"><span data-stu-id="d48db-189">You can also use the shorthand `function` construct for pattern matching, which is useful when you're writing functions which make use of [Partial Application](language-reference/functions/index.md#partial-application-of-arguments):</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L741-L759)]

<span data-ttu-id="d48db-190">Etwas Ihnen möglicherweise aufgefallen ist die Verwendung von der `_` Muster.</span><span class="sxs-lookup"><span data-stu-id="d48db-190">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="d48db-191">Dies bezeichnet man die [Platzhaltermuster](language-reference/pattern-matching.md#wildcard-pattern), dies ist eine Möglichkeit, dies zu sagen "Ich kümmern sich nicht darum was etwas ist".</span><span class="sxs-lookup"><span data-stu-id="d48db-191">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="d48db-192">Obwohl es bequem erscheint, können Sie versehentlich umgehen vollständig Mustervergleich und nicht mehr vom Zeitpunkt der Kompilierung Erzwingungen profitieren, wenn Sie nicht mit Bedacht vorgehen `_`.</span><span class="sxs-lookup"><span data-stu-id="d48db-192">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="d48db-193">Es wird am besten verwendet, wenn Sie bestimmte Teile eines Typs zerlegten interessieren nicht wenn Muster entsprechen, oder der abschließenden Klausel, wenn Sie alle sinnvollen Fälle in einem Mustervergleichsausdruck aufgezählt haben.</span><span class="sxs-lookup"><span data-stu-id="d48db-193">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="d48db-194">[Aktive Muster](language-reference/active-patterns.md) anderes leistungsfähiges Instrument, mit dem Mustervergleich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d48db-194">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="d48db-195">Dateien können Sie die Eingabedaten in benutzerdefinierte Formulare, Zerlegen von an der Aufrufsite für Muster Übereinstimmung zu partitionieren.</span><span class="sxs-lookup"><span data-stu-id="d48db-195">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="d48db-196">Sie können auch parametrisiert werden somit auf die Partition als Funktion definiert.</span><span class="sxs-lookup"><span data-stu-id="d48db-196">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="d48db-197">Erweitern im vorherige Beispiel zur Unterstützung von aktive Muster sieht ungefähr so aus:</span><span class="sxs-lookup"><span data-stu-id="d48db-197">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L761-L783)]

## <a name="optional-types"></a><span data-ttu-id="d48db-198">Optionale Typen</span><span class="sxs-lookup"><span data-stu-id="d48db-198">Optional Types</span></span>

<span data-ttu-id="d48db-199">Ein Sonderfall des Unterscheidungs-Union-Typen wird der Optionstyp der eignet sich daher, dass es ein Teil der f#-Kernbibliothek handelt.</span><span class="sxs-lookup"><span data-stu-id="d48db-199">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="d48db-200">[Der Optionstyp](language-reference/options.md) ist ein Typ, der eine der beiden Fälle darstellt: ein Wert oder nichts überhaupt.</span><span class="sxs-lookup"><span data-stu-id="d48db-200">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="d48db-201">Es wird in jedem Szenario verwendet, in dem ein Wert kann oder möglicherweise nicht von einem bestimmten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d48db-201">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="d48db-202">Dies erzwingt dann für beide Fälle Besorgnis Kompilierzeit statt Besorgnis Runtime somit berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="d48db-202">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="d48db-203">Diese werden häufig in APIs verwendet, in denen `null` wird verwendet, um "nichts" stattdessen darstellen somit Dadurch entfällt die Notwendigkeit kümmern `NullReferenceException` in vielen Fällen.</span><span class="sxs-lookup"><span data-stu-id="d48db-203">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L791-L811)]

## <a name="units-of-measure"></a><span data-ttu-id="d48db-204">Maßeinheiten</span><span class="sxs-lookup"><span data-stu-id="d48db-204">Units of Measure</span></span>

<span data-ttu-id="d48db-205">Eine einzigartige Funktion des # des Typsystems ist die Möglichkeit, den Kontext für numerische Literale über Einheiten festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d48db-205">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="d48db-206">[Maßeinheiten](language-reference/units-of-measure.md) ermöglichen es Ihnen, einen numerischen Typ mit einer Einheit, z. B. Meter, zuordnen und haben Funktionen ausführen können numerische Literale, anstatt Einheiten.</span><span class="sxs-lookup"><span data-stu-id="d48db-206">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="d48db-207">Dadurch kann der Compiler, stellen Sie sicher, dass die Typen von numerischen Literalen übergebene sinnvoll unter einem bestimmten Kontext, somit-Runtime-Fehler dieser Art von Arbeit zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="d48db-207">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L818-L839)]

<span data-ttu-id="d48db-208">Die f#-Kernbibliothek definiert viele SI Einheitentypen und einheitenkonvertierungen.</span><span class="sxs-lookup"><span data-stu-id="d48db-208">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="d48db-209">Um mehr zu erfahren, sehen Sie sich die [Microsoft.FSharp.Data.UnitSystems.SI-Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="d48db-209">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="d48db-210">Klassen und Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="d48db-210">Classes and Interfaces</span></span>

<span data-ttu-id="d48db-211">F# bietet auch vollständige Unterstützung für .NET-Klassen, [Schnittstellen](language-reference/interfaces.md), [abstrakte Klassen](language-reference/abstract-classes.md), [Vererbung](language-reference/inheritance.md)und so weiter.</span><span class="sxs-lookup"><span data-stu-id="d48db-211">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="d48db-212">[Klassen](language-reference/classes.md) sind Typen, die .NET-Objekten darstellen wofür können Eigenschaften, Methoden und Ereignisse als seine [Elemente](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="d48db-212">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L848-L877)]

<span data-ttu-id="d48db-213">Definieren von generischen Klassen ist sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="d48db-213">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L884-L905)]

<span data-ttu-id="d48db-214">Um eine Schnittstelle zu implementieren, verwenden Sie entweder `interface ... with` Syntax oder einer [Objektausdruck](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d48db-214">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L912-L931)]

## <a name="which-types-to-use"></a><span data-ttu-id="d48db-215">Welche Typen zu verwenden</span><span class="sxs-lookup"><span data-stu-id="d48db-215">Which Types to Use</span></span>

<span data-ttu-id="d48db-216">Das Vorhandensein von Klassen, Datensätze und Unterscheidungs-Unions, Tupeln führt zu einer Kernfrage: welches sollten Sie verwenden?</span><span class="sxs-lookup"><span data-stu-id="d48db-216">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="d48db-217">Wie die meisten alles im Leben hängt Ihre Situation die Antwort.</span><span class="sxs-lookup"><span data-stu-id="d48db-217">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="d48db-218">Tupel sind hervorragend für mehrere Werte aus einer Funktion zurückgeben, und verwenden ein Ad-hoc-Aggregat von Werten als Wert selbst.</span><span class="sxs-lookup"><span data-stu-id="d48db-218">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="d48db-219">Eine "Step up" aus Tupeln, dass mit dem Namen Bezeichnungen und Unterstützung für optionale Elemente sind Datensätze.</span><span class="sxs-lookup"><span data-stu-id="d48db-219">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="d48db-220">Sie sind hervorragend für eine niedrige Zeremonie-Darstellung der Daten in Transit über das Programm.</span><span class="sxs-lookup"><span data-stu-id="d48db-220">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="d48db-221">Da sie Strukturgleichheit aufweisen, sind sie einfach zu verwenden, mit dem Vergleich.</span><span class="sxs-lookup"><span data-stu-id="d48db-221">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="d48db-222">Unterscheidungs-Unions sind vielseitig verwendbar, aber die Core Vorteil besteht darin, nutzen Sie diese in Verbindung mit dem Mustervergleich zum Konto für alle möglichen "Shapes", die über Daten verfügen können.</span><span class="sxs-lookup"><span data-stu-id="d48db-222">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="d48db-223">Klassen sind hervorragend für eine Vielzahl von Gründen, z. B. Wenn Sie Informationen darstellen, und binden auch diese Informationen, um Funktionen müssen.</span><span class="sxs-lookup"><span data-stu-id="d48db-223">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="d48db-224">Als Faustregel gilt Wenn Sie Funktionen haben grundsätzlich auf einige Daten gebunden ist wird mithilfe von Klassen und die Prinzipien des objektorientiertes Programmieren ein großer Vorteil.</span><span class="sxs-lookup"><span data-stu-id="d48db-224">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="d48db-225">Klassen sind auch der bevorzugte Datentyp bei der Interaktion mit c# und Visual Basic, wie diese Sprachen für nahezu alles Klassen verwenden.</span><span class="sxs-lookup"><span data-stu-id="d48db-225">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d48db-226">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="d48db-226">Next Steps</span></span>

<span data-ttu-id="d48db-227">Nun, dass Sie einige der wichtigsten Features der Programmiersprache gesehen haben, sollten Sie zum Schreiben Ihrer ersten F#-Programs bereit sein!</span><span class="sxs-lookup"><span data-stu-id="d48db-227">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="d48db-228">Auschecken [Einstieg](tutorials/getting-started/index.md) erhalten Sie Informationen zum Einrichten Ihrer Entwicklungsumgebung und Code schreiben.</span><span class="sxs-lookup"><span data-stu-id="d48db-228">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="d48db-229">Die nächsten Schritte für weitere kann einen beliebigen Namen, aber es wird empfohlen [Funktionen als erstrangige Werte](introduction-to-functional-programming/functions-as-first-class-values.md) <!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> abzurufenden mit Kernkonzepte funktionale Programmierung vertraut.</span><span class="sxs-lookup"><span data-stu-id="d48db-229">The next steps for learning more can be whatever you like, but we recommend [Functions as First-Class Values](introduction-to-functional-programming/functions-as-first-class-values.md)<!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="d48db-230">Diese werden bei der Erstellung robuster ' Software ' in f# unentbehrlich.</span><span class="sxs-lookup"><span data-stu-id="d48db-230">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="d48db-231">Darüber hinaus sehen Sie sich die [f#-Sprachreferenz](language-reference/index.md) einem umfassenden Sortiment von konzeptuellen Inhalt in f# zu sehen.</span><span class="sxs-lookup"><span data-stu-id="d48db-231">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
