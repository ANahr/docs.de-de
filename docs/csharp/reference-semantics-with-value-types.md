---
title: Verweissemantik mit Werttypen
description: Grundlegendes zu Sprachfeatures, die das Kopieren von Strukturen auf ein Minimum reduzieren
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="f5c0c-103">Verweissemantik mit Werttypen</span><span class="sxs-lookup"><span data-stu-id="f5c0c-103">Reference semantics with value types</span></span>

<span data-ttu-id="f5c0c-104">Das Verwenden von Werttypen hat den Vorteil, dass sie häufig Heapzuweisungen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="f5c0c-105">Ihr Nachteil ist, dass sie als Wert kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="f5c0c-106">Dies macht es schwieriger, Algorithmen zu optimieren, die mit großen Datenmengen arbeiten.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="f5c0c-107">Neue Sprachfeatures in C# 7.2 bieten Mechanismen, die eine Semantik zur Übergabe als Verweis mit Werttypen ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="f5c0c-108">Wenn Sie diese Features geschickt einsetzen, können Sie sowohl Speicherbelegungen als auch Kopiervorgänge minimieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="f5c0c-109">In diesem Artikel werden diese neuen Features untersucht.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-109">This article explores those new features.</span></span>

<span data-ttu-id="f5c0c-110">Viele der Codebeispiele in diesem Artikel veranschaulichen die neuen Features von C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="f5c0c-111">Um diese Features nutzen zu können, müssen Sie Ihr Projekt für die Verwendung von C# 7.2 oder höher konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="f5c0c-112">Sie können zur Auswahl Visual Studio verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="f5c0c-113">Klicken Sie für jedes Projekt im Menü **Projekt** auf **Eigenschaften**.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="f5c0c-114">Wählen Sie die Registerkarte **Build** aus, und klicken Sie auf **Erweitert**.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="f5c0c-115">Hier können Sie die Sprachversion konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-115">From there, configure the language version.</span></span> <span data-ttu-id="f5c0c-116">Wählen Sie entweder „7.2“ oder „Neueste“.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="f5c0c-117">Alternativ können Sie die *CSPROJ*-Datei bearbeiten und den folgenden Knoten hinzufügen:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="f5c0c-118">Sie können als Wert entweder „7.2“ oder „latest“ verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="f5c0c-119">Übergeben von Argumenten als schreibgeschützte Verweise</span><span class="sxs-lookup"><span data-stu-id="f5c0c-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="f5c0c-120">Ab C# 7.2 kann das Schlüsselwort `in` verwendet werden, das die vorhandenen Schlüsselwörter `ref` und `out` zum Übergeben von Argumenten als Verweise ergänzt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="f5c0c-121">Durch das `in`-Schlüsselwort wird festgelegt, dass das Argument als Verweis übergeben wird, die aufgerufene Methode aber nicht den Wert ändert.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="f5c0c-122">Dieser Zusatz bietet zahlreiche Möglichkeiten, Ihre Entwurfsabsicht auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="f5c0c-123">Werttypen werden bei der Übergabe an eine aufgerufene Methode kopiert, wenn Sie keinen der folgenden Modifizierer in den Methodensignaturen angeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="f5c0c-124">Jeder dieser Modifizierer legt fest, dass ein Werttyp als Verweis übergeben wird, wodurch ein Kopieren vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="f5c0c-125">Jeder Modifizierer drückt eine andere Absicht aus:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="f5c0c-126">`out`: Diese Methode legt den Wert des Arguments fest, das als dieser Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="f5c0c-127">`ref`: Diese Methode kann den Wert des Arguments festlegen, das als dieser Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="f5c0c-128">`in`: Diese Methode ändert den Wert des Arguments nicht, das als dieser Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="f5c0c-129">Wenn Sie den Modifizierer `in` zur Übergabe eines Arguments als Verweis hinzufügen, legen Sie als Entwurfsabsicht fest, dass Argumente als Verweis übergeben werden sollen, um unnötiges Kopieren zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="f5c0c-130">Sie beabsichtigen nicht, das als Argument verwendete Objekt zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="f5c0c-131">Der folgende Code zeigt als Beispiel eine Methode, die den Abstand zwischen Punkten in einem 3D-Raum berechnet.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="f5c0c-132">Die Argumente sind zwei Strukturen, die jeweils drei double-Werte enthalten.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="f5c0c-133">Ein double-Wert ist 8 Byte groß, also umfasst jedes Argument 24 Byte.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="f5c0c-134">Durch Angabe des Modifizierers `in` übergeben Sie – abhängig von der Architektur des Computers – einen 4-Byte- oder 8-Byte-Verweis an diese Argumente.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="f5c0c-135">Der Größenunterschied ist gering, kann sich aber schnell summieren, wenn Ihre Anwendung diese Methode in einer kurzen Schleife mit vielen unterschiedlichen Werten aufruft.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="f5c0c-136">Der Modifizierer `in` ergänzt `out` und `ref` auch in anderer Weise.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="f5c0c-137">Sie können keine Überladungen einer Methode erstellen, die sich nur durch das Vorhandensein von `in`, `out` oder `ref` unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="f5c0c-138">Diese neuen Regeln erweitern dasselbe Verhalten, das stets für `out`- und `ref`-Parameter definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="f5c0c-139">Der Modifizierer `in` kann auf einen beliebigen Member angewendet werden, der Parameter akzeptiert: Methoden, Delegaten, Lambdas, lokale Funktionen, Indexer, Operatoren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="f5c0c-140">Im Gegensatz zu `ref`- und `out`-Argumenten können Sie Literalwerte oder Konstanten für die Argumente für einen `in`-Parameter verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="f5c0c-141">Außerdem müssen Sie im Gegensatz zu einem `ref`- oder `out`-Parameter den Modifizierer `in` nicht an der Aufrufsite anwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="f5c0c-142">Der folgende Code zeigt zwei Beispiele zum Aufruf der `CalculateDistance`-Methode.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="f5c0c-143">Im ersten Beispiel werden zwei lokale Variablen als Verweis übergeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="f5c0c-144">Im zweiten Beispiel wird als Teil des Methodenaufrufs eine temporäre Variable erstellt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="f5c0c-145">Der Compiler kann auf verschiedene Weise sicherstellen, dass der Schreibschutz eines `in`-Arguments erzwungen wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="f5c0c-146">Zunächst kann die aufgerufene Methode nicht direkt einem `in`-Parameter zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="f5c0c-147">Eine direkte Zuweisung zu einem Feld eines `in`-Parameters ist nicht möglich, wenn dieser Wert vom Typ `struct` ist.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="f5c0c-148">Außerdem können Sie keinen `in`-Parameter an eine Methode übergeben, die den Modifizierer `ref` oder `out` verwendet.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="f5c0c-149">Diese Regeln gelten für jedes Feld eines `in`-Parameters, falls das Feld vom Typ `struct` und auch der Parameter vom Typ `struct` ist.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="f5c0c-150">Tatsächlich gelten diese Regeln für mehrere Memberzugriffsebenen, falls die Typen auf allen Ebenen `structs` sind.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="f5c0c-151">Der Compiler erzwingt, dass `struct`-Typen als `in`-Argumente übergeben werden und deren `struct`-Member schreibgeschützte Variablen sind, wenn sie als Argumente an anderen Methoden übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="f5c0c-152">Durch die Verwendung von `in`-Parametern können potenzielle Leistungseinbußen vermieden werden, die durch aufwendige Kopiervorgänge entstehen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="f5c0c-153">Die Semantik eines Methodenaufrufs ändert sich hierdurch nicht.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="f5c0c-154">Aus diesem Grund müssen Sie nicht den `in`-Modifizierer an der Aufrufstelle angeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="f5c0c-155">Wenn Sie jedoch den `in`-Modifizierer an der Aufrufstelle weglassen, wird dem Compiler mitgeteilt, dass es aus folgenden Gründen zulässig ist, eine Kopie des Arguments zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="f5c0c-156">Ein Argumenttyp wird in implizit in einen Parametertyp konvertiert; eine Identitätskonvertierung findet jedoch nicht statt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="f5c0c-157">Das Argument ist ein Ausdruck, verfügt jedoch nicht über eine bekannte Speichervariable.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="f5c0c-158">Eine überladene Methode unterscheidet sich nur durch die (fehlende) Angabe von `in`.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="f5c0c-159">In diesem Fall wird die überladene Methode verwendet, für die Argumente als Wert übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="f5c0c-160">Diese Regeln sind nützlich, wenn Sie vorhandenen Code anpassen und schreibgeschützte Verweisargumente verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="f5c0c-161">In der aufgerufenen Methode können Sie alle Instanzmethoden aufrufen, die als Wert übergebene Parameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="f5c0c-162">In diesen Instanzen wird eine Kopie des `in`-Parameters erstellt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="f5c0c-163">Da der Compiler eine temporäre Variable für jeden `in`-Parameter erstellen kann, können Sie auch Standardwerte für jeden `in`-Parameter angeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="f5c0c-164">Im folgenden Codebeispiel wird der Ursprung (Punkt 0,0) als Standardwert für den zweiten Punkt verwendet:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="f5c0c-165">Wenn der Compiler dazu gezwungen werden soll, schreibgeschützte Argumente als Verweis zu übergeben, müssen Sie wie im folgenden Beispiel gezeigt den `in`-Modifizierer für Argumente an der Aufrufstelle angeben:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="f5c0c-166">Durch dieses Verhalten können `in`-Parameter leichter über einen gewissen Zeitraum in große Codebasen, in denen Leistungssteigerungen möglich sind, eingeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="f5c0c-167">Zuerst fügen Sie den `in`-Modifizierer den Methodensignaturen hinzu.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="f5c0c-168">Anschließend ergänzen Sie die Aufrufstellen um den `in`-Modifizierer und erstellen `readonly struct`-Typen, damit der Compiler keine defensive Kopien von `in`-Parametern an mehreren Speicherorten erstellt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="f5c0c-169">Der Parameter `in` kann auch mit Verweistypen oder numerischen Werten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="f5c0c-170">Allerdings sind die Vorteile in beiden Fällen – wenn überhaupt – nur minimal.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="f5c0c-171">`ref readonly`-Rückgaben</span><span class="sxs-lookup"><span data-stu-id="f5c0c-171">`ref readonly` returns</span></span>

<span data-ttu-id="f5c0c-172">Sie möchten vielleicht auch einen Werttyp als Verweis zurückgeben, aber dem Aufrufer verbieten, diesen Wert zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="f5c0c-173">Verwenden Sie den Modifizierer `ref readonly`, um diese Entwurfsabsicht auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="f5c0c-174">So werden Leser darüber informiert, dass Sie einen Verweis auf vorhandene Daten zurückgeben, aber keine Änderungen zulassen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="f5c0c-175">Der Compiler erzwingt, dass der Aufrufer den Verweis nicht ändern kann.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="f5c0c-176">Versuche einer direkten Wertzuweisung führen zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="f5c0c-177">Der Compiler kann jedoch nicht wissen, ob eine Membermethode den Zustand der Struktur ändert.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="f5c0c-178">Um sicherzustellen, dass das Objekt nicht geändert wird, erstellt der Compiler eine und ruft Memberverweise mit dieser Kopie auf.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="f5c0c-179">Alle Änderungen werden an der Defensivkopie vorgenommen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="f5c0c-180">Wahrscheinlich würde die Bibliothek, die `Point3D` verwendet, im Code oft den Ursprung verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="f5c0c-181">Jede Instanz erstellt ein neues Objekt im Stapel.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="f5c0c-182">Es kann vorteilhaft sein, eine Konstante zu erstellen und diese als Verweis zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="f5c0c-183">Wenn Sie jedoch einen Verweis auf den internen Speicher zurückgeben, möchten Sie möglicherweise erzwingen, dass der Aufrufer den referenzierten Speicher nicht ändern kann.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="f5c0c-184">Der folgende Code definiert eine schreibgeschützte Eigenschaft zur Rückgabe von `readonly ref` an einen `Point3D`, der den Ursprung angibt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="f5c0c-185">Das Kopieren einer ref readonly-Rückgabe ist einfach: Weisen Sie sie einfach einer Variablen zu, die nicht mit dem Modifizierer `ref readonly` deklariert wurde.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="f5c0c-186">Der Compiler generiert Code, um das Objekt im Rahmen der Zuweisung zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="f5c0c-187">Wenn Sie `ref readonly return` eine Variable zuweisen, können Sie entweder eine `ref readonly`-Variable oder eine als Wert übergebene Kopie des schreibgeschützten Verweises angeben:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="f5c0c-188">Die erste Zuweisung im vorhergehenden Code erstellt eine Kopie der Konstanten `Origin` und weist diese Kopie zu.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="f5c0c-189">Die zweite weist einen Verweis zu.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-189">The second assigns a reference.</span></span> <span data-ttu-id="f5c0c-190">Beachten Sie, dass der Modifizierer `readonly` Teil der Variablendeklaration sein muss.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="f5c0c-191">Der referenzierte Verweis kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="f5c0c-192">Derartige Versuche führen zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="f5c0c-193">`readonly struct`-Typ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-193">`readonly struct` type</span></span>

<span data-ttu-id="f5c0c-194">Das Anwenden von `ref readonly` auf Strukturen mit hoher Auslastung kann ausreichend sein.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="f5c0c-195">In anderen Fällen möchten Sie vielleicht eine unveränderliche Struktur erstellen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="f5c0c-196">In derartigen Situationen können Sie immer schreibgeschützte Verweise übergeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="f5c0c-197">Durch diese Vorgehensweise entfallen die Defensivkopien, die beim Zugriff auf Methoden einer Struktur erstellt werden, die als `in`-Parameter verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="f5c0c-198">Sie erreichen dies, indem Sie einen `readonly struct`-Typ erstellen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="f5c0c-199">Sie können den Modifizierer `readonly` einer Strukturdeklaration hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="f5c0c-200">Der Compiler erzwingt, dass alle Instanzmember der Struktur als `readonly` festgelegt sind. `struct` muss unveränderlich sein.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="f5c0c-201">Es gibt weitere Optimierungen für `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="f5c0c-202">Sie können den Modifizierer `in` überall dort verwenden, wo `readonly struct` ein Argument ist.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="f5c0c-203">Zusätzlich können Sie `readonly struct` als `ref return` zurückgeben, wenn Sie ein Objekt zurückgeben, dessen Lebensdauer über den Bereich der Methode hinausgeht, die das Objekt zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="f5c0c-204">Schließlich erzeugt der Compiler effizienteren Code, wenn Sie Member von `readonly struct` aufrufen: Der `this`-Verweis – anstelle einer Kopie des Empfängers – ist immer ein `in`-Parameter, der als Verweis an die Membermethode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="f5c0c-205">Durch diese Optimierung entfallen weitere Kopiervorgänge, wenn Sie `readonly struct` verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="f5c0c-206">`Point3D` ist ein hervorragender Kandidat für diese Änderung.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="f5c0c-207">Der folgende Code zeigt eine aktualisierte `ReadonlyPoint3D`-Struktur:</span><span class="sxs-lookup"><span data-stu-id="f5c0c-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="f5c0c-208">`ref struct`-Typ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-208">`ref struct` type</span></span>

<span data-ttu-id="f5c0c-209">Ein weiteres zugehöriges Sprachfeature ist die Möglichkeit, einen Werttyp zu deklarieren, der im Stapel zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="f5c0c-210">Anders ausgedrückt: Diese Typen können nie im Heap als Member einer anderen Klasse erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="f5c0c-211">Der primäre Beweggrund für dieses Feature waren <xref:System.Span%601> und zugehörige Strukturen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="f5c0c-212"><xref:System.Span%601> kann einen verwalteten Zeiger als einen seiner Member enthalten, wobei der andere die span-Länge angibt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="f5c0c-213">Die Implementierung erfolgt etwas anders, weil C# keine Zeiger auf verwalteten Speicher außerhalb eines unsicheren Kontexts unterstützt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="f5c0c-214">Jeder Schreibvorgang, der den Zeiger und die Länge ändert, ist nicht unteilbar.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="f5c0c-215">Das bedeutet, dass ein <xref:System.Span%601> Bereichsfehlern oder anderen Sicherheitsverletzungen unterliegen würde, wenn es nicht auf einen einzelnen Stapelrahmen beschränkt wäre.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="f5c0c-216">Zusätzlich führt das Platzieren eines verwalteten Zeigers im GC-Heap typischerweise zu einem Absturz zur JIT-Zeit.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="f5c0c-217">Möglicherweise haben Sie ähnliche Anforderungen, wenn Sie mit Speicher arbeiten, der mit [`stackalloc`](language-reference/keywords/stackalloc.md) erstellt wurde, oder wenn Sie Speicher aus Interop-APIs verwenden.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="f5c0c-218">Sie können für diese Anforderungen eigene `ref struct`-Typen definieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="f5c0c-219">In diesem Artikel wird aus Gründen der Einfachheit `Span<T>` in den Beispielen verwendet.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="f5c0c-220">Mit der `ref struct`-Deklaration wird deklariert, dass sich eine Struktur dieses Typs auf dem Stapel befinden muss.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="f5c0c-221">Die Sprache stellt die sichere Verwendung dieser Typen sicher.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="f5c0c-222">Zu den weiteren als `ref struct` deklarierten Typen gehört <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="f5c0c-223">Das Ziel, einen `ref struct`-Typ als im Stapel zugewiesene Variable zu behalten, führt zu verschiedenen Regeln, die der Compiler für alle `ref struct`-Typen erzwingt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="f5c0c-224">Sie können für `ref struct` kein Boxing durchführen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="f5c0c-225">Sie können einen `ref struct`-Typ nicht einer Variablen vom Typ `object`, `dynamic` oder einem Schnittstellentyp zuweisen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="f5c0c-226">Sie können `ref struct` nicht als Member einer Klasse oder einer normalen Struktur deklarieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="f5c0c-227">Sie können keine lokalen Variablen deklarieren, bei denen es sich um `ref struct`-Typen in asynchronen Methoden handelt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="f5c0c-228">Sie können sie in synchronen Methoden deklarieren, die `Task`, `Task<T>` oder taskähnliche Typen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="f5c0c-229">Sie können lokale `ref struct`-Variablen nicht in Iteratoren deklarieren.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="f5c0c-230">Sie können `ref struct`-Variablen nicht in Lambda-Ausdrücken oder lokalen Funktionen erfassen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="f5c0c-231">Diese Einschränkungen stellen sicher, dass Sie `ref struct` nicht versehentlich in einer Weise verwenden, die zu einer Höherstufung in den verwalteten Heap führt.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="f5c0c-232">`readonly ref struct`-Typ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-232">`readonly ref struct` type</span></span>

<span data-ttu-id="f5c0c-233">Das Deklarieren einer Struktur als `readonly ref` vereint die Vorteile und Einschränkungen der `ref struct`- und `readonly struct`-Deklarationen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="f5c0c-234">Im folgenden Beispiel wird die Verwendung von `readonly ref struct` veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="f5c0c-235">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="f5c0c-235">Conclusions</span></span>

<span data-ttu-id="f5c0c-236">Diese Erweiterungen der Sprache C# wurden für leistungskritische Algorithmen entwickelt, bei denen Speicherbelegungen entscheidend sein können, um die erforderliche Leistung zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="f5c0c-237">Sie werden feststellen, dass Sie diese Features möglicherweise nicht oft in dem Code verwenden, den Sie schreiben.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="f5c0c-238">Diese Verbesserungen wurden jedoch an vielen Stellen im .NET Framework übernommen.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="f5c0c-239">Da immer mehr APIs diese Features nutzen, werden Sie feststellen, dass sich die Leistung Ihrer eigenen Anwendungen verbessert.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
