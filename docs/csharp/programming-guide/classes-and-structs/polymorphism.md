---
title: Polymorphismus (C#-Programmierhandbuch)
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
caps.latest.revision: 31
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: c278a6a931154af97cab5b1ff33124dd31a3fa2e
ms.contentlocale: de-de
ms.lasthandoff: 07/28/2017

---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="5847b-102">Polymorphismus (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="5847b-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="5847b-103">Polymorphismus wird häufig nach der Kapselung und der Vererbung als die dritte Säule der objektorientierten Programmierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5847b-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="5847b-104">Es handelt sich dabei um ein griechisches Wort, das "Vielgestaltigkeit" bedeutet und zwei verschiedene Aspekte umfasst:</span><span class="sxs-lookup"><span data-stu-id="5847b-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
-   <span data-ttu-id="5847b-105">In Methodenparametern, Auflistungen und Arrays können Objekte einer abgeleiteten Klasse zur Laufzeit als Objekte einer Basisklasse behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="5847b-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="5847b-106">In diesem Fall ist der deklarierte Typ des Objekts nicht mehr mit dem Laufzeittyp identisch.</span><span class="sxs-lookup"><span data-stu-id="5847b-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
-   <span data-ttu-id="5847b-107">Basisklassen können [virtuelle](../../../csharp/language-reference/keywords/virtual.md) *Methoden* definieren und implementieren und können von abgeleiteten Klassen [überschrieben](../../../csharp/language-reference/keywords/override.md) werden, was bedeutet, dass sie ihre eigene Definition und Implementierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="5847b-107">Base classes may define and implement [virtual](../../../csharp/language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../../csharp/language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="5847b-108">Zur Laufzeit, wenn die Methode von Clientcode aufgerufen wird, sucht die CLR den Laufzeittyp des Objekts und ruft die Überschreibung der virtuellen Methode auf.</span><span class="sxs-lookup"><span data-stu-id="5847b-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="5847b-109">In Ihrem Quellcode können Sie daher eine Methode in einer Basisklasse aufrufen und bewirken, dass die Methodenversion der abgeleiteten Klasse ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="5847b-110">Dank virtueller Methoden können Sie auf einheitliche Weise mit Gruppen verwandter Objekte arbeiten.</span><span class="sxs-lookup"><span data-stu-id="5847b-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="5847b-111">Nehmen Sie beispielsweise an, Sie haben eine Zeichenanwendung, mit der ein Benutzer verschiedene Arten von Formen auf einer Zeichenoberfläche erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="5847b-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="5847b-112">Zur Kompilierzeit wissen Sie nicht, welche spezifischen Typen von Formen der Benutzer erstellen wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="5847b-113">Die Anwendung muss jedoch alle verschiedenen Formentypen, die erstellt werden, nachverfolgen und diese als Antwort auf die Mausaktionen des Benutzers aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="5847b-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="5847b-114">Sie können Polymorphismus verwenden, um dieses Problem mithilfe von zwei einfachen Schritten zu lösen:</span><span class="sxs-lookup"><span data-stu-id="5847b-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1.  <span data-ttu-id="5847b-115">Erstellen Sie eine Klassenhierarchie, in der jede spezifische Formenklasse von einer gemeinsamen Basisklasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2.  <span data-ttu-id="5847b-116">Verwenden Sie eine virtuelle Methode, um die entsprechende Methode in einer abgeleiteten Klasse durch einen einzigen Aufruf der Basisklassenmethode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5847b-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="5847b-117">Erstellen Sie zuerst eine Basisklasse namens `Shape` und abgeleitete Klassen, wie z. B. `Rectangle`, `Circle` und `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="5847b-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="5847b-118">Geben Sie der `Shape`-Klasse eine virtuelle Methode namens `Draw`, und überschreiben Sie sie in jeder abgeleiteten Klasse, um die jeweilige Form zu zeichnen, die die Klasse darstellt.</span><span class="sxs-lookup"><span data-stu-id="5847b-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="5847b-119">Erstellen Sie ein `List<Shape>`-Objekt und fügen Sie einen Kreis, ein Dreieck und ein Rechteck hinzu.</span><span class="sxs-lookup"><span data-stu-id="5847b-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="5847b-120">Um die Zeichenoberfläche zu aktualisieren, verwenden Sie eine [foreach](../../../csharp/language-reference/keywords/foreach-in.md)-Schleife, um die Liste zu durchlaufen und die `Draw`-Methode für jedes `Shape`-Objekt in der Liste aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5847b-120">To update the drawing surface, use a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="5847b-121">Obwohl jedes Objekt in der Liste einen deklarierten `Shape`-Typ aufweist, wird der Laufzeittyp (die überschriebene Version der Methode in jeder abgeleiteten Klasse) aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5847b-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 <span data-ttu-id="5847b-122">[!code-cs[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-122">[!code-cs[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]</span></span>  
  
 <span data-ttu-id="5847b-123">In C# ist jeder Typ polymorph, da alle Typen, einschließlich benutzerdefinierten Typen, von <xref:System.Object> erben.</span><span class="sxs-lookup"><span data-stu-id="5847b-123">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="5847b-124">Übersicht über Polymorphismus</span><span class="sxs-lookup"><span data-stu-id="5847b-124">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="5847b-125">Virtuelle Member</span><span class="sxs-lookup"><span data-stu-id="5847b-125">Virtual Members</span></span>  
 <span data-ttu-id="5847b-126">Wenn eine abgeleitete Klasse von einer Basisklasse erbt, erhält sie alle Methoden, Felder, Eigenschaften und Ereignisse der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="5847b-126">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="5847b-127">Der Designer der abgeleiteten Klassen kann entscheiden, ob:</span><span class="sxs-lookup"><span data-stu-id="5847b-127">The designer of the derived class can choose whether to</span></span>  
  
-   <span data-ttu-id="5847b-128">virtuelle Member in der Basisklasse überschrieben werden sollen</span><span class="sxs-lookup"><span data-stu-id="5847b-128">override virtual members in the base class,</span></span>  
  
-   <span data-ttu-id="5847b-129">die nächste Basisklassenmethoden vererbt ohne Überschreiben vererbt werden soll,</span><span class="sxs-lookup"><span data-stu-id="5847b-129">inherit the closest base class method without overriding it</span></span>  
  
-   <span data-ttu-id="5847b-130">neue nicht virtuelle Member der Member definiert werden sollen, die die Basisklassenimplementierungen verbergen.</span><span class="sxs-lookup"><span data-stu-id="5847b-130">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="5847b-131">Eine abgeleitete Klasse kann einen Basisklassenmember nur überschreiben, wenn der Basisklassenmember als [virtuell](../../../csharp/language-reference/keywords/virtual.md) oder [abstrakt](../../../csharp/language-reference/keywords/abstract.md) deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="5847b-131">A derived class can override a base class member only if the base class member is declared as [virtual](../../../csharp/language-reference/keywords/virtual.md) or [abstract](../../../csharp/language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="5847b-132">Der abgeleitete Member muss das [override](../../../csharp/language-reference/keywords/override.md)-Schlüsselwort verwenden, um explizit anzugeben, dass die Methode an dem virtuellen Aufruf beteiligt sein soll.</span><span class="sxs-lookup"><span data-stu-id="5847b-132">The derived member must use the [override](../../../csharp/language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="5847b-133">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="5847b-133">The following code provides an example:</span></span>  
  
 <span data-ttu-id="5847b-134">[!code-cs[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-134">[!code-cs[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]</span></span>  
  
 <span data-ttu-id="5847b-135">Felder können nicht virtuelle sein; nur Methoden, Eigenschaften, Ereignisse und Indexer können virtuell sein.</span><span class="sxs-lookup"><span data-stu-id="5847b-135">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="5847b-136">Wenn eine abgeleitete Klasse einen virtuellen Member überschreibt, wird dieser Member auch dann aufgerufen, wenn auf eine Instanz dieser Klasse als Instanz der Basisklasse zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-136">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="5847b-137">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="5847b-137">The following code provides an example:</span></span>  
  
 <span data-ttu-id="5847b-138">[!code-cs[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-138">[!code-cs[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]</span></span>  
  
 <span data-ttu-id="5847b-139">Mithilfe virtueller Methoden und Eigenschaften können abgeleitete Klassen eine Basisklasse erweitern, ohne die Basisklassenimplementierung einer Methode verwenden zu müssen.</span><span class="sxs-lookup"><span data-stu-id="5847b-139">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="5847b-140">Weitere Informationen finden Sie unter [Versionsverwaltung mit den Schlüsselwörtern „override“ und „new“](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="5847b-140">For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="5847b-141">Eine Schnittstelle bietet eine weitere Möglichkeit zur Definition einer Methode bzw. einer Gruppe von Methoden, deren Implementierung von abgeleiteten Klassen übernommen wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-141">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="5847b-142">Weitere Informationen finden Sie unter [Schnittstellen](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="5847b-142">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="5847b-143">Ausblenden von Basisklassenmembern für neue Member</span><span class="sxs-lookup"><span data-stu-id="5847b-143">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="5847b-144">Wenn Sie möchten, dass der abgeleitete Member denselben Namen wie ein Member in einer Basisklasse aufweist, jedoch nicht möchten, dass dieser an dem virtuellen Aufruf beteiligt ist, können Sie das [new](../../../csharp/language-reference/keywords/new.md)-Schlüsselwort verwenden.</span><span class="sxs-lookup"><span data-stu-id="5847b-144">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../../csharp/language-reference/keywords/new.md) keyword.</span></span> <span data-ttu-id="5847b-145">Das `new`-Schlüsselwort wird dem Rückgabetyp eines Klassenmembers vorangestellt, der ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-145">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="5847b-146">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="5847b-146">The following code provides an example:</span></span>  
  
 <span data-ttu-id="5847b-147">[!code-cs[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-147">[!code-cs[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]</span></span>  
  
 <span data-ttu-id="5847b-148">Auf ausgeblendete Klassenmember kann vom Clientcode immer noch zugegriffen werden, indem die Instanz der abgeleiteten Klasse in eine Instanz der Basisklasse umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-148">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="5847b-149">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5847b-149">For example:</span></span>  
  
 <span data-ttu-id="5847b-150">[!code-cs[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-150">[!code-cs[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]</span></span>  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="5847b-151">Verhindern, dass abgeleitete Klassen virtuelle Member überschreiben</span><span class="sxs-lookup"><span data-stu-id="5847b-151">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="5847b-152">Virtuelle Member bleiben praktisch unendlich erhalten, unabhängig davon, wie viele Klassen zwischen dem virtuellen Member und der Klasse deklariert wurden, die diesen ursprünglich deklariert hat.</span><span class="sxs-lookup"><span data-stu-id="5847b-152">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="5847b-153">Wenn Klasse A einen virtuellen Member deklariert und Klasse B von A erbt und Klasse C von B erbt, so erbt C den virtuellen Member und hat die Option, diesen zu überschreiben, unabhängig davon, ob Klasse B das Überschreibung für diesen Member deklariert hat.</span><span class="sxs-lookup"><span data-stu-id="5847b-153">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="5847b-154">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="5847b-154">The following code provides an example:</span></span>  
  
 <span data-ttu-id="5847b-155">[!code-cs[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-155">[!code-cs[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]</span></span>  
  
 <span data-ttu-id="5847b-156">Eine abgeleitete Klasse kann die virtuelle Vererbung stoppen, indem das Überschreiben als [versiegelt](../../../csharp/language-reference/keywords/sealed.md) deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="5847b-156">A derived class can stop virtual inheritance by declaring an override as [sealed](../../../csharp/language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="5847b-157">Hierfür muss das `sealed`-Schlüsselwort in der Klassenmemberdeklaration vor das `override`-Schlüsselwort gestellt werden.</span><span class="sxs-lookup"><span data-stu-id="5847b-157">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="5847b-158">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="5847b-158">The following code provides an example:</span></span>  
  
 <span data-ttu-id="5847b-159">[!code-cs[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-159">[!code-cs[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]</span></span>  
  
 <span data-ttu-id="5847b-160">Im vorherigen Beispiel ist die Methode `DoWork` für jede von C abgeleitete Klasse nicht mehr virtuell. Sie ist weiterhin virtuell für Instanzen von C, selbst wenn diese in Typ B oder Typ A umgewandelt werden. Versiegelte Methoden können, wie im folgenden Beispiel gezeigt, mithilfe des `new`-Schlüsselworts durch abgeleitete Klassen ersetzt werden:</span><span class="sxs-lookup"><span data-stu-id="5847b-160">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 <span data-ttu-id="5847b-161">[!code-cs[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-161">[!code-cs[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]</span></span>  
  
 <span data-ttu-id="5847b-162">In diesem Fall wird, wenn `DoWork` für D mithilfe einer Variablen vom Typ D aufgerufen wird, das neue `DoWork` aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="5847b-162">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="5847b-163">Wenn eine Variable vom Typ C, B oder A zum Zugreifen auf eine Instanz von D verwendet wird, befolgt ein Aufruf von `DoWork` die Regeln der virtuellen Vererbung, und diese Aufrufe werden an die Implementierung von `DoWork` für Klasse C weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="5847b-163">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="5847b-164">Zugreifen auf virtuelle Basisklassenmember von abgeleiteten Klassen aus</span><span class="sxs-lookup"><span data-stu-id="5847b-164">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="5847b-165">Eine abgeleitete Klasse, die eine Methode oder Eigenschaft ersetzt oder überschrieben hat, kann immer noch auf die Methode oder Eigenschaft in der Basisklasse mithilfe des base-Schlüsselworts zugreifen.</span><span class="sxs-lookup"><span data-stu-id="5847b-165">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the base keyword.</span></span> <span data-ttu-id="5847b-166">Der folgende Code veranschaulicht dies:</span><span class="sxs-lookup"><span data-stu-id="5847b-166">The following code provides an example:</span></span>  
  
 <span data-ttu-id="5847b-167">[!code-cs[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]</span><span class="sxs-lookup"><span data-stu-id="5847b-167">[!code-cs[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]</span></span>  
  
 <span data-ttu-id="5847b-168">Weitere Informationen finden Sie unter [base](../../../csharp/language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="5847b-168">For more information, see [base](../../../csharp/language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5847b-169">Es wird empfohlen, dass virtuelle Member `base` verwenden, um die Basisklassenimplementierung dieses Members in seiner eigenen Implementierung aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5847b-169">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="5847b-170">Durch Zulassen des Basisklassenverhaltens kann sich die abgeleitete Klasse auf die Implementierung von Verhalten konzentrieren, das spezifisch für die abgeleitete Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="5847b-170">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="5847b-171">Wenn die Basisklassenimplementierung nicht aufgerufen wird, liegt es an der abgeleiteten Klasse, ihr Verhalten kompatibel mit dem Verhalten der Basisklasse zu gestalten.</span><span class="sxs-lookup"><span data-stu-id="5847b-171">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="5847b-172">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="5847b-172">In This Section</span></span>  
  
-   [<span data-ttu-id="5847b-173">Versionsverwaltung mit den Schlüsselwörtern "override" und "new"</span><span class="sxs-lookup"><span data-stu-id="5847b-173">Versioning with the Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="5847b-174">Wann müssen die Schlüsselwörter "override" und "new" verwendet werden?</span><span class="sxs-lookup"><span data-stu-id="5847b-174">Knowing When to Use Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="5847b-175">Gewusst wie: Überschreiben der ToString-Methode</span><span class="sxs-lookup"><span data-stu-id="5847b-175">How to: Override the ToString Method</span></span>](../../../csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method.md)  
  
## <a name="see-also"></a><span data-ttu-id="5847b-176">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5847b-176">See Also</span></span>  
 <span data-ttu-id="5847b-177">[C#-Programmierhandbuch](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-177">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="5847b-178">[C#-Programmierhandbuch](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-178">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="5847b-179">[Vererbung](../../../csharp/programming-guide/classes-and-structs/inheritance.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-179">[Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md) </span></span>  
 <span data-ttu-id="5847b-180">[Abstrakte und versiegelte Klassen und Klassenmember](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-180">[Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span></span>  
 <span data-ttu-id="5847b-181">[Methoden](../../../csharp/programming-guide/classes-and-structs/methods.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-181">[Methods](../../../csharp/programming-guide/classes-and-structs/methods.md) </span></span>  
 <span data-ttu-id="5847b-182">[Ereignisse](../../../csharp/programming-guide/events/index.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-182">[Events](../../../csharp/programming-guide/events/index.md) </span></span>  
 <span data-ttu-id="5847b-183">[Eigenschaften](../../../csharp/programming-guide/classes-and-structs/properties.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-183">[Properties](../../../csharp/programming-guide/classes-and-structs/properties.md) </span></span>  
 <span data-ttu-id="5847b-184">[Indexer](../../../csharp/programming-guide/indexers/index.md) </span><span class="sxs-lookup"><span data-stu-id="5847b-184">[Indexers](../../../csharp/programming-guide/indexers/index.md) </span></span>  
 [<span data-ttu-id="5847b-185">Typen</span><span class="sxs-lookup"><span data-stu-id="5847b-185">Types</span></span>](../../../csharp/programming-guide/types/index.md)

