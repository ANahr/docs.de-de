---
title: "Einschränkungen für Typparameter (C#-Programmierhandbuch)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 6f7c80acdb3815af4b5d545297894778029a9104
ms.sourcegitcommit: 8bde7a3432f30fc771079744955c75c58c4eb393
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/20/2018
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="ef3e7-102">Einschränkungen für Typparameter (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="ef3e7-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="ef3e7-103">Wenn Sie eine generische Klasse definieren, können Sie Beschränkungen auf die Arten der Typen anwenden, die Clientcode für generische Typargumente verwenden kann, wenn er Ihre Klasse instanziiert.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="ef3e7-104">Wenn Clientcode versucht, Ihre Klasse zu instanziieren, indem er einen Typ verwendet, der durch Ihre Einschränkung nicht erlaubt ist, kommt es zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="ef3e7-105">Diese Einschränkungen werden als Constraints bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-105">These restrictions are called constraints.</span></span> <span data-ttu-id="ef3e7-106">Constraints werden mit dem kontextuellen Schlüsselwort `where` angegeben.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="ef3e7-107">In der folgenden Tabelle werden die sechs verschiedenen Contrainttypen aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="ef3e7-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="ef3e7-108">Constraint</span><span class="sxs-lookup"><span data-stu-id="ef3e7-108">Constraint</span></span>|<span data-ttu-id="ef3e7-109">description</span><span class="sxs-lookup"><span data-stu-id="ef3e7-109">Description</span></span>|  
|----------------|-----------------|  
|`where T: struct`|<span data-ttu-id="ef3e7-110">Das Typargument muss ein Werttyp sein.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-110">The type argument must be a value type.</span></span> <span data-ttu-id="ef3e7-111">Jeder Werttyp außer <xref:System.Nullable> kann angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-111">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="ef3e7-112">Weitere Informationen finden Sie unter [Using Nullable Types (Verwenden von Nullable-Typen)](../../../csharp/programming-guide/nullable-types/using-nullable-types.md).</span><span class="sxs-lookup"><span data-stu-id="ef3e7-112">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|`where T : class`|<span data-ttu-id="ef3e7-113">Das Typargument muss ein Verweistyp sein. Dies gilt ebenfalls für Klassen-, Schnittstellen-, Delegat- oder Arraytypen.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-113">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|`where T : new()`|<span data-ttu-id="ef3e7-114">Das Typargument muss einen öffentlichen, parameterlosen Konstruktor aufweisen.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-114">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="ef3e7-115">Beim gemeinsamen Verwenden anderen Constraints muss der `new()`-Constraint zuletzt angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-115">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="ef3e7-116">`where T : `*\<Basisklassenname>*</span><span class="sxs-lookup"><span data-stu-id="ef3e7-116">`where T : `*\<base class name>*</span></span>|<span data-ttu-id="ef3e7-117">Das Typargument muss die angegebene Basisklasse sein oder von dieser abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-117">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="ef3e7-118">`where T : `*\<Schnittstellenname>*</span><span class="sxs-lookup"><span data-stu-id="ef3e7-118">`where T : `*\<interface name>*</span></span>|<span data-ttu-id="ef3e7-119">Das Typargument muss die angegebene Schnittstelle sein oder diese implementieren.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-119">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="ef3e7-120">Es können mehrere Schnittstelleneinschränkungen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-120">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="ef3e7-121">Die einschränkende Schnittstelle kann auch generisch sein.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-121">The constraining interface can also be generic.</span></span>|  
|`where T : U`|<span data-ttu-id="ef3e7-122">Das Typargument, das für T angegeben wurde, muss das für T angegebene Argument sein oder von diesem abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-122">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="ef3e7-123">Weshalb Constraints?</span><span class="sxs-lookup"><span data-stu-id="ef3e7-123">Why Use Constraints</span></span>  
 <span data-ttu-id="ef3e7-124">Wenn Sie untersuchen möchten, ob ein bestimmtes Argument in einer generischen Liste gültig ist oder es mit einem anderen Element vergleichen möchten, muss der Compiler eine Garantie haben, dass der Operator oder die Methode, die er aufgerufen hat, von jedem Typargument unterstützt wird, das von Clientcode angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-124">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="ef3e7-125">Diese Garantie wird gegeben, indem Sie einen oder mehrere Constraints auf Ihre generische Klassendefinition anwenden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-125">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="ef3e7-126">Der Basisklassenconstraint sagt dem Compiler z.B., dass nur Objekte dieses Typs oder Objekte, die von diesem Typ abgeleitet werden, als Typargumente verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-126">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="ef3e7-127">Sobald der Compiler diese Garantie hat, kann er erlauben, dass Methoden dieses Typs in der generischen Klasse aufgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-127">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="ef3e7-128">Constraints werden mit dem kontextuellen Schlüsselwort `where` angewendet.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-128">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="ef3e7-129">Im folgenden Codebeispiel wird die Funktionalität veranschaulicht, die der `GenericList<T>`-Klasse durch das Anwenden eines Basisklassenconstraints hinzugefügt werden kann (in [Einführung in Generika](../../../csharp/programming-guide/generics/introduction-to-generics.md)).</span><span class="sxs-lookup"><span data-stu-id="ef3e7-129">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="ef3e7-130">Mit dem Constraint kann die generische Klasse die `Employee.Name`-Eigenschaft verwenden, da alle Elemente des Typs T sicher ein `Employee`-Objekt oder ein Objekt, das von `Employee` erbt, sind.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-130">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="ef3e7-131">Mehrere Constraints können wie folgt auf den gleichen Typenparameter angewendet werden, und die Contraints können selbst generische Typen sein:</span><span class="sxs-lookup"><span data-stu-id="ef3e7-131">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="ef3e7-132">Indem Sie den Typparameter einschränken, erhöhen Sie die Zahl an zulässigen Vorgängen und Methodenaufrufen von denjenigen, die vom einschränkenden Typ und allen Typen in dessen Vererbungshierarchie unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-132">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="ef3e7-133">Beim Entwerfen generischer Klassen und Methoden müssen Sie Constraints auf den Typparameter anwenden, wenn Sie Vorgänge mit den generischen Membern durchführen möchten, die über das einfache Zuweisen und Aufrufen von Methoden hinausgehen, die nicht von `System.Object` unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-133">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="ef3e7-134">Wenn Sie den Constraint `where T : class` anwenden, vermeiden Sie das Verwenden der Operatoren `==` und `!=` mit dem Typparameter, da diese nur auf Verweisidentität und nicht auf Wertgleichheit prüfen.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-134">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="ef3e7-135">Dies ist auch der Fall, wenn diese Operatoren in einem Typ überladen werden, der als Argument verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-135">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="ef3e7-136">Der folgende Code veranschaulicht diesen Aspekt. Die Ausgabe ist FALSE, obwohl die <xref:System.String>-Klasse den `==`-Operator überlädt.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-136">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="ef3e7-137">Dieses Verhalten tritt auf, da der Compiler zur Kompilierzeit nur weiß, dass T ein Verweistyp ist, und deshalb die Standardoperatoren verwenden muss, die für alle Verweistypen zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-137">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="ef3e7-138">Wenn Sie auf Wertgleichheit prüfen müssen, wird empfohlen, dass Sie den `where T : IComparable<T>`-Constraint anwenden und die Schnittstelle in jeder Klasse implementieren, die verwendet wird, um die generische Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-138">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="ef3e7-139">Einschränken mehrerer Parameter</span><span class="sxs-lookup"><span data-stu-id="ef3e7-139">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="ef3e7-140">Sie können wie im folgenden Beispiel gezeigt Constraints auf mehrere Parameter und mehrere Constraints auf einen einzelnen Parameter anwenden:</span><span class="sxs-lookup"><span data-stu-id="ef3e7-140">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="ef3e7-141">Ungebundene Typparameter</span><span class="sxs-lookup"><span data-stu-id="ef3e7-141">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="ef3e7-142">Typparameter, auf die keine Constraints angewendet wurden, wie z.B. T in der öffentlichen Klasse `SampleClass<T>{}`, werden als ungebundene Typparameter bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-142">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="ef3e7-143">Für ungebundene Typparameter gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="ef3e7-143">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="ef3e7-144">Die Operatoren `!=` und `==` können nicht verwendet werden, weil es keine Garantie gibt, dass das jeweilige Typargument diese auch unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-144">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="ef3e7-145">Sie können in und aus `System.Object` oder implizit in einen Schnittstellentyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-145">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="ef3e7-146">Sie können mit [NULL](../../../csharp/language-reference/keywords/null.md) vergleichen.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-146">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="ef3e7-147">Wenn ein ungebundener Parameter mit `null` verglichen wird, gibt der Vergleich immer FALSE zurück, wenn das Typargument ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-147">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="ef3e7-148">Typparameter als Constraints</span><span class="sxs-lookup"><span data-stu-id="ef3e7-148">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="ef3e7-149">Es ist nützlich, einen Typparameter wie in folgendem Beispiel gezeigt als Constraint zu verwenden, wenn eine Memberfunktion mit ihren eigenen Typparametern diesen Parameter auf den Typparameter des enthaltenden Typs einschränken muss:</span><span class="sxs-lookup"><span data-stu-id="ef3e7-149">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="ef3e7-150">Im vorherigen Beispiel ist `T` ein Typconstraint im Kontext der `Add`-Methode und ein ungebundener Typparameter im Kontext der `List`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-150">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="ef3e7-151">Typparameter können auch in generischen Klassendefinitionen als Constraints verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-151">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="ef3e7-152">Beachten Sie, dass Typparameter in spitzen Klammern zusammen mit allen anderen Typparametern deklariert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-152">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="ef3e7-153">Das Verwenden von Typparametern als Constraints für generische Klassen ist nur bis zu einem gewissen Punkt nützlich, da der Compiler keine Informationen über den Typparameter annehmen kann, nur dass er von `System.Object` abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-153">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="ef3e7-154">Sie sollten Typparameter als Constraints dann verwenden, wenn Sie eine Vererbungsbeziehung zwischen zwei Typparametern erzwingen möchten.</span><span class="sxs-lookup"><span data-stu-id="ef3e7-154">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ef3e7-155">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="ef3e7-155">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="ef3e7-156">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="ef3e7-156">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="ef3e7-157">Einführung in Generika</span><span class="sxs-lookup"><span data-stu-id="ef3e7-157">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="ef3e7-158">Generische Klassen</span><span class="sxs-lookup"><span data-stu-id="ef3e7-158">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="ef3e7-159">new-Einschränkung</span><span class="sxs-lookup"><span data-stu-id="ef3e7-159">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
