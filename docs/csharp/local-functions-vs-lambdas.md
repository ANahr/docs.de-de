---
title: "Lokale Funktionen im Vergleich zu Lambdaausdrücken"
description: "Erfahren Sie, warum lokale Funktionen unter Umständen besser geeignet sind als Lambdaausdrücke."
keywords: "C#, .NET, .NET Core, neueste Funktionen, Neuigkeiten, lokale Funktionen, Lambdaausdrücke"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="646fe-104">Lokale Funktionen, die im Vergleich zu Lambda-Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="646fe-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="646fe-105">Auf den ersten Blick sind [lokale Funktionen](programming-guide/classes-and-structs/local-functions.md) und [Lambdaausdrücke](lambda-expressions.md) sehr ähnlich.</span><span class="sxs-lookup"><span data-stu-id="646fe-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="646fe-106">In vielen Fällen ist die Wahl zwischen der Verwendung von Lambda-Ausdrücke und lokale Funktionen nur wenige der Stil und einem persönlichen Vorlieben.</span><span class="sxs-lookup"><span data-stu-id="646fe-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="646fe-107">Es gibt jedoch real Unterschiede in den dort können Sie verwenden eine oder andere, die Sie kennen sollten.</span><span class="sxs-lookup"><span data-stu-id="646fe-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="646fe-108">Sehen wir uns die Unterschiede zwischen der Implementierungen des Fakultätsalgorithmus als lokale Funktion und als Lambdaausdruck an.</span><span class="sxs-lookup"><span data-stu-id="646fe-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="646fe-109">Erste die Version mit einer lokalen Funktion:</span><span class="sxs-lookup"><span data-stu-id="646fe-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="646fe-110">Vergleichen Sie diese Implementierung mit einer Version, die Lambdaausdrücke verwendet:</span><span class="sxs-lookup"><span data-stu-id="646fe-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="646fe-111">Der lokalen Funktionen haben Namen.</span><span class="sxs-lookup"><span data-stu-id="646fe-111">The local functions have names.</span></span> <span data-ttu-id="646fe-112">Der Lambda-Ausdrücke sind anonyme Methoden, die auf Variablen zugewiesen sind, sind `Func` oder `Action` Typen.</span><span class="sxs-lookup"><span data-stu-id="646fe-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="646fe-113">Wenn Sie eine lokale Funktion deklarieren, gehören die Argumenttypen und der Rückgabetyp der Funktionsdeklaration.</span><span class="sxs-lookup"><span data-stu-id="646fe-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="646fe-114">Statt Bestandteil der Text des Lambda-Ausdrucks gehören Ausdruck, der Argumenttypen und der Rückgabetyp des Lambda-Ausdrucks Variablentyp Deklaration.</span><span class="sxs-lookup"><span data-stu-id="646fe-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="646fe-115">Diese zwei Unterschiede klarer Code zur Folge.</span><span class="sxs-lookup"><span data-stu-id="646fe-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="646fe-116">Lokale Funktionen besitzen verschiedene Regeln für die definitive Zuweisung als Lambda-Ausdrücke.</span><span class="sxs-lookup"><span data-stu-id="646fe-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="646fe-117">Eine lokale Funktionsdeklaration kann von jedem Ort Code verwiesen werden, in denen sich im Bereich befindet.</span><span class="sxs-lookup"><span data-stu-id="646fe-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="646fe-118">Ein Lambda-Ausdruck muss in einer zuweisungsanordnung zugewiesen werden, bevor Zugriff auf (oder möglich durch die Delgate verweisen auf den Lambda-Ausdruck aufgerufen.) Beachten Sie, dass die Version mit Lambdaausdrücken den Lambdaausdruck `nthFactorial` deklarieren und initialisieren muss, bevor er definiert wird.</span><span class="sxs-lookup"><span data-stu-id="646fe-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="646fe-119">Wird das nicht gemacht, führt dies zu einem Kompilierzeitfehler, weil auf `nthFactorial` verwiesen wurde, bevor es zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="646fe-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="646fe-120">Das bedeutet, rekursive Algorithmen einfacher zu erstellen, mit der lokalen Funktionen sind.</span><span class="sxs-lookup"><span data-stu-id="646fe-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="646fe-121">Sie können deklarieren und definieren eine lokale Funktion, die sich selbst aufruft.</span><span class="sxs-lookup"><span data-stu-id="646fe-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="646fe-122">Lambda-Ausdrücke müssen deklariert werden und ein Standardwert zugewiesen werden, bevor sie einen Text neu zugewiesen werden können, die der gleichen Lambdaausdruck verweist auf.</span><span class="sxs-lookup"><span data-stu-id="646fe-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="646fe-123">Definitiven Zuweisungsregeln wirken sich auch auf alle Variablen, die von der lokalen Epression der Funktion oder Lambda-Ausdruck erfasst werden.</span><span class="sxs-lookup"><span data-stu-id="646fe-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="646fe-124">Lokale Funktionen und Lambda-Ausdruck Regeln fordern, dass alle erfassten Variablen an dem Punkt definitiv zugewiesen werden, wenn der lokale-Funktion oder einen Lambda-Ausdruck in einen Delegaten konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="646fe-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="646fe-125">Der Unterschied ist, dass Lambda-Ausdrücke in Delegaten konvertiert werden, wenn sie deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="646fe-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="646fe-126">Lokale Funktionen werden in Delegaten nur bei Verwendung als einen Delegaten konvertiert.</span><span class="sxs-lookup"><span data-stu-id="646fe-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="646fe-127">Wenn Sie eine lokale zu deklarieren und darauf nur verweisen, indem Sie diese wie eine Methode aufruft, wird er nicht in einen Delegaten konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="646fe-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="646fe-128">Diese Regel können Sie eine lokale Funktion an einen beliebigen Ort in seinem einschließenden Bereich zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="646fe-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="646fe-129">Es ist üblich, deklarieren Sie lokale Funktionen am Ende der übergeordneten Methode nach return-Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="646fe-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="646fe-130">Der Compiler kann im dritten statische Analysen durchführen, die lokale Funktionen erfasste Variablen im einschließenden Bereich definitiv zugewiesen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="646fe-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="646fe-131">Betrachten Sie das folgende Beispiel:</span><span class="sxs-lookup"><span data-stu-id="646fe-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="646fe-132">Der Compiler können Sie ermitteln, `Local` definitiv zugewiesen `y` beim Aufruf.</span><span class="sxs-lookup"><span data-stu-id="646fe-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="646fe-133">Da `Local` wird aufgerufen, bevor die `return` -Anweisung `y` Definitiely wird zugewiesen werden, auf die `return` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="646fe-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="646fe-134">Die Analyse, die es ermöglicht, dass die Analyse den vierten Unterschied ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="646fe-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="646fe-135">Je nach ihrer Verwendung können lokale Funktionen Heapzuordnungen vermeiden, die immer für Lambda-Ausdrücke erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="646fe-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="646fe-136">Wenn eine lokale Funktion niemals in einen Delegaten konvertiert wird und keines der Variablen, die von der lokalen Funktion erfasst, die von anderen Lambdas oder lokale Funktionen, die in Delegaten konvertiert werden aufgezeichnet wird, kann der Compiler Heapzuordnungen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="646fe-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="646fe-137">Betrachten Sie das folgende asynchrone Beispiel:</span><span class="sxs-lookup"><span data-stu-id="646fe-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="646fe-138">Der Abschluss dieses Lambdaausdrucks enthält die Variablen `address`, `index` und `name`.</span><span class="sxs-lookup"><span data-stu-id="646fe-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="646fe-139">Im Fall von lokalen Funktionen ist das Objekt, das den Abschluss implementiert, möglicherweise vom Typ `struct`.</span><span class="sxs-lookup"><span data-stu-id="646fe-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="646fe-140">Dieses Strukturtyps würde durch Verweis auf die lokale Funktion übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="646fe-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="646fe-141">Dieser Unterschied in der Implementierung würde auf eine Zuweisung zu speichern.</span><span class="sxs-lookup"><span data-stu-id="646fe-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="646fe-142">Die Instanziierung für Lambda-Ausdrücke erforderlich bedeutet, dass zusätzliche speicherbelegungen, u. u. einen Faktor in zeitkritischem Codepfaden.</span><span class="sxs-lookup"><span data-stu-id="646fe-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="646fe-143">Lokale Funktionen erfordern diesen Mehraufwand nicht.</span><span class="sxs-lookup"><span data-stu-id="646fe-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="646fe-144">Im obigen Beispiel hat die Version mit der lokalen Funktion zwei Zuordnungen weniger als die Version mit dem Lambdaausdruck.</span><span class="sxs-lookup"><span data-stu-id="646fe-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="646fe-145">Die Entsprechung dieser Methode mit der lokalen Funktion verwendet auch eine Klasse für den Abschluss.</span><span class="sxs-lookup"><span data-stu-id="646fe-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="646fe-146">Ob der Abschluss für eine lokale Funktion als `class` oder `struct` implementiert wird, ist ein Implementierungsdetail.</span><span class="sxs-lookup"><span data-stu-id="646fe-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="646fe-147">Eine lokale Funktion verwendet möglicherweise `struct`, während ein Lambdaausdruck immer `class` nutzt.</span><span class="sxs-lookup"><span data-stu-id="646fe-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="646fe-148">Eine letzter Vorteil, der in diesem Beispiel zu kurz gekommen ist, besteht darin, dass lokale Funktionen mithilfe der `yield return`-Syntax als Iteratoren implementiert werden können, um eine Sequenz von Werten zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="646fe-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="646fe-149">Die `yield return` Anweisung ist in Lambda-Ausdrücken nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="646fe-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="646fe-150">Während lokale Funktionen für Lambdaausdrücke als überflüssig erscheinen, dienen sie tatsächlich anderen Zwecken und haben unterschiedliche Verwendungen.</span><span class="sxs-lookup"><span data-stu-id="646fe-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="646fe-151">Lokale Funktionen sind effizienter, im Fall dass Sie eine Funktion schreiben möchten, die nur aus dem Kontext einer anderen Methode abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="646fe-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
