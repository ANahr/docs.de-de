---
title: Compilerfehler CS0173 | Microsoft-Dokumentation
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: error-reference
f1_keywords:
- CS0173
dev_langs:
- CSharp
helpviewer_keywords:
- CS0173
ms.assetid: eb1797ad-bf62-4e2b-8922-bef4aff36954
caps.latest.revision: 10
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Human Translation
ms.sourcegitcommit: 400dfda51d978f35c3995f90840643aaff1b9c13
ms.openlocfilehash: 144067f841e1ff6502d29a83a0e701624f8cdc15
ms.contentlocale: de-de
ms.lasthandoff: 03/24/2017

---
# <a name="compiler-error-cs0173"></a>Compilerfehler CS0173
Der Typ des bedingten Ausdrucks kann nicht bestimmt werden, da keine implizite Konvertierung zwischen „class1“ und „class2“ vorhanden ist.  
  
 Konvertierungen zwischen Klassen sind hilfreich, wenn Sie möchten, dass Objekte von anderen Klassen mit dem gleichen Code arbeiten. Allerdings können zwei Klassen, die zusammenarbeiten, keine gegenseitigen und redundanten Konvertierungen oder keine impliziten Konvertierungen haben. Die Typen von `class1` und `class2` werden unabhängig voneinander bestimmt, und der allgemeine Typ wird als der Typ des bedingten Ausdrucks ausgewählt. Weitere Informationen darüber, wie Typen bestimmt werden, finden Sie unter [Conditional operator cannot cast implicitly (Bedingter Operator kann nicht implizit umwandeln)](http://go.microsoft.com/fwlink/?LinkId=213999).  
  
 Um CS0173 zu beheben, überprüfen Sie, ob nur eine implizite Konvertierung zwischen `class1` und `class2` vorhanden ist, unabhängig davon, in welche Richtung die Konvertierung geht und unabhängig davon, in welcher Klasse sie besteht. Weitere Informationen finden Sie unter [Tabelle für implizite numerische Konvertierungen](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md) und [Konvertierungsoperatoren](../../../csharp/programming-guide/statements-expressions-operators/conversion-operators.md).  
  
## <a name="example"></a>Beispiel  
 Im folgenden Beispiel wird CS0173 generiert:  
  
```csharp  
// CS0173.cs  
public class C {}  
  
public class A   
{  
    //// The following code defines an implicit conversion operator from    
    //// type C to type A.  
    //public static implicit operator A(C c)  
    //{  
    //    A a = new A();  
    //    a = c;  
    //    return a;  
    //}  
}  
  
public class MyClass  
{  
    public static void F(bool b)  
    {  
        A a = new A();  
        C c = new C();  
  
        // The following line causes CS0173 because there is no implicit  
        // conversion from a to c or from c to a.  
        object o = b ? a : c;  
  
        // To resolve the error, you can cast a and c.  
        //object o = b ? (object)a : (object)c;  
  
        // Alternatively, you can add a conversion operator from class C to  
        // class A, or from class A to class C, but not both.  
    }  
  
   public static void Main()  
   {  
      F(true);  
   }  
}  
```  
  
## <a name="example"></a>Beispiel  
 Der folgende Code erzeugt keinen CS0173 in Visual Studio 2005, jedoch in höheren Versionen.  
  
```csharp  
//cs0173_2.cs  
class M  
{  
    static int Main ()  
    {  
        int X = 1;  
        // The following line causes CS0173 in Visual Studio 2005.  
        object o = (X == 0) ? null : null;  
        return -1;  
    }  
}  
```
