---
title: Dekonstruieren von Tupeln und anderen Typen
description: Informationen zum Dekonstruieren von Tupeln und anderen Typen.
keywords: .NET, .NET Core, C#
author: rpetrusha
ms-author: ronpet
ms.date: 07/18/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.translationtype: HT
ms.sourcegitcommit: 863940512f33568ee10569da4712e7e646bc3ba7
ms.openlocfilehash: ad0ed6568da073683545727ef47f6a223942c8d6
ms.contentlocale: de-de
ms.lasthandoff: 08/12/2017

---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="5af6c-104">Dekonstruieren von Tupeln und anderen Typen</span><span class="sxs-lookup"><span data-stu-id="5af6c-104">Deconstructing tuples and other types</span></span> #

<span data-ttu-id="5af6c-105">Ein Tupel stellt einen einfachen Weg bereit, um mehrere Werte aus einem Methodenaufruf abzurufen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-105">A tuple provides a light-weight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="5af6c-106">Sobald Sie den Tupel abrufen, müssen Sie jedoch seine individuellen Elemente bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="5af6c-106">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="5af6c-107">Jedes Element einzeln zu bearbeiten ist jedoch mühselig, wie das folgende Beispiel zeigt.</span><span class="sxs-lookup"><span data-stu-id="5af6c-107">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="5af6c-108">Die Methode `QueryCityData` gibt ein 3-Tupel zurück, und jedes seiner Elemente wird in einem separaten Vorgang einer Variable zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-108">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

<span data-ttu-id="5af6c-109">[!code-csharp[WithoutDeconstruction (Ohne Dekonstruieren)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-109">[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]</span></span>

<span data-ttu-id="5af6c-110">Das Abrufen von mehreren Feld- und Eigenschaftswerten aus einem Objekt kann genauso mühselig sein: Sie müssen einen Feld- oder Eigenschaftswert einer Variable zuweisen, indem Sie jedes Element einzeln eingeben.</span><span class="sxs-lookup"><span data-stu-id="5af6c-110">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span> 

<span data-ttu-id="5af6c-111">Ab C# 7 können Sie mit einem einzigen *deconstruct* (Dekonstruieren)-Vorgang mehrere Elemente aus einem Tupel oder mehrere berechnete, Feld- und Eigenschaftswerte aus einem Objekt abrufen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-111">Starting with C# 7, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="5af6c-112">Wenn Sie ein Tupel dekonstruieren, weisen Sie seine Elemente einzelnen Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="5af6c-112">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="5af6c-113">Wenn Sie ein Objekt dekonstruieren, weisen Sie bestimmte Elemente einzelnen Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="5af6c-113">When you deconstruct an object, you assign selected values to individual variables.</span></span> 

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="5af6c-114">Dekonstruieren eines Tupel</span><span class="sxs-lookup"><span data-stu-id="5af6c-114">Deconstructing a tuple</span></span>

<span data-ttu-id="5af6c-115">Die Features von C# bieten eine integrierte Unterstützung für Dekonstruieren von Tupeln, sodass Sie alle Elemente in einem Tupel mit einem einzigen Vorgang entpacken können.</span><span class="sxs-lookup"><span data-stu-id="5af6c-115">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="5af6c-116">Die allgemeine Syntax für das Dekonstruieren eines Tupel ist ähnlich der Syntax für das Definieren eines Tupel: Auf der linken Seite einer Zuweisungsanweisung umschließen Sie die Variablen, denen die Elemente zugewiesen werden sollen, mit Klammern.</span><span class="sxs-lookup"><span data-stu-id="5af6c-116">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="5af6c-117">Die folgende Anweisung weist die Elemente eines 4-Tupels beispielsweise vier einzelnen Variablen zu:</span><span class="sxs-lookup"><span data-stu-id="5af6c-117">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="5af6c-118">Es gibt zwei Wege zum Dekonstruieren eines Tupel:</span><span class="sxs-lookup"><span data-stu-id="5af6c-118">There are two ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="5af6c-119">Sie können den Typ jedes Felds innerhalb der Klammern explizit deklarieren.</span><span class="sxs-lookup"><span data-stu-id="5af6c-119">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="5af6c-120">Das folgende Beispiel verwendet diese Methode, um den 3-Tupel zu dekonstruieren, der von der Methode `QueryCityData` zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="5af6c-120">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    <span data-ttu-id="5af6c-121">[!code-csharp[Deconstruction-Explicit (Explizites Dekonstruieren)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-121">[!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]</span></span>

- <span data-ttu-id="5af6c-122">Sie können das Schlüsselwort `var` verwenden, damit C# den Typ jeder Variable herleitet.</span><span class="sxs-lookup"><span data-stu-id="5af6c-122">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="5af6c-123">Platzieren Sie das Schlüsselwort `var` außerhalb der Klammern.</span><span class="sxs-lookup"><span data-stu-id="5af6c-123">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="5af6c-124">Im folgenden Beispiel wird ein Typrückschluss beim Dekonstruieren des von der Methode `QueryCityData` zurückgegebenen 3-Tupel verwendet.</span><span class="sxs-lookup"><span data-stu-id="5af6c-124">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>
 
    <span data-ttu-id="5af6c-125">[!code-csharp[Dekonstruktion: Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-125">[!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]</span></span>

    <span data-ttu-id="5af6c-126">Sie können das Schlüsselwort `var` auch einzeln mit beliebigen oder allen Variablendeklarationen innerhalb der Klammern verwenden.</span><span class="sxs-lookup"><span data-stu-id="5af6c-126">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span> 

    <span data-ttu-id="5af6c-127">[!code-csharp[Dekonstruktion: Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-127">[!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]</span></span>

    <span data-ttu-id="5af6c-128">Dies ist jedoch sehr mühselig und wird nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-128">This is cumbersome and is not recommended.</span></span>

<span data-ttu-id="5af6c-129">Beachten Sie, dass Sie einen bestimmten Typ außerhalb der Klammern nicht spezifizieren können, auch wenn jedes Feld im Tupel den selben Typ hat.</span><span class="sxs-lookup"><span data-stu-id="5af6c-129">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="5af6c-130">Dadurch wird der Compilerfehler CS8136 „Durch die Dekonstruktion der Form „var (...)“ wird ein bestimmter Typ für „var“ unzulässig.“ generiert.</span><span class="sxs-lookup"><span data-stu-id="5af6c-130">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="5af6c-131">Beachten Sie, dass Sie ebenfalls jedes Element des Tupel einer Variable zuweisen müssen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-131">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="5af6c-132">Wenn Sie Elemente auslassen, generiert der Compiler den Fehler: CS8132, „Tupel mit x Elementen kann nicht in y Variablen dekonstruiert werden.“</span><span class="sxs-lookup"><span data-stu-id="5af6c-132">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="5af6c-133">Dekonstruieren von Tupelelementen mit Ausschüssen</span><span class="sxs-lookup"><span data-stu-id="5af6c-133">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="5af6c-134">Häufig sind Sie beim Dekonstruieren eines Tupel nur an den Werten mancher Elemente interessiert.</span><span class="sxs-lookup"><span data-stu-id="5af6c-134">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="5af6c-135">Ab C# 7 können Sie die Unterstützung von C# für *discards* (Ausschüsse) nutzen, bei dem es sich um lesegeschützte Variablen handelt, die Sie ignorieren möchten.</span><span class="sxs-lookup"><span data-stu-id="5af6c-135">Starting with C# 7, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="5af6c-136">Ein Ausschuss wird in einer Zuweisung durch einen Unterstrich („\_“) angegeben.</span><span class="sxs-lookup"><span data-stu-id="5af6c-136">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="5af6c-137">Sie können beliebig viele Werte verwerfen, diese werden alle in einem einzigen Ausschuss dargestellt, `_`.</span><span class="sxs-lookup"><span data-stu-id="5af6c-137">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="5af6c-138">Das folgende Beispiel veranschaulicht die Verwendung von Tupels mit Ausschüssen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-138">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="5af6c-139">Die Methode `QueryCityDataForYears` gibt einen 6-Tupel mit dem Namen einer Stadt, ihrer Fläche, einer Jahreszahl, der Bevölkerung der Stadt in diesem Jahr, einer zweiten Jahreszahl und der Bevölkerung der Stadt im zweiten Jahr zurück.</span><span class="sxs-lookup"><span data-stu-id="5af6c-139">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="5af6c-140">Das Beispiel zeigt die Veränderung der Bevölkerung zwischen diesen beiden Jahren.</span><span class="sxs-lookup"><span data-stu-id="5af6c-140">The example shows the change in population between those two years.</span></span> <span data-ttu-id="5af6c-141">Von den Daten, die im Tupel verfügbar sind, ist die Fläche der Stadt nicht relevant für uns und außerdem kennen wir den Namen der Stadt und die zwei Datumswerte zur Entwurfszeit.</span><span class="sxs-lookup"><span data-stu-id="5af6c-141">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="5af6c-142">Darum sind wir nur an den zwei Bevölkerungsgwerten interessiert, die im Tupel gespeichert sind und behandeln die restlichen Werte als Ausschuss.</span><span class="sxs-lookup"><span data-stu-id="5af6c-142">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

<span data-ttu-id="5af6c-143">[!code-csharp[Tuple-discard (Tupel-Ausschuss)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-143">[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="5af6c-144">Dekonstruieren von benutzerdefinierten Typen</span><span class="sxs-lookup"><span data-stu-id="5af6c-144">Deconstructing user-defined types</span></span>

<span data-ttu-id="5af6c-145">Typen, die kein Tupel sind, bieten keine integrierte Unterstützung für Ausschüsse.</span><span class="sxs-lookup"><span data-stu-id="5af6c-145">Non-tuple types do not offer built-in support for discards.</span></span> <span data-ttu-id="5af6c-146">Als Autor einer Klasse, Struktur oder Schnittstelle können Sie jedoch den Instanzen des Typs das Dekonstruieren durch die Implementierung von mindestens einer Methode `Deconstruct` gestatten.</span><span class="sxs-lookup"><span data-stu-id="5af6c-146">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="5af6c-147">Die Methode gibt „void“ zurück und jeder Wert, der dekonstruiert werden soll, wird durch den Parameter [out](language-reference/keywords/out-parameter-modifier.md) in der Methodensignatur angegeben.</span><span class="sxs-lookup"><span data-stu-id="5af6c-147">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="5af6c-148">Die folgende Methode `Deconstruct` einer `Person`-Klasse gibt beispielsweise den Vor-, Zweit- und Nachnamen zurück:</span><span class="sxs-lookup"><span data-stu-id="5af6c-148">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

<span data-ttu-id="5af6c-149">[!code-csharp[Class-deconstruct (Dekonstruieren einer Klasse)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-149">[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]</span></span>

<span data-ttu-id="5af6c-150">Sie können dann eine Instanz der Klasse `Person` mit dem Namen `p` mit einer Zuweisung wie im folgenden Beispiel dekonstruieren:</span><span class="sxs-lookup"><span data-stu-id="5af6c-150">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

<span data-ttu-id="5af6c-151">[!code-csharp[Class-deconstruct (Dekonstruieren einer Klasse)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-151">[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]</span></span>

<span data-ttu-id="5af6c-152">Das folgende Beispiel überlädt die Methode `Deconstruct`, um verschiedene Kombinationen von Eigenschaften eines `Person`-Objekts zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="5af6c-152">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="5af6c-153">Einzelne Überladungen geben Folgendes zurück:</span><span class="sxs-lookup"><span data-stu-id="5af6c-153">Individual overloads return:</span></span>

- <span data-ttu-id="5af6c-154">Einen Vor- und Nachnamen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-154">A first and last name.</span></span>
- <span data-ttu-id="5af6c-155">Einen Vor-, Nach- und Zweitnamen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-155">A first, last, and middle name.</span></span>
- <span data-ttu-id="5af6c-156">Einen Vor- und Nachnamen, einen Namen einer Stadt und eines Staats.</span><span class="sxs-lookup"><span data-stu-id="5af6c-156">A first name, a last name, a city name, and a state name.</span></span>

<span data-ttu-id="5af6c-157">[!code-csharp[Class-deconstruct (Dekonstruieren einer Klasse)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-157">[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]</span></span>

<span data-ttu-id="5af6c-158">Da Sie die Methode `Deconstruct` überladen können, um Gruppen von Daten zurückzusenden, die häufig aus einem Objekt extrahiert werden, sollten Sie bei der Definition von `Deconstruct`-Methoden darauf achten, dass deren Signaturen unverkennbar und eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="5af6c-158">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="5af6c-159">Mehrere `Deconstruct`-Methoden, die über dieselbe Anzahl an `out`-Parametern oder über dieselbe Anzahl und dieselben Typen von `out`-Parametern in unterschiedlicher Reihenfolge verfügen, können zu Verwirrung führen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-159">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span> 

<span data-ttu-id="5af6c-160">Die überladene Methode `Deconstruct` im folgenden Beispiel veranschaulicht eine mögliche Quelle der Verwirrung.</span><span class="sxs-lookup"><span data-stu-id="5af6c-160">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="5af6c-161">Die erste Überladung gibt den Vor-, Zweit- und Nachnamen und das Alter eines `Person`-Objekts in dieser Reihenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="5af6c-161">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="5af6c-162">Die zweite Überladung gibt die Informationen zu den Namen nur zusammen mit dem jährlichen Einkommen zurück. Die Reihenfolge von Vor-, Zweit- und Nachname ist jedoch eine andere.</span><span class="sxs-lookup"><span data-stu-id="5af6c-162">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="5af6c-163">Dadurch kann die Reihenfolge eines Arguments beim Dekonstruieren einer `Person`-Instanz leicht verwechselt werden.</span><span class="sxs-lookup"><span data-stu-id="5af6c-163">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

<span data-ttu-id="5af6c-164">[!code-csharp[Deconstruct-ambiguity (Mehrdeutigkeit beim Dekonstruieren)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-164">[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]</span></span>

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="5af6c-165">Dekonstruieren eines benutzerdefinierten Typs mit Ausschüssen</span><span class="sxs-lookup"><span data-stu-id="5af6c-165">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="5af6c-166">Genau wie bei [Tupels](#deconstructing-tuple-elements-with-discards) können Sie Ausschüsse verwenden, um ausgewählte Elemente zu ignorieren, die von einer `Deconstruct`-Methode zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="5af6c-166">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="5af6c-167">Jeder Ausschuss wird von einer Variable mit dem Namen „\_“ definiert, und ein einziger Dekonstruierungsvorgang kann mehrere Ausschüsse beinhalten.</span><span class="sxs-lookup"><span data-stu-id="5af6c-167">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="5af6c-168">Im folgenden Beispiel wird ein `Person`-Objekt in vier Zeichenfolgen (den Vor- und Nachnamen, die Stadt und den Staat) dekonstruiert, der Nachname und der Staat werden jedoch verworfen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-168">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

<span data-ttu-id="5af6c-169">[!code-csharp[Class-discard (Ausschuss bei Klassen)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-169">[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]</span></span>

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="5af6c-170">Dekonstruieren eines benutzerdefinierten Typs mit einer Erweiterungsmethode</span><span class="sxs-lookup"><span data-stu-id="5af6c-170">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="5af6c-171">Wenn Sie nicht der Autor einer Klasse, Struktur oder Schnittstelle sind, können Sie die Objekte dieses Typs dennoch dekonstruieren, indem Sie eine oder mehrere `Deconstruct`[extension methods (Erweiterungsmethoden)](programming-guide/classes-and-structs/extension-methods.md) implementieren, um die Werte zurückzugeben, an denen Sie interessiert sind.</span><span class="sxs-lookup"><span data-stu-id="5af6c-171">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span> 

<span data-ttu-id="5af6c-172">Im folgenden Beispiel werden zwei `Deconstruct`-Erweiterungsmethoden für die Klasse <xref:System.Reflection.PropertyInfo?displayProperty=fullName> definiert.</span><span class="sxs-lookup"><span data-stu-id="5af6c-172">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=fullName> class.</span></span> <span data-ttu-id="5af6c-173">Die erste gibt einen Satz von Werten zurück, der die Merkmale der Eigenschaft angibt, einschließlich ihres Typs, ob es sich dabei um eine statische oder eine Instanzeigenschaft handelt und ob die Eigenschaft schreibgeschützt oder indiziert ist.</span><span class="sxs-lookup"><span data-stu-id="5af6c-173">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="5af6c-174">Die zweite gibt die Zugriffsebene der Eigenschaft an.</span><span class="sxs-lookup"><span data-stu-id="5af6c-174">The second indicates the property's accessibility.</span></span> <span data-ttu-id="5af6c-175">Da die Zugriffsebene von Get- und Set-Zugriffsmethoden Unterschiede aufweisen kann, geben boolesche Werte an, ob die Eigenschaft über separate Get- und Set-Zugriffsmethoden verfügt und, wenn dies der Fall ist, ob sie über dieselbe Zugriffsebene verfügen.</span><span class="sxs-lookup"><span data-stu-id="5af6c-175">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="5af6c-176">Wenn es nur eine Zugriffsmethode gibt oder die Get- und Set-Zugriffsmethode über dieselbe Zugriffsebene verfügen, gibt die Variable `access` die Zugriffsebene der Eigenschaft als Ganzes an.</span><span class="sxs-lookup"><span data-stu-id="5af6c-176">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="5af6c-177">Andernfalls wird die Zugriffsebene der Get- und Set-Zugriffsmethoden von den Variablen `getAccess` und `setAccess` angezeigt.</span><span class="sxs-lookup"><span data-stu-id="5af6c-177">Otherwise, the accessibility of the get and set accessors are indicated by the accessaccessibility is indicated by the `getAccess` and `setAccess` variables.</span></span>

<span data-ttu-id="5af6c-178">[!code-csharp[Extension-deconstruct (Dekonstruieren von Erweiterungen)](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]</span><span class="sxs-lookup"><span data-stu-id="5af6c-178">[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]</span></span>
 
## <a name="see-also"></a><span data-ttu-id="5af6c-179">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5af6c-179">See also</span></span>
<span data-ttu-id="5af6c-180">[Discards (Ausschuss)](discards.md) </span><span class="sxs-lookup"><span data-stu-id="5af6c-180">[Discards](discards.md) </span></span>  
[<span data-ttu-id="5af6c-181">Tupel</span><span class="sxs-lookup"><span data-stu-id="5af6c-181">Tuples</span></span>](tuples.md)  

