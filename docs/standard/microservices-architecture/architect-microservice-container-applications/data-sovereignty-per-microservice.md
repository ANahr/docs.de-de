---
title: Daten Hoheit pro microservice
description: ".NET Microservices Architektur für Datenvolumes .NET-Anwendungen | Daten Hoheit pro microservice"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c51daae04215cfa6f5b5b8d2158a8ed1a8949652
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/22/2017
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="0ffd0-104">Daten Hoheit pro microservice</span><span class="sxs-lookup"><span data-stu-id="0ffd0-104">Data sovereignty per microservice</span></span>

<span data-ttu-id="0ffd0-105">Eine wichtige-Regel für Microservices-Architektur ist, dass jeder Microservice seine Domänendaten und Logik besitzen muss.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-105">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="0ffd0-106">Ebenso wie eine vollständige Anwendung die Logik und die Daten besitzt, muss daher jedes Microservice die Logik und die Daten unter einer autonomen Lebenszyklus mit unabhängigen Bereitstellung pro Microservice besitzen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-106">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="0ffd0-107">Dies bedeutet, dass das konzeptionelle Modell der Domäne zwischen Subsystemen oder Microservices abweichen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-107">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="0ffd0-108">Unternehmensanwendungen, erwägen Sie, wo Beziehung Management (CRM) kundenanwendungen transaktionale Subsysteme und Kunden Unterstützung Subsysteme jedem Aufruf auf eindeutige Kunden Entitätsattribute und erwerben und jeweils eine andere verwendet wird. Begrenzt, die den Kontext (BC).</span><span class="sxs-lookup"><span data-stu-id="0ffd0-108">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="0ffd0-109">Dieses Prinzip ähnelt in [Domain driven Design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), wobei jede [begrenzt, die den Kontext](https://martinfowler.com/bliki/BoundedContext.html) oder autonome Subsystems oder der Dienst muss seine Domänenmodell (Daten plus Logik und Verhalten) besitzen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-109">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="0ffd0-110">Jeder DDD begrenzt, die den Kontext entspricht einem Business Microservice (eine oder mehrere Dienste).</span><span class="sxs-lookup"><span data-stu-id="0ffd0-110">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="0ffd0-111">(Wir erweitern bisher über das Muster begrenzt, die den Kontext im nächsten Abschnitt.)</span><span class="sxs-lookup"><span data-stu-id="0ffd0-111">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="0ffd0-112">Andererseits, ist die herkömmliche (monolithischen Data) Ansatz in vielen Anwendungen verwendet eine einzelne zentrale Datenbank oder nur wenige Datenbanken.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-112">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="0ffd0-113">Dies ist häufig eine normalisierte SQL-Datenbank, die für die gesamte Anwendung und alle seine interne Subsysteme verwendet wird, wie in Abbildung 4-7 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-113">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="0ffd0-114">**Abbildung 4-7**.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-114">**Figure 4-7**.</span></span> <span data-ttu-id="0ffd0-115">Hoheit Datenvergleich: aufgrund eines monolithischen Datenbank im Vergleich zu Microservices</span><span class="sxs-lookup"><span data-stu-id="0ffd0-115">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="0ffd0-116">Der zentralisierten Datenbankansatz sieht einfacher ursprünglich und scheint so aktivieren Sie die Wiederverwendung von Entitäten in verschiedenen Subsysteme um alles konsistent zu machen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-116">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="0ffd0-117">Aber in der Wirklichkeit liegt, dass Sie zum Schluss großer Tabellen, die verschiedenen Subsysteme an viele dienen und, Attribute und Spalten, die nicht benötigt werden in den meisten Fällen enthalten.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-117">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="0ffd0-118">Es ist vergleichbar mit dem Versuch, die auf derselben physischen Zuordnung verwenden Sie für einen kurzen Trail wandern, eine Tag lang Car Reise dauert und dem Erlernen Geography.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-118">it is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="0ffd0-119">Eine monolithische Anwendung i. d. r. eine einzelne relationale Datenbank hat zwei wichtige Vorteile: [ACID-Transaktionen](https://en.wikipedia.org/wiki/ACID) und die SQL-Sprache, beide arbeiten in allen Tabellen und Daten im Zusammenhang mit der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-119">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="0ffd0-120">Dieser Ansatz bietet eine Möglichkeit, einfach eine Abfrage schreiben, die Daten aus mehreren Tabellen kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-120">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="0ffd0-121">Datenzugriff wird jedoch wesentlich komplexer, wenn der Wechsel zu einer Microservices-Architektur.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-121">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="0ffd0-122">Aber selbst wenn ACID-Transaktionen können oder innerhalb eines Microservice oder begrenzt, die den Kontext verwendet werden soll, die Daten, die im Besitz von jeder Microservice ist für diese Microservice privat und können nur über seine Microservice-API zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-122">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="0ffd0-123">Kapseln von Daten sichergestellt, dass die Microservices locker gekoppelt sind und können unabhängig voneinander weiterentwickelt.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-123">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="0ffd0-124">Wenn Sie mehrere Dienste zugreifen auf die gleichen Daten wurden, müsste Schemaupdates koordinierten Updates für alle Dienste.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-124">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="0ffd0-125">Dadurch wird der Microservice Lebenszyklus Autonomie unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-125">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="0ffd0-126">Aber verteilte Datenstrukturen bedeuten, dass Sie eine einzelne ACID-Transaktion über Microservices vornehmen können.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-126">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="0ffd0-127">Dies bedeutet wiederum, dass Sie eventuelle Konsistenz verwenden müssen, wenn ein Geschäftsprozess mehrere Microservices umfasst.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-127">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="0ffd0-128">Dies ist viel schwieriger zu implementieren als einfache SQL-Joins. auf ähnliche Weise sind viele weitere Funktionen, relationale Datenbank nicht über mehrere Microservices verfügbar.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-128">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="0ffd0-129">Weiterführende Themen selbst, verschiedene Microservices verwenden häufig unterschiedliche *Arten* von Datenbanken.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-129">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="0ffd0-130">Moderne Anwendungen Store und Prozess verschiedene Arten von Daten und einer relationalen Datenbank ist nicht immer die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-130">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="0ffd0-131">Für einige Anwendungsfälle, eine NoSQL-Datenbank, z. B. Azure DocumentDB oder MongoDB ist ein bequemer Datenmodell und bieten eine bessere Leistung und Skalierbarkeit als eine SQL-Datenbank wie SQL Server oder Azure SQL-Datenbank.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-131">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="0ffd0-132">In anderen Fällen ist eine relationale Datenbank immer noch die beste Herangehensweise.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-132">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="0ffd0-133">Aus diesem Grund Microservices basierende Anwendungen häufig eine Mischung von SQL- und NoSQL-Datenbanken, die in einigen Fällen aufgerufen wird, verwenden die [polyglot Persistenz](http://martinfowler.com/bliki/PolyglotPersistence.html) Ansatz.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-133">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](http://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="0ffd0-134">Eine partitionierte polyglotte persistenter Architektur für die Speicherung von weist viele Vorteile.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-134">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="0ffd0-135">Dazu gehören lose miteinander verknüpfte Dienste und eine bessere Leistung, Skalierbarkeit, Kosten und verwaltbarkeit.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-135">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="0ffd0-136">Allerdings können sie eine distributed Data Management Herausforderung dar, führen, da in erläutert "[identifizieren Domänenmodell Grenzen](#identifying-domain-model-boundaries-for-each-microservice)" weiter unten in diesem Kapitel.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-136">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="0ffd0-137">Die Beziehung zwischen Microservices und das Muster begrenzt, die den Kontext</span><span class="sxs-lookup"><span data-stu-id="0ffd0-137">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="0ffd0-138">Das Konzept der Microservice leitet sich von der [begrenzt, die den Kontext (BC) Muster](http://martinfowler.com/bliki/BoundedContext.html) in [Domain driven Design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span><span class="sxs-lookup"><span data-stu-id="0ffd0-138">The concept of microservice derives from the [Bounded Context (BC) pattern](http://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="0ffd0-139">DDD, die sie in mehrere BCs unterteilen und explizit Umrisslinien mit großen Modellen behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-139">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="0ffd0-140">Jede BC benötigen ihre eigenen Modell und Datenbank; Ebenso, besitzt jede Microservice ihre verknüpften Daten.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-140">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="0ffd0-141">Darüber hinaus in der Regel jeder BC verfügt über eine eigene [ubiquitäre Sprache](http://martinfowler.com/bliki/UbiquitousLanguage.html) Kommunikation zwischen Softwareentwickler und Domänenexperten helfen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-141">In addition, each BC usually has its own [ubiquitous language](http://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="0ffd0-142">Diese Begriffe (hauptsächlich Domänenentitäten) in der ubiquitäre Sprache können unterschiedliche Namen besitzen, in unterschiedlichen Kontexten der begrenzt, selbst wenn andere Domänenentitäten gemeinsam die gleiche Identität (d. h. die eindeutige ID, die verwendet wird, um die Entität aus dem Speicher gelesen) verwendet.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-142">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="0ffd0-143">Beispielsweise kann in einem Benutzerprofil begrenzt, die den Kontext der Entität "Domain" Benutzer Identität Domänenentität des Käufers in der Reihenfolge begrenzt, die den Kontext freigeben.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-143">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="0ffd0-144">Ein Microservice ist daher wie einem begrenzt, die den Kontext, aber es gibt auch an, dass es sich um ein verteilter Dienst handelt.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-144">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="0ffd0-145">Für jede begrenzt, die den Kontext als separater Prozess erstellt wurde, und es muss verteilte Protokolle wie HTTP/HTTPS, WebSockets, oben erwähnt oder [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span><span class="sxs-lookup"><span data-stu-id="0ffd0-145">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="0ffd0-146">Das Muster begrenzt, die den Kontext wird allerdings nicht angegeben, ob der begrenzt, die den Kontext ein verteilter Dienst, oder wenn sie einfach eine logische Begrenzung (z. B. eine generische Subsystem) ist in einer Anwendung aufgrund eines monolithischen Bereitstellung.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-146">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="0ffd0-147">Es ist wichtig, markieren Sie, dass eine gute Möglichkeit zum Definieren eines Diensts für jeden Kontext begrenzt ist werden.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-147">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="0ffd0-148">Sie haben aber nicht um den Entwurf, um es zu beschränken.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-148">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="0ffd0-149">In einigen Fällen müssen Sie einen begrenzt, die den Kontext entwerfen oder Business Microservice besteht aus mehreren physischen Dienste.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-149">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="0ffd0-150">Aber letztendlich, beide Muster – begrenzt, die den Kontext und Microservice – eng miteinander verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-150">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="0ffd0-151">DDD profitiert von der Microservices durch echte Grenzen in Form von verteilten Microservices abrufen.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-151">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="0ffd0-152">Aber Ideen wie das Modell zwischen Microservices nicht freigeben werden, was Sie auch in einem Kontext begrenzt werden soll.</span><span class="sxs-lookup"><span data-stu-id="0ffd0-152">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="0ffd0-153">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="0ffd0-153">Additional resources</span></span>

-   <span data-ttu-id="0ffd0-154">**Chris Rißling. Muster: Datenbank pro Dienst**
    [*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="0ffd0-154">**Chris Richardson. Pattern: Database per service**
[*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="0ffd0-155">**Martin Fowler. BoundedContext**
    [*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="0ffd0-155">**Martin Fowler. BoundedContext**
[*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="0ffd0-156">**Martin Fowler. PolyglotPersistence**
    [*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="0ffd0-156">**Martin Fowler. PolyglotPersistence**
[*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="0ffd0-157">**Alberto Brandolini. Strategische Domain Driven Design mithilfe der Zuordnung von Kontext**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="0ffd0-157">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0ffd0-158">[Vorherigen] (Microservices-architecture.md) [weiter] (logische-im Vergleich zur-Physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="0ffd0-158">[Previous] (microservices-architecture.md) [Next] (logical-versus-physical-architecture.md)</span></span>
