---
title: Strategien zum Beheben von Teilfehlern
description: ".NET-Microservicesarchitektur für .NET-Containeranwendungen | Strategien zum Beheben von Teilfehlern"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 0b5fdb03e4b0d0c2d4e8aa8a897fd46d56707f11
ms.sourcegitcommit: c3957fdb990060559d73cca44ab3e2c7b4d049c0
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/05/2018
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="21cc9-104">Strategien zum Beheben von Teilfehlern</span><span class="sxs-lookup"><span data-stu-id="21cc9-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="21cc9-105">Zu den Strategien für den Umgang mit Teilfehlern zählen die folgenden:</span><span class="sxs-lookup"><span data-stu-id="21cc9-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="21cc9-106">**Asynchrone Kommunikation (z.B. meldungsbasierte Kommunikation) in allen internen Microservices verwenden:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="21cc9-107">Es wird dringend empfohlen, keine langen Ketten synchroner HTTP-Aufrufe in den internen Microservices zu erstellen, da dieser falsche Entwurf im Endeffekt die Hauptursache für fehlerhafte Ausfälle wird.</span><span class="sxs-lookup"><span data-stu-id="21cc9-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="21cc9-108">Außer bei der Front-End-Kommunikation zwischen Clientanwendungen und der ersten Ebene der Microservices oder differenzierten API-Gateways wird sogar empfohlen, nach dem anfänglichen Anforderung/Antwort-Zyklus in den internen Microservices nur asynchrone (nachrichtenbasierte) Kommunikation zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="21cc9-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="21cc9-109">Konsistenz- und ereignisgesteuerte Architekturen helfen dabei, Welleneffekte zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="21cc9-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="21cc9-110">Diese Ansätze erzwingen ein höheres Maß an Autonomie der Microservices und verhindern daher das hier beschriebene Problem.</span><span class="sxs-lookup"><span data-stu-id="21cc9-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="21cc9-111">**Wiederholungen mit exponentiellem Backoff verwenden:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="21cc9-112">Diese Technik hilft dabei, kurze und vorübergehende Fehler zu vermeiden, indem Aufrufwiederholungen eine bestimmte Anzahl von Malen ausgeführt werden, falls der Dienst für kurze Zeit nicht verfügbar war.</span><span class="sxs-lookup"><span data-stu-id="21cc9-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="21cc9-113">Dazu kann es aufgrund von vorübergehenden Netzwerkproblemen kommen oder wenn ein Microservice/Container in einen anderen Knoten oder ein anderes Cluster verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="21cc9-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="21cc9-114">Werden diese Wiederholungen jedoch nicht ordnungsgemäß mit Trennschaltern entworfen, kann dies die Welleneffekte verschärfen und letztendlich zu einem [Denial-of-Service-Angriff (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack) führen.</span><span class="sxs-lookup"><span data-stu-id="21cc9-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="21cc9-115">**Netzwerktimeouts umgehen:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-115">**Work around network timeouts**.</span></span> <span data-ttu-id="21cc9-116">Clients sollten so konzipiert werden, dass sie nicht auf unbestimmte Zeit blockiert sind und Timeouts beim Warten auf einer Antwort verwenden.</span><span class="sxs-lookup"><span data-stu-id="21cc9-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="21cc9-117">Durch Timeouts wird sichergestellt, dass Ressourcen nie unbegrenzt gebunden sind.</span><span class="sxs-lookup"><span data-stu-id="21cc9-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="21cc9-118">**Trennschalter implementieren:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="21cc9-119">Bei diesem Ansatz verfolgt der Prozess die Anzahl der fehlerhaften Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="21cc9-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="21cc9-120">Wenn die Fehlerrate einen konfigurierten Grenzwert überschreitet, wird der Trennschalter geschlossen, und weitere Versuche lösen sofort einen Fehler aus.</span><span class="sxs-lookup"><span data-stu-id="21cc9-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="21cc9-121">(Wenn sehr viele Anforderungen fehlschlagen, kann das daran liegen, dass der Dienst nicht verfügbar ist und dass das Senden von Anforderungen zwecklos ist.) Nach Ablauf der Timeoutphase versucht der Client erneut, eine Anforderung zu senden, und wenn diese erfolgreich ist, wird der Trennschalter wieder geöffnet.</span><span class="sxs-lookup"><span data-stu-id="21cc9-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="21cc9-122">**Fallbacks bereitstellen:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-122">**Provide fallbacks**.</span></span> <span data-ttu-id="21cc9-123">Bei diesem Ansatz führt der Clientprozess Fallbacklogik aus, wenn eine Anforderung fehlschlägt: Es werden z.B. zwischengespeicherte Daten oder ein Standardwert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="21cc9-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="21cc9-124">Dieser Ansatz eignet sich für Abfragen und ist bei Updates oder Befehlen komplexer.</span><span class="sxs-lookup"><span data-stu-id="21cc9-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="21cc9-125">**Anzahl der Anforderungen in der Warteschlange begrenzen:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="21cc9-126">Clients sollten eine Obergrenze für die Anzahl der ausstehenden Anforderungen vorgeben, die ein Clientmicroservice an einen bestimmten Dienst senden kann.</span><span class="sxs-lookup"><span data-stu-id="21cc9-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="21cc9-127">Wenn der Grenzwert erreicht wurde, sind weitere Anforderungen zwecklos, und diese Versuche lösen sofort einen Fehler aus.</span><span class="sxs-lookup"><span data-stu-id="21cc9-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="21cc9-128">Im Hinblick auf die Implementierung kann diese Anforderung mithilfe der [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead)-Richtlinie aus Polly erfüllt werden.</span><span class="sxs-lookup"><span data-stu-id="21cc9-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="21cc9-129">Dieser Ansatz ist im Wesentlichen eine Parallelisierungsdrosselung mit <xref:System.Threading.SemaphoreSlim> als Implementierung.</span><span class="sxs-lookup"><span data-stu-id="21cc9-129">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="21cc9-130">Er lässt außerdem eine „Warteschlange“ außerhalb des Bulkheads zu.</span><span class="sxs-lookup"><span data-stu-id="21cc9-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="21cc9-131">Sie können zu viele Ladevorgänge vor der Ausführung bereits proaktiv verhindern, z.B. wenn Kapazität ausgelastet ist.</span><span class="sxs-lookup"><span data-stu-id="21cc9-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="21cc9-132">Die Antwort auf bestimmte Fehlerszenarios wird dann schneller gesendet, als ein Trennschalter reagieren würde, da ein Trennschalter auf Fehler wartet.</span><span class="sxs-lookup"><span data-stu-id="21cc9-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="21cc9-133">Das BulkheadPolicy-Objekt in Polly gibt an, wie voll der Bulkhead und die Warteschlange sind, und bietet Überlaufereignisse an, damit er auch für die automatisierte horizontale Skalierung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="21cc9-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="21cc9-134">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="21cc9-134">Additional resources</span></span>

-   <span data-ttu-id="21cc9-135">**Resilienzmuster**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="21cc9-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="21cc9-136">**Adding Resilience and Optimizing Performance (Hinzufügen von Beständigkeit und Optimieren der Leistung)**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="21cc9-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="21cc9-137">**Bulkhead:**</span><span class="sxs-lookup"><span data-stu-id="21cc9-137">**Bulkhead.**</span></span> <span data-ttu-id="21cc9-138">GitHub-Repository.</span><span class="sxs-lookup"><span data-stu-id="21cc9-138">GitHub repo.</span></span> <span data-ttu-id="21cc9-139">Implementierung mit Polly-Richtlinie</span><span class="sxs-lookup"><span data-stu-id="21cc9-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="21cc9-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="21cc9-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="21cc9-141">**Entwerfen robuster Anwendungen für Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="21cc9-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="21cc9-142">**Behandlung vorübergehender Fehler**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="21cc9-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="21cc9-143">[Zurück] (handle-partial-failure.md) [Weiter] (implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="21cc9-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
