---
title: Vereinfachte CQRS und DDD Muster in ein Microservice anwenden
description: ".NET Microservices Architektur für Datenvolumes .NET-Anwendungen | Vereinfachte CQRS und DDD Muster in ein Microservice anwenden"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 99fd7ce32039742e23f8e01aa4c33cddd7a9f698
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="ea8f4-104">Vereinfachte CQRS und DDD Muster in ein Microservice anwenden</span><span class="sxs-lookup"><span data-stu-id="ea8f4-104">Applying simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="ea8f4-105">CQRS ist eine architektonische Muster, die eine Trennung der Modelle zum Lesen und Schreiben von Daten.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-105">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="ea8f4-106">Der zugehörige Begriff [Befehl Abfrage Trennung (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) ursprünglich von Bertrand Meyer in seinem Buch definierten *dienstorientierten Software Objektkonstruktion*.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-106">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="ea8f4-107">Die Grundidee ist, dass Sie eine Systemvorgänge zwei scharf getrennten Kategorien aufteilen können:</span><span class="sxs-lookup"><span data-stu-id="ea8f4-107">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

-   <span data-ttu-id="ea8f4-108">Abfragen.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-108">Queries.</span></span> <span data-ttu-id="ea8f4-109">Diese ein Ergebnis zurückgeben, und ändern Sie den Status des Systems nicht, und sie sind keine Nebenwirkungen.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-109">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

-   <span data-ttu-id="ea8f4-110">Befehle.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-110">Commands.</span></span> <span data-ttu-id="ea8f4-111">Diese ändern den Status eines Systems.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-111">These change the state of a system.</span></span>

<span data-ttu-id="ea8f4-112">CQS ist ein einfaches Konzept – es geht um Methoden innerhalb desselben Objekts wird von Abfragen oder Befehle.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-112">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="ea8f4-113">Jede Methode Zustand zurückgibt, oder gar Status, aber nicht beides.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-113">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="ea8f4-114">Auch ein einzelnes Muster Repositoryobjekt kann CQS entsprechen.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-114">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="ea8f4-115">CQS können einen grundlegenden Prinzip CQRS betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-115">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="ea8f4-116">[Befehl und Abfrage Verantwortung Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) von Greg Young eingeführt und stark vom Udi Dahan und andere höher gestuft wurde.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-116">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="ea8f4-117">Es basiert auf dem Prinzip CQS, auch wenn es mehr detailliert erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-117">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="ea8f4-118">Sie können ein Muster basierend auf Befehle und Ereignisse sowie optional auf asynchrone Nachrichten berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-118">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="ea8f4-119">CQRS bezieht sich in vielen Fällen für erweiterte Szenarios, verfügen Sie über eine andere physische Datenbank für Lesevorgänge (Abfragen) als für Schreibvorgänge (Updates).</span><span class="sxs-lookup"><span data-stu-id="ea8f4-119">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="ea8f4-120">Darüber hinaus kann ein mehr evolved CQRS System implementieren [Ereignis Insourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) für Ihre Datenbank Updates so Sie würde nur Speichern von Ereignissen im Domänenmodell speichern die aktuellen Zustandsdaten, statt.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-120">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="ea8f4-121">Dies ist jedoch nicht die in diesem Handbuch verwendeten Ansatz; Wir verwenden die einfachste CQRS Vorgehensweise umfasst nur die Abfragen mit den Befehlen unterteilen.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-121">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="ea8f4-122">Der Aspekt Trennung CQRS erfolgt durch Gruppieren von Abfrageoperationen in einer Ebene und Befehle in einer anderen Ebene.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="ea8f4-123">Jede Ebene weist einen eigenen Datenmodell (Beachten Sie, dass das Modell, nicht unbedingt eine andere Datenbank zutrifft) und basiert auf einem eigenen Kombination von Mustern und -Technologien.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="ea8f4-124">Vor allem können die beiden Ebenen innerhalb der gleichen Ebene oder Microservice, wie im Beispiel (Reihenfolge Microservice) zu diesem Handbuch verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="ea8f4-125">Oder kann auf verschiedene Microservices oder Prozesse implementiert werden, damit optimiert und ohne Auswirkungen auf voneinander getrennt dezentral skaliert werden können.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="ea8f4-126">CQRS bedeutet dies, dass zwei Objekte für einen Vorgang Lese-/Schreibzugriff, in denen in anderen Kontexten vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="ea8f4-127">Es gibt Gründe für eine nicht normalisierte Lesevorgänge-Datenbank verfügen, die in erweiterten CQRS Literatur Sie lernen aus.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="ea8f4-128">Jedoch nicht verwenden wir hier diesen Ansatz, in dem das Ziel besteht darin, mehr Flexibilität in den Abfragen statt beschränken die Abfragen mit Einschränkungen DDD Muster wie Aggregate zu haben.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="ea8f4-129">Ein Beispiel für diese Art des Diensts ist die Reihenfolge Microservice aus der eShopOnContainers Referenz-Anwendung.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="ea8f4-130">Dieser Dienst implementiert einen Microservice basierend auf einen vereinfachten Ansatz ein CQRS.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="ea8f4-131">Es verwendet einer einzelnen Datenquelle oder Datenbank, jedoch zwei logischen Modellen plus DDD Muster für die transaktionale Domäne, wie in Abbildung 9 – 2 gezeigt.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 9-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="ea8f4-132">**Abbildung 9 – 2**.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-132">**Figure 9-2**.</span></span> <span data-ttu-id="ea8f4-133">Vereinfachte CQRS und DDD-basierte microservice</span><span class="sxs-lookup"><span data-stu-id="ea8f4-133">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="ea8f4-134">Die Anwendungsebene kann die Web-API selbst sein.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-134">The application layer can be the Web API itself.</span></span> <span data-ttu-id="ea8f4-135">Hier die wichtiger Design Aspekt ist, dass die Microservice der Abfragen und ViewModels (insbesondere für die Clientanwendungen erstellte Datenmodelle) aufgeteilt wurde aus der Befehle, Domänenmodell und Transaktionen, die das CQRS-Muster folgen.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-135">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="ea8f4-136">Dadurch bleibt die Abfragen unabhängig von Einschränkungen und Einschränkungen von DDD-Muster, die nur für Transaktionen und Updates, sinnvoll stammen, wie in späteren Abschnitten erläutert.</span><span class="sxs-lookup"><span data-stu-id="ea8f4-136">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ea8f4-137">[Vorherigen] (index.md) [weiter] (Eshoponcontainers-Cqrs-Ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="ea8f4-137">[Previous] (index.md) [Next] (eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
