---
title: Entwerfen der Persistenzebene der Infrastruktur
description: .NET-Microservicesarchitektur für .NET-Containeranwendungen | Entwerfen der Persistenzebene der Infrastruktur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.openlocfilehash: 2b15fcaeaa8934caceaeab963123650354abf291
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
ms.locfileid: "33578912"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="8a5a7-103">Entwerfen der Persistenzebene der Infrastruktur</span><span class="sxs-lookup"><span data-stu-id="8a5a7-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="8a5a7-104">Komponenten der Datenpersistenz bieten Zugriff auf die Daten, die innerhalb der Grenzen eines Microservices gehostet werden (d.h. in der Datenbank eines Microservices).</span><span class="sxs-lookup"><span data-stu-id="8a5a7-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="8a5a7-105">Sie enthalten die tatsächliche Implementierung von Komponenten wie Repositorys und [Arbeitseinheits](https://martinfowler.com/eaaCatalog/unitOfWork.html)-Klassen wie benutzerdefinierte EF-DBContexts.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="8a5a7-106">Das Repositorymuster</span><span class="sxs-lookup"><span data-stu-id="8a5a7-106">The Repository pattern</span></span>

<span data-ttu-id="8a5a7-107">Repositorys sind Klassen oder Komponenten, welche die für den Zugriff auf Datenquellen erforderliche Logik einschließen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="8a5a7-108">Sie zentralisieren allgemeine Funktionen für den Datenzugriff und bieten dabei eine bessere Verwaltbarkeit und Entkopplung der Infrastruktur oder Technologie, die für den Zugriff auf Datenbanken über die Domänenmodellebene verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="8a5a7-109">Wenn Sie eine ORM wie Entity Framework verwenden, wird der zu implementierende Code dank LINQ und starker Typisierung vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-109">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="8a5a7-110">Dadurch können Sie sich auf die Logik der Datenpersistenz konzentrieren und müssen sich nicht mit der Grundstruktur des Datenzugriffs befassen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="8a5a7-111">Das Repositorymuster stellt eine Methode mit umfassender Dokumentation für die Arbeit mit einer Datenquelle dar.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="8a5a7-112">Im Buch [Patterns of Enterprise Application Architecture (Muster der Architektur von Unternehmensanwendungen)](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/) beschreibt Martin Fowler ein Repository wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8a5a7-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="8a5a7-113">Ein Repository führt die Tasks eines Zwischenspeichers zwischen den Domänenmodellebenen und der Datenzuordnung aus und agiert dabei ähnlich wie eine Reihe von Domänenobjekten im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="8a5a7-114">Clientobjekte erstellen deklarativ Abfragen und senden diese an die Repositorys, um Antworten darauf zu bekommen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="8a5a7-115">Im Prinzip schließt ein Repository eine Reihe von Objekten, die in der Datenbank gespeichert sind, sowie Vorgänge ein, die darin ausgeführt werden können, und bietet damit eine Möglichkeit, die näher an der Persistenzebene liegt.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="8a5a7-116">Zudem unterstützen Repositorys den Zweck der eindeutigen und unidirektionalen Trennung der Abhängigkeit zwischen der Arbeitsdomäne und der Datenzuordnung.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="8a5a7-117">Definieren eines Repositorys pro Aggregat</span><span class="sxs-lookup"><span data-stu-id="8a5a7-117">Define one repository per aggregate</span></span>

<span data-ttu-id="8a5a7-118">Sie sollten für jedes Aggregat bzw. für jeden Aggregatstamm eine Repositoryklasse erstellen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="8a5a7-119">In einem auf domänengesteuerten Entwurfsmustern basierenden Microservice sollten Sie für das Update der Datenbank als einzigen Kanal die Repositorys verwenden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-119">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="8a5a7-120">Grund dafür ist, dass sie in einer 1:1-Beziehung zum Aggregatstamm stehen, wodurch die Invarianten und die Transaktionskonsistenz des Aggregats gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="8a5a7-121">Die Datenbank kann auch über andere Kanäle abgefragt werden (nach einem CQRS-Ansatz), da sich der Status der Datenbank bei Abfragen nicht ändert.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-121">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="8a5a7-122">Der Transaktionsbereich (die Updates) muss jedoch immer von den Repositorys und den Aggregatstämmen gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-122">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="8a5a7-123">Im Wesentlichen können Sie in einem Repository den Arbeitsspeicher mit Daten auffüllen, die aus der Datenbank in Form von Domänenentitäten stammen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="8a5a7-124">Sobald sich die Entitäten im Arbeitsspeicher befinden, können sie geändert und über Transaktionen wieder in der Datenbank gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="8a5a7-125">Wie bereits erwähnt wurde, werden bei Verwendung des CQS/CQRS-Architekturmusters die ersten Abfragen mit Abfragen aus dem Domänenmodell über einfache SQL-Anweisungen mit Dapper ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-125">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="8a5a7-126">Dieser Ansatz ist flexibler als Repositorys, da Sie alle erforderlichen Tabelle abfragen und verknüpfen können und diese Abfragen nicht durch Regeln aus den Aggregaten eingeschränkt werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="8a5a7-127">Diese Daten sind dann auf der Darstellungsebene oder in der Client-App enthalten.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-127">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="8a5a7-128">Wenn der Benutzer Änderungen vornimmt, werden die zu aktualisierenden Daten von der Client-App oder der Darstellungsebene auf die Anwendungsebene (z.B. ein Web-API-Dienst) verschoben.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-128">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="8a5a7-129">Wenn Sie in einem Befehlshandler einen Befehl (mit Daten) empfangen, rufen Sie die Daten, die Sie aus der Datenbank aktualisieren möchten, über Repositorys ab.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-129">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="8a5a7-130">Sie aktualisieren die Daten im Arbeitsspeicher mit den Informationen, die mit den Befehlen übergeben wurden, und können die Daten (Domänenentitäten) anschließend in der Datenbank über eine Transaktion hinzufügen oder aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="8a5a7-131">Denken Sie daran, dass für jeden Aggregatstamm wie in Abbildung 9-17 dargestellt nur ein Repository definiert werden sollte.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="8a5a7-132">Damit das Ziel des Aggregatstamms erreicht wird und die Transaktionskonsistenz zwischen allen Objekten im Aggregat erhalten bleibt, sollten Sie niemals für jede Tabelle in der Datenbank ein Repository erstellen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="8a5a7-133">**Abbildung 9-17**.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-133">**Figure 9-17**.</span></span> <span data-ttu-id="8a5a7-134">Die Beziehung zwischen Repositorys, Aggregaten und Datenbanktabellen</span><span class="sxs-lookup"><span data-stu-id="8a5a7-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="8a5a7-135">Erzwingen eines Aggregatstamms pro Repository</span><span class="sxs-lookup"><span data-stu-id="8a5a7-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="8a5a7-136">Es kann sinnvoll sein, Ihren Repositoryentwurf so zu implementieren, dass die Regel erzwungen wird, nach der nur Aggregatstämme über Repositorys verfügen sollten.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="8a5a7-137">Sie können einen generischen oder grundlegenden Repositorytyp erstellen, der den Entitätstyp einschränkt, mit dem er arbeitet, um sicherzustellen, dass die Entitäten die IAggregateRoot-Markerschnittstelle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="8a5a7-138">Daher implementiert jede auf der Infrastrukturebene implementierte Repositoryklasse wie im folgenden Code dargestellt ihren eigenen Vertrag bzw. ihre eigene Schnittstelle:</span><span class="sxs-lookup"><span data-stu-id="8a5a7-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="8a5a7-139">Jede spezifische Repositoryschnittstelle implementiert die generische IRepository-Schnittstelle:</span><span class="sxs-lookup"><span data-stu-id="8a5a7-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="8a5a7-140">Eine bessere Möglichkeit, damit der Code die Konvention erzwingt, dass die einzelnen Repositorys mit einem einzelnen Aggregat verknüpft sein sollten, besteht jedoch darin, einen generischen Repositorytyp zu implementieren, damit eindeutig ist, dass Sie ein Repository für ein bestimmtes Aggregat verwenden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-140">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="8a5a7-141">Dies kann wie im folgenden Code dargestellt ohne großen Aufwand durch die Implementierung dieses generischen Typs in der IRepository-Basisschnittstelle geschehen:</span><span class="sxs-lookup"><span data-stu-id="8a5a7-141">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="8a5a7-142">Das Repositorymuster erleichtert das Testen Ihrer Anwendungslogik</span><span class="sxs-lookup"><span data-stu-id="8a5a7-142">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="8a5a7-143">Das Repositorymuster bietet die Möglichkeit, Ihre Anwendung ohne großen Aufwand mithilfe von Komponententests zu testen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-143">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="8a5a7-144">Beachten Sie, dass bei Komponententests nur Ihr Code getestet wird, nicht die Infrastruktur, damit dieses Ziel durch die Repositoryabstraktionen leichter erreicht werden kann.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-144">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="8a5a7-145">Wie in einem Abschnitt weiter oben erwähnt, wird empfohlen, die Repositoryschnittstellen auf der Domänenmodellebene zu definieren und anzuordnen, damit die Anwendungsebene (z.B. Ihr Web-API-Microservice) nicht direkt von der Infrastrukturebene abhängt, auf der Sie die tatsächlichen Repositoryklassen implementiert haben.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-145">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="8a5a7-146">Auf diese Weise und durch Verwendung der Abhängigkeitsinjektion in den Controllern Ihrer Web-API können Sie Pseudorepositorys implementieren, die anstelle von Daten aus der Datenbank falsche Daten zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-146">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="8a5a7-147">Mit diesem entkoppelten Ansatz können Sie Komponententests erstellen und ausführen, in denen die Logik Ihrer Anwendung getestet werden kann, ohne dass eine Verbindung zur Datenbank erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-147">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="8a5a7-148">Verbindungen zu Datenbanken können fehlschlagen, und aus zwei Gründen ist von der Durchführung von Hunderten von Tests in einer Datenbank abzuraten.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-148">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="8a5a7-149">Zunächst einmal kann dies aufgrund der zahlreichen Tests viel Zeit in Anspruch nehmen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-149">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="8a5a7-150">Zudem könnten sich die Datensätze in der Datenbank ändern. Dies könnte Auswirkungen auf die Ergebnisse Ihrer Tests haben, sodass diese möglicherweise nicht konsistent sind.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-150">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="8a5a7-151">Das Testen der Datenbank ist kein Komponententest, sondern ein Integrationstest.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-151">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="8a5a7-152">Für die Datenbanken sollten viele schnelle Komponententests, aber wenige Integrationstest durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-152">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="8a5a7-153">Im Hinblick auf die Abgrenzung von Problemen bei Komponententests verwaltet Ihre Logik Domänenentitäten im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-153">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="8a5a7-154">Es wird davon ausgegangen, dass die Repositoryklasse diese Entitäten übermittelt hat.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-154">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="8a5a7-155">Sobald Ihre Logik die Domänenentitäten ändert, wird davon ausgegangen, dass diese ordnungsgemäß in der Repositoryklasse gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-155">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="8a5a7-156">Wichtig dabei ist, dass Komponententests für Ihr Domänenmodell und die zugehörige Domänenlogik erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-156">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="8a5a7-157">Aggregatstämme stellen die hauptsächlichen Konsistenzgrenzen in DDD dar.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-157">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="8a5a7-158">Der Unterschied zwischen dem Repositorymuster und dem älteren Muster der Datenzugriffsklasse (DAL-Klasse)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-158">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="8a5a7-159">Ein Datenzugriffsobjekt führt direkt Datenzugriffs- und Persistenzvorgänge für den Speicher aus.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-159">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="8a5a7-160">Ein Repository markiert die Daten mit den Vorgängen, die Sie in dem Speicher eines Arbeitseinheitsobjekts (wie in EF bei der Verwendung des DbContext) durchführen möchten. Diese Updates werden jedoch nicht sofort durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-160">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="8a5a7-161">Eine Arbeitseinheit wird als einzelne Transaktion bezeichnet, die mehrere INSERT-, UPDATE- oder DELETE-Vorgänge umfasst.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-161">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="8a5a7-162">Einfach ausgedrückt bedeutet dies, dass alle INSERT-, UPDATE- und DELETE-Transaktionen für eine bestimmte Benutzeraktion (z.B. die Registrierung auf einer Website) in einer einzelnen Transaktion verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-162">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="8a5a7-163">Dies ist effizienter als mehrere Datenbanktransaktionen auf umständlichere Weise zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-163">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="8a5a7-164">Diese Persistenzvorgänge werden zu einem späteren Zeitpunkt in einer einzelnen Aktion durchgeführt, wenn Ihr Code aus der Anwendungsebene dies anordnet.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-164">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="8a5a7-165">Die Entscheidung, ob die im Speicher vorgenommenen Änderungen am tatsächlichen Datenbankspeicher angewendet werden sollen, basiert in der Regel auf dem [Arbeitseinheitsmuster](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="8a5a7-165">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="8a5a7-166">In EF wird das Arbeitseinheitsmuster als DBContext implementiert.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-166">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="8a5a7-167">In vielen Fällen kann dieses Muster bzw. diese Methode zum Anwenden von Vorgängen im Speicher die Anwendungsleistung erhöhen und die Gefahr von Inkonsistenzen verringern.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-167">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="8a5a7-168">Zudem können Transaktionsblockierungen in den Datenbanktabellen verringert werden, da alle vorgesehenen Vorgänge im Rahmen einer Transaktion zugesichert werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-168">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="8a5a7-169">Im Vergleich zur Ausführung vieler isolierter Vorgänge in der Datenbank ist dies der effizientere Weg.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-169">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="8a5a7-170">Daher kann die ausgewählte ORM die Ausführung in der Datenbank optimieren, indem statt der Ausführung vieler kleiner und separater Transaktionen mehrere Updateaktionen innerhalb derselben Transaktion gruppiert werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-170">Therefore, the selected ORM is able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="8a5a7-171">Repositorys sollten nicht obligatorisch sein</span><span class="sxs-lookup"><span data-stu-id="8a5a7-171">Repositories should not be mandatory</span></span>

<span data-ttu-id="8a5a7-172">Benutzerdefinierte Repositorys sind aus den oben genannten Gründen hilfreich, und dies ist der Ansatz für den Microservice „Ordering“ (Bestellung) in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-172">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="8a5a7-173">Es ist jedoch kein essentielles Muster, das in einem DDD-Entwurf oder auch in der allgemeinen Entwicklung in .NET implementiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-173">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="8a5a7-174">Jimmy Bogard hat beispielsweise Folgendes geäußert, als er direktes Feedback zu diesem Leitfaden gegeben hat:</span><span class="sxs-lookup"><span data-stu-id="8a5a7-174">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="8a5a7-175">Dies wird wahrscheinlich mein ausführlichstes Feedback.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-175">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="8a5a7-176">Ich bin wirklich kein Fan von Repositorys, hauptsächlich deshalb, weil sie die wichtigen Details des zugrunde liegenden Persistenzmechanismus ausblenden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-176">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="8a5a7-177">Deswegen vertraue ich auch bei Befehlen auf MediatR.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-177">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="8a5a7-178">Ich kann die volle Leistung der Persistenzebene nutzen und das gesamte Domänenverhalten per Push in meine Aggregatstämme übertragen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-178">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="8a5a7-179">Normalerweise möchte ich keine Pseudorepositorys haben. Ich muss diese Integrationstests weiterhin am Original durchführen können.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-179">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="8a5a7-180">Dass wir uns nach CQRS gerichtet haben, bedeutet, dass wir keine Repositorys mehr benötigt haben.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-180">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="8a5a7-181">Wir finden Repositorys nützlich, können jedoch bestätigen, dass sie für Ihr DDD nicht so entscheidend sind wie das Aggregatmuster und das umfassende Domänenmodell.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-181">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="8a5a7-182">Daher können Sie selbst entscheiden, ob Sie das Repositorymuster verwenden möchten oder nicht.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-182">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="8a5a7-183">Das Spezifikationsmuster</span><span class="sxs-lookup"><span data-stu-id="8a5a7-183">The Specification pattern</span></span>

<span data-ttu-id="8a5a7-184">Das Spezifikationsmuster (dessen vollständiger Name Abfragespezifikationsmuster lautet) ist ein DDD-Entwurfsmuster, das als Ort dient, an dem Sie die Definition einer Abfrage mit optionaler Sortier- und Auslagerungslogik ablegen können.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-184">The Specification pattern (its full name would be Query-specification pattern) is a Domain-Driven Design pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="8a5a7-185">Das Spezifikationsmuster definiert eine Abfrage in einem Objekt.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-185">The Specification pattern defines a query in an object.</span></span> <span data-ttu-id="8a5a7-186">Wenn Sie beispielsweise eine ausgelagerte Abfrage einschließen möchten, die nach bestimmten Produkten sucht, können Sie eine PagedProduct-Spezifikation erstellen, die die erforderlichen Eingabeparameter (pageNumber, pageSize, filter usw.) akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-186">For example, in order to encapsulate a paged query that searches for some products, you can create a PagedProduct specification that takes the necessary input parameters (pageNumber, pageSize, filter, etc.).</span></span> <span data-ttu-id="8a5a7-187">Anschließend würde eine ISpecification-Schnittstelle innerhalb einer Repositorymethode (üblicherweise eine List()-Überladung) akzeptiert und die erwartete Abfrage anhand dieser Spezifikation ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-187">Then, within any Repository method (usually a List() overload) it would accept an ISpecification and run the expected query based on that specification.</span></span>

<span data-ttu-id="8a5a7-188">Die Verwendung dieses Ansatzes hat mehrere Vorteile:</span><span class="sxs-lookup"><span data-stu-id="8a5a7-188">There are several benefits to this approach:</span></span>

* <span data-ttu-id="8a5a7-189">Die Spezifikation hat einen Namen (im Gegensatz zu einer Reihe von LINQ-Ausdrücken), den Sie bei Diskussionen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

* <span data-ttu-id="8a5a7-190">Für die Spezifikation kann ein Komponententest ausgeführt werden, um sicherzustellen, dass sie korrekt ist.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-190">The specification can be unit tested in isolation to ensure it is right.</span></span> <span data-ttu-id="8a5a7-191">Sie kann auch ohne großen Aufwand wiederverwendet werden, wenn Sie ähnliche Verhaltensweisen benötigen,</span><span class="sxs-lookup"><span data-stu-id="8a5a7-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="8a5a7-192">beispielsweise in einer MVC View-Aktion, einer Web API-Aktion sowie in verschiedenen Diensten.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

* <span data-ttu-id="8a5a7-193">Eine Spezifikation kann auch verwendet werden, um die Form der zurückzugebenen Daten zu beschreiben, damit in Abfragen nur die erforderlichen Daten zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="8a5a7-194">Dadurch entfällt die Notwendigkeit des Lazy Loadings in Webanwendungen (wovon in der Regel ohnehin abgeraten wird). Zudem wird verhindert, dass Repositoryimplementierungen mit diesen Details überladen werden.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-194">This eliminates the need for lazy loading in web applications (which is usually not a good idea) and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="8a5a7-195">Ein Beispiel für eine generische Spezifikationsschnittstelle ist der folgende Code aus [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span><span class="sxs-lookup"><span data-stu-id="8a5a7-195">An example of a generic Specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="8a5a7-196">In den nächsten Abschnitten wird erläutert, wie das Spezifikationsmuster mit Entity Framework Core 2.0 implementiert und wie es über eine beliebige Repositoryklasse verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-196">In the upcoming sections, it is explained how to implement the Specification pattern with Entity Framework Core 2.0 and how to use it from any Repository class.</span></span>

<span data-ttu-id="8a5a7-197">**Wichtiger Hinweis:** Bei diesem Spezifikationsmuster handelt es sich um ein altes Muster, das auf viele verschiedene Arten implementiert werden kann, z.B. in den folgenden zusätzlichen Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-197">**Important note:** The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="8a5a7-198">Als Muster bzw. Anregung ist es hilfreich, ältere Ansätze zu kennen. Meiden Sie jedoch ältere Implementierungen, die keinen modernen Sprachfunktionen wie Linq und Ausdrücke nutzen.</span><span class="sxs-lookup"><span data-stu-id="8a5a7-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="8a5a7-199">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="8a5a7-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="8a5a7-200">Das Repositorymuster</span><span class="sxs-lookup"><span data-stu-id="8a5a7-200">The Repository pattern</span></span>

-   <span data-ttu-id="8a5a7-201">**Edward Hieatt und Rob Mee. Repository pattern (Repositorymuster).**
    [*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-201">**Edward Hieatt and Rob Mee. Repository pattern.**
[*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="8a5a7-202">**The Repository Pattern (Das Repositorymuster)**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-202">**The Repository pattern**
[*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="8a5a7-203">**Repository Pattern: A data persistence abstraction (Repositorymuster: Eine Datenpersistenzabstraktion)**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-203">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="8a5a7-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software (Domänengesteuertes Design: Umgang mit Komplexität im Kern einer Software).**</span><span class="sxs-lookup"><span data-stu-id="8a5a7-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="8a5a7-205">(Buch; enthält eine Diskussion des Repositorymusters) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-205">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="8a5a7-206">Arbeitseinheitsmuster</span><span class="sxs-lookup"><span data-stu-id="8a5a7-206">Unit of Work pattern</span></span>

-   <span data-ttu-id="8a5a7-207">**Martin Fowler. Unit of Work pattern (Arbeitseinheitsmuster).**
    [*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-207">**Martin Fowler. Unit of Work pattern.**
[*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="8a5a7-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application (Implementieren der Muster „Repository“ und „Arbeitseinheit“ in eine ASP.NET MVC-Anwendung)**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="8a5a7-209">Das Spezifikationsmuster</span><span class="sxs-lookup"><span data-stu-id="8a5a7-209">The Specification pattern</span></span>

-   <span data-ttu-id="8a5a7-210">**The Specification pattern (Das Spezifikationsmuster)**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-210">**The Specification pattern.**
[*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span></span>

-   <span data-ttu-id="8a5a7-211">**Evans, Eric (2004). Domain-Driven Design. Addison-Wesley. S. 224.**</span><span class="sxs-lookup"><span data-stu-id="8a5a7-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

-   <span data-ttu-id="8a5a7-212">**Specifications (Spezifikationen). Martin Fowler**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-212">**Specifications. Martin Fowler**
[*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="8a5a7-213">[Zurück] (domain-events-design-implementation.md) [Weiter] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="8a5a7-213">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
