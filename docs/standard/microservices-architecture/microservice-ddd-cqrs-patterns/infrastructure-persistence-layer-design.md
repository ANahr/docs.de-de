---
title: Entwerfen der Infrastruktur Persistenzebene
description: ".NET Microservices Architektur für Datenvolumes .NET-Anwendungen | Entwerfen der Infrastruktur Persistenzebene"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="21ed9-104">Entwerfen der Infrastruktur Persistenzebene</span><span class="sxs-lookup"><span data-stu-id="21ed9-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="21ed9-105">Dauerhaftigkeitskomponenten Daten bereitstellen, Zugriff auf die Daten innerhalb der Grenzen des ein Microservice (d. h. ein Microservice-Datenbank) gehostet wird.</span><span class="sxs-lookup"><span data-stu-id="21ed9-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="21ed9-106">Sie enthalten die tatsächliche Implementierung von Komponenten wie Repositorys und [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) -Klassen, wie benutzerdefinierte EF DBContexts.</span><span class="sxs-lookup"><span data-stu-id="21ed9-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="21ed9-107">Das Repositorymuster</span><span class="sxs-lookup"><span data-stu-id="21ed9-107">The Repository pattern</span></span>

<span data-ttu-id="21ed9-108">Repositorys werden Klassen oder Komponenten, die die Logik erforderlich, um den Zugriff auf Datenquellen zu kapseln.</span><span class="sxs-lookup"><span data-stu-id="21ed9-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="21ed9-109">Diese Zentralisierung allgemeine Data Access-Funktionalität, bietet eine bessere Verwaltbarkeit und die Entkopplung der Infrastruktur oder eine Technologie, die Zugriff auf die Datenbanken aus der Domäne der Ebene verwendet.</span><span class="sxs-lookup"><span data-stu-id="21ed9-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="21ed9-110">Wenn Sie ein ORM wie Entity Framework verwenden, wird der Code, der implementiert werden muss, Dank LINQ und starke Typisierung vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="21ed9-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="21ed9-111">Dadurch können Sie den Fokus auf die Persistenzlogik Daten anstatt auf Daten zugreifen, Basisaufgaben.</span><span class="sxs-lookup"><span data-stu-id="21ed9-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="21ed9-112">Das Repositorymuster ist eine gut dokumentierten Möglichkeit des Arbeitens mit einer Datenquelle.</span><span class="sxs-lookup"><span data-stu-id="21ed9-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="21ed9-113">Im Buch [Muster der Anwendungsarchitektur Enterprise](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Smell beschreibt ein Repository wie folgt:</span><span class="sxs-lookup"><span data-stu-id="21ed9-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="21ed9-114">Ein Repository führt die Tasks der Vermittler zwischen der Domäne dienstmodellebene und datenzuordnung, auf ähnliche Weise auf einen Satz von Domänenobjekten im Arbeitsspeicher fungiert.</span><span class="sxs-lookup"><span data-stu-id="21ed9-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="21ed9-115">-Clientobjekte deklarativ Abfragen erstellen und an den Repositorys für Antworten senden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="21ed9-116">Im Prinzip kapselt ein Repository einen Satz von Objekten, die in der Datenbank und die Vorgänge, die ausgeführt werden können, auf diesen zu ermöglichen, die näher an der Persistenzebene wird gespeichert.</span><span class="sxs-lookup"><span data-stu-id="21ed9-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="21ed9-117">-Repositorys, die unterstützt außerdem des Zwecks trennen, klar und in eine Richtung, die Abhängigkeit zwischen der Domäne für die Arbeit und die Verteilung der Daten oder Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="21ed9-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="21ed9-118">Definieren Sie ein Repository pro Aggregat</span><span class="sxs-lookup"><span data-stu-id="21ed9-118">Define one repository per aggregate</span></span>

<span data-ttu-id="21ed9-119">Für jedes Stammelement aggregate oder aggregate sollten Sie eine Repository-Klasse erstellen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="21ed9-120">In einem Microservice anhand von Mustern Domain driven Design sollte der einzige Kanal, werden, zum Aktualisieren der Datenbank verwendet soll, den Repositorys.</span><span class="sxs-lookup"><span data-stu-id="21ed9-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="21ed9-121">Dies ist, da sie eine direkte Beziehung mit der aggregierten Stamm aufweisen, die des Aggregats Invarianten und Transaktionskonsistenz gesteuert.</span><span class="sxs-lookup"><span data-stu-id="21ed9-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="21ed9-122">Es ist angemessen, Fragen Sie die Datenbank über andere Kanäle (wie nach einem CQRS-Ansatz), da es sich bei Abfragen der Status der Datenbank nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="21ed9-123">Allerdings Bereich transaktional – Updates – muss immer durch den Repositorys und die aggregate Stämme gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="21ed9-124">Im Wesentlichen können mit einem Repository Daten im Arbeitsspeicher zu füllen, die aus der Datenbank in Form von Domänenentitäten stammen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="21ed9-125">Sobald die Entitäten im Arbeitsspeicher befinden, können sie geändert und dann in der Datenbank über Transaktionen übernommen werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="21ed9-126">Wie oben bereits erwähnt, wenn Sie das architektonische CQS/CQRS-Muster verwenden, werden die anfängliche Abfragen von clientseitigen Abfragen Out Domänenmodell ausgeführt durch einfache SQL-Anweisungen, die mit dapper, durch ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="21ed9-127">Dieser Ansatz ist viel mehr als Repositorys flexibel, da Sie können Abfragen und verknüpfen alle Tabellen müssen und diese Abfragen werden nicht von Regeln aus der Aggregate eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="21ed9-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="21ed9-128">Diese Daten werden für die Präsentation Ebene oder Client-app wechseln</span><span class="sxs-lookup"><span data-stu-id="21ed9-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="21ed9-129">Wenn der Benutzer Änderungen vornimmt, stammen die Daten aktualisiert werden aus der Client-app oder eine Präsentation-Ebene für die Anwendungsebene (z. B. eine Web-API-Dienst).</span><span class="sxs-lookup"><span data-stu-id="21ed9-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="21ed9-130">Wenn Sie einen Befehl (mit Daten) im Befehlshandler erhalten, verwenden Sie Repositorys zum Abrufen der Daten, die Sie aus der Datenbank aktualisieren möchten.</span><span class="sxs-lookup"><span data-stu-id="21ed9-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="21ed9-131">Sie es im Arbeitsspeicher mit den Informationen, die mit den Befehlen übergeben aktualisieren, und klicken Sie dann hinzufügen oder aktualisieren Sie die Daten (Domänenentitäten) in der Datenbank über eine Transaktion.</span><span class="sxs-lookup"><span data-stu-id="21ed9-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="21ed9-132">Wir müssen betonen erneut, die nur ein Repository sollte für jedes aggregieren Stammelement definiert werden, wie in Abbildung 9-17 gezeigt.</span><span class="sxs-lookup"><span data-stu-id="21ed9-132">We must emphasize again that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="21ed9-133">Um das Ziel der Stamm-aggregate, die Transaktionskonsistenz zwischen allen Objekten innerhalb des Aggregats aufrechterhalten zu erreichen, sollten Sie niemals ein Repository für jede Tabelle in der Datenbank erstellen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="21ed9-134">**Abbildung 9-17**.</span><span class="sxs-lookup"><span data-stu-id="21ed9-134">**Figure 9-17**.</span></span> <span data-ttu-id="21ed9-135">Die Beziehung zwischen Repositorys, Aggregate und Datenbanktabellen</span><span class="sxs-lookup"><span data-stu-id="21ed9-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="21ed9-136">Erzwingen eine aggregierte Stamm pro repository</span><span class="sxs-lookup"><span data-stu-id="21ed9-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="21ed9-137">Es kann sinnvoll sein, die Ihrem Repository Entwurf so implementieren, dass sie die Regel führt dazu, dass nur aggregate Stämme Repositorys verfügen sollen sein.</span><span class="sxs-lookup"><span data-stu-id="21ed9-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="21ed9-138">Sie können einen generische oder eine Basis-Repository-Typ erstellen, der den Typ von Entitäten einschränkt, mit dem es um sicherzustellen, dass sie die IAggregateRoot markerschnittstelle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="21ed9-139">Daher implementiert jede Repository-Klasse, die auf der Infrastrukturebene implementiert einen eigenen Vertrag oder einer Schnittstelle, wie im folgenden Code gezeigt:</span><span class="sxs-lookup"><span data-stu-id="21ed9-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="21ed9-140">Jede Schnittstelle spezifischen Repository implementiert die generische IRepository-Schnittstelle:</span><span class="sxs-lookup"><span data-stu-id="21ed9-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="21ed9-141">Jedoch eine bessere Möglichkeit, den Code die Konvention zu erzwingen, dass jedes Repository zu einer einzelnen gesamtverstärkung verknüpft werden soll wäre, einen generischen Repository-Typ zu implementieren, sodass er explizit ist, dass Sie ein Repository für eine bestimmte Aggregat entwickeln verwenden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="21ed9-142">Dies kann problemlos durch die Implementierung dieses Generikum in der Basisschnittstelle IRepository wie im folgenden Code erfolgen:</span><span class="sxs-lookup"><span data-stu-id="21ed9-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="21ed9-143">Das Repositorymuster erleichtert es, die Anwendungslogik zu testen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="21ed9-144">Das Repositorymuster bietet die Möglichkeit, leicht Testen Ihrer Anwendung mit Komponententests abgedeckt.</span><span class="sxs-lookup"><span data-stu-id="21ed9-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="21ed9-145">Denken Sie daran, dass Komponententests nur getestet, Ihr Code, der nicht-Infrastruktur, sodass die Repository-Abstraktionen erreichen dieses Ziels erleichtern.</span><span class="sxs-lookup"><span data-stu-id="21ed9-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="21ed9-146">Wie in einem Abschnitt weiter oben erwähnt, wird empfohlen, dass Sie definieren platziert die Repository-Schnittstellen in die Domäne der Ebene, damit die Anwendungsschicht (z. B. Ihre Web-API-Microservice) nicht direkt auf die Infrastrukturebene abhängt, in denen Ihnen implementiert die tatsächliche Repositoryklassen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="21ed9-147">Indem Sie auf diese Weise und mithilfe der Abhängigkeitsinjektion in die Ihre Web-API-Controller, können Sie simulierten Repositorys implementieren, die Pseudodaten anstelle von Daten aus der Datenbank zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="21ed9-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="21ed9-148">Entkoppelte Ansatz ermöglicht Ihnen das Erstellen und Ausführen von Komponententests, die können nur die Logik Ihrer Anwendung testen, ohne Verbindung mit der Datenbank.</span><span class="sxs-lookup"><span data-stu-id="21ed9-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="21ed9-149">Verbindungen mit Datenbanken können fehlschlagen, vor allem Hunderte von Tests für eine Datenbank ausgeführt wird und fehlerhafte zwei Gründen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="21ed9-150">Zuerst, dauert es sehr lange aufgrund der großen Anzahl von Tests.</span><span class="sxs-lookup"><span data-stu-id="21ed9-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="21ed9-151">Zweitens können die Datenbankdatensätze ändern und Auswirkungen auf die Ergebnisse der Tests, sodass sie möglicherweise nicht konsistent.</span><span class="sxs-lookup"><span data-stu-id="21ed9-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="21ed9-152">Tests für die Datenbank ist keine Komponententests erneut durch, sondern eine Integration testen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="21ed9-153">Sie sollten viele Komponententests schnell ausgeführt haben, aber weniger Integrationstests für die Datenbanken.</span><span class="sxs-lookup"><span data-stu-id="21ed9-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="21ed9-154">Im Hinblick auf die Abgrenzung von Problemen bei Komponententests verarbeitet Ihre Logik Domänenentitäten im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="21ed9-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="21ed9-155">Es wird davon ausgegangen, dass die Repository-Klasse, die die übermittelt hat.</span><span class="sxs-lookup"><span data-stu-id="21ed9-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="21ed9-156">Sobald Ihre Logik die Domänenentitäten ändert, wird angenommen, dass es sich bei die Repository-Klasse werden ordnungsgemäß gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="21ed9-157">Wichtig dabei ist zum Erstellen von Komponententests für Ihre Domänenmodell und ihrer Domänenlogik.</span><span class="sxs-lookup"><span data-stu-id="21ed9-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="21ed9-158">Aggregate sind die wichtigsten Konsistenz Grenzen in DDD.</span><span class="sxs-lookup"><span data-stu-id="21ed9-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="21ed9-159">Der Unterschied zwischen dem Repository und das ältere Datenzugriff (DAL) Klasse Muster</span><span class="sxs-lookup"><span data-stu-id="21ed9-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="21ed9-160">Ein Datenzugriffsobjekt führt direkt Datenvorgänge Zugriff und persistenten Speicher.</span><span class="sxs-lookup"><span data-stu-id="21ed9-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="21ed9-161">Ein Repository markiert die Daten für die Vorgänge, die Sie in den Speicher einer Einheit von Arbeitsobjekt (wie in der EF bei Verwendung von ' DbContext '), aber diese Updates durchführen möchten nicht sofort ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates will not be performed immediately.</span></span>

<span data-ttu-id="21ed9-162">Eine Arbeitseinheit wird bezeichnet als einzelne Transaktion, die umfasst mehrere INSERT-, Update- und delete-Operationen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="21ed9-163">Einfach ausgedrückt bedeutet dies, dass alle INSERT-, Update- und Löschtransaktionen für eine bestimmte Benutzeraktion (z. B. die Registrierung auf einer Website), in einer einzelnen Transaktion verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="21ed9-164">Dies ist jedoch effizienter, anstatt mehrere Datenbanktransaktionen geschwätzigeren so zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="21ed9-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="21ed9-165">Diese mehrere persistenzvorgänge werden weiter unten in einer einzigen Aktion ausgeführt werden, wenn Ihr Code von der Anwendungsebene von Befehlen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-165">These multiple persistence operations will be performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="21ed9-166">Die Entscheidung zum Anwenden der in-Memory-Änderungen auf den tatsächlichen Datenbankspeicher in der Regel hängt die [Unit of Work Muster](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="21ed9-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="21ed9-167">In der EF wird das Muster Unit of Work als DBContext implementiert.</span><span class="sxs-lookup"><span data-stu-id="21ed9-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="21ed9-168">In vielen Fällen kann dieses Muster oder eine Möglichkeit zum Anwenden von Vorgängen für den Speicher Anwendungsleistung erhöhen, und verringern die Gefahr von Inkonsistenzen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="21ed9-169">Außerdem verringert es Transaktion blockiert sind in den Datenbanktabellen, da die vorgesehene Vorgänge als Teil einer einzigen Transaktion ein Commit ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="21ed9-170">Dies ist jedoch effizienter, im Vergleich zu viele isolierte Vorgänge für die Datenbank ausführen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="21ed9-171">Aus diesem Grund werden können die Ausführung für die Datenbank zu optimieren, indem Sie mehrere Updateaktionen innerhalb derselben Transaktion erfolgt, im Gegensatz zu oft kleiner und separate Transaktion gruppieren die ausgewählten ORM.</span><span class="sxs-lookup"><span data-stu-id="21ed9-171">Therefore, the selected ORM will be able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="21ed9-172">Repositorys darf nicht obligatorisch sein.</span><span class="sxs-lookup"><span data-stu-id="21ed9-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="21ed9-173">Benutzerdefinierte Repositorys eignen sich für die oben genannten Gründe, und das ist der Ansatz für die Sortierung Microservice in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="21ed9-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="21ed9-174">Es ist jedoch kein wichtige Muster, um in einen DDD Entwurf implementieren oder sogar im allgemeinen-Entwicklung in .NET.</span><span class="sxs-lookup"><span data-stu-id="21ed9-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="21ed9-175">Jimmy Bogard, bei der Bereitstellung von direkten Feedback zu diesem Handbuch said z. B. Folgendes:</span><span class="sxs-lookup"><span data-stu-id="21ed9-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="21ed9-176">Dies wird wahrscheinlich mein größten Feedback haben.</span><span class="sxs-lookup"><span data-stu-id="21ed9-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="21ed9-177">Ich bin wirklich keines Lüfters des Repositorys, die hauptsächlich, da sie wichtige Details des zugrunde liegenden Dauerhaftigkeit ausblenden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="21ed9-178">Der warum ich MediatR für Befehle zu finden.</span><span class="sxs-lookup"><span data-stu-id="21ed9-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="21ed9-179">Ich kann die volle Leistung von der Persistenzebene verwenden und alle dieser Domänenverhalten in meinem aggregieren Stämme push.</span><span class="sxs-lookup"><span data-stu-id="21ed9-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="21ed9-180">Ich möchte nicht in der Regel Meine Repositorys modellieren – ich muss weiterhin haben, die die Integration mit reale Sache Test.</span><span class="sxs-lookup"><span data-stu-id="21ed9-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="21ed9-181">CQRS passiert vorgesehen, dass wir eine Notwendigkeit einer Repositorys wirklich mehr hatten.</span><span class="sxs-lookup"><span data-stu-id="21ed9-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="21ed9-182">Wir finden Repositorys nützlich, aber wir bestätigen Sie, dass sie nicht für Ihre DDD, bei der Datenerfassung entscheidender Bedeutung sind, die die aggregierten Muster und umfangreiche Domänenmodell sind.</span><span class="sxs-lookup"><span data-stu-id="21ed9-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="21ed9-183">Daher verwenden Sie das Repositorymuster, davon, wie Sie sehen passen.</span><span class="sxs-lookup"><span data-stu-id="21ed9-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="21ed9-184">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="21ed9-184">Additional resources</span></span>

##### <a name="the-repository-pattern"></a><span data-ttu-id="21ed9-185">Das Repositorymuster</span><span class="sxs-lookup"><span data-stu-id="21ed9-185">The Repository pattern</span></span>

-   <span data-ttu-id="21ed9-186">**Edward Hieatt und Rob me. Repositorymuster. ** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="21ed9-186">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="21ed9-187">**Das Repositorymuster**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="21ed9-187">**The Repository pattern**
[*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="21ed9-188">**Repositorymuster: Eine Daten persistenzabstraktion**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="21ed9-188">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="21ed9-189">**Eric Evans. Domain Driven Design: Tackling, Complexity in the Heart of Software wird.**</span><span class="sxs-lookup"><span data-stu-id="21ed9-189">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="21ed9-190">(Book; enthält eine Erläuterung der des Repositorymusters) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="21ed9-190">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

##### <a name="unit-of-work-pattern"></a><span data-ttu-id="21ed9-191">Einheit des Musters mit Aufgaben</span><span class="sxs-lookup"><span data-stu-id="21ed9-191">Unit of Work pattern</span></span>

-   <span data-ttu-id="21ed9-192">**Martin Fowler. Die Einheit der Arbeit Muster. ** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="21ed9-192">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="21ed9-193">**Implementieren das Repository und die Einheit der Arbeit Muster in einer ASP.NET MVC-Anwendung**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/ Implementing-the-Repository-and-Unit-of-Work-Patterns-in-an-ASP-NET-MVC-Application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="21ed9-193">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="21ed9-194">[Vorherigen] (Domäne-Ereignisse-Design-implementation.md) [weiter] (Infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="21ed9-194">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
