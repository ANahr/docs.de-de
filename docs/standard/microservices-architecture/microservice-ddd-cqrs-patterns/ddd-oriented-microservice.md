---
title: Ein Microservice DDD-orientierten entwerfen
description: ".NET Microservices Architektur für Datenvolumes .NET-Anwendungen | Ein Microservice DDD-orientierten entwerfen"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="b0ac4-104">Ein Microservice DDD-orientierten entwerfen</span><span class="sxs-lookup"><span data-stu-id="b0ac4-104">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="b0ac4-105">Domain driven Design (DDD) Fürsprecher Modellierung basierend auf die Realität Unternehmen als relevant für Ihre Anwendungsfälle.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-105">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="b0ac4-106">Im Kontext der Erstellung von Anwendungen dreht DDD Probleme als Domänen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-106">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="b0ac4-107">Unabhängige Problembereiche als begrenzt Kontexte beschrieben (jeder begrenzt, die den Kontext entspricht ein Microservice), und hebt hervor, die eine einheitliche Sprache, um diese Probleme zu erörtern.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-107">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="b0ac4-108">Es wird auch vorgeschlagen viele technische Konzepte und Muster, z. B. Domänenentitäten mit umfangreichen Modellen (keine [anemic Domänenmodell](https://martinfowler.com/bliki/AnemicDomainModel.html)), Objekte, Aggregate und aggregieren Stamm (bzw. Stammentität) zur Unterstützung der internen Implementierung Regeln.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-108">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="b0ac4-109">Dieser Abschnitt enthält den Entwurf und die Implementierung dieser interne Muster.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-109">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="b0ac4-110">In einigen Fällen sind diese technischen DDD-Regeln und Muster als Hindernisse angesehen, die eine steile Lernkurve für die Implementierung DDD Ansätze aufweisen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-110">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="b0ac4-111">Aber der wichtigste Teil ist nicht die Muster selbst, aber den Code organisieren, sodass es auf die geschäftlichen Probleme ausgerichtet ist, und mithilfe der gleichen geschäftsbegriffe (ubiquitäre Sprache).</span><span class="sxs-lookup"><span data-stu-id="b0ac4-111">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="b0ac4-112">Darüber hinaus sollten DDD Ansätze angewendet werden, nur, wenn Sie komplexe Microservices mit erheblichen Geschäftsregeln implementieren.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-112">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="b0ac4-113">Mit einfacher Ansätzen können einfachere Aufgaben, wie ein CRUD-Dienst verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-113">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="b0ac4-114">WHERE zum Zeichnen der Grenzen ist die wichtigste Aufgabe beim Entwerfen und eine Microservice definieren.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-114">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="b0ac4-115">DDD Muster können Sie die Komplexität in der Domäne zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-115">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="b0ac4-116">Für das Domänenmodell für jede begrenzt, die den Kontext identifizieren und definieren die Entitäten, die Wert-Objekte und die Aggregate, die Ihre Domäne zu modellieren.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-116">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="b0ac4-117">Sie erstellen und optimieren ein Domänenmodell, die innerhalb einer Grenze enthalten ist, die den Kontext definiert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-117">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="b0ac4-118">Und das ist in Form einer Microservice sehr explizit.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-118">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="b0ac4-119">Die Komponenten innerhalb dieser Grenzen am Ende Ihrer Microservices wird zwar in manchen Fällen a BC oder Business Microservices können mehrere physische Dienste bestehen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-119">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="b0ac4-120">DDD geht es um Grenzen und deshalb Microservices.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-120">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="b0ac4-121">Behalten Sie die Microservice Kontextgrenzen relativ klein</span><span class="sxs-lookup"><span data-stu-id="b0ac4-121">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="b0ac4-122">Bestimmen die Grenzen zwischen den Kontexten begrenzt platzieren gleicht zwei konkurrierenden Ziele.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-122">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="b0ac4-123">Zuerst möchten Sie anfänglich die kleinste mögliche Microservices erstellen zwar, die nicht der Haupt-Treiber werden soll; Erstellen Sie eine Begrenzung um Dinge, die Kohäsion benötigen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-123">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="b0ac4-124">Zweitens, möchten Sie ' geschwätzige ' Kommunikation zwischen Microservices zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-124">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="b0ac4-125">Diese Ziele können miteinander widersprechen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-125">These goals can contradict one another.</span></span> <span data-ttu-id="b0ac4-126">Sie sollten diese verteilen, indem Zerlegen von das System in beliebig viele kleine Microservices wie möglich bis Kommunikationsgrenzen schnell wächst mit jeder weitere Verbindungsversuche trennen Sie einen neuen begrenzt, die den Kontext angezeigt.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-126">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="b0ac4-127">Kohäsion ist-Schlüssel in einem einzelnen gebundene Kontext.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-127">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="b0ac4-128">Ähnliches gilt für die [Unangemessene Intimität Codegeruch](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) bei der Implementierung von Klassen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-128">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="b0ac4-129">Wenn zwei Microservices viel miteinander zusammenarbeiten müssen, sollten sie möglicherweise die gleichen Microservice sein.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-129">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="b0ac4-130">Eine andere Möglichkeit, dies ist die Autonomie.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-130">Another way to look at this is autonomy.</span></span> <span data-ttu-id="b0ac4-131">Wenn ein Microservice auf einen anderen Dienst direkt eine Anfrage angewiesen ist, ist es nicht tatsächlich autonome.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-131">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="b0ac4-132">Ebenen in DDD microservices</span><span class="sxs-lookup"><span data-stu-id="b0ac4-132">Layers in DDD microservices</span></span>

<span data-ttu-id="b0ac4-133">Die meisten unternehmensanwendungen mit erheblichen geschäftlichen und technischen Komplexität werden durch mehrere Ebenen definiert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-133">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="b0ac4-134">Die Ebenen sind eine logische Artefakt und beziehen sich nicht auf die Bereitstellung des Diensts.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-134">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="b0ac4-135">Sie vorhanden sind, um die Komplexität im Code verwalten Entwicklern zu helfen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-135">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="b0ac4-136">Unterschiedliche Ebenen (z. B. die Domäne Modellebene im Vergleich zu der Darstellungsschicht usw.) möglicherweise unterschiedliche Typen der Übersetzungen zwischen diesen Typen erfordert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-136">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="b0ac4-137">Beispielsweise könnte eine Entität aus der Datenbank geladen werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-137">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="b0ac4-138">Teil dieser Informationen oder eine Aggregation von Informationen, einschließlich weiterer Daten von anderen Entitäten kann dann an den Client-Benutzeroberfläche über eine REST-Web-API gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-138">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="b0ac4-139">Der Punkt hier ist, dass die Entität "Domain" in der Domäne der Ebene enthalten ist und sollten nicht an anderen Bereichen, die es nicht zu, z. B. auf die Präsentationsebene gehört weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-139">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="b0ac4-140">Darüber hinaus benötigen Sie immer gültige Entitäten (finden Sie unter der [entwerfen Überprüfungen in der Domäne der Ebene](#designing-validations-in-the-domain-model-layer) Abschnitt) durch aggregieren Stammelemente (Stamm-Entitäten) gesteuert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-140">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="b0ac4-141">Entitäten sollten daher nicht mit Clientansichten gebunden werden, weil auf Benutzeroberflächenebene einige Daten immer noch nicht überprüft werden können.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-141">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="b0ac4-142">Dies ist das ViewModel für.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-142">This is what the ViewModel is for.</span></span> <span data-ttu-id="b0ac4-143">Das ViewModel ist ein Datenmodell ausschließlich für die Präsentation Ebene benötigt.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-143">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="b0ac4-144">Die Domänenentitäten gehören nicht direkt auf das ViewModel.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-144">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="b0ac4-145">Stattdessen müssen Sie zwischen Entitäten ViewModels "und" Domäne und umgekehrt zu übersetzen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-145">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="b0ac4-146">Wenn bewältigt Fortschritts relativ komplex ist, es ist wichtig, haben ein Domänenmodell, der durch aggregieren Stammelemente, die (wir gehen in diese ausführlicher weiter unten) Sie sicher stellen, dass die Invarianten und die Regeln bezüglich gesteuert werden dieser Gruppe von Entitäten (aggregate) über einen einzelnen Eintrag ausgeführt Punkt oder ein Tor aggregieren Stamm.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-146">When tackling complexity, it is important to have a domain model controlled by aggregate roots (we go into this in more detail later) that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry point or gate, the aggregate root.</span></span>

<span data-ttu-id="b0ac4-147">Abbildung 9 – 5 veranschaulicht, wie ein mehrstufigen Entwurf in der eShopOnContainers-Anwendung implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-147">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="b0ac4-148">**Abbildung 9 – 5**.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-148">**Figure 9-5**.</span></span> <span data-ttu-id="b0ac4-149">DDD Ebenen in der Reihenfolge Microservice in eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="b0ac4-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="b0ac4-150">Möchten Sie das System so entwerfen, dass jede Ebene nur mit bestimmten anderen Ebenen kommuniziert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-150">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="b0ac4-151">Die möglicherweise leichter zu erzwingen, wenn Ebenen als unterschiedliche Klassenbibliotheken implementiert werden, da Sie deutlich erkennen können, welche Abhängigkeiten zwischen Bibliotheken festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-151">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="b0ac4-152">Für die Instanz, die Domäne der Ebene nicht ergreift eine Abhängigkeit auf eine beliebige andere Ebene (die Domäne Modellklassen Plain Old CLR Objects, werden sollte oder [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), Klassen).</span><span class="sxs-lookup"><span data-stu-id="b0ac4-152">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="b0ac4-153">Wie in Abbildung 9 – 6 gezeigt die **Ordering.Domain** Ebene Bibliothek weist Abhängigkeiten nur für die .NET Core-Bibliotheken jedoch nicht auf eine beliebige andere benutzerdefinierte Bibliothek (Data-Bibliothek, Persistenz-Bibliothek, usw.).</span><span class="sxs-lookup"><span data-stu-id="b0ac4-153">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries but not on any other custom library (data library, persistence library, etc.).</span></span>

![](./media/image7.PNG)

<span data-ttu-id="b0ac4-154">**Abbildung 9 – 6**.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-154">**Figure 9-6**.</span></span> <span data-ttu-id="b0ac4-155">Ebenen implementiert werden, wie Bibliotheken eine bessere Steuerung des Abhängigkeiten zwischen Ebenen zulassen</span><span class="sxs-lookup"><span data-stu-id="b0ac4-155">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="b0ac4-156">Die Domäne der Ebene</span><span class="sxs-lookup"><span data-stu-id="b0ac4-156">The domain model layer</span></span>

<span data-ttu-id="b0ac4-157">Ausgezeichnete Buch des Eric Evans [Domain Driven Design](http://domainlanguage.com/ddd/) besagt, dass die folgenden zu der Ebene der Domäne und der Anwendungsschicht.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-157">Eric Evans's excellent book [Domain Driven Design](http://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="b0ac4-158">**Domäne der Ebene**: verantwortlich für die Darstellung von Konzepten der Business, Informationen zu den Unternehmenssituation und Geschäftsregeln.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-158">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="b0ac4-159">Zustand, der die Unternehmenssituation wird gesteuert, und hier verwendet werden, obwohl alle technischen Konfigurationsdetails, speichern es an die Infrastruktur delegiert werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-159">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="b0ac4-160">Diese Ebene ist das Kernstück von Business-Software.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-160">This layer is the heart of business software.</span></span>

<span data-ttu-id="b0ac4-161">Die Domäne der Ebene ist, in denen das Unternehmen ausgedrückt wird.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-161">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="b0ac4-162">Wenn Sie eine Domäne der Ebene Microservice in .NET implementieren, wird, auf dieser Ebene als eine Klassenbibliothek mit den Domänenentitäten codiert, die Daten plus Verhalten (Methoden mit Logik) zu erfassen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-162">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="b0ac4-163">Nach der [Persistenz Unkenntnis](http://deviq.com/persistence-ignorance/) und [Infrastruktur Unkenntnis](https://ayende.com/blog/3137/infrastructure-ignorance) Prinzipien, die dieser Ebene müssen Details zur Persistenz von Daten vollständig ignorieren.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-163">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="b0ac4-164">Diese Aufgaben Persistenz sollte durch die Infrastrukturebene erfolgen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-164">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="b0ac4-165">Aus diesem Grund diese Ebene nicht abwartet, direkte Abhängigkeiten in der Infrastruktur, was bedeutet, dass eine Regel wichtige ist, dass die Domäne Modell Entitätsklassen werden soll [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-165">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="b0ac4-166">Domänenentitäten sollte direkte Abhängigkeit (z. B. von einer Basisklasse ableiten) nicht auf alle Data Access-Infrastruktur-Framework wie Entity Framework oder NHibernate aufweisen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-166">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="b0ac4-167">Im Idealfall sollten Ihrer Domänenentitäten nicht abgeleitet bzw. implementiert diesen beliebigen Typs in einem Infrastruktur-Framework definiert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-167">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="b0ac4-168">Die meisten modernen ORM-Frameworks wie Entity Framework Core können dieser Ansatz, sodass der Infrastruktur nicht Ihren Modellklassen Domäne verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-168">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="b0ac4-169">Allerdings ist mit POCO-Entitäten nicht immer möglich, wenn bestimmte NoSQL-Datenbanken und Frameworks, z. B. Akteure und zuverlässige Auflistungen in Azure Service Fabric verwenden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-169">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="b0ac4-170">Auch wenn es auf dem Prinzip der Persistenz Unkenntnis für Sie Domänenmodell folgen wichtig ist, sollte nicht Persistenz Bedenken ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-170">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="b0ac4-171">Es ist immer noch sehr wichtig zu verstehen, die physische Datenmodell und wie sie Ihr Objektmodell Entität zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-171">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="b0ac4-172">Andernfalls können Sie Entwürfe gar nicht erstellen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-172">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="b0ac4-173">Dies bedeutet auch, nicht können Sie ein Modell für eine relationale Datenbank dauern und verschieben Sie sie direkt zu einem NoSQL oder dokumentorientiert Datenbank.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-173">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="b0ac4-174">In anderen Modellen Entität kann das Modell entsprechen, aber in der Regel nicht.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-174">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="b0ac4-175">Es sind noch Einschränkungen, die Ihre Entitätsmodell, sowohl auf die speichertechnologie und ORM-Technologie als Grundlage folgen muss.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-175">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="b0ac4-176">Die Anwendungsebene</span><span class="sxs-lookup"><span data-stu-id="b0ac4-176">The application layer</span></span>

<span data-ttu-id="b0ac4-177">Verschieben in einen für die Anwendungsebene, wir können erneut cite-Eric Evanss Buchs [Domain Driven Design](http://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="b0ac4-177">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](http://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="b0ac4-178">**Anwendungsschicht:** definiert die Aufträge, die Software führen soll, und leitet die ausdrucksbasierte Domänenobjekte um Probleme zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-178">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="b0ac4-179">Die Aufgaben, denen dieser Ebene für die verantwortliche sind für das Unternehmen sinnvoll oder erforderlich ist, für die Interaktion mit den Anwendungsschichten auf anderen Systemen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-179">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="b0ac4-180">Diese Ebene wird schlanke beibehalten.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-180">This layer is kept thin.</span></span> <span data-ttu-id="b0ac4-181">Er enthält keinen Geschäftsregeln oder zur Wissensermittlung, aber nur Koordinaten Aufgaben und Delegaten arbeiten, zusammenarbeitselemente von Domänenobjekten in der nächsten Ebene nach unten.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-181">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="b0ac4-182">Es muss kein Status reflektieren die Unternehmenssituation allerdings Zustand, der den Fortschritt einer Aufgabe für den Benutzer oder die Anwendung aufweisen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-182">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="b0ac4-183">Ein Microservice-Anwendungsebene in .NET wird häufig als ASP.NET Core Web-API-Projekt codiert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-183">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="b0ac4-184">Das Projekt implementiert die Microservice Interaktion, Remotezugriff auf das Netzwerk und die externe Web-APIs, die über die Benutzeroberfläche oder Client-apps verwendet.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-184">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="b0ac4-185">Es schließt Abfragen, wenn mit einem CQRS-Ansatz, Befehle, die von der Microservice und sogar die ereignisgesteuerte Kommunikation zwischen Microservices (integrationsereignisse) akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-185">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="b0ac4-186">Die ASP.NET Core-Web-API, die die Anwendungsebene darstellt dürfen keine Geschäftsregeln oder domänenwissen (insbesondere Domänenregeln für Transaktionen oder Updates); enthalten. Diese sollte Besitz der Domäne Modell-Klassenbibliothek.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-186">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="b0ac4-187">Die Anwendung Ebene muss nur Koordinate muss Aufgaben und nicht halten oder eine beliebige Domäne Zustand (Domänenmodell) definieren.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-187">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="b0ac4-188">Es delegiert die Ausführung von Geschäftsregeln für die Domäne Modellklassen selbst (aggregieren Stämme und Domänenentitäten), die letztlich die Daten in dieser Domänenentitäten aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-188">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="b0ac4-189">Grundsätzlich ist die Anwendungslogik, in allen Fällen implementieren, die von einem bestimmten front-End-abhängen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-189">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="b0ac4-190">Beispielsweise muss die Implementierung im Zusammenhang mit einem Web-API-Dienst.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-190">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="b0ac4-191">Das Ziel ist, dass die Domänenlogik in die Domäne der Ebene, die Invarianten, das Datenmodell und entsprechende Geschäftsregeln definieren völlig unabhängig von der Präsentation und Anwendungsschicht sein muss.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-191">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="b0ac4-192">Am häufigsten daran, muss die Domäne der Ebene nicht direkt von einem Infrastructure-Framework abhängig.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-192">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="b0ac4-193">Die Infrastrukturebene</span><span class="sxs-lookup"><span data-stu-id="b0ac4-193">The infrastructure layer</span></span>

<span data-ttu-id="b0ac4-194">Die Infrastrukturebene ist wie die Daten, die anfänglich, in der Domänenentitäten (im Arbeitsspeicher gehalten werden) in Datenbanken oder anderen persistenten Speicher beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-194">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="b0ac4-195">Entity Framework Core-Code verwendet ein Beispiel für die Klassen der Repository-Muster implementieren, die ein ' DbContext ' zu verwenden, um Daten in einer relationalen Datenbank beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-195">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="b0ac4-196">In Übereinstimmung mit den oben erwähnten [Persistenz Unkenntnis](http://deviq.com/persistence-ignorance/) und [Infrastruktur Unkenntnis](https://ayende.com/blog/3137/infrastructure-ignorance) Prinzipien, die Infrastrukturebene müssen nicht "verunreinigt" die Domäne der Ebene.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-196">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="b0ac4-197">Sie müssen die Domäne Modell Entität Klassen agnostisch aus der Infrastruktur, mit denen Sie Daten (EF oder einem anderen Framework) beizubehalten halten, indem nicht harte Abhängigkeiten Frameworks dauert.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-197">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="b0ac4-198">Die Domäne Modell Layer-Klassenbibliothek müssen nur Ihr domänencode nur [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) Entität Klassen implementieren das Kernstück der Software und vollständig vom infrastrukturtechnologien.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-198">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="b0ac4-199">Daher Ihre Ebenen oder Klassenbibliotheken und Projekte sollten letztlich richten sich nach der Domäne der Ebene (Library), nicht umgekehrt, wie in Abbildung 9 – 7 dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-199">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="b0ac4-200">**Abbildung 9 – 7**.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-200">**Figure 9-7**.</span></span> <span data-ttu-id="b0ac4-201">Abhängigkeiten zwischen Ebenen in DDD</span><span class="sxs-lookup"><span data-stu-id="b0ac4-201">Dependencies between layers in DDD</span></span>

<span data-ttu-id="b0ac4-202">Dieser Entwurf Ebene sollte unabhängig für jeden Microservice erfolgen.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-202">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="b0ac4-203">Wie bereits erwähnt, können Sie den komplexesten Microservices implementieren befolgen DDD-Muster, bei der Implementierung einfacher datengesteuerte Microservices (einfache CRUD in einer einzelnen Ebene) auf einfachere Weise.</span><span class="sxs-lookup"><span data-stu-id="b0ac4-203">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b0ac4-204">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="b0ac4-204">Additional resources</span></span>

-   <span data-ttu-id="b0ac4-205">**DevIQ. Persistenz Unkenntnis Prinzip**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="b0ac4-205">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="b0ac4-206">**Oren Eini. Infrastruktur Unkenntnis**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="b0ac4-206">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="b0ac4-207">**Angel Lopez. In den Ebenen-Architektur In Domain Driven Design**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="b0ac4-207">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="b0ac4-208">[Vorherigen] (Cqrs-Microservice-reads.md) [weiter] (Microservice Domäne model.md)</span><span class="sxs-lookup"><span data-stu-id="b0ac4-208">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>
