---
title: Domain-Ereignisse. Entwurf und Implementierung
description: ".NET Microservices Architektur für Datenvolumes .NET-Anwendungen | Domain-Ereignisse, Entwurf und Implementierung"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 2d98b302be4ee72d8225526944fc3e41cbadcb5f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="fb039-105">Domain-Ereignisse: Entwurf und Implementierung</span><span class="sxs-lookup"><span data-stu-id="fb039-105">Domain events: design and implementation</span></span>

<span data-ttu-id="fb039-106">Verwenden Sie Domain-Ereignisse, um explizit Nebeneffekte der Änderungen in Ihrer Domäne zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="fb039-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="fb039-107">Verwenden Sie in anderen Worten, und verwenden DDD-Terminologie Domäne Ereignisse Nebeneffekte über mehrere Aggregate explizit implementiert.</span><span class="sxs-lookup"><span data-stu-id="fb039-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="fb039-108">Verwenden Sie optional für eine bessere Skalierbarkeit und weniger Auswirkungen in Datenbanksperren eventuellen Konsistenz zwischen Aggregate innerhalb der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="fb039-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="fb039-109">Was ist ein Ereignis Domäne?</span><span class="sxs-lookup"><span data-stu-id="fb039-109">What is a domain event?</span></span>

<span data-ttu-id="fb039-110">Ein Ereignis ist etwas, das in der Vergangenheit geschehen ist.</span><span class="sxs-lookup"><span data-stu-id="fb039-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="fb039-111">Ein Ereignis für die Domäne ist, logisch, etwas, das in einer bestimmten Domäne aufgetreten sind, und etwas andere Teile der gleichen Domäne (in-Process) beachten und potenziell auf reagieren soll.</span><span class="sxs-lookup"><span data-stu-id="fb039-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="fb039-112">Ein wesentlicher Vorteil des Domain-Ereignisse ist, dass Nebeneffekte, nachdem ein Fehler in einer Domäne aufgetreten explizit statt implizit ausgedrückt werden kann.</span><span class="sxs-lookup"><span data-stu-id="fb039-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="fb039-113">Diese Seite, die Auswirkungen konsistent sein müssen, damit entweder alle Vorgänge im Zusammenhang mit der Geschäftsaufgabe ausgeführt, oder keine von ihnen.</span><span class="sxs-lookup"><span data-stu-id="fb039-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="fb039-114">Domain-Ereignisse aktivieren Sie darüber hinaus eine bessere Trennung von Anliegen zwischen Klassen innerhalb der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="fb039-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="fb039-115">Z. B. Wenn Sie einfach nur Entity Framework und Entitäten oder sogar Aggregate verwenden, wenn es von einem Anwendungsfall provoked Nebeneffekte werden müssen, werden die implementiert werden als eine implizite Konzept in der gekoppelten Code nach dem ein Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="fb039-115">For example, if you are just using just Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="fb039-116">Aber wenn Sie diesen Code einfach angezeigt wird, bemerken Sie möglicherweise nicht diesen Code (den Nebeneffekt) ist Teil der wichtigsten Operation oder eigentlich ein Nebeneffekt ist.</span><span class="sxs-lookup"><span data-stu-id="fb039-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="fb039-117">Andererseits, vereinfacht die Verwendung von Domain-Ereignisse das Konzept, explizite und ubiquitäre Sprache Teil.</span><span class="sxs-lookup"><span data-stu-id="fb039-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="fb039-118">Beispielsweise ist in der Anwendung eShopOnContainers erstellen eine Bestellung nicht nur die Reihenfolge; Aktualisieren oder einen Käufer aggregieren basierend auf den ursprünglichen Benutzer erstellt, da der Benutzer ein Käufer nicht ist, bis es eine Bestellung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="fb039-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="fb039-119">Bei Verwendung von Domain-Ereignisse können Sie diese Domäne regelbasiert in die ubiquitäre Sprache Domänenexperten gebotenen explizit Ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="fb039-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="fb039-120">Domäne Ereignisse ähneln Sichtdefinitionen messagingstil-Ereignisse mit einem wichtigen Unterschied.</span><span class="sxs-lookup"><span data-stu-id="fb039-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="fb039-121">Mit echten messaging, Message Queuing-, nachrichtenbroker oder einen Servicebus AMPQ verwenden wird eine Nachricht immer asynchron gesendet und kommuniziert über Prozesse und Computern.</span><span class="sxs-lookup"><span data-stu-id="fb039-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="fb039-122">Dies ist hilfreich beim Integrieren von mehrere Kontexte begrenzt, Microservices oder sogar bei unterschiedlichen Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="fb039-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="fb039-123">Mit Domain-Ereignisse auslösen eines Ereignisses aus der Domäne, die Sie aktuell ausführen möchten, enthält jedoch keine Nebeneffekte innerhalb der gleichen Domäne ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb039-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="fb039-124">Die Domäne Ereignisse und ihre Nebeneffekte (die Aktionen im Anschluss daran ausgelöst, die vom Ereignishandler verwaltet werden) sollten fast sofort auftreten, in der Regel in-Process "und" innerhalb der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="fb039-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="fb039-125">Daher konnte die Domäne Ereignisse synchron oder asynchron sein.</span><span class="sxs-lookup"><span data-stu-id="fb039-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="fb039-126">-Integrationsereignisse, sollte jedoch immer asynchron sein.</span><span class="sxs-lookup"><span data-stu-id="fb039-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="fb039-127">Domain-Ereignisse im Vergleich zu integrationsereignisse</span><span class="sxs-lookup"><span data-stu-id="fb039-127">Domain events versus integration events</span></span>

<span data-ttu-id="fb039-128">Semantisch gesehen sind Domänen- und Integration Ereignisse das gleiche: Benachrichtigungen über etwas, das soeben aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="fb039-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="fb039-129">Ihre Implementierung muss jedoch unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="fb039-129">However, their implementation must be different.</span></span> <span data-ttu-id="fb039-130">Domain-Ereignisse werden nur Nachrichten, die per Push übertragen, um ein Ereignisverteiler Domäne, die als ein in-Memory-Vermittler basierend auf einen IoC-Container oder andere Methoden implementiert werden konnte.</span><span class="sxs-lookup"><span data-stu-id="fb039-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="fb039-131">Andererseits, werden der Zweck der integrationsereignisse Transaktionen mit ausgeführtem Commit und Updates für zusätzliche Subsysteme weitergegeben, ob sie andere Microservices, begrenzt, die den Kontext oder sogar externen Anwendungen sind.</span><span class="sxs-lookup"><span data-stu-id="fb039-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="fb039-132">Sie sollten daher auftreten, nur wenn die Entität erfolgreich beibehalten wird, seit in vielen Fällen schlägt dies fehl, der gesamte Vorgang tatsächlich nie aufgetreten sind.</span><span class="sxs-lookup"><span data-stu-id="fb039-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="fb039-133">Darüber hinaus und als erwähnt, Integration müssen Ereignisse auf asynchrone Kommunikation zwischen mehreren Microservices (andere begrenzt Kontexten) oder sogar externen Systeme/Anwendungen basieren.</span><span class="sxs-lookup"><span data-stu-id="fb039-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="fb039-134">Bus Ereignisschnittstelle benötigt daher eine Infrastruktur, die ermöglicht die prozessübergreifende Kommunikation zwischen potenziell Remotedienste verteilt.</span><span class="sxs-lookup"><span data-stu-id="fb039-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="fb039-135">Es können auf eine kommerzielle Servicebus-Warteschlangen, eine freigegebene Datenbank verwendet wird, wie ein Postfach oder andere verteilt basieren und idealerweise push Basis-messaging-Systems.</span><span class="sxs-lookup"><span data-stu-id="fb039-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="fb039-136">Domain-Ereignisse als eine bevorzugte Methode zum Auslösen von Nebeneffekte über mehrere Aggregate innerhalb der gleichen Domäne</span><span class="sxs-lookup"><span data-stu-id="fb039-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="fb039-137">Wenn im Zusammenhang mit einem aggregierten Instanz zusätzliche Domänenregeln für die Ausführung auf eine oder mehrere zusätzliche Aggregate erforderlich, einen Befehl ausführen, sollten Sie entwerfen und implementieren die möglichen Nebeneffekte, die von der Domäne Ereignisse ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="fb039-138">Wie in Abbildung 9-14 und als eines der wichtigsten Anwendungsfälle, ein Ereignis Domäne sollte Zustandsänderungen über mehrere Aggregate innerhalb desselben Modells Domäne weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="fb039-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="fb039-139">**Abbildung 9 – 14**.</span><span class="sxs-lookup"><span data-stu-id="fb039-139">**Figure 9-14**.</span></span> <span data-ttu-id="fb039-140">Domain-Ereignisse, um Konsistenz zwischen mehrere Aggregate innerhalb der gleichen Domäne zu erzwingen</span><span class="sxs-lookup"><span data-stu-id="fb039-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="fb039-141">Wenn der Benutzer eine Bestellung initiiert, löst das Ereignis für die Domäne OrderStarted in der Abbildung Erstellung eines Objekts Käufer in der Reihenfolge Microservice basierend auf den ursprünglichen Benutzerinformationen aus der Identität Microservice (mit Informationen, die im Befehl CreateOrder bereitgestellten) werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="fb039-142">Das Ereignis für die Domäne wird anhand des Aggregats Reihenfolge generiert, wenn es ursprünglich erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="fb039-143">Alternativ können Sie aggregierten Stamm für Ereignisse, die ausgelöst wird, von einem Mitglied der Aggregate (untergeordneten Entitäten) abonniert haben.</span><span class="sxs-lookup"><span data-stu-id="fb039-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="fb039-144">Jede OrderItem untergeordnete Entität kann z. B. ein Ereignis auszulösen, wenn dem Artikelpreis über einen bestimmten Betrag liegt, oder die Menge der Product-Element ist zu hoch.</span><span class="sxs-lookup"><span data-stu-id="fb039-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="fb039-145">Aggregieren Stamm kann diese Ereignisse empfangen und eine globale Berechnung oder eine Aggregation durchführen.</span><span class="sxs-lookup"><span data-stu-id="fb039-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="fb039-146">Es ist wichtig zu verstehen, dass diese Kommunikation ereignisbasierten nicht direkt in die Aggregate implementiert ist. In diesem Fall müssen Sie eine Domäne Ereignishandler implementieren.</span><span class="sxs-lookup"><span data-stu-id="fb039-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="fb039-147">Behandeln der Ereignisse für die Domäne ist eine Anwendung relevant.</span><span class="sxs-lookup"><span data-stu-id="fb039-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="fb039-148">Die Domäne der Ebene konzentrieren sich nur auf die Domänenlogik – Dinge, die einer Domäne Expert ansehen würde, nicht Anwendung Infrastrukturkomponenten, wie Handler und Nebeneffekte persistenzaktionen mit Repositorys.</span><span class="sxs-lookup"><span data-stu-id="fb039-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="fb039-149">Daher ist die Ebene für die Anwendung dort stehen Ihnen sollte Domäne Ereignishandler Aktionen auslösen, wenn eine Domäne-Ereignis ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="fb039-150">Domain-Ereignisse können auch verwendet werden, um eine beliebige Anzahl von Anwendungsaktionen auszulösen, und was noch wichtiger ist, erhöhen Sie diese Anzahl in der Zukunft entkoppelte so geöffnet sein müssen.</span><span class="sxs-lookup"><span data-stu-id="fb039-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="fb039-151">Z. B. wenn der Auftrag gestartet wird, können Sie ein Ereignis Domäne weitergegeben, Info zu anderen Aggregaten oder sogar Anwendungsaktionen wie Benachrichtigungen auslösen veröffentlichen möchten.</span><span class="sxs-lookup"><span data-stu-id="fb039-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="fb039-152">Wichtige Punkt soll in ist die öffnen Anzahl von Aktionen an, die ausgeführt werden, wenn ein Domain-Ereignis auftritt.</span><span class="sxs-lookup"><span data-stu-id="fb039-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="fb039-153">Schließlich werden die Aktionen und Regeln in der Domäne und der Anwendung erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="fb039-154">Die Komplexität oder die Anzahl der Aktionen Nebeneffekte, wenn etwas passiert wächst, jedoch wurden Wenn Code mit "Kleben" gekoppelt (d. h. nur Instanziieren von Objekten mit dem new-Schlüsselwort in C#\#), dann jedes Mal, wenn Sie benötigt, um eine neue Aktion hinzufügen, Sie müssen Ändern Sie den ursprünglichen Code.</span><span class="sxs-lookup"><span data-stu-id="fb039-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="fb039-155">Dies könnte in neue Fehler kommen, da mit jeder neuen Anforderung Sie der ursprünglichen Codefluss ändern müssen würde.</span><span class="sxs-lookup"><span data-stu-id="fb039-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="fb039-156">Dies gilt für die [Öffnen/geschlossen Prinzip](https://en.wikipedia.org/wiki/Open/closed_principle) aus [EINFARBIG](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="fb039-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="fb039-157">Nicht nur das, die ursprüngliche Klasse, die die Vorgänge orchestriert wurde Wachstum und hinausgeht würde, der gegen wechselt, die [einzelne Verantwortung Prinzip (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="fb039-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="fb039-158">Andererseits, können Sie bei Verwendung von Domain-Ereignisse eine differenzierte und entkoppelte Implementierung erstellen, durch die Trennung von Aufgaben, die diesen Ansatz verwenden:</span><span class="sxs-lookup"><span data-stu-id="fb039-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="fb039-159">Senden eines Befehls (z. B. CreateOrder) an.</span><span class="sxs-lookup"><span data-stu-id="fb039-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="fb039-160">Erhalten Sie den Befehl Befehlshandler.</span><span class="sxs-lookup"><span data-stu-id="fb039-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="fb039-161">Ausführen einer einzelnen gesamtverstärkung Transaktion.</span><span class="sxs-lookup"><span data-stu-id="fb039-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="fb039-162">(Optional) Lösen Sie die Domäne-Ereignisse für Nebeneffekte (z. B. OrderStartedDomainDvent).</span><span class="sxs-lookup"><span data-stu-id="fb039-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainDvent).</span></span>
1.  <span data-ttu-id="fb039-163">Handle Domäne Ereignisse (innerhalb des aktuellen Prozesses) Thast werden eine offene Anzahl von möglichen Nebeneffekte in mehreren Aggregate oder Aktionen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-163">Handle domain events (within the current process) thast will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="fb039-164">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="fb039-164">For example:</span></span>
    -   <span data-ttu-id="fb039-165">Vergewissern Sie sich, oder erstellen Sie Käufer "und" Payment-Methode.</span><span class="sxs-lookup"><span data-stu-id="fb039-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="fb039-166">Erstellen Sie und senden Sie ein Ereignis verknüpften Integration mit dem Ereignisbus Zustände über Microservices oder des Triggers externe Aktionen, z. B. zum Senden einer e-Mails an den Käufer weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="fb039-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="fb039-167">Andere Nebeneffekte zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="fb039-167">Handle other side effects.</span></span>

<span data-ttu-id="fb039-168">Wie in Abbildung 9 – 15 gezeigt, kann beginnend mit der gleichen Domäne-Ereignis behandelt werden mehrere Aktionen, die im Zusammenhang mit anderen Aggregaten in der Domäne oder zusätzliche Aktionen, die Sie über das Herstellen einer Verbindung mit Integration-Ereignissen und den-Ereignisbus Microservices ausführen müssen.</span><span class="sxs-lookup"><span data-stu-id="fb039-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="fb039-169">**Abbildung 9 – 15**.</span><span class="sxs-lookup"><span data-stu-id="fb039-169">**Figure 9-15**.</span></span> <span data-ttu-id="fb039-170">Behandlung von mehreren Aktionen pro Domäne</span><span class="sxs-lookup"><span data-stu-id="fb039-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="fb039-171">Die Ereignishandler sind in der Regel in der Anwendungsschicht, da Sie für die Microservice Verhalten infrastrukturobjekte wie z. B. Repositorys oder einer Anwendung-API verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb039-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="fb039-172">In dieser Hinsicht ähneln Ereignishandler Befehlshandler, damit sowohl der Anwendungsschicht gehören.</span><span class="sxs-lookup"><span data-stu-id="fb039-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="fb039-173">Die wichtiger besteht Unterschied darin, dass ein Befehl nur einmal verarbeitet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="fb039-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="fb039-174">Ist möglicherweise ein Ereignis Domäne verarbeitet die 0 (null) oder  *n*  erreicht, da Wenn von mehreren Empfängern oder Ereignishandler mit einem anderen Zweck für jeden Handler empfangen werden können.</span><span class="sxs-lookup"><span data-stu-id="fb039-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="fb039-175">Die Möglichkeit, eine open Anzahl von Handler pro Domäne Ereignis können Sie viele weitere Domänenregeln hinzufügen, ohne Auswirkungen auf den aktuellen Code.</span><span class="sxs-lookup"><span data-stu-id="fb039-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="fb039-176">Implementieren die folgenden Geschäftsregel, die nach einem Ereignis rechts durchgeführt werden soll kann beispielsweise so einfach wie das Hinzufügen von wenigen Ereignishandler (oder auch nur eine) sein:</span><span class="sxs-lookup"><span data-stu-id="fb039-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="fb039-177">Wenn die Gesamtmenge von einem Kunden im Windows Store erworben haben, über eine beliebige Anzahl von Bestellungen, $6.000 überschreitet, jede neue Bestellung 10 % Preisnachlass angewendet, und benachrichtigen Sie den Kunden mit einer e-Mail-Adresse zu diesem Rabatt für zukünftige Aufträge.</span><span class="sxs-lookup"><span data-stu-id="fb039-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="fb039-178">Implementierung von Ereignissen der Domäne</span><span class="sxs-lookup"><span data-stu-id="fb039-178">Implementing domain events</span></span>

<span data-ttu-id="fb039-179">In c# ist ein Ereignis Domäne einfach einen Daten-Betrieb Struktur oder Klasse, wie ein DTO, anhand der Informationen im Zusammenhang zu was nur in der Domäne aufgetreten ist, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="fb039-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : IAsyncNotification
{
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
        int cardTypeId, string cardNumber,
        string cardSecurityNumber, string cardHolderName,
        DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="fb039-180">Dies ist im Wesentlichen eine Klasse, die die Daten, die im Zusammenhang mit dem OrderStarted-Ereignis enthält.</span><span class="sxs-lookup"><span data-stu-id="fb039-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="fb039-181">Im Hinblick auf die ubiquitäre Sprache der Domäne, da ein Ereignis ist, die in der Vergangenheit aufgetreten sind muss der Klassenname des Ereignisses als Vergangenheitsform Verb, z. B. OrderStartedDomainEvent oder OrderShippedDomainEvent dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="fb039-182">Das ist wie das Ereignis für die Domäne in der Reihenfolge Microservice in eShopOnContainers implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="fb039-183">Wie erwähnt, ist ein wichtiges Merkmal der Ereignisse, die seit ein Ereignis ist etwas, das in der Vergangenheit aufgetreten sind, nicht geändert werden sollte.</span><span class="sxs-lookup"><span data-stu-id="fb039-183">As we have noted, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="fb039-184">Daher muss es einer unveränderlichen Klasse sein.</span><span class="sxs-lookup"><span data-stu-id="fb039-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="fb039-185">Sie können im vorangehenden Code angezeigt, denen die Eigenschaften schreibgeschützt sind und von außerhalb des Objekts sind.</span><span class="sxs-lookup"><span data-stu-id="fb039-185">You can see in the preceding code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="fb039-186">Die einzige Möglichkeit zum Aktualisieren des Objekts ist durch den Konstruktor auf, wenn Sie das Ereignisobjekt erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb039-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="fb039-187">Auslösen von Ereignissen der Domäne</span><span class="sxs-lookup"><span data-stu-id="fb039-187">Raising domain events</span></span>

<span data-ttu-id="fb039-188">Die nächste Frage ist, wie eine Domäne-Ereignis ausgelöst wird, damit er seine zugehörige Ereignishandler erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="fb039-189">Sie können mehrere Ansätze verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb039-189">You can use multiple approaches.</span></span>

<span data-ttu-id="fb039-190">Udi Dahan ursprünglich vorgeschlagene (z. B. in mehreren zusammenhängen, Beiträge, wie [Domain-Ereignisse – Erstellen einer 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) mit einer statischen Klasse für die Verwaltung und durch das Auslösen der Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="fb039-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="fb039-191">Dazu gehören beispielsweise eine statische Klasse mit dem Namen DomainEvents, die auslösen würde Domäne Ereignisse sofort, wenn sie aufgerufen wird, mithilfe der Syntax wie DomainEvents.Raise (Ereignis MyEvent).</span><span class="sxs-lookup"><span data-stu-id="fb039-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="fb039-192">Jimmy Bogard geschrieben wurde, einen Blogbeitrag ([Stärkung Ihrer Domäne: Domäne Ereignisse](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) empfiehlt, einen ähnlichen Ansatz.</span><span class="sxs-lookup"><span data-stu-id="fb039-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="fb039-193">Allerdings sendet die Ereignisse Domänenklasse statisch ist, beim es auch Handler sofort.</span><span class="sxs-lookup"><span data-stu-id="fb039-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="fb039-194">Dies erschwert testen und Debuggen, da die Ereignishandler mit Nebenwirkungen Logik ausgeführt werden, sofort, nachdem das Ereignis ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="fb039-195">Wenn Sie Tests debuggen sind, sollten Sie den Fokus auf und nur in den aktuellen aggregieren Klassen geschieht; Sie sollten keine plötzlich zu anderer Ereignishandler für Nebeneffekte, die im Zusammenhang mit anderen Aggregaten oder Anwendungslogik umgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="fb039-196">Dies ist deshalb andere Ansätze entwickelt haben, wie im nächsten Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="fb039-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="fb039-197">Die verzögerte Ansatz für den durch das Auslösen und Auslösen von Ereignissen</span><span class="sxs-lookup"><span data-stu-id="fb039-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="fb039-198">Statt direkt an einen Ereignishandler für die Domäne verteilt, ein besserer Ansatz ist, die Ereignisse für die Domäne zu einer Auflistung hinzufügen und dann beim Verteilen von diesen Ereignissen Domäne *direkt vor dem* oder *rechten*  *nach dem* Commit der Transaktion (wie bei SaveChanges in EF).</span><span class="sxs-lookup"><span data-stu-id="fb039-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="fb039-199">(Dieser Ansatz wurden durch Jimmy Bogard beschrieben, die in diesen Beitrag [eine bessere Domäne Ereignisse Muster](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="fb039-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="fb039-200">Entscheidung, ob Sie die Domäne Ereignisse senden ist rechts vor oder nach rechts, nach dem Commit der Transaktion wichtig, da sie bestimmt, ob Sie die Nebeneffekte im Rahmen derselben Transaktion oder in unterschiedlichen Transaktionen enthalten.</span><span class="sxs-lookup"><span data-stu-id="fb039-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="fb039-201">In letzterem Fall müssen Sie die letztliche Konsistenz über mehrere Aggregate zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="fb039-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="fb039-202">In diesem Thema wird im nächsten Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="fb039-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="fb039-203">Die verzögerte Herangehensweise ist, welche eShopOnContainers verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb039-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="fb039-204">Fügen Sie zunächst die Ereignisse in Ihren Entitäten in einer Auflistung oder eine Liste der Ereignisse pro Entität geschieht.</span><span class="sxs-lookup"><span data-stu-id="fb039-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="fb039-205">Diese Liste sollte Teil des Entitätsobjekts oder besser noch, Teil der Basisentität-Klasse handeln, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="fb039-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example:</span></span>

```csharp
public abstract class Entity
{
    private List<IAsyncNotification> _domainEvents;

    public List<IAsyncNotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(IAsyncNotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<IAsyncNotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(IAsyncNotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="fb039-206">Wenn Sie ein Ereignis auslösen möchten, fügen Sie einfach auf die ereignisauflistung innerhalb einer entitätsmethode, die aggregate platziert werden, wie im folgenden Code dargestellt:</span><span class="sxs-lookup"><span data-stu-id="fb039-206">When you want to raise an event, you just add it to the event collection to be placed within an aggregate entity method, as the following code shows:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
    cardTypeId,
    cardNumber,
    cardSecurityNumber,
    cardHolderName,
    cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="fb039-207">Beachten Sie, dass das einzige, das die Methode AddDomainEvent auf diese Weise wird ein Ereignis zur Liste hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-207">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="fb039-208">Noch kein Ereignis ausgelöst, und keine Ereignishandler noch aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="fb039-208">No event is raised yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="fb039-209">Tatsächlich möchten Sie die Ereignisse weiter unten auf verteilen, wenn Sie die Transaktion an die Datenbank übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-209">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="fb039-210">Bei Verwendung von Entity Framework Core bedeutet, dass in der SaveChanges-Methode der EF-DbContext, wie im folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="fb039-210">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<int> SaveEntitiesAsync()
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);
        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="fb039-211">Mit dem folgenden Code verteilen Sie die Entität-Ereignisse, die den entsprechenden Ereignishandler.</span><span class="sxs-lookup"><span data-stu-id="fb039-211">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="fb039-212">Das Gesamtergebnis ist, dass Sie von verteilen es mit einem Ereignishandler das Auslösen eines Ereignisses Domäne entkoppelten haben (eine einfache Hinzufügen zu einer Liste im Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="fb039-212">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="fb039-213">Darüber hinaus je nach Art der Verteiler Sie verwenden, konnten Sie die Ereignisse synchron oder asynchron verteilen.</span><span class="sxs-lookup"><span data-stu-id="fb039-213">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="fb039-214">Bedenken Sie, dass hier transaktionale Grenzen in erhebliche stammen spielen.</span><span class="sxs-lookup"><span data-stu-id="fb039-214">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="fb039-215">Wenn mehr als ein Aggregat Ihre Komponententests von Arbeit und die Transaktion ausgeführt werden kann (wie bei der Verwendung von EF-Kern- und einer relationalen Datenbank), kann dies gut funktionieren.</span><span class="sxs-lookup"><span data-stu-id="fb039-215">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="fb039-216">Wenn jedoch Transaktion Aggregate erstrecken kann, z. B. Wenn Sie eine NoSQL-Datenbank, wie Azure DocumentDB, verwenden Sie zum Implementieren von zusätzlichen Schritte aus, um die Konsistenz zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="fb039-216">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="fb039-217">Dies ist ein weiterer Grund, warum Persistenz Unkenntnis nicht universelle ist; Es setzt das Speichersystem, das Sie verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb039-217">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="fb039-218">Einzelne Transaktion über Aggregate im Vergleich zu eventuellen Konsistenz für Aggregate</span><span class="sxs-lookup"><span data-stu-id="fb039-218">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="fb039-219">Die Frage, ob zum Ausführen einer einzelnen Transaktions für Aggregate im Vergleich zu der vertrauenden Seite auf eventuelle Konsistenz über diese Aggregate ist ein kontroverse.</span><span class="sxs-lookup"><span data-stu-id="fb039-219">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="fb039-220">Viele DDD Autoren wie Eric Evans und Vaughn Vernon der Regel, eine Transaktion Vertreter = ein Aggregat und daher für eventuelle Konsistenz über Aggregate behaupten.</span><span class="sxs-lookup"><span data-stu-id="fb039-220">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="fb039-221">Beispielsweise ist in seinem Buch *Driven Design*, Eric Evans besagt, dass dies:</span><span class="sxs-lookup"><span data-stu-id="fb039-221">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="fb039-222">Jede Regel, die Aggregate umfasst wird nicht erwartet werden, dass jederzeit auf dem neuesten Stand sein.</span><span class="sxs-lookup"><span data-stu-id="fb039-222">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="fb039-223">Durch die Verarbeitung von Ereignissen, Batchverarbeitung oder anderen Aktualisierungsmechanismen können andere Abhängigkeiten innerhalb einer bestimmten Zeit aufgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="fb039-223">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="fb039-224">(Pg.</span><span class="sxs-lookup"><span data-stu-id="fb039-224">(pg.</span></span> <span data-ttu-id="fb039-225">128)</span><span class="sxs-lookup"><span data-stu-id="fb039-225">128)</span></span>

<span data-ttu-id="fb039-226">Vaughn Vernon besagt, dass in der folgenden [effektiven aggregieren Entwurf. Teil II: Treffen aggregiert arbeiten zusammen](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="fb039-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="fb039-227">Wenn also Ausführung eines Befehls auf einem aggregieren Instanz erfordert, dass zusätzliche Geschäftsregeln auf eine oder mehrere Aggregate ausgeführt verwenden eventuellen Konsistenz \[...\] Es ist eine praktische Möglichkeit, eventuelle Konsistenz in einem Modell DDD unterstützen.</span><span class="sxs-lookup"><span data-stu-id="fb039-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="fb039-228">Ein Aggregatmethoden veröffentlicht ein Domäne-Ereignis, die Zeit, die an einen oder mehrere asynchrone Abonnenten übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="fb039-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="fb039-229">Diese Begründung basiert auf Hinwendung differenzierte Transaktionen anstelle von Transaktionen umfasst viele Aggregate oder Entitäten.</span><span class="sxs-lookup"><span data-stu-id="fb039-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="fb039-230">Die Idee dabei ist, dass im zweiten Fall die Anzahl von Datenbanksperren erhebliche in umfangreichen Anwendungen mit hoher Skalierbarkeit Anforderungen kann.</span><span class="sxs-lookup"><span data-stu-id="fb039-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="fb039-231">Übernahme der Tatsache, die dass die hoch skalierbare Anwendungen sofortige Transaktionskonsistenz zwischen mehrere Aggregate keine müssen unterstützt das Konzept der eventuellen Konsistenz akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="fb039-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="fb039-232">Atomische Änderungen häufig nicht vom Unternehmen erforderlich sind, und es ist in jedem Fall die Zuständigkeit für die Domänenexperten bestimmen, ob bestimmte Vorgänge Atomarische Transaktionen oder nicht benötigen.</span><span class="sxs-lookup"><span data-stu-id="fb039-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="fb039-233">Wenn ein Vorgang immer eine atomarische Transaktion zwischen mehrere Aggregate benötigt, Fragen Sie sich, ob Ihre Aggregat größer muss oder wurde nicht ordnungsgemäß entworfen.</span><span class="sxs-lookup"><span data-stu-id="fb039-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="fb039-234">Anderen Entwicklern und Architekten wie Jimmy Bogard sind jedoch nur eine einzelne Transaktion über mehrere Aggregate Aufteilung – jedoch nur, wenn diese zusätzlichen Aggregate mit Nebeneffekte für den gleichen ursprünglichen Befehl verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="fb039-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="fb039-235">Zum Beispiel im [eine bessere Domäne Ereignisse Muster](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard besagt, dass dies:</span><span class="sxs-lookup"><span data-stu-id="fb039-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="fb039-236">Ich möchte in der Regel die Nebeneffekte einer Domäne Ereignis innerhalb der gleichen logischen Transaktion, jedoch nicht notwendigerweise in demselben Gültigkeitsbereich Auslösen des Ereignisses Domäne eintritt \[...\] Kurz bevor wir unsere Transaktion einen Commit auszuführen, verteilen wir unsere Ereignisse an ihre jeweiligen Handler.</span><span class="sxs-lookup"><span data-stu-id="fb039-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="fb039-237">Wenn Sie die Domäne Ereignisse rechts weiterleitet *vor* Ausführen eines Commits für die ursprüngliche Transaktion, es ist, da die Nebeneffekte des diese Ereignisse, die in derselben Transaktion eingeschlossen werden soll.</span><span class="sxs-lookup"><span data-stu-id="fb039-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="fb039-238">Z. B. wenn EF DbContext SaveChanges-Methode ein Fehler auftritt, wird die Transaktion alle Änderungen, z. B. das Ergebnis keine Nebeneffekt-Vorgänge, die durch die verknüpfte Domäne Ereignishandler implementiert Rollback.</span><span class="sxs-lookup"><span data-stu-id="fb039-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="fb039-239">Dies ist, da der DbContext-Lebensdauer-Bereich standardmäßig als "" definiert ist "beschränkt."</span><span class="sxs-lookup"><span data-stu-id="fb039-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="fb039-240">Aus diesem Grund wird der DbContext-Objekt von mehreren Repository-Objekten, die innerhalb der gleichen Gültigkeitsbereich oder Objektdiagramm instanziierte gemeinsam genutzt.</span><span class="sxs-lookup"><span data-stu-id="fb039-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="fb039-241">Dies stimmt mit dem HttpRequest-Bereich, bei der Entwicklung von Web-API oder MVC-apps.</span><span class="sxs-lookup"><span data-stu-id="fb039-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="fb039-242">In Wirklichkeit können beide Ansätze (einzelnen unteilbaren Transaktion und eventuellen Konsistenz) rechts sein.</span><span class="sxs-lookup"><span data-stu-id="fb039-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="fb039-243">Es hängt von Ihrer Domäne oder Business-Anforderungen und Domänenexperten Sie zu informieren, was.</span><span class="sxs-lookup"><span data-stu-id="fb039-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="fb039-244">Davon wie skalierbaren den Dienst benötigen (präzisere Transaktionen sind weniger Auswirkungen in Bezug auf die Datenbanksperren).</span><span class="sxs-lookup"><span data-stu-id="fb039-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="fb039-245">Und hängt von Umfang Investition riskieren möchten in Ihrem Code vornehmen, da die letztliche Konsistenz mehr komplexen Code erfordert, um die Erkennung von möglichen Inkonsistenzen Aggregate und Ausgleich Aktionen implementiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="fb039-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="fb039-246">Müssen Sie berücksichtigen, dass wenn Sie an der ursprünglichen Aggregat- und danach Änderungen, wenn die Ereignisse weitergeleitet werden, ein Problem besteht und die Ereignishandler ihre Nebeneffekte können kein commit durchgeführt, müssen Inkonsistenzen zwischen Aggregate.</span><span class="sxs-lookup"><span data-stu-id="fb039-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="fb039-247">Eine Möglichkeit zum Ausgleich Aktionen ermöglichen wäre, die Domäne Ereignisse in zusätzliche Datenbanktabellen speichern, damit sie die ursprüngliche Transaktion beteiligt sein können.</span><span class="sxs-lookup"><span data-stu-id="fb039-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="fb039-248">Danach könnten Sie einen Batchprozess verfügen, der Inkonsistenzen erkennt und Ausgleich Vorgänge ausgeführt wird, vergleichen Sie dazu die Liste von Ereignissen mit dem aktuellen Status der Aggregate.</span><span class="sxs-lookup"><span data-stu-id="fb039-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="fb039-249">Die Ausgleich Aktionen sind Teil der ein komplexes Thema, das tiefgehende Analysen von Ihrer Seite die enthält erfordern, mit dem Geschäftsbenutzer und Domänenexperten diskutiert.</span><span class="sxs-lookup"><span data-stu-id="fb039-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="fb039-250">In jedem Fall können Sie die Methode auswählen, die Sie benötigen.</span><span class="sxs-lookup"><span data-stu-id="fb039-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="fb039-251">Jedoch der ursprüngliche verzögert Ansatz – vor dem bestätigen, die Ereignisse auslösen, damit Sie eine einzelne Transaktion verwenden, ist der einfachste Ansatz bei Verwendung von EF-Kern- und einer relationalen Datenbank.</span><span class="sxs-lookup"><span data-stu-id="fb039-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="fb039-252">Es ist einfacher zu implementieren und in vielen Geschäftssituationen gültig.</span><span class="sxs-lookup"><span data-stu-id="fb039-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="fb039-253">Es ist auch Ansatz wird in der Reihenfolge Microservice in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="fb039-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="fb039-254">Aber wie Sie tatsächlich dispatch-Ereignisse an ihre jeweiligen Ereignishandler?</span><span class="sxs-lookup"><span data-stu-id="fb039-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="fb039-255">Was ist die \_Vermittler-Objekt, das Sie im vorherigen Beispiel sehen?</span><span class="sxs-lookup"><span data-stu-id="fb039-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="fb039-256">Die muss nur mit den Methoden und Elemente, die Sie verwenden können, um zwischen Ereignissen und den Ereignishandler zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="fb039-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="fb039-257">Die Domäne Ereignisverteiler: Zuordnen von Ereignissen zu Ereignishandlern</span><span class="sxs-lookup"><span data-stu-id="fb039-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="fb039-258">Sobald Sie verteilen oder die Ereignisse veröffentlichen können sind, benötigen Sie eine Art des Artefakt, das das Ereignis veröffentlicht werden sollen, sodass alle verknüpften Handler sie erhalten und Nebeneffekte Prozess auf der Grundlage dieses Ereignisses.</span><span class="sxs-lookup"><span data-stu-id="fb039-258">Once you are able to dispatch or publish the events, you need some kind of artifact that will publish the event so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="fb039-259">Ein besteht Ansatz darin real Messagingsystem oder sogar eine-Ereignisbus, meist basierend auf einer Servicebus im Gegensatz zu den Ereignissen im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="fb039-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="fb039-260">Im ersten Fall wird real messaging wäre jedoch Ausgangsstruktur für Verarbeitungsereignisse Domäne, da Sie nur die Ereignisse innerhalb des gleichen Prozesses verarbeiten müssen (d. h. innerhalb der gleichen Ebene der Domäne und Anwendung).</span><span class="sxs-lookup"><span data-stu-id="fb039-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="fb039-261">Eine andere Möglichkeit, die für mehrere Ereignishandler zugeordnet ist, mit Typen Registrierung in einen IoC-Container, damit Sie dynamisch, wo Sie die Ereignisse per Rückschluss ableiten können.</span><span class="sxs-lookup"><span data-stu-id="fb039-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="fb039-262">Das heißt, müssen Sie wissen, was Ereignishandler müssen, um ein bestimmtes Ereignis abzurufen.</span><span class="sxs-lookup"><span data-stu-id="fb039-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="fb039-263">Abbildung 9 und 16 zeigt einen vereinfachten Ansatz ein, an.</span><span class="sxs-lookup"><span data-stu-id="fb039-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="fb039-264">**Abbildung 9 und 16**.</span><span class="sxs-lookup"><span data-stu-id="fb039-264">**Figure 9-16**.</span></span> <span data-ttu-id="fb039-265">Domäne Ereignisverteiler mit steuerungsumkehrcontainer (IoC)</span><span class="sxs-lookup"><span data-stu-id="fb039-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="fb039-266">Sie können alle zugrunde liegenden Funktionen und Elementen, die diesen Ansatz selbst implementieren erstellen.</span><span class="sxs-lookup"><span data-stu-id="fb039-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="fb039-267">Allerdings können Sie auch verfügbare Bibliotheken wie verwenden [MediatR](https://github.com/jbogard/MediatR), die im Hintergrund verwendet Ihrer IoT-Containers.</span><span class="sxs-lookup"><span data-stu-id="fb039-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoT container.</span></span> <span data-ttu-id="fb039-268">Sie können daher direkt die vordefinierten Schnittstellen und die Vermittler Objektmethoden veröffentlichen/Dispatch verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb039-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="fb039-269">Im Code müssen Sie zunächst die Handler Ereignistypen im IoC-Container zu registrieren, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="fb039-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example:</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement
        // IAsyncNotificationHandler<>) in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(
            typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
            .GetTypeInfo().Assembly)
            .Where(t => t.IsClosedTypeOf(typeof(IAsyncNotificationHandler<>)))
            .AsImplementedInterfaces();
        // Other registrations ...
    }
}
```

<span data-ttu-id="fb039-270">Der Code zunächst identifiziert die Assembly, die die Ereignishandler für die Domäne enthält, suchen Sie die Assembly, die alle der Handler enthält (mit typeof(ValidateOrAddBuyerAggregateWhenXxxx), aber Sie hätten jeder andere Ereignishandler zum Suchen der Assembly).</span><span class="sxs-lookup"><span data-stu-id="fb039-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="fb039-271">Da alle Ereignishandler die IAsyncNotificationHandler-Schnittstelle implementieren, den Code dann einfach Suchvorgänge für diese Datentypen und registriert den Ereignishandler.</span><span class="sxs-lookup"><span data-stu-id="fb039-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="fb039-272">Gewusst wie: Abonnieren von Ereignissen der Domäne</span><span class="sxs-lookup"><span data-stu-id="fb039-272">How to subscribe to domain events</span></span>

<span data-ttu-id="fb039-273">Bei Verwendung von MediatR muss jeder Ereignishandler einen Ereignistyp, der für den generischen Parameter der Schnittstelle IAsyncNotificationHandler bereitgestellt wird verwenden, wie Sie in den folgenden Code sehen können:</span><span class="sxs-lookup"><span data-stu-id="fb039-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the IAsyncNotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="fb039-274">Basierend auf der Beziehung zwischen Ereignis und Ereignishandler, der das Abonnement betrachtet werden kann, das Artefakt MediatR ermitteln die Ereignishandler für jedes Ereignis und aller diese Ereignishandler ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="fb039-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="fb039-275">Behandeln von Ereignissen Domäne</span><span class="sxs-lookup"><span data-stu-id="fb039-275">How to handle domain events</span></span>

<span data-ttu-id="fb039-276">Abschließend implementiert der Ereignishandler in der Regel Ebene Anwendungscode, der Infrastruktur-Repositorys zum Abrufen der erforderlichen zusätzlichen Aggregate und auszuführende Nebeneffekte Domänenlogik verwendet.</span><span class="sxs-lookup"><span data-stu-id="fb039-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="fb039-277">Der folgende Code zeigt ein Beispiel.</span><span class="sxs-lookup"><span data-stu-id="fb039-277">The following code shows an example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
    : IAsyncNotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;
    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // Parameter validations
        //...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ?
            orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;
        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }
        buyer.VerifyOrAddPaymentMethod(cardTypeId,
            $"Payment Method on {DateTime.UtcNow}",
            orderStartedEvent.CardNumber,
            orderStartedEvent.CardSecurityNumber,
            orderStartedEvent.CardHolderName,
            orderStartedEvent.CardExpiration,
            orderStartedEvent.Order.Id);
        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) :
        _buyerRepository.Add(buyer);
        await _buyerRepository.UnitOfWork.SaveEntitiesAsync();
        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="fb039-278">Diese Ereignishandlercode Ebene Anwendungscode gilt da Infrastruktur-Repositorys, die verwendet wird, wie der Infrastruktur Persistenzebene im nächsten Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="fb039-278">This event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="fb039-279">Ereignishandler können auch andere Infrastrukturkomponenten verwenden.</span><span class="sxs-lookup"><span data-stu-id="fb039-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="fb039-280">Domain-Ereignisse können integrationsereignisse außerhalb der Grenzen Microservice veröffentlicht werden generiert.</span><span class="sxs-lookup"><span data-stu-id="fb039-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="fb039-281">Schließlich ist wichtig zu erwähnen, dass Sie manchmal sollten Ereignisse über mehrere Microservices weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="fb039-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="fb039-282">Ein Ereignis Integration angesehen wird, und es über eine Ereignisbus aus jeder Ereignishandler bestimmte Domäne veröffentlicht werden konnte.</span><span class="sxs-lookup"><span data-stu-id="fb039-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="fb039-283">Schlussfolgerungen auf Domain-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="fb039-283">Conclusions on domain events</span></span> 

<span data-ttu-id="fb039-284">Wie erwähnt, verwenden Sie Domain-Ereignisse, um explizit Nebeneffekte der Änderungen in Ihrer Domäne zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="fb039-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="fb039-285">Um DDD Terminologie verwenden zu können, verwenden Sie Domäne Ereignisse Nebeneffekte über eine oder mehrere Aggregate explizit implementiert.</span><span class="sxs-lookup"><span data-stu-id="fb039-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="fb039-286">Verwenden Sie darüber hinaus und für eine bessere Skalierbarkeit und weniger Auswirkungen auf die Datenbanksperren, die letztliche Konsistenz zwischen Aggregate innerhalb der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="fb039-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="fb039-287">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="fb039-287">Additional resources</span></span>

-   <span data-ttu-id="fb039-288">**Greg Young. Was ist ein Ereignis Domäne? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="fb039-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="fb039-289">**Jan Stenberg. Ereignisse der Domäne und eventuelle Konsistenz**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="fb039-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="fb039-290">**Jimmy Bogard. Eine bessere Domäne Ereignisse Muster**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="fb039-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="fb039-291">**Vaughn Vernon. Effektive aggregieren Entwurf Teil II: Ausführenden Aggregate arbeiten zusammen**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_Artikel/Vernon\_2011\_ 2. pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="fb039-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="fb039-292">**Jimmy Bogard. Stärkung Ihrer Domäne: Domäne Ereignisse**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="fb039-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="fb039-293">**Tony Truong. Domäne Ereignisse Muster Beispiel**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="fb039-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="fb039-294">**Udi Dahan. Vorgehensweise: Erstellen Sie vollständig gekapselt Domänenmodelle**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="fb039-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="fb039-295">**Udi Dahan. Erstellen einer Domäne Ereignisse – 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="fb039-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="fb039-296">**Udi Dahan. Domain-Ereignisse – Rettung**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="fb039-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="fb039-297">**Jan Kronquist. Nicht veröffentlichen von Ereignissen der Domäne, zurückgeben! ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="fb039-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="fb039-298">**Cesar de la Torre. Domäne-Ereignisse im Vergleich zu DDD und Microservices Architekturen-Integrationsereignisse**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="fb039-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="fb039-299">[Vorherigen] (Client-Side-validation.md) [weiter] (Infrastruktur-Persistenz-Ebene – design.md)</span><span class="sxs-lookup"><span data-stu-id="fb039-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
