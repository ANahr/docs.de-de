---
title: Übersicht über Synchronisierungsprimitiven
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: e35c2337ff7e416cb5f2c869f8ede160e05d369f
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
ms.locfileid: "33592014"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="257c2-102">Übersicht über Synchronisierungsprimitiven</span><span class="sxs-lookup"><span data-stu-id="257c2-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="257c2-103">.NET Framework stellt eine Reihe von Synchronisierungsmechanismen zum Steuern der Interaktionen von Threads und zum Vermeiden von Racebedingungen bereit.</span><span class="sxs-lookup"><span data-stu-id="257c2-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="257c2-104">Diese können grob in drei Kategorien eingeteilt werden: Sperren, Signalisieren und Interlocked-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="257c2-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="257c2-105">Diese Kategorien sind weder präzise noch klar definiert: Einige Synchronisierungsmechanismen weisen Merkmale mehrerer Kategorien auf. Ereignisse, die einen einzelnen Thread zu einem Zeitpunkt freigegeben, funktionieren wie Sperren. Die Freigabe einer Sperren kann als Signal betrachtet werden. und Interlocked-Vorgänge können verwendet werden, um Sperren zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="257c2-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="257c2-106">Die Kategorien sind jedoch trotzdem.</span><span class="sxs-lookup"><span data-stu-id="257c2-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="257c2-107">Es ist wichtig zu beachten, dass die Threadsynchronisierung kooperativ erfolgt.</span><span class="sxs-lookup"><span data-stu-id="257c2-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="257c2-108">Wenn auch nur ein Thread einen Synchronisierungsmechanismus umgeht und direkt auf die geschützte Ressource zugreift, kann der Synchronisierungsmechanismus nicht effektiv sein.</span><span class="sxs-lookup"><span data-stu-id="257c2-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="257c2-109">Diese Übersicht enthält folgende Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="257c2-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="257c2-110">Sperren</span><span class="sxs-lookup"><span data-stu-id="257c2-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="257c2-111">Signaling</span><span class="sxs-lookup"><span data-stu-id="257c2-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="257c2-112">Einfache Synchronisierungstypen</span><span class="sxs-lookup"><span data-stu-id="257c2-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="257c2-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="257c2-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="257c2-114">Interlocked-Vorgänge</span><span class="sxs-lookup"><span data-stu-id="257c2-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="257c2-115">Sperren</span><span class="sxs-lookup"><span data-stu-id="257c2-115">Locking</span></span>  
 <span data-ttu-id="257c2-116">Sperren gewähren jeweils einem Thread oder einer angegebenen Anzahl von Threads die Kontrolle über eine  Ressource.</span><span class="sxs-lookup"><span data-stu-id="257c2-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="257c2-117">Ein Thread, der eine exklusive Sperre anfordert, wenn die Sperre aktiv ist, wird gesperrt, bis die Sperre verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="257c2-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="257c2-118">Exklusive Sperren</span><span class="sxs-lookup"><span data-stu-id="257c2-118">Exclusive Locks</span></span>  
 <span data-ttu-id="257c2-119">Die einfachste Form einer Sperre ist die `lock`-Anweisung in C# und die `SyncLock`-Anweisung in Visual Basic, die den Zugriff auf einen Codeblock steuert.</span><span class="sxs-lookup"><span data-stu-id="257c2-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="257c2-120">So ein Block wird häufig als kritischer Abschnitt bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="257c2-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="257c2-121">Die `lock`-Anweisung wird mithilfe der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>- und <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode implementiert und verwendet den `try…catch…finally`-Block, um sicherzustellen, dass die Sperre aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="257c2-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses `try…catch…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="257c2-122">Im Allgemeinen ist die Verwendung der `lock`- oder `SyncLock`-Anweisung zum Schützen kleiner Codeblöcke, die nie mehr als eine einzelne Methode umfassen, die beste Verwendung der <xref:System.Threading.Monitor>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="257c2-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="257c2-123">Die <xref:System.Threading.Monitor>-Klasse ist zwar leistungsstark, aber anfällig für verwaiste Sperren und Deadlocks.</span><span class="sxs-lookup"><span data-stu-id="257c2-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="257c2-124">Monitor-Klasse</span><span class="sxs-lookup"><span data-stu-id="257c2-124">Monitor Class</span></span>  
 <span data-ttu-id="257c2-125">Die <xref:System.Threading.Monitor>-Klasse bietet zusätzliche Funktionen, die in Verbindung mit der `lock`-Anweisung verwendet werden können:</span><span class="sxs-lookup"><span data-stu-id="257c2-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="257c2-126">Die <xref:System.Threading.Monitor.TryEnter%2A>-Methode ermöglicht es einem Thread, der blockiert ist, zu warten, bis die Ressource nach einem angegebenen Intervall freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="257c2-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="257c2-127">Es gibt einen booleschen Wert, der Erfolg oder Fehler angibt und der verwendet werden kann, um potenzielle Deadlocks zu erkennen und zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="257c2-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="257c2-128">Die <xref:System.Threading.Monitor.Wait%2A>-Methode wird von einem Thread in einem kritischen Abschnitt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="257c2-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="257c2-129">Sie gibt die Steuerung der Ressource auf und blockiert, bis die Ressource wieder verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="257c2-130">Die Methoden <xref:System.Threading.Monitor.Pulse%2A> und <xref:System.Threading.Monitor.PulseAll%2A> lassen einen Thread zu, der die Sperre freigibt, oder rufen <xref:System.Threading.Monitor.Wait%2A> auf, um an einen oder mehrere Threads in die Warteschlange einzufügen, sodass diese die Sperre erhalten können.</span><span class="sxs-lookup"><span data-stu-id="257c2-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="257c2-131">Mithilfe von Timeouts für <xref:System.Threading.Monitor.Wait%2A>-Methodenüberladungen können wartende Threads in die Bereitschaftswarteschlange versetzt werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="257c2-132">Die <xref:System.Threading.Monitor>-Klasse kann in mehreren Anwendungsdomänen Sperren bereitstellen, wenn das für die Sperre verwendete Objekt von <xref:System.MarshalByRefObject> abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="257c2-133"><xref:System.Threading.Monitor> weist Threadaffinität auf.</span><span class="sxs-lookup"><span data-stu-id="257c2-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="257c2-134">Das heißt, ein Thread im Monitor muss ihn durch Aufrufen von <xref:System.Threading.Monitor.Exit%2A> oder <xref:System.Threading.Monitor.Wait%2A> verlassen.</span><span class="sxs-lookup"><span data-stu-id="257c2-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="257c2-135">Die <xref:System.Threading.Monitor>-Klasse kann nicht instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="257c2-136">Ihre Methoden sind statisch (`Shared` in Visual Basic) und reagieren auf ein instanziierbares Sperrobjekt.</span><span class="sxs-lookup"><span data-stu-id="257c2-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="257c2-137">Eine grundlegende Übersicht finden Sie unter [Monitore](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="257c2-137">For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="257c2-138">Mutex-Klasse</span><span class="sxs-lookup"><span data-stu-id="257c2-138">Mutex Class</span></span>  
 <span data-ttu-id="257c2-139">Threads fordern eine <xref:System.Threading.Mutex> durch Aufruf einer Überladung der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode an.</span><span class="sxs-lookup"><span data-stu-id="257c2-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="257c2-140">Überladungen mit Timeouts werden bereitgestellt, damit Threads den Wartevorgang aufgeben können.</span><span class="sxs-lookup"><span data-stu-id="257c2-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="257c2-141">Im Gegensatz zur <xref:System.Threading.Monitor>-Klasse kann ein Mutex lokal oder global sein.</span><span class="sxs-lookup"><span data-stu-id="257c2-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="257c2-142">Globale Mutexe, auch als benannte Mutexe bezeichnet, sind im gesamten Betriebssystem sichtbar und können verwendet werden, um Threads in mehreren Anwendungsdomänen oder Prozessen zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="257c2-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="257c2-143">Lokale Mutexe stammen von <xref:System.MarshalByRefObject> ab und können über Anwendungsdomänengrenzen hinweg verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="257c2-144">Darüber hinaus wird <xref:System.Threading.Mutex> von <xref:System.Threading.WaitHandle> abgeleitet, was bedeutet, dass sie mit Signalisierungsmechanismen verwendet werden kann, die von <xref:System.Threading.WaitHandle> bereitgestellt werden, wie z. B. die Methoden <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> und <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="257c2-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="257c2-145">Wie <xref:System.Threading.Monitor> weist auch <xref:System.Threading.Mutex> Threadaffinität auf.</span><span class="sxs-lookup"><span data-stu-id="257c2-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="257c2-146">Im Gegensatz zu <xref:System.Threading.Monitor> kann <xref:System.Threading.Mutex>-Objekt instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="257c2-147">Eine grundlegende Übersicht finden Sie unter [Mutexe](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="257c2-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="257c2-148">SpinLock-Klasse</span><span class="sxs-lookup"><span data-stu-id="257c2-148">SpinLock Class</span></span>  
 <span data-ttu-id="257c2-149">Beginnend mit [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] können Sie die <xref:System.Threading.SpinLock>-Klasse verwenden, wenn der von <xref:System.Threading.Monitor> erforderte Aufwand die Leistung beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="257c2-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="257c2-150">Wenn <xref:System.Threading.SpinLock> auf einen gesperrten kritischen Abschnitt stößt, bleibt sie einfach in einer Schleife, bis die Sperre verfügbar wird.</span><span class="sxs-lookup"><span data-stu-id="257c2-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="257c2-151">Wenn die Sperre für eine sehr kurze Zeit aufrechterhalten wird, bieten Spinvorgänge eine bessere Leistung als das Blockieren.</span><span class="sxs-lookup"><span data-stu-id="257c2-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="257c2-152">Wenn aber die Sperre für mehr als einige Zehntel Zyklen aufrechterhalten wird, ist die Leistung von <xref:System.Threading.SpinLock> genauso gut wie von <xref:System.Threading.Monitor>, verwendet aber mehr CPU-Zyklen und kann so die Leistung von anderen Threads oder Prozessen beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="257c2-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="257c2-153">Andere Sperren</span><span class="sxs-lookup"><span data-stu-id="257c2-153">Other Locks</span></span>  
 <span data-ttu-id="257c2-154">Sperren müssen nicht exklusiv sein.</span><span class="sxs-lookup"><span data-stu-id="257c2-154">Locks need not be exclusive.</span></span> <span data-ttu-id="257c2-155">Es ist häufig nützlich, eine begrenzte Anzahl von Threads gleichzeitigen Zugriff auf eine Ressource zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="257c2-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="257c2-156">Semaphoren und Lese-/Schreibsperren sollen diese Art von Zugriff auf einen Ressourcenpool steuern.</span><span class="sxs-lookup"><span data-stu-id="257c2-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="257c2-157">ReaderWriterLock-Klasse</span><span class="sxs-lookup"><span data-stu-id="257c2-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="257c2-158">Die <xref:System.Threading.ReaderWriterLockSlim>-Klasse wird verwendet, wenn ein Thread, der Daten ändert (der Writer) exklusiven Zugriff auf eine Ressource haben muss.</span><span class="sxs-lookup"><span data-stu-id="257c2-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="257c2-159">Wenn der Writer nicht aktiv ist, kann eine beliebige Anzahl Readern auf die Ressource zugreifen (z. B. durch Aufrufen der <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>-Methode).</span><span class="sxs-lookup"><span data-stu-id="257c2-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="257c2-160">Wenn ein Thread exklusiven Zugriff anfordert (z. B. durch Aufrufen der <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>-Methode), werden nachfolgende Readeranforderungen blockiert, bis alle vorhandenen Reader die Sperre beendet haben und der Writer die Sperre aktiviert und beendet hat.</span><span class="sxs-lookup"><span data-stu-id="257c2-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="257c2-161"><xref:System.Threading.ReaderWriterLockSlim> weist Threadaffinität auf.</span><span class="sxs-lookup"><span data-stu-id="257c2-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="257c2-162">Eine grundlegende Übersicht finden Sie unter [Lese-/Schreibsperren](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="257c2-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="257c2-163">Semaphore-Klasse</span><span class="sxs-lookup"><span data-stu-id="257c2-163">Semaphore Class</span></span>  
 <span data-ttu-id="257c2-164">Die <xref:System.Threading.Semaphore>-Klasse ermöglicht einer festgelegten Anzahl von Threads den Zugriff auf eine Ressource.</span><span class="sxs-lookup"><span data-stu-id="257c2-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="257c2-165">Zusätzliche Threads fordern den Ressourcenblock an, bis ein Thread das Semaphor freigibt.</span><span class="sxs-lookup"><span data-stu-id="257c2-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="257c2-166">Wie die <xref:System.Threading.Mutex>-Klasse wird auch <xref:System.Threading.Semaphore> von <xref:System.Threading.WaitHandle> abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="257c2-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="257c2-167">Wie <xref:System.Threading.Mutex> kann auch <xref:System.Threading.Semaphore> entweder lokal oder global sein.</span><span class="sxs-lookup"><span data-stu-id="257c2-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="257c2-168">Diese Klasse kann über Anwendungsdomänengrenzen hinweg verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="257c2-169">Im Gegensatz zu <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> und <xref:System.Threading.ReaderWriterLock> weist <xref:System.Threading.Semaphore> keine Threadaffinität auf.</span><span class="sxs-lookup"><span data-stu-id="257c2-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="257c2-170">Das heißt, sie kann in Szenarien verwendet werden, in denen ein Thread das Semaphor erhält und ein anderer es freigibt.</span><span class="sxs-lookup"><span data-stu-id="257c2-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="257c2-171">Eine grundlegende Übersicht finden Sie unter [Semaphore und SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="257c2-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="257c2-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> ist ein einfaches Semaphor für die Synchronisierung innerhalb einer einzelnen Prozessgrenze.</span><span class="sxs-lookup"><span data-stu-id="257c2-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="257c2-173">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="257c2-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="257c2-174">Signaling</span><span class="sxs-lookup"><span data-stu-id="257c2-174">Signaling</span></span>  
 <span data-ttu-id="257c2-175">Die einfachste Möglichkeit, auf ein Signal von einem anderen Thread zu warten, ist das Aufrufen der <xref:System.Threading.Thread.Join%2A>-Methode, die blockiert, bis der andere Thread abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="257c2-176"><xref:System.Threading.Thread.Join%2A> verfügt über zwei Überladungen, die es einem blockierten Thread ermöglichen, den Wartevorgang nach ein angegebenen Intervall zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="257c2-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="257c2-177">Wait-Handles stellen viel umfangreichere Warte- und Signalfunktionen bereit.</span><span class="sxs-lookup"><span data-stu-id="257c2-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="257c2-178">Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="257c2-178">Wait Handles</span></span>  
 <span data-ttu-id="257c2-179">Wait-Handles stammen von der <xref:System.Threading.WaitHandle>-Klasse ab, die wiederum von <xref:System.MarshalByRefObject> abstammt.</span><span class="sxs-lookup"><span data-stu-id="257c2-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="257c2-180">Folglich können Wait-Handles verwendet werden, um die Aktivitäten von Threads über Anwendungsdomänengrenzen hinweg zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="257c2-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="257c2-181">Threads blockieren Wait-Handles durch Aufrufen der Instanzmethode <xref:System.Threading.WaitHandle.WaitOne%2A> oder einer der statischen Methoden <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> oder <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="257c2-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="257c2-182">Wie sie freigegeben werden, hängt von der aufgerufenen Methode sowie von der Art des Wait-Handles ab.</span><span class="sxs-lookup"><span data-stu-id="257c2-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="257c2-183">Eine grundlegende Übersicht finden Sie unter [Wait-Handle](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="257c2-183">For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="257c2-184">Ereignis-Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="257c2-184">Event Wait Handles</span></span>  
 <span data-ttu-id="257c2-185">Ereignis-Wait-Handles schließen die <xref:System.Threading.EventWaitHandle>-Klasse und die abgeleiteten Klassen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent> ein.</span><span class="sxs-lookup"><span data-stu-id="257c2-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="257c2-186">Threads werden von einem Ereignis-Wait-Handle freigegeben, wenn das Ereignis-Wait-Handle durch Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A>-Methode oder mithilfe der <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode signalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="257c2-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="257c2-187">Ereignis-Wait-Handles setzen sich entweder selbst automatisch zurück (wie ein Drehkreuz, das bei jedem Signalisieren nur einen Thread durchlässt) oder müssen manuell zurückgesetzt werden (wie ein Tor, das bis zum Signal geschlossen und dann geöffnet wird, bis es jemand wieder schließt.</span><span class="sxs-lookup"><span data-stu-id="257c2-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="257c2-188">Wie die Namen bereits andeuten stellen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent> die beiden genannten Handles dar.</span><span class="sxs-lookup"><span data-stu-id="257c2-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="257c2-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> ist ein einfaches Ereignis für die Synchronisierung innerhalb einer einzelnen Prozessgrenze.</span><span class="sxs-lookup"><span data-stu-id="257c2-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="257c2-190">Ein <xref:System.Threading.EventWaitHandle> kann beide Ereignistypen darstellen und entweder lokal oder global sein.</span><span class="sxs-lookup"><span data-stu-id="257c2-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="257c2-191">Die abgeleiteten Klassen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent> sind immer lokal.</span><span class="sxs-lookup"><span data-stu-id="257c2-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="257c2-192">Ereignis-Wait-Handles weisen keine Threadaffinität auf.</span><span class="sxs-lookup"><span data-stu-id="257c2-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="257c2-193">Jeder Thread kann einem Ereignis-Wait-Handle signalisiert.</span><span class="sxs-lookup"><span data-stu-id="257c2-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="257c2-194">Eine grundlegende Übersicht finden Sie unter [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="257c2-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="257c2-195">Mutex- und Semaphore-Klassen</span><span class="sxs-lookup"><span data-stu-id="257c2-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="257c2-196">Da die Klassen <xref:System.Threading.Mutex> und <xref:System.Threading.Semaphore> von <xref:System.Threading.WaitHandle> abgeleitet werden, können sie mit den statischen Methoden von <xref:System.Threading.WaitHandle> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="257c2-197">Ein Thread kann z. B. mithilfe der <xref:System.Threading.WaitHandle.WaitAll%2A>-Methode warten, bis alle drei der folgenden Bedingungen erfüllt sind: ein <xref:System.Threading.EventWaitHandle> wird signalisiert, ein <xref:System.Threading.Mutex> wird freigegeben und ein <xref:System.Threading.Semaphore> wird freigegeben.</span><span class="sxs-lookup"><span data-stu-id="257c2-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="257c2-198">Ebenso kann ein Thread mithilfe der <xref:System.Threading.WaitHandle.WaitAny%2A>-Methode warten, bis eine dieser Bedingungen erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="257c2-199">Für ein <xref:System.Threading.Mutex> oder ein <xref:System.Threading.Semaphore> bedeutet Signalisierung, freigegeben zu werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="257c2-200">Wenn einer der Typen als erstes Argument der <xref:System.Threading.WaitHandle.SignalAndWait%2A>-Methode verwendet wird, wird er freigegeben.</span><span class="sxs-lookup"><span data-stu-id="257c2-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="257c2-201">Im Fall eines <xref:System.Threading.Mutex>, der Threadaffinität aufweist, wird eine Ausnahme ausgelöst, wenn der aufrufende Thread das Mutex nicht besitzt.</span><span class="sxs-lookup"><span data-stu-id="257c2-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="257c2-202">Wie bereits erwähnt, weisen Semaphore keine Threadaffinität auf.</span><span class="sxs-lookup"><span data-stu-id="257c2-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="257c2-203">Barriere</span><span class="sxs-lookup"><span data-stu-id="257c2-203">Barrier</span></span>  
 <span data-ttu-id="257c2-204">Die <xref:System.Threading.Barrier>-Klasse bietet eine Möglichkeit, mehrere Threads zyklisch zu synchronisieren, sodass sie gleichzeitig am gleichen Punkt blocken und warten, bis alle anderen Threads abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="257c2-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="257c2-205">Eine Barriere ist nützlich, wenn ein oder mehrere Threads die Ergebnisse eines anderen Threads benötigen, um mit der nächsten Phase eines Algorithmus fortzufahren.</span><span class="sxs-lookup"><span data-stu-id="257c2-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="257c2-206">Weitere Informationen finden Sie unter [Barrier](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="257c2-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="257c2-207">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="257c2-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="257c2-208">Einfache Synchronisierungstypen</span><span class="sxs-lookup"><span data-stu-id="257c2-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="257c2-209">Ab [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] können Sie Synchronisierungsprimitiven verwenden, die schnelle Leistung durch Vermeiden teurer Abhängigkeiten von Win32-Kernelobjekten bereitstellen, wie z. B. Wait-Handles (sofern möglich).</span><span class="sxs-lookup"><span data-stu-id="257c2-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="257c2-210">Im Allgemeinen sollten Sie diese Typen verwenden, wenn die Wartezeiten kurz sind und nur dann, wenn die ursprünglichen Synchronisierungstypen ausprobiert und als unzureichend eingestuft wurden.</span><span class="sxs-lookup"><span data-stu-id="257c2-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="257c2-211">Die einfachen Typen können nicht in Szenarien verwendet werden, die prozessübergreifende Kommunikation erfordern.</span><span class="sxs-lookup"><span data-stu-id="257c2-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="257c2-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> ist eine einfache Version von <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="257c2-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="257c2-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> ist eine einfache Version von <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="257c2-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="257c2-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> stellt ein Ereignis dar, das signalisiert wird, wenn die Anzahl null ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="257c2-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> ermöglicht die Synchronisierung mehrerer Threads miteinander, ohne dass die Steuerung durch einen Master-Thread erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="257c2-216">Eine Barriere verhindert, dass jeder Thread fortgesetzt wird, bis alle Threads einen bestimmten Punkt erreicht haben.</span><span class="sxs-lookup"><span data-stu-id="257c2-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="257c2-217">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="257c2-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="257c2-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="257c2-218">SpinWait</span></span>  
 <span data-ttu-id="257c2-219">Ab [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] können Sie die <xref:System.Threading.SpinWait?displayProperty=nameWithType>-Struktur verwenden, wenn ein Thread warten muss, bis ein Ereignis signalisiert oder eine Bedingung erfüllt wird, außer wenn die tatsächliche Wartezeit voraussichtlich kürzer als die erforderliche Wartezeit beim Verwenden eines Wait-Handles oder einer anderen Blockierung des aktuellen Threads ist.</span><span class="sxs-lookup"><span data-stu-id="257c2-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="257c2-220">Mithilfe von <xref:System.Threading.SpinWait> können Sie einen kurzen Wartezeitraum angeben und danach nur dann auslösen (z. B. durch Warten oder Ruhezustand), wenn die Bedingung nicht in der angegebenen Zeit erfüllt wurde.</span><span class="sxs-lookup"><span data-stu-id="257c2-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="257c2-221">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="257c2-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="257c2-222">Interlocked-Vorgänge</span><span class="sxs-lookup"><span data-stu-id="257c2-222">Interlocked Operations</span></span>  
 <span data-ttu-id="257c2-223">Interlocked-Vorgänge sind einfache atomare Operationen auf einen Speicherbereich durch statische Methoden der <xref:System.Threading.Interlocked>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="257c2-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="257c2-224">Diese atomaren Operationen umfassen Addition, Inkrementieren und Dekrementieren, Austausch, bedingter Austausch je nach Vergleich und Lesevorgänge für 64-Bit-Werte auf 32-Bit-Plattformen.</span><span class="sxs-lookup"><span data-stu-id="257c2-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="257c2-225">Die Garantie der Unteilbarkeit gilt nur für einzelne Vorgänge. Wenn mehrere Vorgänge als Einheit ausgeführt werden müssen, muss ein gröberer Synchronisierungsmechanismus verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="257c2-226">Obwohl keine dieser Vorgänge Sperren oder Signale sind, können sie zum Erstellen von Sperren und Signalen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="257c2-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="257c2-227">Da sie systemeigene Vorgänge des Windows-Betriebssystems sind, sind Interlocked-Vorgänge äußerst schnell.</span><span class="sxs-lookup"><span data-stu-id="257c2-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="257c2-228">Interlocked-Vorgänge können mit Garantien für flüchtigen Speicher verwendet werden, um Anwendungen zu schreiben, die leistungsstarke nicht blockierende Parallelität ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="257c2-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="257c2-229">Allerdings benötigen sie ausgefeilte, systemnahe Programmierung, sodass in den meisten Fällen einfache Sperren besser geeignet sind.</span><span class="sxs-lookup"><span data-stu-id="257c2-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="257c2-230">Eine grundlegende Übersicht finden Sie unter [Interlock-Vorgänge](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="257c2-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="257c2-231">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="257c2-231">See Also</span></span>  
 [<span data-ttu-id="257c2-232">Datensynchronisierung für Multithreading</span><span class="sxs-lookup"><span data-stu-id="257c2-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="257c2-233">Monitore</span><span class="sxs-lookup"><span data-stu-id="257c2-233">Monitors</span></span>](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="257c2-234">Mutexe</span><span class="sxs-lookup"><span data-stu-id="257c2-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="257c2-235">Semaphore and SemaphoreSlim (Semaphore und SemaphoreSlim)</span><span class="sxs-lookup"><span data-stu-id="257c2-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="257c2-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="257c2-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="257c2-237">Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="257c2-237">Wait Handles</span></span>](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="257c2-238">Interlocked-Vorgänge</span><span class="sxs-lookup"><span data-stu-id="257c2-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="257c2-239">Lese-/Schreibsperren</span><span class="sxs-lookup"><span data-stu-id="257c2-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="257c2-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="257c2-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="257c2-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="257c2-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="257c2-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="257c2-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
