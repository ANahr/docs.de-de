---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="7a11c-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="7a11c-102">EventWaitHandle</span></span>
<span data-ttu-id="7a11c-103">Die <xref:System.Threading.EventWaitHandle> Klasse kann Threads durch das signalisieren und Signale warten miteinander zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="7a11c-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="7a11c-104">Ereignis-Wait-Handles (auch einfach als Ereignisse bezeichnet) werden Wait-Handles, die signalisiert werden können, um eine oder mehrere wartende Threads zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="7a11c-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="7a11c-105">Nach es signalisiert wird, wird einem Ereignis-Wait-Handle entweder manuell oder automatisch zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="7a11c-106">Die <xref:System.Threading.EventWaitHandle> Klasse kann entweder ein lokales Ereignis Wait-Handle (lokales Ereignis) darstellen, oder ein benanntes Systemereignis-wait-Handle (benannten Ereignis oder Systemereignis für alle Prozesse sichtbar).</span><span class="sxs-lookup"><span data-stu-id="7a11c-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7a11c-107">Ereignis-Wait-Handles sind keine Ereignisse in dem Sinne, die in der Regel durch das Wort in .NET Framework vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="7a11c-108">Es gibt keine Delegaten oder einen Ereignishandler beteiligt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="7a11c-109">Das Wort "Ereignis" dient zum sie beschreiben, da sie normalerweise als Betriebssystem-Ereignisse bezeichnet wurden haben und die Act anzeigenden das Wait-Handle zu wartenden Threads angibt, die ein Ereignis aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="7a11c-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="7a11c-110">Sowohl lokale als auch benannte Ereignis-Wait-Handles verwenden Synchronisierungsobjekte des Systems, die durch geschützt sind <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Wrapper um sicherzustellen, dass die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="7a11c-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="7a11c-111">Sie können die <xref:System.Threading.WaitHandle.Dispose%2A> Methode, um die Ressourcen freizugeben, sofort nach Beendigung unter Verwendung des Objekts.</span><span class="sxs-lookup"><span data-stu-id="7a11c-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="7a11c-112">Ereignis-Wait-Handles, die automatisch zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="7a11c-113">Erstellen Sie ein Automatisches Rücksetzen-Ereignis, durch Angabe <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> beim Erstellen der <xref:System.Threading.EventWaitHandle> Objekt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="7a11c-114">Wie der Name schon sagt, wird dieses Synchronisierungsereignis automatisch zurückgesetzt, wenn nach der Freigabe eines einzelnen wartenden Threads signalisiert.</span><span class="sxs-lookup"><span data-stu-id="7a11c-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="7a11c-115">Signalisiert das Ereignis durch Aufrufen seiner <xref:System.Threading.EventWaitHandle.Set%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7a11c-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="7a11c-116">Automatisches Rücksetzen Ereignisse werden normalerweise verwendet, um exklusiven Zugriff auf eine Ressource für einen einzelnen Thread zu einem Zeitpunkt bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="7a11c-117">Ein Thread die Ressource anfordert, durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="7a11c-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="7a11c-118">Wenn kein anderer Thread das Wait-Handle enthalten kann, gibt die Methode `true` und der aufrufende Thread hat die Steuerung der Ressource.</span><span class="sxs-lookup"><span data-stu-id="7a11c-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7a11c-119">Wie bei allen Synchronisierungsmechanismen, müssen Sie sicherstellen, dass alle Codepfade in der entsprechenden Wait-Handle warten, bevor Sie den Zugriff auf eine geschützte Ressource.</span><span class="sxs-lookup"><span data-stu-id="7a11c-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="7a11c-120">Threadsynchronisierung ist kooperativ.</span><span class="sxs-lookup"><span data-stu-id="7a11c-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="7a11c-121">Wenn ein Automatisches Rücksetzen Ereignis signalisiert wird, wenn keine Threads warten, bleibt es signalisiert, bis ein Thread versucht, darauf zu warten.</span><span class="sxs-lookup"><span data-stu-id="7a11c-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="7a11c-122">Das Ereignis den Thread freigibt und sofort zurückgesetzt werden, sodass nachfolgende Threads blockiert.</span><span class="sxs-lookup"><span data-stu-id="7a11c-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="7a11c-123">Ereignis-Wait-Handles, die das manuelle Zurücksetzen</span><span class="sxs-lookup"><span data-stu-id="7a11c-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="7a11c-124">Erstellen Sie ein Ereignis für manuelles Zurücksetzen, indem <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> beim Erstellen der <xref:System.Threading.EventWaitHandle> Objekt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="7a11c-125">Wie der Name schon sagt, wird dieses Synchronisierungsereignis muss manuell zurückgesetzt werden, nachdem es signalisiert worden ist.</span><span class="sxs-lookup"><span data-stu-id="7a11c-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="7a11c-126">Bis zum Zurücksetzen, durch Aufrufen seiner <xref:System.Threading.EventWaitHandle.Reset%2A> -Methode, Threads, die auf das Ereignis-Handle zu warten fortsetzen sofort ohne zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="7a11c-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="7a11c-127">Ein manuelles Zurücksetzen Ereignis verhält sich wie das Gate eines Tiergeheges.</span><span class="sxs-lookup"><span data-stu-id="7a11c-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="7a11c-128">Wenn das Ereignis signalisiert wird, Threads, die darauf warten zu blockieren, z. B. Pferde Geheges.</span><span class="sxs-lookup"><span data-stu-id="7a11c-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="7a11c-129">Wenn das Ereignis signalisiert wurde, durch Aufrufen seiner <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, alle wartenden Threads sind frei, um den Vorgang fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="7a11c-130">Das Ereignis bleibt signalisiert, bis seine <xref:System.Threading.EventWaitHandle.Reset%2A> -Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="7a11c-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="7a11c-131">Dadurch wird dem Zurücksetzungsereignis für manuelles auf eine ideale Möglichkeit, um Threads zu speichern, die müssen warten, bis ein Thread eine Aufgabe abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="7a11c-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="7a11c-132">Wie Pferde Tiergeheges verlassen dauert es Zeit für die freigegebene Threads, die vom Betriebssystem geplant werden und die Ausführung fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="7a11c-133">Wenn die <xref:System.Threading.EventWaitHandle.Reset%2A> Methode wird aufgerufen, bevor alle Threads, die verbleibenden Threads wieder zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="7a11c-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="7a11c-134">Welche Threads wieder und welche Threads blockieren hängt zufällige Faktoren wie die Last auf dem System, die Anzahl der Threads wartet für den Planer und So weiter.</span><span class="sxs-lookup"><span data-stu-id="7a11c-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="7a11c-135">Dies ist kein Problem, wenn der Thread, der das Ereignis signalisiert endet, nachdem hat, also die gängigsten Verwendungsmuster.</span><span class="sxs-lookup"><span data-stu-id="7a11c-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="7a11c-136">Gegebenenfalls den Thread, der dem Ereignis, um eine neue Aufgabe beginnen, nachdem alle Waiting signalisiert Threads wieder ausgeführt, müssen Sie sie blockieren, bis alle wartenden Threads wieder aufgenommen haben.</span><span class="sxs-lookup"><span data-stu-id="7a11c-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="7a11c-137">Andernfalls stehen Ihnen eine Racebedingung, und das Verhalten des Codes ist unvorhersehbar.</span><span class="sxs-lookup"><span data-stu-id="7a11c-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="7a11c-138">Funktionen, die automatische und manuelle Ereignisse gemeinsam sind</span><span class="sxs-lookup"><span data-stu-id="7a11c-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="7a11c-139">In der Regel eine oder mehrere Threads blockiert ein <xref:System.Threading.EventWaitHandle> erst ein Blockierung Thread aufruft, die <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, die einem der wartenden Threads (im Fall von Ereignissen für automatisches Zurücksetzen) oder alle von ihnen frei (im Fall von manuell zurücksetzen Ereignisse).</span><span class="sxs-lookup"><span data-stu-id="7a11c-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="7a11c-140">Ein Thread kann darauf hinweisen ein <xref:System.Threading.EventWaitHandle> und dann blockieren, die davon einer atomaren Operation durch Aufrufen der statischen <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="7a11c-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="7a11c-141"><xref:System.Threading.EventWaitHandle>Objekte können verwendet werden, mit der statischen <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> und <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="7a11c-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="7a11c-142">Da die <xref:System.Threading.EventWaitHandle> und <xref:System.Threading.Mutex> beide Klassen ableiten <xref:System.Threading.WaitHandle>, können Sie beide Klassen mit diesen Methoden.</span><span class="sxs-lookup"><span data-stu-id="7a11c-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="7a11c-143">Benannte Ereignisse</span><span class="sxs-lookup"><span data-stu-id="7a11c-143">Named Events</span></span>  
 <span data-ttu-id="7a11c-144">Windows-Betriebssystem ermöglicht, Ereignis-Wait-Handles zu Namen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="7a11c-145">Ein benanntes Ereignis ist systemweit sichtbar.</span><span class="sxs-lookup"><span data-stu-id="7a11c-145">A named event is system wide.</span></span> <span data-ttu-id="7a11c-146">D. h., sobald das benannte Ereignis erstellt wurde, ist es für alle Threads in allen Prozessen sichtbar.</span><span class="sxs-lookup"><span data-stu-id="7a11c-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="7a11c-147">Daher können benannte Ereignisse zum Synchronisieren der Aktivitäten von Prozessen und Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="7a11c-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="7a11c-148">Sie erstellen ein <xref:System.Threading.EventWaitHandle> Objekt, das ein benanntes Systemereignis darstellt, mit einer der Konstruktoren, die den Namen eines Ereignisses angibt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7a11c-149">Da benannte Ereignisse systemweit sichtbar sind, ist es möglich, mehrere <xref:System.Threading.EventWaitHandle> benannte Ereignis Objekte, die die gleiche darstellen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="7a11c-150">Bei jedem eines Konstruktors Aufruf oder der <xref:System.Threading.EventWaitHandle.OpenExisting%2A> -Methode, wird ein neuer <xref:System.Threading.EventWaitHandle> Objekt erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="7a11c-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="7a11c-151">Wiederholt den gleichen Namen angeben, erstellt mehrere Objekte, die dasselbe benannte Ereignis darstellen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="7a11c-152">Vorsicht wird empfohlen, in die Verwendung von benannten Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="7a11c-152">Caution is advised in using named events.</span></span> <span data-ttu-id="7a11c-153">Da sie systemweit sichtbar sind, kann ein anderer Prozess, der den gleichen Namen verwendet unerwartet Ihre Threads blockiert.</span><span class="sxs-lookup"><span data-stu-id="7a11c-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="7a11c-154">Böswilliger Code, der auf demselben Computer ausgeführt wird, könnte dies als Grundlage für einen Denial-of-Service-Angriff verwenden.</span><span class="sxs-lookup"><span data-stu-id="7a11c-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="7a11c-155">Verwenden Sie die zugriffssteuerungssicherheit zum Schutz einer <xref:System.Threading.EventWaitHandle> Objekt, das ein benanntes Ereignis vorzugsweise darstellt, über einen Konstruktor, der angibt, ein <xref:System.Security.AccessControl.EventWaitHandleSecurity> Objekt.</span><span class="sxs-lookup"><span data-stu-id="7a11c-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="7a11c-156">Sie können auch anwenden, mittels der Sicherheit der <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> -Methode, aber dies bleibt so ein verwundbarkeitszeitfenster zwischen der Erstellung der Ereignis-Wait-Handle und die Zeit, die sie geschützt ist.</span><span class="sxs-lookup"><span data-stu-id="7a11c-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="7a11c-157">Schützen von Ereignissen mit der Zugriffssteuerung Sicherheit schützt böswillige Angriffe zu verhindern, aber dieser Mechanismus löst nicht des Problems unbeabsichtigter Namenskonflikte.</span><span class="sxs-lookup"><span data-stu-id="7a11c-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7a11c-158">Im Gegensatz zu den <xref:System.Threading.EventWaitHandle> -Klasse, die abgeleiteten Klassen <xref:System.Threading.AutoResetEvent> und <xref:System.Threading.ManualResetEvent> kann darstellen, die nur lokale wait-Handles.</span><span class="sxs-lookup"><span data-stu-id="7a11c-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="7a11c-159">Sie können keine benanntes Systemereignisse darstellen.</span><span class="sxs-lookup"><span data-stu-id="7a11c-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7a11c-160">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="7a11c-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="7a11c-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="7a11c-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
