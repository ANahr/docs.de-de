---
title: Häufig verwendete Webanwendungsarchitekturen
description: Entwerfen moderner Webanwendungen mit ASP.NET Core und Microsoft Azure | Häufig verwendete Webanwendungsarchitekturen
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: dc5580d38ac29a5e923a4b7d84f9d7e077d5cdb2
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/23/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="ac789-103">Häufig verwendete Webanwendungsarchitekturen</span><span class="sxs-lookup"><span data-stu-id="ac789-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="ac789-104">„Wenn Sie denken, dass eine gute Architektur viel Geld kostet, dann haben Sie noch nicht mit einer schlechten gearbeitet.“</span><span class="sxs-lookup"><span data-stu-id="ac789-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="ac789-105">_– Brian Foote und Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="ac789-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="ac789-106">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="ac789-106">Summary</span></span>

<span data-ttu-id="ac789-107">Die meisten herkömmlichen .NET-Anwendungen werden als einzelne Einheiten bereitgestellt, die einer ausführbaren Datei oder einer Webanwendung entsprechen, die innerhalb einer IIS-Anwendungsdomäne ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ac789-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="ac789-108">Dabei handelt es sich um das wohl einfachste Bereitstellungsmodell, das sich gut für interne und kleinere öffentliche Anwendungen eignet.</span><span class="sxs-lookup"><span data-stu-id="ac789-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="ac789-109">Allerdings eignet sich für die meisten wichtigen Geschäftsanwendungen sogar mit dieser einzelnen Bereitstellungseinheit die logische Unterteilung in mehrere Schichten.</span><span class="sxs-lookup"><span data-stu-id="ac789-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="ac789-110">Was sind monolithische Anwendungen?</span><span class="sxs-lookup"><span data-stu-id="ac789-110">What is a monolithic application?</span></span>

<span data-ttu-id="ac789-111">Monolithische Anwendungen sind in Bezug auf ihr Verhalten vollkommen unabhängig.</span><span class="sxs-lookup"><span data-stu-id="ac789-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="ac789-112">Sie interagieren zwar möglichweise mit anderen Diensten oder Datenspeichern, während sie Vorgänge ausführen, aber der Hauptbestandteil ihres Verhaltens liegt in ihren eigenen Prozessen, und die gesamte Anwendung wird in der Regel als einzelne Einheit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ac789-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="ac789-113">Wenn eine solche Anwendung eine horizontale Skalierung vornehmen muss, wird in der Regel die gesamte Anwendung auf mehreren Servern oder virtuellen Computern dupliziert.</span><span class="sxs-lookup"><span data-stu-id="ac789-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="ac789-114">All-in-One-Anwendungen</span><span class="sxs-lookup"><span data-stu-id="ac789-114">All-in-One applications</span></span>

<span data-ttu-id="ac789-115">Jede Anwendungsarchitektur muss mindestens ein Projekt umfassen.</span><span class="sxs-lookup"><span data-stu-id="ac789-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="ac789-116">In dieser Architektur ist die gesamte Logik der Anwendung in nur einem Projekt enthalten. Außerdem wird sie in nur eine Assembly kompiliert und als einzelne Einheit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ac789-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="ac789-117">Wenn ein neues ASP.NET Core-Projekt erstellt wird, stellt dieses anfangs immer einen All-in-One-Monolith dar. Dabei macht es keinen Unterschied, ob es über Visual Studio oder die Befehlszeile erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="ac789-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="ac789-118">Dieser Monolith enthält das gesamte Verhalten der Anwendung, einschließlich der Darstellungs-, Geschäfts- und Datenzugriffslogik.</span><span class="sxs-lookup"><span data-stu-id="ac789-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="ac789-119">In Abbildung 5-1 wird die Dateistruktur einer App dargestellt, die aus einem Projekt besteht.</span><span class="sxs-lookup"><span data-stu-id="ac789-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="ac789-120">**Abbildung 5-1.**</span><span class="sxs-lookup"><span data-stu-id="ac789-120">**Figure 5-1.**</span></span> <span data-ttu-id="ac789-121">Eine ASP.NET Core-App, die nur aus einem Projekt besteht</span><span class="sxs-lookup"><span data-stu-id="ac789-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="ac789-122">Wenn eine App nur aus einem Projekt besteht, wird das Prinzip „Separation of Concerns“ durch die Verwendung von Ordnern unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ac789-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="ac789-123">Die Standardvorlage enthält separate Ordner für Verantwortlichkeiten von MVC-Mustern für Modelle, Ansichten und Controller sowie zusätzliche Ordner für Daten und Dienste.</span><span class="sxs-lookup"><span data-stu-id="ac789-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="ac789-124">Wenn Sie diese Vorlage verwenden, sollten Darstellunsgdetails weitestgehend auf den Ansichtenordner (Views) beschränkt sein, und Implementierungsdetails zum Datenzugriff sollten auf Klassen beschränkt sein, die im Datenordner (Data) gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="ac789-125">Die Geschäftslogik sollte in Diensten und Klassen gespeichert sein, die im Modellordner (Models) enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="ac789-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="ac789-126">Diese monolithische Projektmappe, die aus nur einem Projekt besteht, ist zwar sehr einfach strukturiert, weist aber auch einige Nachteile auf.</span><span class="sxs-lookup"><span data-stu-id="ac789-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="ac789-127">Wenn der Umfang des Projekts ausgeweitet wird, entstehen auch immer mehr Dateien und Ordner.</span><span class="sxs-lookup"><span data-stu-id="ac789-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="ac789-128">Elemente, die die Benutzeroberfläche betreffen (z.B. Modelle, Ansichten und Controller), sind in unterschiedlichen Ordnern gespeichert, die nicht gemeinsam in alphabetischer Reihenfolge sortiert sind.</span><span class="sxs-lookup"><span data-stu-id="ac789-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="ac789-129">Dieses Problem wird noch größer, wenn zusätzliche Konstrukte auf Benutzeroberflächenebene wie Filter oder ModelBinders-Elemente zu ihren jeweiligen Ordnern hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="ac789-130">Die Geschäftslogik ist auf die Modell- und Dienstordner (Models und Services) aufgeteilt, und es gibt keinen Anhaltspunkt dafür, welche Klassen in welchen Ordnern von welchen anderen Elementen abhängig sein sollen.</span><span class="sxs-lookup"><span data-stu-id="ac789-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="ac789-131">Dadurch, dass auf Projektebene keine Sortierung vorgenommen wird, wird der Code häufig unübersichtlich, und es entsteht sogenannter [Spaghetticode](http://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="ac789-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="ac789-132">Um diese Probleme zu umgehen, greifen Entwickler häufig auf die Möglichkeit zurück, Anwendungen in Projektmappen mit mehreren Projekten auszuweiten. In diesen Projektmappen ist dann jedes Projekt auf einer bestimmten *Schicht* einer Anwendung gespeichert.</span><span class="sxs-lookup"><span data-stu-id="ac789-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="ac789-133">Was sind Schichten?</span><span class="sxs-lookup"><span data-stu-id="ac789-133">What are layers?</span></span>

<span data-ttu-id="ac789-134">Wenn eine Anwendung immer komplexer wird, können Sie dagegen vorgehen, indem Sie sie anhand ihrer Zuständigkeiten und Aufgaben aufteilen.</span><span class="sxs-lookup"><span data-stu-id="ac789-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="ac789-135">Dieses Prinzip wird als „Separation of Concerns“ (Trennung von Belangen“ bezeichnet und hilft Ihnen dabei, die Codebasis zu ordnen, damit Sie problemlos feststellen können, an welcher Stelle bestimmte Funktionen implementiert wurden.</span><span class="sxs-lookup"><span data-stu-id="ac789-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="ac789-136">Die Strukturierung Ihres Codes ist aber nicht der einzige Vorteil einer aus Schichten bestehenden Architektur.</span><span class="sxs-lookup"><span data-stu-id="ac789-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="ac789-137">Wenn Sie Code in Schichten unterteilen, können häufig verwendete grundlegende Funktionen in der gesamten Anwendung wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="ac789-138">Dies hat den Vorteil, dass Sie weniger Code schreiben müssen und die Anwendung für eine Implementierung standardisiert wird, was dem Don‘t Repeat Yourself-Prinzip entspricht.</span><span class="sxs-lookup"><span data-stu-id="ac789-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="ac789-139">Wenn eine Architektur aus Schichten besteht, können Anwendungen Einschränkungen für die Kommunikation zwischen den einzelnen Schichten erzwingen.</span><span class="sxs-lookup"><span data-stu-id="ac789-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="ac789-140">Dies erleichtert die Kapselung.</span><span class="sxs-lookup"><span data-stu-id="ac789-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="ac789-141">Wenn eine Schicht geändert oder ersetzt wird, sollten nur die Schichten betroffen sein, die mit dieser zusammenarbeiten.</span><span class="sxs-lookup"><span data-stu-id="ac789-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="ac789-142">Wenn Sie einschränken, welche Schichten voneinander abhängig sind, können die Auswirkungen von Änderungen verringert werden, sodass eine einzige Änderung nicht die gesamte Anwendung betrifft.</span><span class="sxs-lookup"><span data-stu-id="ac789-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="ac789-143">Schichten (und die Kapselung) vereinfachen das Ersetzen von Funktionen innerhalb der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="ac789-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="ac789-144">Möglicherweise verwendet z.B. eine Anwendung anfangs ihre eigene SQL Server-Datenbank als Persistenzspeicher. Sie können sich dann später aber immer noch dafür entscheiden, eine cloudbasierte Persistenzstrategie oder eine Web-API zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="ac789-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="ac789-145">Wenn die Anwendungen ihre Persistenzimplementierungen innerhalb einer logischen Schicht kapseln, kann diese SQL Server-spezifische Schicht durch eine neue Implementierung derselben öffentlichen Schnittstelle ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="ac789-146">Neben der Möglichkeit, Implementierungen auszutauschen, um möglichen zukünftigen Änderungen von Anforderungen vorzubeugen, können diese mithilfe von Anwendungsschichten auch zu Testzwecken ausgetauscht werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="ac789-147">Die Schichten können während der Tests durch falsche Implementierungen ersetzt werden, die bekannte Antworten auf Anforderungen bereitstellen, sodass Sie keine Tests mehr schreiben müssen, die mit der echten Daten- oder Benutzeroberflächenschicht der Anwendung arbeiten.</span><span class="sxs-lookup"><span data-stu-id="ac789-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="ac789-148">Dadurch können Tests einfacher geschrieben und im Vergleich zu Tests der echten Infrastruktur der Anwendung schneller ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="ac789-149">Das Erstellen logischer Schichten ist eine häufig verwendete Technik zum Verbessern der Strukturierung von Code in Unternehmensanwendungen. Es gibt mehrere Möglichkeiten, Code in Schichten zu strukturieren.</span><span class="sxs-lookup"><span data-stu-id="ac789-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="ac789-150">*Schichten* stellen eine logische Unterteilung aller Bestandteile einer App dar.</span><span class="sxs-lookup"><span data-stu-id="ac789-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="ac789-151">Wenn die Anwendungslogik physisch auf separate Server oder Prozesse verteilt wird, werden diese separaten Bereitstellunsgsziele als *Ebenen* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ac789-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="ac789-152">Die Verwendung einer Anwendung mit mehreren Schichten, die für eine einzelne Schicht bereitgestellt wird, ist möglich und wird häufig angewandt.</span><span class="sxs-lookup"><span data-stu-id="ac789-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="ac789-153">Traditionelle Architektur einer Anwendung mit mehreren Schichten</span><span class="sxs-lookup"><span data-stu-id="ac789-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="ac789-154">In Abbildung 5-2 wird die am häufigsten verwendete Unterteilung einer Anwendungslogik in Schichten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="ac789-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="ac789-155">**Abbildung 5-2.**</span><span class="sxs-lookup"><span data-stu-id="ac789-155">**Figure 5-2.**</span></span> <span data-ttu-id="ac789-156">Typische Anwendungsschichten</span><span class="sxs-lookup"><span data-stu-id="ac789-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="ac789-157">Diese Schichten werden häufig mit den englischen Abkürzungen UI für User Interface (Benutzeroberfläche), BLL für Business Logic Layer (Schicht der Geschäftslogik) und DAL für Data Access Layer (Schicht für den Datenzugriff) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ac789-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="ac789-158">Wenn diese Architektur verwendet wird, senden Benutzer Anforderungen über die Benutzeroberflächenschicht, die nur mit der BLL interagiert.</span><span class="sxs-lookup"><span data-stu-id="ac789-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="ac789-159">Die BLL kann wiederum die DAL für Anforderungen hinsichtlich des Datenzugriffs aufrufen.</span><span class="sxs-lookup"><span data-stu-id="ac789-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="ac789-160">Die UI-Schicht sollte keine direkten Anforderungen an die DAL senden oder direkt mithilfe anderer Methoden mit der Persistenz interagieren.</span><span class="sxs-lookup"><span data-stu-id="ac789-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="ac789-161">Gleichzeitig sollte die BLL nur über die DAL mit der Persistenz interagieren.</span><span class="sxs-lookup"><span data-stu-id="ac789-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="ac789-162">Auf diese Weise wird jeder Schicht eine individuelle bekannte Verantwortlichkeit zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="ac789-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="ac789-163">Dieser traditionelle Ansatz zum Erstellen von Schichten hat allerdings den Nachteil, dass Abhängigkeiten zur Kompilierzeit von oben nach unten ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="ac789-164">Das heißt, die UI-Schicht ist von der BLL abhängig, die wiederum von der DAL abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="ac789-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="ac789-165">Das wiederum bedeutet, dass die BLL, die in der Regel die wichtigste Logik innerhalb der Anwendung aufweist, von den Implementierungsdetails zum Datenzugriff abhängig ist (und dadurch häufig auch eine Datenbank benötigt).</span><span class="sxs-lookup"><span data-stu-id="ac789-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="ac789-166">Das Testen einer Geschäftslogik in einer Architektur wie dieser gestaltet sich häufig als schwierig und erfordert eine Testdatenbank.</span><span class="sxs-lookup"><span data-stu-id="ac789-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="ac789-167">Sie können dieses Problem wie im nächsten Abschnitt beschrieben mit dem Dependency Inversion-Prinzip angehen.</span><span class="sxs-lookup"><span data-stu-id="ac789-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="ac789-168">In Abbildung 5-3 wird eine Projektmappe als Beispiel dargestellt, in der die Anwendung anhand von Zuständigkeiten bzw. Schichten in drei Projekte unterteilt wird.</span><span class="sxs-lookup"><span data-stu-id="ac789-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="ac789-169">**Abbildung 5-3.**</span><span class="sxs-lookup"><span data-stu-id="ac789-169">**Figure 5-3.**</span></span> <span data-ttu-id="ac789-170">Eine einfache monolithische Anwendung mit drei Projekten</span><span class="sxs-lookup"><span data-stu-id="ac789-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="ac789-171">Obwohl diese Anwendung aus Strukturierungsgründen mehrere Projekte verwendet, wird sie als einzelne Einheit bereitgestellt und ihre Clients interagieren mit ihr wie mit einer einzelnen Web-App.</span><span class="sxs-lookup"><span data-stu-id="ac789-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="ac789-172">Dies vereinfacht die Bereitstellung.</span><span class="sxs-lookup"><span data-stu-id="ac789-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="ac789-173">In Abbildung 5-4 wird dargestellt, wie eine solche App unter Verwendung von Windows Azure gehostet werden kann.</span><span class="sxs-lookup"><span data-stu-id="ac789-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="ac789-174">**Abbildung 5-4.**</span><span class="sxs-lookup"><span data-stu-id="ac789-174">**Figure 5-4.**</span></span> <span data-ttu-id="ac789-175">Einfache Bereitstellung einer Azure-Web-App</span><span class="sxs-lookup"><span data-stu-id="ac789-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="ac789-176">Wenn die Anforderungen an eine App höher werden, ist möglicherweise eine komplexere und robustere Bereitstellungslösung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="ac789-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="ac789-177">In Abbildung 5-5 ist ein Beispiel einer komplexeren Bereitstellung dargestellt, die mehrere zusätzliche Funktionen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ac789-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="ac789-178">**Abbildung 5-5.**</span><span class="sxs-lookup"><span data-stu-id="ac789-178">**Figure 5-5.**</span></span> <span data-ttu-id="ac789-179">Bereitstellen einer Web-App in Azure App Service</span><span class="sxs-lookup"><span data-stu-id="ac789-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="ac789-180">Innerhalb der Anwendung verbessert diese Unterteilung in mehrere Projekte anhand von Zuständigkeiten deren Verwaltbarkeit.</span><span class="sxs-lookup"><span data-stu-id="ac789-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="ac789-181">Diese Einheit kann zentral oder horizontal hochskaliert werden, um die cloudbasierte bedarfsgesteuerte Skalierbarkeit zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="ac789-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="ac789-182">Beim zentralen Hochskalieren werden zusätzliche CPU, zusätzlicher Arbeitsspeicher, zusätzlicher Speicherplatz auf dem Datenträger oder andere Ressourcen zu dem Server bzw. den Servern hinzugefügt, der bzw. die Ihre App hosten.</span><span class="sxs-lookup"><span data-stu-id="ac789-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="ac789-183">Beim horizontalen Hochskalieren werden zusätzliche Instanzen der Server hinzugefügt. Dabei macht es keinen Unterschied, ob es sich um physische Server oder virtuelle Computer handelt.</span><span class="sxs-lookup"><span data-stu-id="ac789-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="ac789-184">Wenn Ihre App auf mehreren Instanzen gehostet wird, wird ein Lastenausgleich vorgenommen, um individuellen App-Instanzen Anforderungen zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="ac789-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="ac789-185">Der einfachste Ansatz zum Skalieren einer Webanwendung in Azure ist das manuelle Konfigurieren einer Skalierung im App Service-Plan der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="ac789-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="ac789-186">In Abbildung 5-6 wird die Anzeige des Azure-Dashboards dargestellt, über die Sie konfigurieren können, wie viele Instanzen einer App zugrunde liegen.</span><span class="sxs-lookup"><span data-stu-id="ac789-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="ac789-187">**Abbildung 5-6.**</span><span class="sxs-lookup"><span data-stu-id="ac789-187">**Figure 5-6.**</span></span> <span data-ttu-id="ac789-188">Skalieren des App Service-Plans in Azure</span><span class="sxs-lookup"><span data-stu-id="ac789-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="ac789-189">Clean Architecture</span><span class="sxs-lookup"><span data-stu-id="ac789-189">Clean architecture</span></span>

<span data-ttu-id="ac789-190">Anwendungen, die den Prinzipien Dependency Inversion und Domain-Driven Design (DDD) folgen, weisen alle eine ähnliche Architektur auf.</span><span class="sxs-lookup"><span data-stu-id="ac789-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="ac789-191">Diese Architektur wurde in den vergangenen Jahren unterschiedlich benannt.</span><span class="sxs-lookup"><span data-stu-id="ac789-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="ac789-192">Zuerst wurde diese Architektur als „Hexagonal Architecture“ bezeichnet. Darauf folgte der Begriff „Ports-and-Adapters“.</span><span class="sxs-lookup"><span data-stu-id="ac789-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="ac789-193">Heutzutage spricht man aber eher von [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) bzw. [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="ac789-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="ac789-194">In diesem E-Book wird der Begriff „Clean Architecture“ als Grundlage zum Beschreiben dieser Architektur verwendet.</span><span class="sxs-lookup"><span data-stu-id="ac789-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="ac789-195">Die Clean Architecture kann sowohl für Anwendungen erstellt werden, die dem DDD-Prinzip folgen, als auch für Anwendungen, die diesem nicht entsprechen.</span><span class="sxs-lookup"><span data-stu-id="ac789-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="ac789-196">Wenn das DDD-Prinzip angewendet wird, kann die Architektur als „Clean DDD Architecture“ bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="ac789-197">In der Clean Architecture sind die Geschäftslogik und das Anwendungsmodell im Kern der Anwendung enthalten.</span><span class="sxs-lookup"><span data-stu-id="ac789-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="ac789-198">Es wird dann das Prinzip Dependency Inversion angewendet, bei dem die Geschäftslogik nicht mehr vom Datenzugriff oder anderen Aufgaben, die die Infrastruktur betreffen, abhängig ist. Stattdessen sind die Informationen zur Infrastruktur und Implementierung vom Anwendungskern abhängig.</span><span class="sxs-lookup"><span data-stu-id="ac789-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="ac789-199">Dafür werden Abstraktionen oder Schnittstellen im Anwendungskern definiert und anschließend anhand von Typen implementiert, die in der Infrastrukturschicht definiert werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="ac789-200">Diese Architektur wird häufig in Kreisringen dargestellt, die dem Aufbau einer Zwiebel ähneln.</span><span class="sxs-lookup"><span data-stu-id="ac789-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="ac789-201">In Abbildung 5-X wird ein Beispiel dargestellt, mit dem die Architektur dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="ac789-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="ac789-202">**Abbildung 5-7.**</span><span class="sxs-lookup"><span data-stu-id="ac789-202">**Figure 5-7.**</span></span> <span data-ttu-id="ac789-203">Clean Architecture: „Zwiebelansicht“</span><span class="sxs-lookup"><span data-stu-id="ac789-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="ac789-204">In diesem Diagramm beziehen sich alle Abhängigkeiten auf den inneren Kreisring, also auf den Anwendungskern.</span><span class="sxs-lookup"><span data-stu-id="ac789-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="ac789-205">Der Anwendungskern verfügt also nicht über Abhängigkeiten von anderen Anwendungsschichten.</span><span class="sxs-lookup"><span data-stu-id="ac789-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="ac789-206">Die Entitäten und Schnittstellen der Anwendung stehen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="ac789-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="ac789-207">Domänendienste, die in der Regel Schnittstellen implementieren, die im inneren Kreisring definiert sind, befinden sich am äußeren Rand des Anwendungskerns.</span><span class="sxs-lookup"><span data-stu-id="ac789-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="ac789-208">Außerhalb des Anwendungskerns sind sowohl die Benutzeroberfläche als auch die Infrastrukturschichten zwar vom Anwendungskern, aber nicht (unbedingt) voneinander abhängig.</span><span class="sxs-lookup"><span data-stu-id="ac789-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="ac789-209">In Abbildung 5-X wird ein herkömmlicheres horizontales Schichtendiagramm dargestellt, das die Abhängigkeit zwischen Benutzeroberfläche und anderen Schichten besser darstellt.</span><span class="sxs-lookup"><span data-stu-id="ac789-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="ac789-210">**Abbildung 5-8.**</span><span class="sxs-lookup"><span data-stu-id="ac789-210">**Figure 5-8.**</span></span> <span data-ttu-id="ac789-211">Clean Architecture: Ansicht mit horizontalen Schichten</span><span class="sxs-lookup"><span data-stu-id="ac789-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="ac789-212">Beachten Sie, dass die Pfeile mit durchgezogener Linie Abhängigkeiten zur Kompilierzeit darstellen. Die Pfeile mit gestrichelten Linien stellen Abhängigkeiten dar, die nur zur Laufzeit bestehen.</span><span class="sxs-lookup"><span data-stu-id="ac789-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="ac789-213">Unter Verwendung der Clean Architecture funktioniert die UI-Schicht nur mit Schnittstellen, die zur Kompilierzeit im Anwendungskern definiert werden. Im Idealfall sollten diese außerdem nicht über Informationen zu den in der Infrastrukturschicht definierten Implementierungstypen verfügen.</span><span class="sxs-lookup"><span data-stu-id="ac789-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="ac789-214">Zur Laufzeit sind diese Implementierungstypen jedoch erforderlich, damit die App ausgeführt werden kann. Daher müssen Sie definiert und über Dependency Injection mit den Schnittstellen des Anwendungskerns verbunden sein.</span><span class="sxs-lookup"><span data-stu-id="ac789-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="ac789-215">In Abbildung 5-9 wird eine detailliertere Ansicht der Architektur einer ASP.NET Core-Anwendung dargestellt, die anhand dieser Empfehlungen erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ac789-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASP.NET Core-Architektur](./media/image5-9.png)

<span data-ttu-id="ac789-217">**Abbildung 5-9.**</span><span class="sxs-lookup"><span data-stu-id="ac789-217">**Figure 5-9.**</span></span> <span data-ttu-id="ac789-218">Diagramm der ASP.NET Core-Architektur, die dem Prinzip der Clean Architecture folgt</span><span class="sxs-lookup"><span data-stu-id="ac789-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="ac789-219">Da der Anwendungskern nicht von der Infrastrukturschicht abhängig ist, ist es leicht, automatisierte Komponententests für diese Schicht zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="ac789-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="ac789-220">In den Abbildungen 5-10 und 5-11 wird dargestellt, wie Tests mit dieser Architektur in Einklang gebracht werden können.</span><span class="sxs-lookup"><span data-stu-id="ac789-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="ac789-222">**Abbildung 5-10.**</span><span class="sxs-lookup"><span data-stu-id="ac789-222">**Figure 5-10.**</span></span> <span data-ttu-id="ac789-223">Isolierter Komponententest des Anwendungskerns</span><span class="sxs-lookup"><span data-stu-id="ac789-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="ac789-225">**Abbildung 5-11.**</span><span class="sxs-lookup"><span data-stu-id="ac789-225">**Figure 5-11.**</span></span> <span data-ttu-id="ac789-226">Integrationstest von Infrastrukturimplementierungen mit externen Abhängigkeiten</span><span class="sxs-lookup"><span data-stu-id="ac789-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="ac789-227">Da die UI-Schicht nicht über direkte Abhängigkeiten von im Infrastrukturprojekt definierten Typen verfügt, können Implementierungen leicht ausgetauscht werden. Dadurch kann das Testen vereinfacht werden, oder sich ändernde Anwendungsanforderungen lassen sich leichter umsetzen.</span><span class="sxs-lookup"><span data-stu-id="ac789-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="ac789-228">Durch die in ASP.NET Core integrierte Verwendung von und Unterstützung für Dependency Injection eignet sich diese Architektur besonders gut zum Strukturieren wichtiger monolithischer Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="ac789-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="ac789-229">Bei monolithischen Anwendungen werden Projekte für den Anwendungskern, die Infrastruktur und die Benutzeroberfläche als eine einzelne Anwendung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ac789-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="ac789-230">Die Anwendungsarchitektur zur Laufzeit sieht in etwa wie in Abbildung 5-12 dargestellt aus.</span><span class="sxs-lookup"><span data-stu-id="ac789-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core-Architektur 2](./media/image5-12.png)

<span data-ttu-id="ac789-232">**Abbildung 5-12.**</span><span class="sxs-lookup"><span data-stu-id="ac789-232">**Figure 5-12.**</span></span> <span data-ttu-id="ac789-233">Beispiel für die Laufzeitarchitektur einer ASP.NET Core-App</span><span class="sxs-lookup"><span data-stu-id="ac789-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="ac789-234">Strukturieren von Code anhand des Clean Architecture-Prinzips</span><span class="sxs-lookup"><span data-stu-id="ac789-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="ac789-235">In einer gemäß der Clean Architecture erstellten Projektmappe verfügt jedes Projekt über klare Zuständigkeiten.</span><span class="sxs-lookup"><span data-stu-id="ac789-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="ac789-236">Daher gehören zu jedem Projekt bestimmte Typen, und häufig entsprechen Ordner im jeweiligen Projekt diesen Typen.</span><span class="sxs-lookup"><span data-stu-id="ac789-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="ac789-237">Der Anwendungskern enthält das Geschäftsmodell, das wiederum Entitäten, Dienste und Schnittstellen umfasst.</span><span class="sxs-lookup"><span data-stu-id="ac789-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="ac789-238">Diese Schnittstellen umfassen Abstraktionen für Vorgänge, die unter Verwendung der Infrastruktur ausgeführt werden. Damit sind z.B. der Datenzugriff, der Zugriff auf Dateisysteme und Netzwerkaufrufe gemeint. Gelegentlich müssen für diese Schicht installierte Dienste und Schnittstellen mit Typen zusammenarbeiten, bei denen es sich nicht um Entitäten handelt und die nicht von der Benutzeroberfläche oder der Infrastruktur abhängig sind.</span><span class="sxs-lookup"><span data-stu-id="ac789-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="ac789-239">Diese Dienste und Schnittstellen können als einfache Datentransferobjekte (Data Transfer Objects, DTOs) definiert sein.</span><span class="sxs-lookup"><span data-stu-id="ac789-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="ac789-240">Typen des Anwendungskerns</span><span class="sxs-lookup"><span data-stu-id="ac789-240">Application Core Types</span></span>
> -   <span data-ttu-id="ac789-241">Entitäten (Klassen von Geschäftsmodellen, die dauerhaft gespeichert werden)</span><span class="sxs-lookup"><span data-stu-id="ac789-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="ac789-242">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="ac789-242">Interfaces</span></span>
> -   <span data-ttu-id="ac789-243">Dienste</span><span class="sxs-lookup"><span data-stu-id="ac789-243">Services</span></span>
> -   <span data-ttu-id="ac789-244">DTOs</span><span class="sxs-lookup"><span data-stu-id="ac789-244">DTOs</span></span>

<span data-ttu-id="ac789-245">Das Infrastrukturprojekt umfasst in der Regel Implementierungen für den Datenzugriff.</span><span class="sxs-lookup"><span data-stu-id="ac789-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="ac789-246">In einer herkömmlichen ASP.NET Core-Webanwendung umfasst dies die Entity Framework-DbContext-Klasse, jegliche EF Core-Migrationen, die definiert wurden, und Klassen für Implementierungen des Datenzugriffs.</span><span class="sxs-lookup"><span data-stu-id="ac789-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="ac789-247">Die beste Möglichkeit, Implementierungscode für den Datenzugriff zu implementieren, stellt das [Entwurfsmuster Repository](http://deviq.com/repository-pattern/) dar.</span><span class="sxs-lookup"><span data-stu-id="ac789-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="ac789-248">Das Infrastrukturprojekt sollte neben Implementierungen für den Datenzugriff Implementierungen von Diensten enthalten, die mit verschiedenen Bestandteilen der Infrastruktur interagieren.</span><span class="sxs-lookup"><span data-stu-id="ac789-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="ac789-249">Diese Dienste sollten im Anwendungskern definierte Schnittstellen implementierten. Daher sollte im Infrastrukturprojekt ein Verweis auf das Anwendungskernprojekt enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="ac789-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="ac789-250">Typen der Infrastruktur</span><span class="sxs-lookup"><span data-stu-id="ac789-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="ac789-251">EF Core-Typen (DbContext, Migrationen)</span><span class="sxs-lookup"><span data-stu-id="ac789-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="ac789-252">Implementierungstypen für den Datenzugriff (Repositorys)</span><span class="sxs-lookup"><span data-stu-id="ac789-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="ac789-253">Infrastrukturspezifische Dienste (FileLogger, SmtpNotifier etc.)</span><span class="sxs-lookup"><span data-stu-id="ac789-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="ac789-254">Die UI-Schicht in einer ASP.NET Core MVC-Anwendung stellt den Einstiegspunkt für die Anwendung dar und fungiert als ein ASP.NET Core MVC-Projekt.</span><span class="sxs-lookup"><span data-stu-id="ac789-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="ac789-255">Dieses Projekt sollte auf das Anwendungskernprojekt verweisen, und dessen Typen sollten ausschließlich über im Anwendungskern definierte Schnittstellen mit der Infrastruktur interagieren.</span><span class="sxs-lookup"><span data-stu-id="ac789-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="ac789-256">In der UI-Schicht sollten keine direkte Instanziierung oder statische Aufrufe von Typen von Infrastrukturschichten zugelassen werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="ac789-257">Typen der UI-Schicht</span><span class="sxs-lookup"><span data-stu-id="ac789-257">UI Layer Types</span></span>
> -   <span data-ttu-id="ac789-258">Controller</span><span class="sxs-lookup"><span data-stu-id="ac789-258">Controllers</span></span>
> -   <span data-ttu-id="ac789-259">Filter</span><span class="sxs-lookup"><span data-stu-id="ac789-259">Filters</span></span>
> -   <span data-ttu-id="ac789-260">Ansichten</span><span class="sxs-lookup"><span data-stu-id="ac789-260">Views</span></span>
> -   <span data-ttu-id="ac789-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="ac789-261">ViewModels</span></span>
> -   <span data-ttu-id="ac789-262">Startup</span><span class="sxs-lookup"><span data-stu-id="ac789-262">Startup</span></span>

<span data-ttu-id="ac789-263">Die Startup-Klasse ist für das Konfigurieren von Anwendungen und für das Verknüpfen von Implementierungstypen mit Schnittstellen zuständig. Dadurch kann zur Laufzeit erfolgreich Dependency Injection angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="ac789-264">Wenn Sie Dependency Injection in ConfigureServices in der Startup.cs-Datei des UI-Projekts durchführen möchten, muss das Projekt möglicherweise auf das Infrastrukturprojekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="ac789-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="ac789-265">Diese Abhängigkeit kann problemlos mithilfe eines benutzerdefinierten Dependency Injection-Containers entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="ac789-266">Im Hinblick auf das hier aufgeführte Beispiel ist es die einfachste Lösung, wenn Sie zulassen, dass das UI-Projekt auf das Infrastrukturprojekt verweist.</span><span class="sxs-lookup"><span data-stu-id="ac789-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="ac789-267">Monolithische Anwendungen und Container</span><span class="sxs-lookup"><span data-stu-id="ac789-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="ac789-268">Sie können eine einzelne, monolithisch bereitgestellte Webanwendung oder einen Webdienst erstellen und als Container bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="ac789-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="ac789-269">Die Anwendung ist in ihrem Inneren möglicherweise nicht monolithisch strukturiert, sondern in mehrere Bibliotheken, Komponenten oder Schichten unterteilt.</span><span class="sxs-lookup"><span data-stu-id="ac789-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="ac789-270">Extern ist sie ein einzelner Container – z.B. ein einzelner Prozess, eine einzelne Webanwendung oder ein einzelner Dienst.</span><span class="sxs-lookup"><span data-stu-id="ac789-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="ac789-271">Stellen Sie einen einzelnen Container bereit, der diese Anwendung darstellt, um dieses Modell zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="ac789-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="ac789-272">Fügen Sie zum Skalieren einfach weitere Kopien mit einem vorangestellten Lastenausgleich hinzu.</span><span class="sxs-lookup"><span data-stu-id="ac789-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="ac789-273">Die Einfachheit stammt aus der Verwaltung einer einzelnen Bereitstellung in einem einzelnen Container oder virtuellen Computer.</span><span class="sxs-lookup"><span data-stu-id="ac789-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="ac789-274">Sie können, wie in Abbildung 5-X veranschaulicht, mehrere Komponenten, Bibliotheken oder interne Schichten in jeden Container einschließen.</span><span class="sxs-lookup"><span data-stu-id="ac789-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="ac789-275">Allerdings kann dieses monolithische Muster zu einem Konflikt mit dem Containerprinzip *Jeder Container hat nur eine Aufgabe, die er in einem Prozess ausführt* führen.</span><span class="sxs-lookup"><span data-stu-id="ac789-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="ac789-276">Der Nachteil dieses Ansatzes wird offensichtlich, wenn die Anwendung wächst und skaliert werden muss.</span><span class="sxs-lookup"><span data-stu-id="ac789-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="ac789-277">Wenn die gesamte Anwendung skaliert werden kann, ist dies kein Problem.</span><span class="sxs-lookup"><span data-stu-id="ac789-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="ac789-278">In den meisten Fällen stellen jedoch nur einige Teile der Anwendung Engpässe dar, die eine Skalierung erfordern, während andere Komponente weniger häufig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="ac789-279">Wenn Sie das gewöhnliche eCommerce-Beispiel verwenden, müssen Sie sehr wahrscheinlich die Komponente für die Produktinformationen skalieren.</span><span class="sxs-lookup"><span data-stu-id="ac789-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="ac789-280">Viele Kunden suchen Produkte erst und kaufen sie anschließend.</span><span class="sxs-lookup"><span data-stu-id="ac789-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="ac789-281">Mehr Kunden verwenden Ihren Warenkorb als die Zahlungspipeline.</span><span class="sxs-lookup"><span data-stu-id="ac789-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="ac789-282">Weniger Kunden fügen Kommentare hinzu oder zeigen ihren Bestellungsverlauf an.</span><span class="sxs-lookup"><span data-stu-id="ac789-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="ac789-283">Und Sie haben möglicherweise nur eine Handvoll Mitarbeiter in einer bestimmten Region, die den Inhalt und die Marketingkampagnen verwalten müssen.</span><span class="sxs-lookup"><span data-stu-id="ac789-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="ac789-284">Wenn der monolithische Entwurf skaliert wird, wird der gesamte Code mehrmals bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ac789-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="ac789-285">Zusätzlich zu dem Problem, dass alle Komponenten skaliert werden müssen, erfordern Änderungen einer einzelnen Komponente einen erneuten Test der gesamten Anwendung und eine vollständige erneute Bereitstellung aller Instanzen.</span><span class="sxs-lookup"><span data-stu-id="ac789-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="ac789-286">Der monolithische Ansatz wird häufig verwendet, und viele Organisationen arbeiten mit dieser Architektur.</span><span class="sxs-lookup"><span data-stu-id="ac789-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="ac789-287">Viele von ihnen erzielen damit akzeptable Ergebnisse, aber andere stoßen an ihre Grenzen.</span><span class="sxs-lookup"><span data-stu-id="ac789-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="ac789-288">Viele Unternehmen haben ihre Anwendungen unter Verwendung dieses Modells entworfen, da Tools und Infrastruktur schon seit Jahren zu komplex für die Erstellung einer dienstorientierten Architektur (SOA) sind. Sie haben die Notwendigkeit nicht erkannt, etwas zu ändern — bis die Anwendung gewachsen ist.</span><span class="sxs-lookup"><span data-stu-id="ac789-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="ac789-289">Wenn Sie an die Grenzen des monolithischen Ansatzes stoßen, ist der nächste logische Schritt das Aufteilen der App, damit diese Container und Microservices besser nutzen kann.</span><span class="sxs-lookup"><span data-stu-id="ac789-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="ac789-290">Monolithische Anwendungen in Microsoft Azure können mithilfe von dedizierten VMs für jede Instanz bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="ac789-291">Sie können die VMs problemlos skalieren, wenn Sie [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) verwenden.</span><span class="sxs-lookup"><span data-stu-id="ac789-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="ac789-292">[Azure App Service](https://azure.microsoft.com/services/app-service/) kann auch monolithische Anwendungen ausführen und Instanzen problemlos skalieren, ohne dass die VMs verwaltet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="ac789-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="ac789-293">Azure App Services kann ebenfalls einzelne Instanzen von Docker-Containern ausführen, was die Bereitstellung vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="ac789-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="ac789-294">Wenn Sie Docker verwenden, können Sie eine einzelne VM als Docker-Host bereitstellen und mehrere Instanzen ausführen.</span><span class="sxs-lookup"><span data-stu-id="ac789-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="ac789-295">Wenn Sie wie in Abbildung 5-14 dargestellt den Azure Balancer verwenden, können Sie die Skalierung verwalten.</span><span class="sxs-lookup"><span data-stu-id="ac789-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="ac789-296">Die Bereitstellung auf den verschiedenen Hosts kann mit herkömmlichen Bereitstellungsverfahren verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="ac789-297">Docker-Hosts können manuell mit Befehlen wie **docker run** oder durch Automatisierung, z.B. Pipelines für Continuous Delivery (CD), verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="ac789-298">Monolithische Anwendung, die als Container bereitgestellt wird</span><span class="sxs-lookup"><span data-stu-id="ac789-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="ac789-299">Das Verwenden von Containern zur Verwaltung monolithischer Anwendungsbereitstellungen hat einige Vorteile.</span><span class="sxs-lookup"><span data-stu-id="ac789-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="ac789-300">Das Skalieren von Containerinstanzen ist wesentlich schneller und einfacher als die Bereitstellung zusätzlicher VMs.</span><span class="sxs-lookup"><span data-stu-id="ac789-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="ac789-301">Auch wenn VM Scale Sets verwendet wird, um VMs zu skalieren, nimmt deren Instanziierung viel Zeit in Anspruch.</span><span class="sxs-lookup"><span data-stu-id="ac789-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="ac789-302">Wenn die App-Konfiguration als App-Instanz bereitgestellt wird, wird diese als Teil der VM verwaltet.</span><span class="sxs-lookup"><span data-stu-id="ac789-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="ac789-303">Die Bereitstellung von Updates, wie Docker-Images, ist wesentlich schneller und effizienter im Netzwerk.</span><span class="sxs-lookup"><span data-stu-id="ac789-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="ac789-304">Docker-Images starten in der Regel in Sekunden, wodurch Rollouts beschleunigt werden.</span><span class="sxs-lookup"><span data-stu-id="ac789-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="ac789-305">Das Löschen einer Docker-Instanz ist genauso einfach wie das Ausführen eines **docker stop**-Befehls und in der Regel in weniger als einer Sekunde abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="ac789-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="ac789-306">Da Container unveränderlich sind, müssen Sie sich keine Gedanken über beschädigte VMs machen. Es kann allerdings vorkommen, das Updateskripts bestimmte Konfigurationen oder restliche Dateien auf einem Datenträger erfassen.</span><span class="sxs-lookup"><span data-stu-id="ac789-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="ac789-307">Docker kann sich im Hinblick auf monolithische Apps zwar als sinnvoll erweisen. Wenn aber die monolithische Anwendung in Subsysteme unterteilt wird, die skaliert, entwickelt und einzeln bereitgestellt werden können, lohnt es sich möglicherweise, wenn Sie sich mit Microservices vertraut machen.</span><span class="sxs-lookup"><span data-stu-id="ac789-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="ac789-308">Ressourcen: Häufig verwendete Webarchitekturen</span><span class="sxs-lookup"><span data-stu-id="ac789-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="ac789-309">**Clean Architecture**</span><span class="sxs-lookup"><span data-stu-id="ac789-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="ac789-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span><span class="sxs-lookup"><span data-stu-id="ac789-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="ac789-311">**Onion Architecture**</span><span class="sxs-lookup"><span data-stu-id="ac789-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="ac789-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span><span class="sxs-lookup"><span data-stu-id="ac789-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="ac789-313">**The Repository Pattern (Das Muster „Repository“)**</span><span class="sxs-lookup"><span data-stu-id="ac789-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="ac789-314"><http://deviq.com/repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="ac789-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="ac789-315">**Clean Architecture Solution Sample (Projektmappenbeispiel unter Verwendung von Clean Architecture)**</span><span class="sxs-lookup"><span data-stu-id="ac789-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="ac789-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="ac789-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="ac789-317">**E-Book zum Entwerfen von Microservices** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="ac789-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="ac789-318">[Zurück] (architectural-principles.md) [Weiter] (common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="ac789-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
