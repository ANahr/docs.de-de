---
title: 'Gewusst wie: Überprüfen, ob Zeichenfolgen ein gültiges E-Mail-Format aufweisen'
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, examples
- user input, examples
- Regex.IsMatch method
- regular expressions [.NET Framework], examples
- examples [Visual Basic], strings
- IsValidEmail
- validation, email strings
- input, checking
- strings [.NET Framework], examples [Visual Basic]
- email [.NET Framework], validating
- IsMatch method
ms.assetid: 7536af08-4e86-4953-98a1-a8298623df92
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 02c942dea3314581ce8f758bb9ed3ce88c2fe150
ms.sourcegitcommit: 89c93d05c2281b4c834f48f6c8df1047e1410980
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/15/2018
ms.locfileid: "34172329"
---
# <a name="how-to-verify-that-strings-are-in-valid-email-format"></a><span data-ttu-id="d2003-102">Gewusst wie: Überprüfen, ob Zeichenfolgen ein gültiges E-Mail-Format aufweisen</span><span class="sxs-lookup"><span data-stu-id="d2003-102">How to: Verify that Strings Are in Valid Email Format</span></span>
<span data-ttu-id="d2003-103">Im folgenden Beispiel wird mit einem regulären Ausdruck geprüft, ob eine Zeichenfolge ein gültiges E-Mail-Format aufweist.</span><span class="sxs-lookup"><span data-stu-id="d2003-103">The following example uses a regular expression to verify that a string is in valid email format.</span></span>  

> [!NOTE]
>  <span data-ttu-id="d2003-104">Es wird empfohlen, die <xref:System.Net.Mail.MailAddress?displayProperty=nameWithType>-Klasse zu verwenden, wenn die Zeichenfolge ein gültiges E-Mail-Adressformat aufweist.</span><span class="sxs-lookup"><span data-stu-id="d2003-104">We recommend using the <xref:System.Net.Mail.MailAddress?displayProperty=nameWithType> class to check if a string is in valid email address format.</span></span> <span data-ttu-id="d2003-105">Übergeben Sie hierzu die E-Mail-Adresszeichenfolge an den <xref:System.Net.Mail.MailAddress.%23ctor%28System.String%29?displayProperty=nameWithType>-Klassenkonstruktor. Dieser löst eine <xref:System.FormatException> aus, wenn die Zeichenfolge ein unbekanntes Format aufweist.</span><span class="sxs-lookup"><span data-stu-id="d2003-105">To do that, pass the email address string to the <xref:System.Net.Mail.MailAddress.%23ctor%28System.String%29?displayProperty=nameWithType> class constructor, which throws a <xref:System.FormatException> if the string has an unrecognized format.</span></span>  
  
## <a name="example"></a><span data-ttu-id="d2003-106">Beispiel</span><span class="sxs-lookup"><span data-stu-id="d2003-106">Example</span></span>  
 <span data-ttu-id="d2003-107">Im Beispiel wird eine `IsValidEmail` -Methode definiert, die `true` zurückgibt, wenn die Zeichenfolge eine gültige E-Mail-Adresse enthält und andernfalls `false` ; es wird jedoch keine andere Aktion ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d2003-107">The example defines an `IsValidEmail` method, which returns `true` if the string contains a valid email address and `false` if it does not, but takes no other action.</span></span>  
  
 <span data-ttu-id="d2003-108">Um die Gültigkeit der E-Mail-Adresse zu überprüfen ruft die `IsValidEmail`-Methode die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>-Methode mit dem regulären Ausdruck `(@)(.+)$` auf, um den Domänennamen von der E-Mail-Adresse zu trennen.</span><span class="sxs-lookup"><span data-stu-id="d2003-108">To verify that the email address is valid, the `IsValidEmail` method calls the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> method with the `(@)(.+)$` regular expression pattern to separate the domain name from the email address.</span></span> <span data-ttu-id="d2003-109">Der dritte Parameter ist ein <xref:System.Text.RegularExpressions.MatchEvaluator> -Delegat, der die Methode darstellt, die den gefundenen Text verarbeitet und ersetzt.</span><span class="sxs-lookup"><span data-stu-id="d2003-109">The third parameter is a <xref:System.Text.RegularExpressions.MatchEvaluator> delegate that represents the method that processes and replaces the matched text.</span></span> <span data-ttu-id="d2003-110">Das Muster des regulären Ausdrucks wird wie folgt interpretiert:</span><span class="sxs-lookup"><span data-stu-id="d2003-110">The regular expression pattern is interpreted as follows.</span></span>  
  
|<span data-ttu-id="d2003-111">Muster</span><span class="sxs-lookup"><span data-stu-id="d2003-111">Pattern</span></span>|<span data-ttu-id="d2003-112">description</span><span class="sxs-lookup"><span data-stu-id="d2003-112">Description</span></span>|  
|-------------|-----------------|  
|`(@)`|<span data-ttu-id="d2003-113">Das "@"-Zeichen wird als Übereinstimmung verwendet.</span><span class="sxs-lookup"><span data-stu-id="d2003-113">Match the @ character.</span></span> <span data-ttu-id="d2003-114">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="d2003-114">This is the first capturing group.</span></span>|  
|`(.+)`|<span data-ttu-id="d2003-115">Ein- oder mehrmalige Übereinstimmung mit beliebigem Zeichen.</span><span class="sxs-lookup"><span data-stu-id="d2003-115">Match one or more occurrences of any character.</span></span> <span data-ttu-id="d2003-116">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="d2003-116">This is the second capturing group.</span></span>|  
|`$`|<span data-ttu-id="d2003-117">Beendet die Suche am Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d2003-117">End the match at the end of the string.</span></span>|  
  
 <span data-ttu-id="d2003-118">Der Domänenname wird zusammen mit dem "@"-Zeichen der `DomainMapper` -Methode übergeben, die die <xref:System.Globalization.IdnMapping> -Klasse verwendet, um Unicode-Zeichen in ihre Punycode-Entsprechungen zu übersetzen, die außerhalb des 7-Bit-ASCII-Zeichenbereichs liegen.</span><span class="sxs-lookup"><span data-stu-id="d2003-118">The domain name along with the @ character is passed to the `DomainMapper` method, which uses the <xref:System.Globalization.IdnMapping> class to translate Unicode characters that are outside the US-ASCII character range to Punycode.</span></span> <span data-ttu-id="d2003-119">Darüber hinaus wird die Methode auch das `invalid`-Flag auf `True` fest, wenn die <xref:System.Globalization.IdnMapping.GetAscii%2A?displayProperty=nameWithType>-Methode ein unzulässiges Zeichen im Domänennamen erkennt.</span><span class="sxs-lookup"><span data-stu-id="d2003-119">The method also sets the `invalid` flag to `True` if the <xref:System.Globalization.IdnMapping.GetAscii%2A?displayProperty=nameWithType> method detects any invalid characters in the domain name.</span></span> <span data-ttu-id="d2003-120">Diese Methode gibt den Punycode-Domänennamen, der dem "@"-Zeichen vorangestellt ist, an die `IsValidEmail` -Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="d2003-120">The method returns the Punycode domain name preceded by the @ symbol to the `IsValidEmail` method.</span></span>  
  
 <span data-ttu-id="d2003-121">Die `IsValidEmail`-Methode ruft dann die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>-Methode auf, um zu überprüfen, ob die Adresse dem Muster eines regulären Ausdrucks entspricht.</span><span class="sxs-lookup"><span data-stu-id="d2003-121">The `IsValidEmail` method then calls the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method to verify that the address conforms to a regular expression pattern.</span></span>  
  
 <span data-ttu-id="d2003-122">Beachten Sie, dass die `IsValidEmail` -Methode keine Authentifizierung zur Überprüfung der E-Mail-Adresse durchführt.</span><span class="sxs-lookup"><span data-stu-id="d2003-122">Note that the `IsValidEmail` method does not perform authentication to validate the email address.</span></span> <span data-ttu-id="d2003-123">Sie bestimmt nur, ob das Format für eine E-Mail-Adresse gültig ist.</span><span class="sxs-lookup"><span data-stu-id="d2003-123">It merely determines whether its format is valid for an email address.</span></span> <span data-ttu-id="d2003-124">Außerdem überprüft die `IsValidEmail` -Methode nicht, ob der Domänenname der obersten Ebene ein gültiger Domänenname ist, der in der [IANA Root Zone Database](https://www.iana.org/domains/root/db)aufgelistet ist, was einen Suchvorgang erfordern würde.</span><span class="sxs-lookup"><span data-stu-id="d2003-124">In addition, the `IsValidEmail` method does not verify that the top-level domain name is a valid domain name listed at the [IANA Root Zone Database](https://www.iana.org/domains/root/db), which would require a look-up operation.</span></span> <span data-ttu-id="d2003-125">Stattdessen verifiziert der reguläre Ausdruck nur, dass der Domänenname der obersten Ebene aus zwei bis 24 ASCII-Zeichen besteht, wobei das erste und letzte Zeichen alphanumerisch und die übrigen Zeichen alphanumerisch oder ein Bindestrich (-) sein müssen.</span><span class="sxs-lookup"><span data-stu-id="d2003-125">Instead, the regular expression merely verifies that the top-level domain name consists of between two and twenty-four ASCII characters, with alphanumeric first and last characters and the remaining characters being either alphanumeric or a hyphen (-).</span></span>  
  
 [!code-csharp[RegularExpressions.Examples.Email#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Examples.Email/cs/example4.cs#7)]
 [!code-vb[RegularExpressions.Examples.Email#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Examples.Email/vb/example4.vb#7)]  
  
 <span data-ttu-id="d2003-126">In diesem Beispiel kann das Muster des regulären Ausdrucks ``^(?(")(".+?(?<!\\)"@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`{}|~\w])*)(?<=[0-9a-z])@))(?([)([(\d{1,3}.){3}\d{1,3}])|(([0-9a-z][-0-9a-z]*[0-9a-z]*.)+[a-z0-9][-a-z0-9]{0,22}[a-z0-9]))$`` wie in der folgenden Tabelle dargestellt interpretiert werden.</span><span class="sxs-lookup"><span data-stu-id="d2003-126">In this example, the regular expression pattern ``^(?(")(".+?(?<!\\)"@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`{}|~\w])*)(?<=[0-9a-z])@))(?([)([(\d{1,3}.){3}\d{1,3}])|(([0-9a-z][-0-9a-z]*[0-9a-z]*.)+[a-z0-9][-a-z0-9]{0,22}[a-z0-9]))$`` is interpreted as shown in the following table.</span></span> <span data-ttu-id="d2003-127">Beachten Sie, dass der reguläre Ausdruck mit dem Flag <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> kompiliert wurde.</span><span class="sxs-lookup"><span data-stu-id="d2003-127">Note that the regular expression is compiled using the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> flag.</span></span>  
  
|<span data-ttu-id="d2003-128">Muster</span><span class="sxs-lookup"><span data-stu-id="d2003-128">Pattern</span></span>|<span data-ttu-id="d2003-129">description</span><span class="sxs-lookup"><span data-stu-id="d2003-129">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="d2003-130">Starten Sie den Vergleich am Beginn der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d2003-130">Begin the match at the start of the string.</span></span>|  
|`(?(")`|<span data-ttu-id="d2003-131">Ermittelt, ob es sich beim ersten Zeichen um ein Anführungszeichen handelt.</span><span class="sxs-lookup"><span data-stu-id="d2003-131">Determine whether the first character is a quotation mark.</span></span> <span data-ttu-id="d2003-132">`(?(")` ist der Anfang eines Alternierungskonstrukts.</span><span class="sxs-lookup"><span data-stu-id="d2003-132">`(?(")` is the beginning of an alternation construct.</span></span>|  
|`(?("")("".+?(?<!\\)""@)`|<span data-ttu-id="d2003-133">Wenn es sich beim ersten Zeichen um ein Anführungszeichen handelt, wird ein öffnendes Anführungszeichen als Übereinstimmung verwendet, dem mindestens ein beliebiges Zeichen und ein schließendes Anführungszeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="d2003-133">If the first character is a quotation mark, match a beginning quotation mark followed by at least one occurrence of any character, followed by an ending quotation mark.</span></span> <span data-ttu-id="d2003-134">Dem schließenden Anführungszeichen darf kein umgekehrter Schrägstrich (\\) vorangestellt sein.</span><span class="sxs-lookup"><span data-stu-id="d2003-134">The ending quotation mark must not be preceded by a backslash character (\\).</span></span> <span data-ttu-id="d2003-135">`(?<!` ist der Anfang einer negativen Lookbehindassertion mit einer Breite von Null.</span><span class="sxs-lookup"><span data-stu-id="d2003-135">`(?<!` is the beginning of a zero-width negative lookbehind assertion.</span></span> <span data-ttu-id="d2003-136">Die Zeichenfolge muss mit einem "@"-Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="d2003-136">The string should conclude with an at sign (@).</span></span>|  
|<code>&#124;(([0-9a-z]</code>|<span data-ttu-id="d2003-137">Wenn es sich beim ersten Zeichen um kein Anführungszeichen handelt, wird ein beliebiges Buchstabenzeichen von a bis z oder A bis Z (die Groß-/Kleinschreibung wird nicht beachtet) oder ein beliebiges numerisches Zeichen von 0 bis 9 als Übereinstimmung verwendet.</span><span class="sxs-lookup"><span data-stu-id="d2003-137">If the first character is not a quotation mark, match any alphabetic character from a to z or A to Z (the comparison is case insensitive), or any numeric character from 0 to 9.</span></span>|  
|`(\.(?!\.))`|<span data-ttu-id="d2003-138">Wenn es sich beim nächsten Zeichen um einen Punkt handelt, wird dieser als Übereinstimmung verwendet.</span><span class="sxs-lookup"><span data-stu-id="d2003-138">If the next character is a period, match it.</span></span> <span data-ttu-id="d2003-139">Wenn es sich um keinen Punkt handelt, wird bis zum nächsten Zeichen weitergesucht und der Vergleich fortsetzt.</span><span class="sxs-lookup"><span data-stu-id="d2003-139">If it is not a period, look ahead to the next character and continue the match.</span></span> <span data-ttu-id="d2003-140">`(?!\.)` ist eine negative Lookaheadassertion mit einer Breite von 0 (Null), die verhindert, dass im lokalen Teil einer E-Mail-Adresse zwei aufeinander folgende Punkte enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="d2003-140">`(?!\.)` is a zero-width negative lookahead assertion that prevents two consecutive periods from appearing in the local part of an email address.</span></span>|  
|<code>&#124;[-!#\$%&'\*\+/=\?\^\`{}\&#124;~\w]</code>|<span data-ttu-id="d2003-141">Wenn es sich beim nächsten Zeichen nicht um einen Punkt handelt, wird ein beliebiges Wortzeichen oder eines der folgenden Zeichen als Übereinstimmung verwendet: -!#$%'\*+=?^\`{}&#124;~.</span><span class="sxs-lookup"><span data-stu-id="d2003-141">If the next character is not a period, match any word character or one of the following characters: -!#$%'\*+=?^\`{}&#124;~.</span></span>|  
|<code>((\.(?!\.))&#124;[-!#\$%'\*\+/=\?\^\`{}\&#124;~\w])*</code>|<span data-ttu-id="d2003-142">0 oder mehr Vorkommen des Alternierungsmusters werden als Übereinstimmung verwendet (ein Punkt, dem ein anderes Zeichen als ein Punkt oder eines aus einer Reihe von Zeichen folgt).</span><span class="sxs-lookup"><span data-stu-id="d2003-142">Match the alternation pattern (a period followed by a non-period, or one of a number of characters) zero or more times.</span></span>|  
|`@`|<span data-ttu-id="d2003-143">Das "@"-Zeichen wird als Übereinstimmung verwendet.</span><span class="sxs-lookup"><span data-stu-id="d2003-143">Match the @ character.</span></span>|  
|`(?<=[0-9a-z])`|<span data-ttu-id="d2003-144">Die Suche wird fortgesetzt, wenn es sich bei dem Zeichen, das dem @-Zeichen vorausgeht, ist, um eines der Zeichen A bis Z, a bis z oder 0 bis 9 handelt.</span><span class="sxs-lookup"><span data-stu-id="d2003-144">Continue the match if the character that precedes the @ character is A through Z, a through z, or 0 through 9.</span></span> <span data-ttu-id="d2003-145">Das `(?<=[0-9a-z])` -Konstrukt definiert eine positive Lookbehindassertion mit einer Breite von 0 (Null).</span><span class="sxs-lookup"><span data-stu-id="d2003-145">The `(?<=[0-9a-z])` construct defines a zero-width positive lookbehind assertion.</span></span>|  
|`(?(\[)`|<span data-ttu-id="d2003-146">Überprüfen Sie, ob es sich bei dem Zeichen, das @ folgt, um eine eckige Klammer links handelt.</span><span class="sxs-lookup"><span data-stu-id="d2003-146">Check whether the character that follows @ is an opening bracket.</span></span>|  
|`(\[(\d{1,3}\.){3}\d{1,3}\])`|<span data-ttu-id="d2003-147">Wenn es sich um eine eckige Klammer links handelt, wird die eckige Klammer links als Übereinstimmung verwendet, der eine IP-Adresse (vier Gruppen aus einer bis drei Ziffern, jeweils durch einen Punkt getrennt) und eine eckige Klammer rechts folgen.</span><span class="sxs-lookup"><span data-stu-id="d2003-147">If it is an opening bracket, match the opening bracket followed by an IP address (four sets of one to three digits, with each set separated by a period) and a closing bracket.</span></span>|  
|<code>&#124;(([0-9a-z][-0-9a-z]*[0-9a-z]*\.)+</code>|<span data-ttu-id="d2003-148">Wenn es sich bei dem Zeichen, das @ folgt, um keine öffnende eckige Klammer handelt, wird ein alphanumerisches Zeichen mit einem Wert von A-Z, a-z oder 0-9 als Übereinstimmung verwendet, dem null oder mehr Vorkommen eines Bindestrichs und kein oder ein alphanumerisches Zeichen mit einem Wert von A-Z, a-z oder 0-9 sowie ein Punkt folgen.</span><span class="sxs-lookup"><span data-stu-id="d2003-148">If the character that follows @ is not an opening bracket, match one alphanumeric character with a value of A-Z, a-z, or 0-9, followed by zero or more occurrences of a hyphen, followed by zero or one alphanumeric character with a value of A-Z, a-z, or 0-9, followed by a period.</span></span> <span data-ttu-id="d2003-149">Dieses Muster kann ein- oder mehrmals wiederholt werden und der Domänenname der obersten Ebene muss darauf folgen.</span><span class="sxs-lookup"><span data-stu-id="d2003-149">This pattern can be repeated one or more times, and must be followed by the top-level domain name.</span></span>|  
|`[a-z0-9][\-a-z0-9]{0,22}[a-z0-9]))`|<span data-ttu-id="d2003-150">Der Domänenname der obersten Ebene muss mit einem alphanumerischen Zeichen (a-z, A-Z und 0-9) beginnen und enden.</span><span class="sxs-lookup"><span data-stu-id="d2003-150">The top-level domain name must begin and end with an alphanumeric character (a-z, A-Z, and 0-9).</span></span> <span data-ttu-id="d2003-151">Er kann außerdem 0 bis 22 ASCII-Zeichen enthalten, die entweder alphanumerische Zeichen oder Bindestriche sind.</span><span class="sxs-lookup"><span data-stu-id="d2003-151">It can also include from zero to 22 ASCII characters that are either alphanumeric or hyphens.</span></span>|  
|`$`|<span data-ttu-id="d2003-152">Beendet die Suche am Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d2003-152">End the match at the end of the string.</span></span>|  
  
## <a name="compiling-the-code"></a><span data-ttu-id="d2003-153">Kompilieren des Codes</span><span class="sxs-lookup"><span data-stu-id="d2003-153">Compiling the Code</span></span>  
 <span data-ttu-id="d2003-154">Die `IsValidEmail` -Methode und die `DomainMapper` -Methode können in einer Bibliothek von Hilfsprogrammmethoden für reguläre Ausdrücke oder als private statische oder Instanzmethoden in der Anwendungsklasse enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="d2003-154">The `IsValidEmail` and `DomainMapper` methods can be included in a library of regular expression utility methods, or they can be included as private static or instance methods in the application class.</span></span>  
  
 <span data-ttu-id="d2003-155">Um sie in einer Bibliothek für reguläre Ausdrücke einzubeziehen, kopieren und fügen Sie den Code in ein Visual Studio-Klassenbibliotheksprojekt ein, oder kopieren und fügen Sie den Code in eine Textdatei ein, und kompilieren Sie ihn über die Befehlszeile mit einem Befehl wie dem folgenden (vorausgesetzt der Name der Quellcodedatei ist "RegexUtilities.cs" oder "RegexUtilities.vb"):</span><span class="sxs-lookup"><span data-stu-id="d2003-155">To include them in a regular expression library, either copy and paste the code into a Visual Studio Class Library project, or copy and paste it into a text file and compile it from the command line with a command like the following (assuming that the name of the source code file is RegexUtilities.cs or RegexUtilities.vb:</span></span>  
  
```csharp  
csc /t:library RegexUtilities.cs  
```  
  
```vb  
vbc /t:library RegexUtilities.vb  
```  
  
 <span data-ttu-id="d2003-156">Sie können auch die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>-Methode verwenden, um diesen regulären Ausdruck in eine Bibliothek für reguläre Ausdrücke einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d2003-156">You can also use the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method to include this regular expression in a regular expression library.</span></span>  
  
 <span data-ttu-id="d2003-157">Wenn sie in einer Bibliothek für reguläre Ausdrücke verwendet werden, können Sie die Methoden mit dem folgenden Code aufrufen:</span><span class="sxs-lookup"><span data-stu-id="d2003-157">If they are used in a regular expression library, you can call them by using code such as the following:</span></span>  
  
 [!code-csharp[RegularExpressions.Examples.Email#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Examples.Email/cs/example4.cs#8)]
 [!code-vb[RegularExpressions.Examples.Email#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Examples.Email/vb/example4.vb#8)]  
  
 <span data-ttu-id="d2003-158">Wenn Sie eine Klassenbibliothek mit dem Namen "RegexUtilities.dll" erstellt haben, die den regulären Ausdruck zur E-Mail-Gültigkeitsprüfung enthält, können Sie dieses Beispiel mit einer der folgenden Methoden kompilieren:</span><span class="sxs-lookup"><span data-stu-id="d2003-158">Assuming you've created a class library named RegexUtilities.dll that includes your email validation regular expression, you can compile this example in either of the following ways:</span></span>  
  
-   <span data-ttu-id="d2003-159">In Visual Studio durch Erstellen eine Konsolenanwendung und Hinzufügen eines Verweises auf RegexUtilities.dll zum Projekt.</span><span class="sxs-lookup"><span data-stu-id="d2003-159">In Visual Studio, by creating a Console Application and adding a reference to RegexUtilities.dll to your project.</span></span>  
  
-   <span data-ttu-id="d2003-160">Über die Befehlszeile durch Kopieren und Einfügen des Quellcodes in eine Textdatei und durch Kompilieren mit einem Befehl wie dem folgenden (vorausgesetzt der Name der Quellcodedatei ist "Example.cs" oder "Example.vb"):</span><span class="sxs-lookup"><span data-stu-id="d2003-160">From the command line, by copying and pasting the source code into a text file and compiling it with a command like the following (assuming that the name of the source code file is Example.cs or Example.vb:</span></span>  
  
    ```csharp  
    csc Example.cs /r:RegexUtilities.dll  
    ```  
  
    ```vb  
    vbc Example.vb /r:RegexUtilities.dll  
    ```  
  
## <a name="see-also"></a><span data-ttu-id="d2003-161">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="d2003-161">See Also</span></span>  
 [<span data-ttu-id="d2003-162">Reguläre Ausdrücke von .NET Framework</span><span class="sxs-lookup"><span data-stu-id="d2003-162">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)
