---
title: Backtracking in regulären Ausdrücken
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 043b4ab00699062d8c1af5866fbeb3773c8ce9af
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/06/2018
ms.locfileid: "44039500"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="94cc4-102">Backtracking in regulären Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="94cc4-102">Backtracking in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="94cc4-103">Eine Rückverfolgung tritt ein, wenn ein Muster eines regulären Ausdrucks optionale [Quantifizierer](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) oder [Alternierungskonstrukte](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)enthält und das Modul für reguläre Ausdrücke in einen zuvor gespeicherten Zustand zurückkehrt, um die Suche nach einer Übereinstimmung fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-103">Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="94cc4-104">Die Rückverfolgung ist für die Leistungsfähigkeit regulärer Ausdrücke von zentraler Bedeutung. Sie ermöglicht flexible und leistungsstarke Ausdrücke, die höchst komplexen Muster entsprechen können.</span><span class="sxs-lookup"><span data-stu-id="94cc4-104">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="94cc4-105">Diese Leistungsfähigkeit zieht aber auch Nachteile mit sich.</span><span class="sxs-lookup"><span data-stu-id="94cc4-105">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="94cc4-106">Die Rückverfolgung ist häufig der wichtigste Faktor, der sich auf die Leistung der Engine für reguläre Ausdrücke auswirkt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-106">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="94cc4-107">Der Entwickler kann jedoch steuern, wie sich die Engine für reguläre Ausdrücke verhält und wie die Rückverfolgung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-107">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="94cc4-108">In diesem Thema wird erläutert, wie die Rückverfolgung funktioniert und wie sie gesteuert werden kann.</span><span class="sxs-lookup"><span data-stu-id="94cc4-108">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94cc4-109">Bei einer NFA-Engine (Nondeterministic Finite Automaton) wie der .NET-Engine für reguläre Ausdrücke liegt die Verantwortung für die Erstellung effizienter und schneller regulärer Ausdrücke im Allgemeinen beim Entwickler.</span><span class="sxs-lookup"><span data-stu-id="94cc4-109">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  
  
 <span data-ttu-id="94cc4-110">Dieses Thema enthält folgende Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="94cc4-110">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="94cc4-111">Linearer Vergleich ohne Rückverfolgung</span><span class="sxs-lookup"><span data-stu-id="94cc4-111">Linear Comparison Without Backtracking</span></span>](#linear_comparison_without_backtracking)  
  
-   [<span data-ttu-id="94cc4-112">Rückverfolgung mit optionalen Quantifizierern oder Alternierungskonstrukten</span><span class="sxs-lookup"><span data-stu-id="94cc4-112">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
-   [<span data-ttu-id="94cc4-113">Rückverfolgung mit geschachtelten optionalen Quantifizierern</span><span class="sxs-lookup"><span data-stu-id="94cc4-113">Backtracking with Nested Optional Quantifiers</span></span>](#backtracking_with_nested_optional_quantifiers)  
  
-   [<span data-ttu-id="94cc4-114">Steuern der Rückverfolgung</span><span class="sxs-lookup"><span data-stu-id="94cc4-114">Controlling Backtracking</span></span>](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="94cc4-115">Linearer Vergleich ohne Rückverfolgung</span><span class="sxs-lookup"><span data-stu-id="94cc4-115">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="94cc4-116">Wenn das Muster eines regulären Ausdrucks nicht über optionale Quantifizierer oder Alternierungskonstrukte verfügt, wird die Engine für reguläre Ausdrücke zeitlich linear ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-116">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="94cc4-117">Das heißt, nachdem die Engine für reguläre Ausdrücke dem ersten Sprachelement im Muster Text in der Eingabezeichenfolge zugeordnet hat, wird versucht, das nächste Sprachelement im Muster dem nächsten Zeichen oder der nächsten Zeichengruppe in der Eingabezeichenfolge zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-117">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="94cc4-118">Dies wird fortgesetzt, bis die Übereinstimmung erfolgreich ausgeführt wurde oder fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-118">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="94cc4-119">In beiden Fällen wechselt die Engine für reguläre Ausdrücke immer je ein Zeichen in der Eingabezeichenfolge weiter.</span><span class="sxs-lookup"><span data-stu-id="94cc4-119">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="94cc4-120">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="94cc4-120">The following example provides an illustration.</span></span> <span data-ttu-id="94cc4-121">Der reguläre Ausdruck `e{2}\w\b` sucht nach zwei Vorkommen des Buchstabens "e", gefolgt von einem beliebigen Wortzeichen, wiederum gefolgt von einer Wortgrenze.</span><span class="sxs-lookup"><span data-stu-id="94cc4-121">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="94cc4-122">Obwohl dieser reguläre Ausdruck den Quantifizierer `{2}`einschließt, wird er auf lineare Weise ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="94cc4-122">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="94cc4-123">Die Engine für reguläre Ausdrücke wird nicht zurückverfolgt, da `{2}` kein optionaler Quantifizierer ist, sondern eine genaue Zahl angibt und keine variable Anzahl von Übereinstimmungen des vorherigen Teilausdrucks.</span><span class="sxs-lookup"><span data-stu-id="94cc4-123">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="94cc4-124">Daher versucht die Engine für reguläre Ausdrücke, eine Übereinstimmung des regulären Ausdrucksmusters mit der Eingabezeichenfolge wie in der folgenden Tabelle dargestellt zu finden.</span><span class="sxs-lookup"><span data-stu-id="94cc4-124">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="94cc4-125">Vorgang</span><span class="sxs-lookup"><span data-stu-id="94cc4-125">Operation</span></span>|<span data-ttu-id="94cc4-126">Position im Muster</span><span class="sxs-lookup"><span data-stu-id="94cc4-126">Position in pattern</span></span>|<span data-ttu-id="94cc4-127">Position in der Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="94cc4-127">Position in string</span></span>|<span data-ttu-id="94cc4-128">Ergebnis</span><span class="sxs-lookup"><span data-stu-id="94cc4-128">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="94cc4-129">1</span><span class="sxs-lookup"><span data-stu-id="94cc4-129">1</span></span>|<span data-ttu-id="94cc4-130">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-130">e</span></span>|<span data-ttu-id="94cc4-131">"needing a reed" (Index 0)</span><span class="sxs-lookup"><span data-stu-id="94cc4-131">"needing a reed" (index 0)</span></span>|<span data-ttu-id="94cc4-132">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-132">No match.</span></span>|  
|<span data-ttu-id="94cc4-133">2</span><span class="sxs-lookup"><span data-stu-id="94cc4-133">2</span></span>|<span data-ttu-id="94cc4-134">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-134">e</span></span>|<span data-ttu-id="94cc4-135">"eeding a reed" (Index 1)</span><span class="sxs-lookup"><span data-stu-id="94cc4-135">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="94cc4-136">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-136">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-137">3</span><span class="sxs-lookup"><span data-stu-id="94cc4-137">3</span></span>|<span data-ttu-id="94cc4-138">e{2}</span><span class="sxs-lookup"><span data-stu-id="94cc4-138">e{2}</span></span>|<span data-ttu-id="94cc4-139">"eding a reed" (Index 2)</span><span class="sxs-lookup"><span data-stu-id="94cc4-139">"eding a reed" (index 2)</span></span>|<span data-ttu-id="94cc4-140">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-140">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-141">4</span><span class="sxs-lookup"><span data-stu-id="94cc4-141">4</span></span>|<span data-ttu-id="94cc4-142">\w</span><span class="sxs-lookup"><span data-stu-id="94cc4-142">\w</span></span>|<span data-ttu-id="94cc4-143">"ding a reed" (Index 3)</span><span class="sxs-lookup"><span data-stu-id="94cc4-143">"ding a reed" (index 3)</span></span>|<span data-ttu-id="94cc4-144">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-144">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-145">5</span><span class="sxs-lookup"><span data-stu-id="94cc4-145">5</span></span>|<span data-ttu-id="94cc4-146">\b</span><span class="sxs-lookup"><span data-stu-id="94cc4-146">\b</span></span>|<span data-ttu-id="94cc4-147">"ing a reed" (Index 4)</span><span class="sxs-lookup"><span data-stu-id="94cc4-147">"ing a reed" (index 4)</span></span>|<span data-ttu-id="94cc4-148">Mögliche Übereinstimmung schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-148">Possible match fails.</span></span>|  
|<span data-ttu-id="94cc4-149">6</span><span class="sxs-lookup"><span data-stu-id="94cc4-149">6</span></span>|<span data-ttu-id="94cc4-150">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-150">e</span></span>|<span data-ttu-id="94cc4-151">"eding a reed" (Index 2)</span><span class="sxs-lookup"><span data-stu-id="94cc4-151">"eding a reed" (index 2)</span></span>|<span data-ttu-id="94cc4-152">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-152">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-153">7</span><span class="sxs-lookup"><span data-stu-id="94cc4-153">7</span></span>|<span data-ttu-id="94cc4-154">e{2}</span><span class="sxs-lookup"><span data-stu-id="94cc4-154">e{2}</span></span>|<span data-ttu-id="94cc4-155">"ding a reed" (Index 3)</span><span class="sxs-lookup"><span data-stu-id="94cc4-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="94cc4-156">Mögliche Übereinstimmung schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-156">Possible match fails.</span></span>|  
|<span data-ttu-id="94cc4-157">8</span><span class="sxs-lookup"><span data-stu-id="94cc4-157">8</span></span>|<span data-ttu-id="94cc4-158">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-158">e</span></span>|<span data-ttu-id="94cc4-159">"ding a reed" (Index 3)</span><span class="sxs-lookup"><span data-stu-id="94cc4-159">"ding a reed" (index 3)</span></span>|<span data-ttu-id="94cc4-160">Übereinstimmung schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-160">Match fails.</span></span>|  
|<span data-ttu-id="94cc4-161">9</span><span class="sxs-lookup"><span data-stu-id="94cc4-161">9</span></span>|<span data-ttu-id="94cc4-162">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-162">e</span></span>|<span data-ttu-id="94cc4-163">"ing a reed" (Index 4)</span><span class="sxs-lookup"><span data-stu-id="94cc4-163">"ing a reed" (index 4)</span></span>|<span data-ttu-id="94cc4-164">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-164">No match.</span></span>|  
|<span data-ttu-id="94cc4-165">10</span><span class="sxs-lookup"><span data-stu-id="94cc4-165">10</span></span>|<span data-ttu-id="94cc4-166">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-166">e</span></span>|<span data-ttu-id="94cc4-167">"ng a reed" (Index 5)</span><span class="sxs-lookup"><span data-stu-id="94cc4-167">"ng a reed" (index 5)</span></span>|<span data-ttu-id="94cc4-168">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-168">No match.</span></span>|  
|<span data-ttu-id="94cc4-169">11</span><span class="sxs-lookup"><span data-stu-id="94cc4-169">11</span></span>|<span data-ttu-id="94cc4-170">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-170">e</span></span>|<span data-ttu-id="94cc4-171">"g a reed" (Index 6)</span><span class="sxs-lookup"><span data-stu-id="94cc4-171">"g a reed" (index 6)</span></span>|<span data-ttu-id="94cc4-172">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-172">No match.</span></span>|  
|<span data-ttu-id="94cc4-173">12</span><span class="sxs-lookup"><span data-stu-id="94cc4-173">12</span></span>|<span data-ttu-id="94cc4-174">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-174">e</span></span>|<span data-ttu-id="94cc4-175">" a reed" (Index 7)</span><span class="sxs-lookup"><span data-stu-id="94cc4-175">" a reed" (index 7)</span></span>|<span data-ttu-id="94cc4-176">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-176">No match.</span></span>|  
|<span data-ttu-id="94cc4-177">13</span><span class="sxs-lookup"><span data-stu-id="94cc4-177">13</span></span>|<span data-ttu-id="94cc4-178">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-178">e</span></span>|<span data-ttu-id="94cc4-179">"a reed" (Index 8)</span><span class="sxs-lookup"><span data-stu-id="94cc4-179">"a reed" (index 8)</span></span>|<span data-ttu-id="94cc4-180">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-180">No match.</span></span>|  
|<span data-ttu-id="94cc4-181">14</span><span class="sxs-lookup"><span data-stu-id="94cc4-181">14</span></span>|<span data-ttu-id="94cc4-182">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-182">e</span></span>|<span data-ttu-id="94cc4-183">" reed" (Index 9)</span><span class="sxs-lookup"><span data-stu-id="94cc4-183">" reed" (index 9)</span></span>|<span data-ttu-id="94cc4-184">Keine Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-184">No match.</span></span>|  
|<span data-ttu-id="94cc4-185">15</span><span class="sxs-lookup"><span data-stu-id="94cc4-185">15</span></span>|<span data-ttu-id="94cc4-186">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-186">e</span></span>|<span data-ttu-id="94cc4-187">"a reed" (Index 10)</span><span class="sxs-lookup"><span data-stu-id="94cc4-187">"reed" (index 10)</span></span>|<span data-ttu-id="94cc4-188">Keine Übereinstimmung</span><span class="sxs-lookup"><span data-stu-id="94cc4-188">No match</span></span>|  
|<span data-ttu-id="94cc4-189">16</span><span class="sxs-lookup"><span data-stu-id="94cc4-189">16</span></span>|<span data-ttu-id="94cc4-190">e</span><span class="sxs-lookup"><span data-stu-id="94cc4-190">e</span></span>|<span data-ttu-id="94cc4-191">"eed" (Index 11)</span><span class="sxs-lookup"><span data-stu-id="94cc4-191">"eed" (index 11)</span></span>|<span data-ttu-id="94cc4-192">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-192">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-193">17</span><span class="sxs-lookup"><span data-stu-id="94cc4-193">17</span></span>|<span data-ttu-id="94cc4-194">e{2}</span><span class="sxs-lookup"><span data-stu-id="94cc4-194">e{2}</span></span>|<span data-ttu-id="94cc4-195">"ed" (Index 12)</span><span class="sxs-lookup"><span data-stu-id="94cc4-195">"ed" (index 12)</span></span>|<span data-ttu-id="94cc4-196">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-196">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-197">18</span><span class="sxs-lookup"><span data-stu-id="94cc4-197">18</span></span>|<span data-ttu-id="94cc4-198">\w</span><span class="sxs-lookup"><span data-stu-id="94cc4-198">\w</span></span>|<span data-ttu-id="94cc4-199">"d" (Index 13)</span><span class="sxs-lookup"><span data-stu-id="94cc4-199">"d" (index 13)</span></span>|<span data-ttu-id="94cc4-200">Mögliche Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-200">Possible match.</span></span>|  
|<span data-ttu-id="94cc4-201">19</span><span class="sxs-lookup"><span data-stu-id="94cc4-201">19</span></span>|<span data-ttu-id="94cc4-202">\b</span><span class="sxs-lookup"><span data-stu-id="94cc4-202">\b</span></span>|<span data-ttu-id="94cc4-203">"" (Index 14)</span><span class="sxs-lookup"><span data-stu-id="94cc4-203">"" (index 14)</span></span>|<span data-ttu-id="94cc4-204">Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-204">Match.</span></span>|  
  
 <span data-ttu-id="94cc4-205">Wenn das Muster eines regulären Ausdrucks keine optionalen Quantifizierer oder Alternierungskonstrukte enthält, entspricht die maximale Anzahl von Vergleichen, die für die Übereinstimmung des regulären Ausdrucksmusters mit der Eingabezeichenfolge erforderlich sind, ungefähr der Anzahl der Zeichen in der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="94cc4-205">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="94cc4-206">In diesem Fall verwendet die Engine für reguläre Ausdrücke 19 Vergleiche, um mögliche Übereinstimmungen in dieser Zeichenfolge mit 13 Zeichen zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="94cc4-206">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="94cc4-207">Mit anderen Worten, die Engine für reguläre Ausdrücke wird zeitlich annähernd linear ausgeführt, wenn sie keine optionalen Quantifizierer oder Alternierungskonstrukte enthält.</span><span class="sxs-lookup"><span data-stu-id="94cc4-207">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>  
  
 [<span data-ttu-id="94cc4-208">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="94cc4-208">Back to top</span></span>](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="94cc4-209">Rückverfolgung mit optionalen Quantifizierern oder Alternierungskonstrukten</span><span class="sxs-lookup"><span data-stu-id="94cc4-209">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="94cc4-210">Wenn ein regulärer Ausdruck optionale Quantifizierer oder Alternierungskonstrukte enthält, erfolgt die Auswertung der Eingabezeichenfolge nicht mehr linear.</span><span class="sxs-lookup"><span data-stu-id="94cc4-210">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="94cc4-211">Mustervergleiche mit einer NFA-Engine werden durch die Sprachelemente im regulären Ausdruck und nicht durch die Zeichen gesteuert, für die in der Eingabezeichenfolge Übereinstimmungen gefunden werden sollen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-211">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="94cc4-212">Daher versucht die Engine für reguläre Ausdrücke, vollständige Übereinstimmungen für die optionalen oder alternativen Teilausdrücke zu finden.</span><span class="sxs-lookup"><span data-stu-id="94cc4-212">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="94cc4-213">Wenn zum nächsten Sprachelement im Teilausdruck gewechselt und keine Übereinstimmung gefunden wird, kann die Engine für reguläre Ausdrücke einen Teil der erfolgreichen Übereinstimmung aufgeben und zu einem zuvor gespeicherten Zustand zurückkehren, um eine Übereinstimmung des gesamten regulären Ausdrucks mit der Eingabezeichenfolge zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-213">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="94cc4-214">Dieses Zurückkehren zu einem zuvor gespeicherten Zustand, um eine Übereinstimmung zu finden, wird als Rückverfolgung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="94cc4-214">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="94cc4-215">Als Beispiel dient das reguläre Ausdrucksmuster `.*(es)`, das mit den Zeichen "es" und allen vorangestellten Zeichen übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-215">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="94cc4-216">Wenn die Eingabezeichenfolge "Essential services are provided by regular expressions." lautet, wird die gesamte Zeichenfolge bis einschließlich der Zeichen "es" im Wort "expressions" nach einer Übereinstimmung mit dem Muster durchsucht.</span><span class="sxs-lookup"><span data-stu-id="94cc4-216">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="94cc4-217">Hierzu verwendet die Engine für reguläre Ausdrücke das Zurückverfolgen wie folgt:</span><span class="sxs-lookup"><span data-stu-id="94cc4-217">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
-   <span data-ttu-id="94cc4-218">Die gesamte Eingabezeichenfolge wird auf Übereinstimmung mit `.*` (Übereinstimmung mit keinem, einem oder mehreren Vorkommen beliebiger Zeichen) geprüft.</span><span class="sxs-lookup"><span data-stu-id="94cc4-218">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
-   <span data-ttu-id="94cc4-219">Es wird versucht, eine Übereinstimmung mit "e" im Muster des regulären Ausdrucks zu finden.</span><span class="sxs-lookup"><span data-stu-id="94cc4-219">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="94cc4-220">Die Eingabezeichenfolge weist jedoch keine weiteren Zeichen für eine Übereinstimmung auf.</span><span class="sxs-lookup"><span data-stu-id="94cc4-220">However, the input string has no remaining characters available to match.</span></span>  
  
-   <span data-ttu-id="94cc4-221">Es wird eine Rückverfolgung zur letzten erfolgreichen Übereinstimmung ausgeführt ("Essential services are provided by regular expressions") und versucht, eine Übereinstimmung von "e" mit dem Punkt am Satzende zu finden.</span><span class="sxs-lookup"><span data-stu-id="94cc4-221">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="94cc4-222">Die Übereinstimmung schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-222">The match fails.</span></span>  
  
-   <span data-ttu-id="94cc4-223">Die Rückverfolgung zu einer vorherigen erfolgreichen Übereinstimmung wird um je ein Zeichen fortgesetzt, bis die vorläufige übereinstimmende Teilzeichenfolge "Essential services are provided by regular expr" lautet.</span><span class="sxs-lookup"><span data-stu-id="94cc4-223">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="94cc4-224">Anschließend wird das "e" im Muster mit dem zweiten "e" in "expressions" verglichen, und es wird eine Übereinstimmung gefunden.</span><span class="sxs-lookup"><span data-stu-id="94cc4-224">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
-   <span data-ttu-id="94cc4-225">Das "s" im Muster wird mit dem "s" verglichen, das dem übereinstimmenden Zeichen "e" folgt (das erste "s" in"expressions").</span><span class="sxs-lookup"><span data-stu-id="94cc4-225">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="94cc4-226">Die Übereinstimmung ist erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="94cc4-226">The match is successful.</span></span>  
  
 <span data-ttu-id="94cc4-227">Bei einer Rückverfolgung erfordert das Abgleichen des regulären Ausdrucksmusters mit der Eingabezeichenfolge, die 55 Zeichen lang ist, 67 Vergleichsoperationen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-227">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="94cc4-228">Wenn das Muster des regulären Ausdrucks einen verzögerten Quantifizierer (`*?(es)`) enthält, sind für den Abgleich mit dem regulären Ausdruck interessanterweise weitere Vergleiche erforderlich.</span><span class="sxs-lookup"><span data-stu-id="94cc4-228">Interestingly, if the regular expression pattern included a lazy quantifier, .`*?(es)`, matching the regular expression would require additional comparisons.</span></span> <span data-ttu-id="94cc4-229">In diesem Fall muss keine Rückverfolgung vom Ende der Zeichenfolge bis zum "r" in "expressions" erfolgen, sondern die Engine für reguläre Ausdrücke würde eine Rückverfolgung bis zum Anfang der Zeichenfolge ausführen, um eine Übereinstimmung mit "Es" zu finden. Hierfür wären 113 Vergleiche erforderlich.</span><span class="sxs-lookup"><span data-stu-id="94cc4-229">In this case, instead of having to backtrack from the end of the string to the "r" in "expressions", the regular expression engine would have to backtrack all the way to the beginning of the string to match "Es" and would require 113 comparisons.</span></span> <span data-ttu-id="94cc4-230">Wenn das Muster eines regulären Ausdrucks ein einzelnes Alternierungskonstrukt oder einen einzelnen optionalen Quantifizierer enthält, ist die Anzahl der zum Abgleichen eines Musters erforderlichen Vergleichsoperationen im Allgemeinen mehr als doppelt so hoch wie die Anzahl der Zeichen in der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="94cc4-230">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>  
  
 [<span data-ttu-id="94cc4-231">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="94cc4-231">Back to top</span></span>](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="94cc4-232">Rückverfolgung mit geschachtelten optionalen Quantifizierern</span><span class="sxs-lookup"><span data-stu-id="94cc4-232">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="94cc4-233">Die Anzahl der für den Abgleich mit einem regulären Ausdrucksmuster erforderlichen Vergleichsoperationen kann sich exponentiell erhöhen, wenn das Muster viele Alternierungskonstrukte bzw. geschachtelte Alternierungskonstrukte oder, wie es am häufigsten vorkommt, geschachtelte optionale Quantifizierer enthält.</span><span class="sxs-lookup"><span data-stu-id="94cc4-233">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="94cc4-234">Beispielsweise ist das reguläre Ausdrucksmuster `^(a+)+$` darauf ausgelegt, eine Übereinstimmung mit einer vollständigen Zeichenfolge zu finden, die mindestens ein "a" enthält.</span><span class="sxs-lookup"><span data-stu-id="94cc4-234">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="94cc4-235">Das Beispiel stellt zwei Eingabezeichenfolgen mit identischer Länge bereit. Aber nur die erste Zeichenfolge stimmt mit dem Muster überein.</span><span class="sxs-lookup"><span data-stu-id="94cc4-235">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="94cc4-236">Die <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType>-Klasse wird verwendet, um zu bestimmen, wie lange die Vergleichsoperation dauert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-236">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="94cc4-237">Wie die Ausgabe des Beispiels zeigt, brauchte die Engine für reguläre Ausdrücke zum Bestimmen, dass eine Eingabezeichenfolge nicht mit dem Muster übereinstimmt, etwa doppelt so lang wie für die Ermittlung einer übereinstimmenden Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="94cc4-237">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="94cc4-238">Dies liegt daran, dass eine fehlgeschlagene Übereinstimmung immer den ungünstigsten Fall darstellt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-238">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="94cc4-239">Die Engine für reguläre Ausdrücke muss den regulären Ausdruck verwenden, um allen möglichen Pfaden durch die Daten zu folgen, bevor es feststellen kann, ob die Übereinstimmung fehlschlägt. Durch die geschachtelten Klammern werden viele zusätzliche Pfade durch die Daten erstellt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-239">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="94cc4-240">Die Engine für reguläre Ausdrücke stellt fest, dass die zweite Zeichenfolge nicht mit dem Muster übereinstimmt, indem wie folgt vorgegangen wird:</span><span class="sxs-lookup"><span data-stu-id="94cc4-240">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
-   <span data-ttu-id="94cc4-241">Das Modul überprüft, ob es sich am Anfang der Zeichenfolge befindet, und vergleicht dann die ersten fünf Zeichen in der Zeichenfolge mit dem Muster `a+`.</span><span class="sxs-lookup"><span data-stu-id="94cc4-241">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="94cc4-242">Anschließend wird sichergestellt, dass keine weiteren Gruppen des Zeichens "a" in der Zeichenfolge vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="94cc4-242">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="94cc4-243">Schließlich wird das Ende der Zeichenfolge überprüft.</span><span class="sxs-lookup"><span data-stu-id="94cc4-243">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="94cc4-244">Da ein zusätzliches Zeichen in der Zeichenfolge verbleibt, schlägt die Übereinstimmung fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-244">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="94cc4-245">Diese fehlgeschlagene Suche nach Übereinstimmung erfordert 9 Vergleiche.</span><span class="sxs-lookup"><span data-stu-id="94cc4-245">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="94cc4-246">Die Engine für reguläre Ausdrücke speichert darüber hinaus Zustandsinformationen aus den Übereinstimmungen von "a" (hier bezeichnet als Übereinstimmung 1), "aa" (Übereinstimmung 2), "aaa" (Übereinstimmung 3) und "aaaa" (Übereinstimmung 4).</span><span class="sxs-lookup"><span data-stu-id="94cc4-246">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
-   <span data-ttu-id="94cc4-247">Das Modul kehrt zur zuvor gespeicherten Übereinstimmung 4 zurück.</span><span class="sxs-lookup"><span data-stu-id="94cc4-247">It returns to the previously saved match 4.</span></span> <span data-ttu-id="94cc4-248">Es wird ermittelt, dass ein zusätzliches Zeichen "a" vorhanden ist, das einer zusätzlichen Erfassungsgruppe zugewiesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="94cc4-248">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="94cc4-249">Schließlich wird das Ende der Zeichenfolge überprüft.</span><span class="sxs-lookup"><span data-stu-id="94cc4-249">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="94cc4-250">Da ein zusätzliches Zeichen in der Zeichenfolge verbleibt, schlägt die Übereinstimmung fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-250">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="94cc4-251">Diese fehlgeschlagene Suche nach Übereinstimmung erfordert 4 Vergleiche.</span><span class="sxs-lookup"><span data-stu-id="94cc4-251">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="94cc4-252">Bisher wurden insgesamt 13 Vergleiche ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-252">So far, a total of 13 comparisons have been performed.</span></span>  
  
-   <span data-ttu-id="94cc4-253">Das Modul kehrt zur zuvor gespeicherten Übereinstimmung 3 zurück.</span><span class="sxs-lookup"><span data-stu-id="94cc4-253">It returns to the previously saved match 3.</span></span> <span data-ttu-id="94cc4-254">Es wird ermittelt, dass zwei zusätzliche "a"-Zeichen vorhanden sind, die einer zusätzlichen Erfassungsgruppe zugewiesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-254">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="94cc4-255">Allerdings schlägt die Überprüfung des Zeichenfolgenendes fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-255">However, the end-of-string test fails.</span></span> <span data-ttu-id="94cc4-256">Anschließend kehrt das Modul zur Übereinstimmung 3 zurück und versucht, die zwei zusätzlichen "a"-Zeichen in zwei zusätzlichen Erfassungsgruppen abzugleichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-256">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="94cc4-257">Die Überprüfung des Zeichenfolgenendes schlägt weiterhin fehl.</span><span class="sxs-lookup"><span data-stu-id="94cc4-257">The end-of-string test still fails.</span></span> <span data-ttu-id="94cc4-258">Diese fehlgeschlagenen Übereinstimmungen erfordern 12 Vergleiche.</span><span class="sxs-lookup"><span data-stu-id="94cc4-258">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="94cc4-259">Bisher wurden insgesamt 25 Vergleiche ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-259">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="94cc4-260">Der Vergleich der Eingabezeichenfolge mit dem regulären Ausdruck wird auf diese Weise fortgesetzt, bis die Engine für reguläre Ausdrücke alle möglichen Übereinstimmungskombinationen durchlaufen hat und dann feststellt, dass keine Übereinstimmung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="94cc4-260">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="94cc4-261">Aufgrund der geschachtelten Quantifizierer handelt es sich bei diesem Vergleich um O(2<sup>n</sup>) oder einen exponentiellen Vorgang, wobei *n* für die Anzahl von Zeichen in der Eingabezeichenfolge steht.</span><span class="sxs-lookup"><span data-stu-id="94cc4-261">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="94cc4-262">Dies bedeutet, dass im ungünstigsten Fall für eine Eingabezeichenfolge von 30 Zeichen etwa 1.073.741.824 Vergleiche und für eine Eingabezeichenfolge von 40 Zeichen ungefähr 1.099.511.627.776 Vergleiche erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="94cc4-262">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="94cc4-263">Wenn Sie Zeichenfolgen mit dieser oder sogar einer größeren Länge verwenden, kann die Ausführung von Methoden mit regulären Ausdrücken erhebliche Zeit in Anspruch nehmen, wenn diese Eingaben verarbeiten, die nicht mit dem regulären Ausdrucksmuster übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-263">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>  
  
 [<span data-ttu-id="94cc4-264">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="94cc4-264">Back to top</span></span>](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a><span data-ttu-id="94cc4-265">Steuern der Rückverfolgung</span><span class="sxs-lookup"><span data-stu-id="94cc4-265">Controlling Backtracking</span></span>  
 <span data-ttu-id="94cc4-266">Mithilfe der Rückverfolgung können Sie leistungsstarke, flexible reguläre Ausdrücke erstellen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-266">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="94cc4-267">Wie allerdings im vorangegangenen Abschnitt erläutert, sind diese Vorteile u. U. mit einer inakzeptabel schlechten Leistung verknüpft.</span><span class="sxs-lookup"><span data-stu-id="94cc4-267">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="94cc4-268">Um eine übermäßige Rückverfolgung zu verhindern, sollten Sie ein Timeoutintervall definieren, wenn Sie ein <xref:System.Text.RegularExpressions.Regex> -Objekt instanziieren oder eine statische Methode für Übereinstimmungen mit regulären Ausdrücken aufrufen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-268">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="94cc4-269">Dies wird im nächsten Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-269">This is discussed in the next section.</span></span> <span data-ttu-id="94cc4-270">Darüber hinaus unterstützt .NET drei Sprachelemente für reguläre Ausdrücke, die das Zurückverfolgen einschränken oder unterdrücken und komplexe reguläre Ausdrücke bei nur wenigen oder gar keinen Leistungseinbußen unterstützen: [nicht zurückverfolgende Teilausdrücke](#Nonbacktracking), [Lookbehindassertionen](#Lookbehind) und [Lookaheadassertionen](#Lookahead).</span><span class="sxs-lookup"><span data-stu-id="94cc4-270">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [nonbacktracking subexpressions](#Nonbacktracking), [lookbehind assertions](#Lookbehind), and [lookahead assertions](#Lookahead).</span></span> <span data-ttu-id="94cc4-271">Weitere Informationen zu den einzelnen Sprachelementen finden Sie unter [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="94cc4-271">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a><span data-ttu-id="94cc4-272">Definieren eines Timeoutintervalls</span><span class="sxs-lookup"><span data-stu-id="94cc4-272">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="94cc4-273">Ab [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]können Sie einen Timeoutwert für das längste Intervall festlegen, innerhalb dessen die Engine für reguläre Ausdrücke nach einer einzelnen Übereinstimmung sucht, bevor der Versuch abgebrochen und eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> -Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-273">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="94cc4-274">Sie geben das Timeoutintervall an, indem Sie einen <xref:System.TimeSpan>-Wert für den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor für reguläre Ausdrucksinstanzen bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-274">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="94cc4-275">Außerdem weist jede statische Methode für Musterübereinstimmungen eine Überladung mit einem <xref:System.TimeSpan> -Parameter auf, der es Ihnen ermöglicht, einen Timeoutwert anzugeben.</span><span class="sxs-lookup"><span data-stu-id="94cc4-275">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="94cc4-276">Standardmäßig wird das Timeoutintervall auf <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> festgelegt, und die Engine für reguläre Ausdrücke gibt kein Timeout zurück.</span><span class="sxs-lookup"><span data-stu-id="94cc4-276">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="94cc4-277">Es wird empfohlen, immer ein Timeoutintervall festzulegen, wenn ein regulärer Ausdruck auf Rückverfolgung angewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="94cc4-277">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="94cc4-278">Eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> -Ausnahme gibt an, dass die Engine für reguläre Ausdrücke keine Übereinstimmung innerhalb des angegebenen Timeoutintervalls finden konnte, sie gibt aber nicht an, warum die Ausnahme ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="94cc4-278">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="94cc4-279">Der Grund kann eine übermäßige Rückverfolgung sein. Es ist jedoch auch möglich, dass das Timeoutintervall angesichts der Systembelastung zum Zeitpunkt, als die Ausnahme ausgelöst wurde, zu niedrig festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="94cc4-279">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="94cc4-280">Wenn Sie die Ausnahme behandeln, können Sie entweder weitere Übereinstimmungen mit der Eingabezeichenfolge abbrechen oder das Timeoutintervall erhöhen und den Vergleichsvorgang erneut ausführen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-280">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="94cc4-281">Im folgenden Code wird beispielsweise der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor aufgerufen, um ein <xref:System.Text.RegularExpressions.Regex>-Objekt mit einem Timeoutwert von einer Sekunde zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="94cc4-281">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="94cc4-282">Das Muster des regulären Ausdrucks `(a+)+$`, das mit mindestens einer Sequenz von einem oder mehreren "a"-Zeichen am Ende einer Zeile übereinstimmt, unterliegt übermäßiger Rückverfolgung.</span><span class="sxs-lookup"><span data-stu-id="94cc4-282">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="94cc4-283">Wenn <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> ausgelöst wird, wird der Timeoutwert im Beispiel bis zu einem maximalen Intervall von drei Sekunden erhöht.</span><span class="sxs-lookup"><span data-stu-id="94cc4-283">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="94cc4-284">Danach wird der Versuch, das Muster abzugleichen, abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-284">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a><span data-ttu-id="94cc4-285">Nicht zurückverfolgender Teilausdruck</span><span class="sxs-lookup"><span data-stu-id="94cc4-285">Nonbacktracking Subexpression</span></span>  
 <span data-ttu-id="94cc4-286">Das Sprachelement `(?>` *Teilausdruck*`)` unterdrückt die Rückverfolgung in einem Teilausdruck.</span><span class="sxs-lookup"><span data-stu-id="94cc4-286">The `(?>` *subexpression*`)` language element suppresses backtracking in a subexpression.</span></span> <span data-ttu-id="94cc4-287">Das Element ist nützlich, um die mit fehlgeschlagenen Übereinstimmungen zusammenhängenden Leistungsprobleme zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="94cc4-287">It is useful for preventing the performance problems associated with failed matches.</span></span>  
  
 <span data-ttu-id="94cc4-288">Das folgende Beispiel zeigt, wie das Unterdrücken der Rückverfolgung bei Verwendung von geschachtelten Quantifizierern die Leistung verbessert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-288">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="94cc4-289">Es wird gemessen, wie viel Zeit die Engine für reguläre Ausdrücke benötigt, um zu ermitteln, dass eine Eingabezeichenfolge nicht mit zwei regulären Ausdrücken übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-289">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="94cc4-290">Der erste reguläre Ausdruck verwendet die Rückverfolgung, um eine Übereinstimmung mit einer Zeichenfolge zu finden, in der Folgendes ein Mal oder mehrmals vorkommt: eine oder mehrere hexadezimale Ziffern, gefolgt von einem Doppelpunkt, gefolgt von einer oder mehreren hexadezimalen Ziffern, gefolgt von zwei Doppelpunkten.</span><span class="sxs-lookup"><span data-stu-id="94cc4-290">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="94cc4-291">Der zweite reguläre Ausdruck ist mit dem ersten identisch, mit der Ausnahme, dass dieser die Rückverfolgung deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-291">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="94cc4-292">Wie die Ausgabe im Beispiel zeigt, ist die Leistungsverbesserung durch das Deaktivieren der Rückverfolgung signifikant.</span><span class="sxs-lookup"><span data-stu-id="94cc4-292">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a><span data-ttu-id="94cc4-293">Lookbehindassertionen</span><span class="sxs-lookup"><span data-stu-id="94cc4-293">Lookbehind Assertions</span></span>  
 <span data-ttu-id="94cc4-294">.NET enthält zwei Sprachelemente, `(?<=`*Teilausdruck*`)` und `(?<!`*Teilausdruck*`)`, die mit dem bzw. den vorherigen Zeichen in der Eingabezeichenfolge übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-294">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="94cc4-295">Beide Sprachelemente sind Assertionen mit einer Breite von 0. Das heißt, sie bestimmen ohne Vorlaufen oder Rückverfolgung, ob eine Übereinstimmung des oder der Zeichen unmittelbar vor dem aktuellen Zeichen mit *Teilausdruck*vorliegt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-295">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="94cc4-296">`(?<=` *Teilausdruck* `)` ist eine positive Lookbehindassertion. Das heißt, das oder die Zeichen vor der aktuellen Position muss bzw. müssen mit *Teilausdruck*übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-296">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="94cc4-297">`(?<!`*Teilausdruck*`)` ist eine negative Lookbehindassertion. Das heißt, das oder die Zeichen vor der aktuellen Position muss bzw. müssen nicht mit *Teilausdruck*übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-297">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="94cc4-298">Positive und negative Lookbehindassertionen sind besonders hilfreich, wenn *Teilausdruck* eine Teilmenge des vorherigen Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="94cc4-298">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="94cc4-299">Im folgenden Beispiel werden zwei äquivalente reguläre Ausdrucksmuster verwendet, die den Benutzernamen in einer E-Mail-Adresse überprüfen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-299">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="94cc4-300">Aufgrund übermäßiger Rückverfolgung tritt beim ersten Muster eine schlechte Leistung auf.</span><span class="sxs-lookup"><span data-stu-id="94cc4-300">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="94cc4-301">Das zweite Muster ist eine Änderung des ersten regulären Ausdrucks, indem ein geschachtelter Quantifizierer durch eine positive Lookbehindassertion ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-301">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="94cc4-302">In der Beispielausgabe wird die Ausführungszeit der <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode angezeigt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-302">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="94cc4-303">Das erste Muster für reguläre Ausdrücke `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-303">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="94cc4-304">Muster</span><span class="sxs-lookup"><span data-stu-id="94cc4-304">Pattern</span></span>|<span data-ttu-id="94cc4-305">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="94cc4-305">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="94cc4-306">Die Suche nach Übereinstimmungen soll am Anfang der Zeichenfolge beginnen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-306">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="94cc4-307">Übereinstimmung mit einem alphanumerischen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-307">Match an alphanumeric character.</span></span> <span data-ttu-id="94cc4-308">Bei diesem Vergleich wird die Groß-/Kleinschreibung nicht beachtet, da die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-308">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="94cc4-309">Übereinstimmung mit keinem, einem oder mehreren Vorkommen eines Bindestrichs, eines Punkts oder eines Wortzeichens.</span><span class="sxs-lookup"><span data-stu-id="94cc4-309">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="94cc4-310">Übereinstimmung mit einem alphanumerischen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-310">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="94cc4-311">Übereinstimmung mit keinem oder mehreren Vorkommen der Kombination aus keinem oder mehreren Bindestrichen, Punkten oder Wortzeichen, gefolgt von einem alphanumerischen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-311">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="94cc4-312">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="94cc4-312">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="94cc4-313">Übereinstimmung mit einem \@-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-313">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="94cc4-314">Das zweite Muster für reguläre Ausdrücke `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`verwendet eine positive Lookbehindassertion.</span><span class="sxs-lookup"><span data-stu-id="94cc4-314">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="94cc4-315">Das Muster wird wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-315">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="94cc4-316">Muster</span><span class="sxs-lookup"><span data-stu-id="94cc4-316">Pattern</span></span>|<span data-ttu-id="94cc4-317">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="94cc4-317">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="94cc4-318">Die Suche nach Übereinstimmungen soll am Anfang der Zeichenfolge beginnen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-318">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="94cc4-319">Übereinstimmung mit einem alphanumerischen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-319">Match an alphanumeric character.</span></span> <span data-ttu-id="94cc4-320">Bei diesem Vergleich wird die Groß-/Kleinschreibung nicht beachtet, da die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-320">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="94cc4-321">Übereinstimmung mit keinem oder mehreren Vorkommen eines Bindestrichs, eines Punkts oder eines Wortzeichens.</span><span class="sxs-lookup"><span data-stu-id="94cc4-321">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="94cc4-322">Überprüfung des letzten übereinstimmenden Zeichens und Fortsetzen des Abgleichs, wenn es sich um ein alphanumerisches Zeichen handelt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-322">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="94cc4-323">Beachten Sie, dass alphanumerische Zeichen eine Teilmenge des Satzes sind, der aus Punkten, Bindestrichen und allen Wortzeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="94cc4-323">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="94cc4-324">Übereinstimmung mit einem \@-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-324">Match an at sign ("\@").</span></span>|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a><span data-ttu-id="94cc4-325">Lookaheadassertionen</span><span class="sxs-lookup"><span data-stu-id="94cc4-325">Lookahead Assertions</span></span>  
 <span data-ttu-id="94cc4-326">.NET enthält zwei Sprachelemente, `(?=`*Teilausdruck*`)` und `(?!`*Teilausdruck*`)`, die mit dem bzw. den nächsten Zeichen in der Eingabezeichenfolge übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-326">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="94cc4-327">Beide Sprachelemente sind Assertionen mit einer Breite von 0. Das heißt, sie bestimmen ohne Vorlaufen oder Rückverfolgung, ob eine Übereinstimmung des oder der Zeichen unmittelbar nach dem aktuellen Zeichen mit *Teilausdruck*vorliegt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-327">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="94cc4-328">`(?=` *Teilausdruck* `)` ist eine positive Lookaheadassertion. Das heißt, das oder die Zeichen nach der aktuellen Position muss bzw. müssen mit *Teilausdruck*übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-328">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="94cc4-329">`(?!`*Teilausdruck*`)` ist eine negative Lookaheadassertion. Das heißt, das oder die Zeichen nach der aktuellen Position muss bzw. müssen nicht mit *Teilausdruck*übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-329">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="94cc4-330">Positive und negative Lookaheadassertionen sind besonders hilfreich, wenn *Teilausdruck* eine Teilmenge des nächsten Teilausdrucks ist.</span><span class="sxs-lookup"><span data-stu-id="94cc4-330">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="94cc4-331">Im folgenden Beispiel werden zwei äquivalente Muster für reguläre Ausdrücke verwendet, die einen vollqualifizierten Typnamen überprüfen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-331">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="94cc4-332">Aufgrund übermäßiger Rückverfolgung tritt beim ersten Muster eine schlechte Leistung auf.</span><span class="sxs-lookup"><span data-stu-id="94cc4-332">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="94cc4-333">Das zweite Muster ist eine Änderung des ersten regulären Ausdrucks, indem ein geschachtelter Quantifizierer durch eine positive Lookaheadassertion ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-333">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="94cc4-334">In der Beispielausgabe wird die Ausführungszeit der <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode angezeigt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-334">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="94cc4-335">Das erste Muster für reguläre Ausdrücke `^(([A-Z]\w*)+\.)*[A-Z]\w*$`ist wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-335">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="94cc4-336">Muster</span><span class="sxs-lookup"><span data-stu-id="94cc4-336">Pattern</span></span>|<span data-ttu-id="94cc4-337">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="94cc4-337">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="94cc4-338">Die Suche nach Übereinstimmungen soll am Anfang der Zeichenfolge beginnen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-338">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="94cc4-339">Übereinstimmung mit einem Buchstaben (A-Z), gefolgt von keinem oder mehreren Wortzeichen (einmaliges oder mehrmaliges Vorkommen), gefolgt von einem Punkt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-339">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="94cc4-340">Bei diesem Vergleich wird die Groß-/Kleinschreibung nicht beachtet, da die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-340">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="94cc4-341">Keine oder mehrmalige Übereinstimmung mit dem vorherigen Muster.</span><span class="sxs-lookup"><span data-stu-id="94cc4-341">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="94cc4-342">Übereinstimmung mit einem Buchstaben, gefolgt von keinem oder mehreren Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-342">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="94cc4-343">Ende des Abgleichs am Ende der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="94cc4-343">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="94cc4-344">Das zweite Muster für reguläre Ausdrücke `^((?=[A-Z])\w+\.)*[A-Z]\w*$`verwendet eine positive Lookaheadassertion.</span><span class="sxs-lookup"><span data-stu-id="94cc4-344">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="94cc4-345">Das Muster wird wie in der folgenden Tabelle gezeigt definiert.</span><span class="sxs-lookup"><span data-stu-id="94cc4-345">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="94cc4-346">Muster</span><span class="sxs-lookup"><span data-stu-id="94cc4-346">Pattern</span></span>|<span data-ttu-id="94cc4-347">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="94cc4-347">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="94cc4-348">Die Suche nach Übereinstimmungen soll am Anfang der Zeichenfolge beginnen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-348">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="94cc4-349">Lookahead zum ersten Zeichen und die Suche nach Übereinstimmungen fortsetzen, wenn es sich um einen Buchstaben (A-Z) handelt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-349">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="94cc4-350">Bei diesem Vergleich wird die Groß-/Kleinschreibung nicht beachtet, da die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType>-Methode mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="94cc4-350">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="94cc4-351">Übereinstimmung mit einem oder mehreren Wortzeichen, gefolgt von einem Punkt.</span><span class="sxs-lookup"><span data-stu-id="94cc4-351">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="94cc4-352">Übereinstimmung mit dem Muster aus einem oder mehreren Wortzeichen, gefolgt von keinem oder mehreren Vorkommen eines Punkts.</span><span class="sxs-lookup"><span data-stu-id="94cc4-352">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="94cc4-353">Das erste Wortzeichen muss ein Buchstabe sein.</span><span class="sxs-lookup"><span data-stu-id="94cc4-353">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="94cc4-354">Übereinstimmung mit einem Buchstaben, gefolgt von keinem oder mehreren Wortzeichen.</span><span class="sxs-lookup"><span data-stu-id="94cc4-354">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="94cc4-355">Ende des Abgleichs am Ende der Eingabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="94cc4-355">End the match at the end of the input string.</span></span>|  
  
 [<span data-ttu-id="94cc4-356">Zurück zum Anfang</span><span class="sxs-lookup"><span data-stu-id="94cc4-356">Back to top</span></span>](#top)  
  
## <a name="see-also"></a><span data-ttu-id="94cc4-357">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="94cc4-357">See also</span></span>

- [<span data-ttu-id="94cc4-358">Reguläre Ausdrücke von .NET</span><span class="sxs-lookup"><span data-stu-id="94cc4-358">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)  
- [<span data-ttu-id="94cc4-359">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</span><span class="sxs-lookup"><span data-stu-id="94cc4-359">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
- [<span data-ttu-id="94cc4-360">Quantifizierer</span><span class="sxs-lookup"><span data-stu-id="94cc4-360">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)  
- [<span data-ttu-id="94cc4-361">Alternierungskonstrukte</span><span class="sxs-lookup"><span data-stu-id="94cc4-361">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)  
- [<span data-ttu-id="94cc4-362">Gruppierungskonstrukte</span><span class="sxs-lookup"><span data-stu-id="94cc4-362">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
