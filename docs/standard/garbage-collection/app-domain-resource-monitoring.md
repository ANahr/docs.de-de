---
title: "Überwachung von Anwendungsdomänenressourcen"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- monitoring managed memory use by application domain
- application domains, memory use
- memory use, monitoring
- application domains, resource monitoring
ms.assetid: 318bedf8-7f35-4f00-b34a-2b7b8e3fa315
caps.latest.revision: "8"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 62a514f94857044af5020d36a1cfd6ce06741ac7
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/21/2017
---
# <a name="application-domain-resource-monitoring"></a><span data-ttu-id="6b849-102">Überwachung von Anwendungsdomänenressourcen</span><span class="sxs-lookup"><span data-stu-id="6b849-102">Application Domain Resource Monitoring</span></span>
<span data-ttu-id="6b849-103">Von Anwendungsdomänenressourcen (ARM) überwachen kann Hosts CPU- und speicherauslastung pro Anwendungsdomäne überwachen.</span><span class="sxs-lookup"><span data-stu-id="6b849-103">Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.</span></span> <span data-ttu-id="6b849-104">Dies ist nützlich für Hosts wie z. B. ASP.NET, die viele Anwendungsdomänen in einem langer Prozess verwenden.</span><span class="sxs-lookup"><span data-stu-id="6b849-104">This is useful for hosts such as ASP.NET that use many application domains in a long-running process.</span></span> <span data-ttu-id="6b849-105">Der Host kann einer Anwendung die Anwendungsdomäne entladen, von denen sich negativ auf die Leistung des gesamten Prozesses, jedoch nur betroffen ist, wenn die problematische Anwendung identifiziert werden kann.</span><span class="sxs-lookup"><span data-stu-id="6b849-105">The host can unload the application domain of an application that is adversely affecting the performance of the entire process, but only if it can identify the problematic application.</span></span> <span data-ttu-id="6b849-106">ARM-Informationen, die verwendet werden können, um solche Entscheidungen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="6b849-106">ARM provides information that can be used to assist in making such decisions.</span></span>  
  
 <span data-ttu-id="6b849-107">Z. B. möglicherweise einem Hostingdienst vieler Anwendungen unter ASP.NET-Servern.</span><span class="sxs-lookup"><span data-stu-id="6b849-107">For example, a hosting service might have many applications running on an ASP.NET server.</span></span> <span data-ttu-id="6b849-108">Wenn eine Anwendung im Prozess zu viel Arbeitsspeicher oder zu viel Prozessorzeit nutzen beginnt, können des Hostingdiensts ARM um die Anwendungsdomäne zu identifizieren, die das Problem verursacht.</span><span class="sxs-lookup"><span data-stu-id="6b849-108">If one application in the process begins consuming too much memory or too much processor time, the hosting service can use ARM to identify the application domain that is causing the problem.</span></span>  
  
 <span data-ttu-id="6b849-109">ARM ist ausreichend einfache in live-Anwendungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="6b849-109">ARM is sufficiently lightweight to use in live applications.</span></span> <span data-ttu-id="6b849-110">Sie können die Informationen zugreifen, mithilfe von ereignisablaufverfolgung für Windows (ETW) oder direkt über verwalteten oder systemeigenen APIs.</span><span class="sxs-lookup"><span data-stu-id="6b849-110">You can access the information by using event tracing for Windows (ETW) or directly through managed or native APIs.</span></span>  
  
## <a name="enabling-resource-monitoring"></a><span data-ttu-id="6b849-111">Aktivieren der Überwachung der Ressource</span><span class="sxs-lookup"><span data-stu-id="6b849-111">Enabling Resource Monitoring</span></span>  
 <span data-ttu-id="6b849-112">ARM kann auf vier Arten aktiviert werden: durch eine Konfigurationsdatei anzugeben, wenn die common Language Runtime (CLR) gestartet wird, mithilfe einer nicht verwalteten hosting-API mit verwaltetem Code oder durch das Überwachen von ARM-ETW-Ereignissen.</span><span class="sxs-lookup"><span data-stu-id="6b849-112">ARM can be enabled in four ways: by supplying a configuration file when the common language runtime (CLR) is started, by using an unmanaged hosting API, by using managed code, or by listening to ARM ETW events.</span></span>  
  
 <span data-ttu-id="6b849-113">Sobald ARM aktiviert ist, beginnt das Sammeln von Daten für alle Anwendungsdomänen im Prozess. Wenn eine Anwendungsdomäne erstellt wurde, bevor die ARM aktiviert ist, beginnt kumulierte Daten ARM aktiviert ist, nicht verwendet werden, wenn die Anwendungsdomäne erstellt wurde. Sobald er aktiviert ist, kann die ARM nicht deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="6b849-113">As soon as ARM is enabled, it begins collecting data on all application domains in the process.If an application domain was created before ARM is enabled, cumulative data starts when ARM is enabled, not when the application domain was created.Once it is enabled, ARM cannot be disabled.</span></span>  
  
-   <span data-ttu-id="6b849-114">Kann ARM an CLR-Starts durch Hinzufügen der [ \<AppDomainResourceMonitoring >](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) Element auf die Konfigurationsdatei und das Festlegen der `enabled` -Attribut `true`.</span><span class="sxs-lookup"><span data-stu-id="6b849-114">You can enable ARM at CLR startup by adding the [\<appDomainResourceMonitoring>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) element to the configuration file, and setting the `enabled` attribute to `true`.</span></span> <span data-ttu-id="6b849-115">Der Wert `false` (Standard) bedeutet lediglich, dass ARM beim Start nicht aktiviert ist, können später mithilfe einer der anderen Mechanismen, die Aktivierung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="6b849-115">A value of `false` (the default) means only that ARM is not enabled at startup; you can activate it later by using one of the other activation mechanisms.</span></span>  
  
-   <span data-ttu-id="6b849-116">Der Host kann ARM aktivieren, indem er die [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) Hostingschnittstelle.</span><span class="sxs-lookup"><span data-stu-id="6b849-116">The host can enable ARM by requesting the [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) hosting interface.</span></span> <span data-ttu-id="6b849-117">Sobald diese Schnittstelle erfolgreich abgerufen wird, wird die ARM aktiviert.</span><span class="sxs-lookup"><span data-stu-id="6b849-117">Once this interface is successfully obtained, ARM is enabled.</span></span>  
  
-   <span data-ttu-id="6b849-118">Verwalteter Code kann durch Festlegen der statischen ARM aktivieren (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> Eigenschaft `true`.</span><span class="sxs-lookup"><span data-stu-id="6b849-118">Managed code can enable ARM by setting the static (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> property to `true`.</span></span> <span data-ttu-id="6b849-119">Sobald die Eigenschaft festgelegt ist, wird ARM aktiviert.</span><span class="sxs-lookup"><span data-stu-id="6b849-119">As soon as the property is set, ARM is enabled.</span></span>  
  
-   <span data-ttu-id="6b849-120">Überwachen von ETW-Ereignissen, um ARM nach dem Start zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="6b849-120">You can enable ARM after startup by listening to ETW events.</span></span> <span data-ttu-id="6b849-121">ARM wird aktiviert und startet das Auslösen von Ereignissen für alle Anwendungsdomänen, wenn Sie den öffentlichen Anbieter aktivieren `Microsoft-Windows-DotNETRuntime` mithilfe der `AppDomainResourceManagementKeyword` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="6b849-121">ARM is enabled and begins raising events for all application domains when you enable the public provider `Microsoft-Windows-DotNETRuntime` by using the `AppDomainResourceManagementKeyword` keyword.</span></span> <span data-ttu-id="6b849-122">Sie müssen auch aktivieren, um Daten mit Anwendungsdomänen und Threads zu korrelieren, die `Microsoft-Windows-DotNETRuntimeRundown` Anbieter mit der `ThreadingKeyword` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="6b849-122">To correlate data with application domains and threads, you must also enable the `Microsoft-Windows-DotNETRuntimeRundown` provider with the `ThreadingKeyword` keyword.</span></span>  
  
## <a name="using-arm"></a><span data-ttu-id="6b849-123">Verwenden ARM</span><span class="sxs-lookup"><span data-stu-id="6b849-123">Using ARM</span></span>  
 <span data-ttu-id="6b849-124">ARM bietet die gesamte Prozessorzeit, die von einer Anwendungsdomäne und drei Arten von Informationen zur Speicherverwendung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6b849-124">ARM provides the total processor time that is used by an application domain and three kinds of information about memory use.</span></span>  
  
-   <span data-ttu-id="6b849-125">**Gesamtprozessorzeit für eine Anwendungsdomäne, in Sekunden**: Dies wird durch Addieren der Threadzeiten, die vom Betriebssystem für alle Threads, die für die Ausführungszeit in der Anwendungsdomäne während seiner Lebensdauer gemeldet berechnet.</span><span class="sxs-lookup"><span data-stu-id="6b849-125">**Total processor time for an application domain, in seconds**: This is calculated by adding up the thread times reported by the operating system for all threads that spent time executing in the application domain during its lifetime.</span></span> <span data-ttu-id="6b849-126">Blockiert, oder verwenden Sie Threads im Ruhezustand nicht Prozessorzeit.</span><span class="sxs-lookup"><span data-stu-id="6b849-126">Blocked or sleeping threads do not use processor time.</span></span> <span data-ttu-id="6b849-127">Wenn ein Thread in systemeigenen Code aufruft, ist die Zeit des Threads in systemeigenem Code an, die in der Anzahl der für die Anwendungsdomäne enthalten, in dem der Aufruf erfolgte.</span><span class="sxs-lookup"><span data-stu-id="6b849-127">When a thread calls into native code, the time that the thread spends in native code is included in the count for the application domain where the call was made.</span></span>  
  
    -   <span data-ttu-id="6b849-128">Verwaltete API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="6b849-128">Managed API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="6b849-129">Hosting-API: [ICLRAppDomainResourceMonitor:: GetCurrentCpuTime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) Methode.</span><span class="sxs-lookup"><span data-stu-id="6b849-129">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) method.</span></span>  
  
    -   <span data-ttu-id="6b849-130">ETW-Ereignisse: `ThreadCreated`, `ThreadAppDomainEnter`, und `ThreadTerminated` Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="6b849-130">ETW events: `ThreadCreated`, `ThreadAppDomainEnter`, and `ThreadTerminated` events.</span></span> <span data-ttu-id="6b849-131">Informationen über Anbieter und Schlüsselwörter finden Sie unter "Überwachen von Ereignissen für Ressource" im [CLR-ETW-Ereignisse](../../../docs/framework/performance/clr-etw-events.md).</span><span class="sxs-lookup"><span data-stu-id="6b849-131">For information about providers and keywords, see "AppDomain Resource Monitoring Events" in [CLR ETW Events](../../../docs/framework/performance/clr-etw-events.md).</span></span>  
  
-   <span data-ttu-id="6b849-132">**Insgesamt verwaltete Zuordnungen, die durch eine Anwendungsdomäne während seiner Lebensdauer in Byte vorgenommen**: gesamte speicherbelegungen immer spiegeln nicht arbeitsspeicherverwendung durch eine Anwendungsdomäne, da die zugeordneten Objekte kurzlebige sein könnten.</span><span class="sxs-lookup"><span data-stu-id="6b849-132">**Total managed allocations made by an application domain during its lifetime, in bytes**: Total allocations do not always reflect memory use by an application domain, because the allocated objects might be short-lived.</span></span> <span data-ttu-id="6b849-133">Wenn eine Anwendung belegt und gibt die große Anzahl von Objekten frei, konnte die Kosten für die Zuordnung jedoch erheblich sein.</span><span class="sxs-lookup"><span data-stu-id="6b849-133">However, if an application allocates and frees huge numbers of objects, the cost of the allocations could be significant.</span></span>  
  
    -   <span data-ttu-id="6b849-134">Verwaltete API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="6b849-134">Managed API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="6b849-135">Hosting-API: [ICLRAppDomainResourceMonitor:: GetCurrentAllocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) Methode.</span><span class="sxs-lookup"><span data-stu-id="6b849-135">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) method.</span></span>  
  
    -   <span data-ttu-id="6b849-136">ETW-Ereignisse: `AppDomainMemAllocated` Ereignis `Allocated` Feld.</span><span class="sxs-lookup"><span data-stu-id="6b849-136">ETW events: `AppDomainMemAllocated` event, `Allocated` field.</span></span>  
  
-   <span data-ttu-id="6b849-137">**Verwalteter Speicher in Bytes, auf das durch eine Anwendungsdomäne verwiesen wird und der nach der letzten vollständigen blockierenden Auflistung**: Dieser Wert ist genau nur nach einer vollständigen blockierenden Auflistung.</span><span class="sxs-lookup"><span data-stu-id="6b849-137">**Managed memory, in bytes, that is referenced by an application domain and that survived the most recent full, blocking collection**: This number is accurate only after a full, blocking collection.</span></span> <span data-ttu-id="6b849-138">(Dies ist im Gegensatz zur gleichzeitigen Garbage Collections, die im Hintergrund ausgeführt und die Anwendung nicht blockieren.) Z. B. die <xref:System.GC.Collect?displayProperty=nameWithType> methodenüberladung bewirkt, dass eine vollständige blockierende Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="6b849-138">(This is in contrast to concurrent collections, which occur in the background and do not block the application.) For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload causes a full, blocking collection.</span></span>  
  
    -   <span data-ttu-id="6b849-139">Verwaltete API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="6b849-139">Managed API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="6b849-140">Hosting-API: [ICLRAppDomainResourceMonitor:: GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) Methode `pAppDomainBytesSurvived` Parameter.</span><span class="sxs-lookup"><span data-stu-id="6b849-140">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pAppDomainBytesSurvived` parameter.</span></span>  
  
    -   <span data-ttu-id="6b849-141">ETW-Ereignisse: `AppDomainMemSurvived` Ereignis `Survived` Feld.</span><span class="sxs-lookup"><span data-stu-id="6b849-141">ETW events: `AppDomainMemSurvived` event, `Survived` field.</span></span>  
  
-   <span data-ttu-id="6b849-142">**Gesamtanzahl der verwalteten Speicher in Bytes, die vom Prozess verwiesen wird und der nach der letzten vollständigen blockierenden Auflistung**: der Speicher für einzelne Anwendungsdomänen an diese Nummer verglichen werden kann.</span><span class="sxs-lookup"><span data-stu-id="6b849-142">**Total managed memory, in bytes, that is referenced by the process and that survived the most recent full, blocking collection**: The survived memory for individual application domains can be compared to this number.</span></span>  
  
    -   <span data-ttu-id="6b849-143">Verwaltete API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="6b849-143">Managed API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="6b849-144">Hosting-API: [ICLRAppDomainResourceMonitor:: GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) Methode `pTotalBytesSurvived` Parameter.</span><span class="sxs-lookup"><span data-stu-id="6b849-144">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pTotalBytesSurvived` parameter.</span></span>  
  
    -   <span data-ttu-id="6b849-145">ETW-Ereignisse: `AppDomainMemSurvived` Ereignis `ProcessSurvived` Feld.</span><span class="sxs-lookup"><span data-stu-id="6b849-145">ETW events: `AppDomainMemSurvived` event, `ProcessSurvived` field.</span></span>  
  
### <a name="determining-when-a-full-blocking-collection-occurs"></a><span data-ttu-id="6b849-146">Bestimmen, wenn eine vollständige stattfindet blockierende Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="6b849-146">Determining When a Full, Blocking Collection Occurs</span></span>  
 <span data-ttu-id="6b849-147">Um zu bestimmen, wenn für die Anzahl der beibehaltenen Speichers korrekt sind, müssen Sie wissen, wenn nur eine vollständigen blockierende Auflistung aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="6b849-147">To determine when counts of survived memory are accurate, you need to know when a full, blocking collection has just occurred.</span></span> <span data-ttu-id="6b849-148">Die Methode für diese Vorgehensweise hängt von der API, die Sie verwenden, um die ARM-Statistik untersuchen.</span><span class="sxs-lookup"><span data-stu-id="6b849-148">The method for doing this depends on the API you use to examine ARM statistics.</span></span>  
  
#### <a name="managed-api"></a><span data-ttu-id="6b849-149">Verwaltete API</span><span class="sxs-lookup"><span data-stu-id="6b849-149">Managed API</span></span>  
 <span data-ttu-id="6b849-150">Wenn Sie die Eigenschaften der verwenden der <xref:System.AppDomain> -Klasse, die Sie verwenden die <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> Methode, um die Registrierung für die Benachrichtigung über vollständige Garbage Collections.</span><span class="sxs-lookup"><span data-stu-id="6b849-150">If you use the properties of the <xref:System.AppDomain> class, you can use the <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> method to register for notification of full collections.</span></span> <span data-ttu-id="6b849-151">Schwellenwert, den Sie verwenden, ist nicht wichtig,, weil Sie darauf, für den Abschluss einer Auflistung anstelle der Ansatz einer Auflistung warten.</span><span class="sxs-lookup"><span data-stu-id="6b849-151">The threshold you use is not important, because you are waiting for the completion of a collection rather than the approach of a collection.</span></span> <span data-ttu-id="6b849-152">Rufen Sie dann die <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> Methode, die blockiert, bis eine vollständige Auflistung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="6b849-152">You can then call the <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> method, which blocks until a full collection has completed.</span></span> <span data-ttu-id="6b849-153">Sie können einen Thread erstellen, der die Methode in einer Schleife aufgerufen und eine Analyse erforderlich ist, wenn die-Methode zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="6b849-153">You can create a thread that calls the method in a loop and does any necessary analysis whenever the method returns.</span></span>  
  
 <span data-ttu-id="6b849-154">Alternativ können Sie rufen die <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> Methode in regelmäßigen Abständen, um festzustellen, ob die Anzahl der Garbage Collections der Generation 2 erhöht hat.</span><span class="sxs-lookup"><span data-stu-id="6b849-154">Alternatively, you can call the <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> method periodically to see if the count of generation 2 collections has increased.</span></span> <span data-ttu-id="6b849-155">Je nach das Abrufintervall möglicherweise dieses Verfahren nicht genau ein Hinweis auf das Vorkommen einer vollständigen Auflistung bereit.</span><span class="sxs-lookup"><span data-stu-id="6b849-155">Depending on the polling frequency, this technique might not provide as accurate an indication of the occurrence of a full collection.</span></span>  
  
#### <a name="hosting-api"></a><span data-ttu-id="6b849-156">Hosting-API</span><span class="sxs-lookup"><span data-stu-id="6b849-156">Hosting API</span></span>  
 <span data-ttu-id="6b849-157">Wenn Sie die nicht verwaltete hosting-API verwenden, der Host muss übergeben der CLR eine Implementierung der [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md) Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="6b849-157">If you use the unmanaged hosting API, your host must pass the CLR an implementation of the [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md) interface.</span></span> <span data-ttu-id="6b849-158">Die CLR ruft die [IHostGCManager:: SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) Methode, wenn die Ausführung des Threads wird, die angehalten wurden fortgesetzt, während eine Sammlung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6b849-158">The CLR calls the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method when it resumes execution of threads that have been suspended while a collection occurs.</span></span> <span data-ttu-id="6b849-159">Die CLR übergibt die Generierung der abgeschlossenen Auflistung als Parameter der Methode, damit der Host bestimmen kann, ob die Auflistung vollständig oder teilweise war.</span><span class="sxs-lookup"><span data-stu-id="6b849-159">The CLR passes the generation of the completed collection as a parameter of the method, so the host can determine whether the collection was full or partial.</span></span> <span data-ttu-id="6b849-160">Die Implementierung der [IHostGCManager:: SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) Methode kann Abfragen für Speicher, um sicherzustellen, dass die Werte abgerufen werden, sobald sie aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="6b849-160">Your implementation of the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method can query for survived memory, to ensure that the counts are retrieved as soon as they are updated.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6b849-161">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="6b849-161">See Also</span></span>  
 <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>  
 [<span data-ttu-id="6b849-162">ICLRAppDomainResourceMonitor-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="6b849-162">ICLRAppDomainResourceMonitor Interface</span></span>](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md)  
 [<span data-ttu-id="6b849-163">\<appDomainResourceMonitoring></span><span class="sxs-lookup"><span data-stu-id="6b849-163">\<appDomainResourceMonitoring></span></span>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)  
 [<span data-ttu-id="6b849-164">CLR-ETW-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="6b849-164">CLR ETW Events</span></span>](../../../docs/framework/performance/clr-etw-events.md)
