---
title: Grundlagen zur Beschleunigung in PLINQ
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="ba372-102">Grundlagen zur Beschleunigung in PLINQ</span><span class="sxs-lookup"><span data-stu-id="ba372-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="ba372-103">Der primäre Zweck von PLINQ ist, um die Ausführung von LINQ to Objects-Abfragen beschleunigen, indem Sie die Delegaten für die Abfrage parallel auf Computern mit mehreren Kernen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ba372-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="ba372-104">PLINQ führt am besten auf, wenn die Verarbeitung der einzelnen Elemente in einer quellauflistung unabhängig, ohne gemeinsam genutzten Zustand zwischen den einzelnen Delegaten beteiligt ist.</span><span class="sxs-lookup"><span data-stu-id="ba372-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="ba372-105">Solche Vorgänge sind häufig in LINQ to Objects und PLINQ und werden oft als "*Parallelschleife*", da sie gut für die Planung in mehreren Threads.</span><span class="sxs-lookup"><span data-stu-id="ba372-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="ba372-106">Nicht alle Abfragen werden jedoch vollständig aus optimal parallelen Vorgängen bestehen; in den meisten Fällen umfasst eine Abfrage einige Operatoren, die entweder nicht parallelisiert werden, oder, die parallele Ausführung verlangsamt.</span><span class="sxs-lookup"><span data-stu-id="ba372-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="ba372-107">Und auch bei Abfragen, die vollständig optimal parallel sind, PLINQ muss noch die Datenquelle partitionieren planen die Arbeit für die Threads und in der Regel die Ergebnisse zusammenführen, wenn die Abfrage abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ba372-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="ba372-108">Alle diese Vorgänge hinzufügen zu den Rechenaufwand für die Parallelisierung; Diese Kosten zum Hinzufügen von Parallelisierung heißen *Aufwand*.</span><span class="sxs-lookup"><span data-stu-id="ba372-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="ba372-109">Zum Erzielen einer optimalen Leistung in einer PLINQ-Abfrage besteht das Ziel darin, die Teile, die optimal parallelen maximieren und minimieren die Teile, die Aufwand erfordern.</span><span class="sxs-lookup"><span data-stu-id="ba372-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="ba372-110">Dieser Artikel enthält Informationen, mit denen Sie PLINQ-Abfragen schreiben, die noch keine richtigen Ergebnisse so effizient wie möglich sind.</span><span class="sxs-lookup"><span data-stu-id="ba372-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="ba372-111">Faktoren, die Leistung von PLINQ-Abfragen auswirken.</span><span class="sxs-lookup"><span data-stu-id="ba372-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="ba372-112">In den folgenden Abschnitten werden einige der wichtigsten Faktoren, die diese Leistungseinbußen für die parallele Abfrage aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="ba372-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="ba372-113">Hierbei handelt es sich um allgemeine Anweisungen, die selbst nicht ausreichend, um die abfrageleistung in allen Fällen vorhergesagt werden.</span><span class="sxs-lookup"><span data-stu-id="ba372-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="ba372-114">Wie immer, ist es wichtig, zum Messen der tatsächlichen Leistung auf Computern bestimmte Abfragen mit einer Reihe von repräsentative Konfigurationen und lädt.</span><span class="sxs-lookup"><span data-stu-id="ba372-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="ba372-115">Rechenaufwand für die gesamte Arbeit.</span><span class="sxs-lookup"><span data-stu-id="ba372-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="ba372-116">Um die Beschleunigung zu erreichen, benötigen eine PLINQ-Abfrage genügend optimal parallelen Arbeit, um den Mehraufwand auszugleichen.</span><span class="sxs-lookup"><span data-stu-id="ba372-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="ba372-117">Die Arbeit kann als den Rechenaufwand für jeden Delegaten multipliziert mit der Anzahl der Elemente in der quellauflistung ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="ba372-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="ba372-118">Vorausgesetzt, dass ein Vorgang kann, desto stärker rechnerisch parallelisiert werden teure es, größer ist die Gelegenheit für Beschleunigung.</span><span class="sxs-lookup"><span data-stu-id="ba372-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="ba372-119">Wenn eine Funktion zum Ausführen einer Millisekunde ausgeführt wird, kann z. B. eine sequenzielle Abfrage mehr als 1000 Elemente einer Sekunde zum Ausführen dieses Vorgangs dauert, wohingegen eine parallele Abfrage auf einem Computer mit vier Kernen nur 250 Millisekunden dauern.</span><span class="sxs-lookup"><span data-stu-id="ba372-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="ba372-120">Dies ergibt eine Beschleunigung von 750 Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="ba372-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="ba372-121">Bei Bedarf die Funktion einer Sekunde, die für jedes Element ausgeführt würde die Beschleunigung 750 Sekunden betragen.</span><span class="sxs-lookup"><span data-stu-id="ba372-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="ba372-122">Wenn der Delegat sehr aufwendig ist, kann PLINQ erhebliche Beschleunigung mit nur wenige Elemente in der quellauflistung bieten.</span><span class="sxs-lookup"><span data-stu-id="ba372-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="ba372-123">Im Gegensatz dazu sind kleine quellauflistung mit trivialen Delegaten im Allgemeinen nicht geeignet für PLINQ.</span><span class="sxs-lookup"><span data-stu-id="ba372-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="ba372-124">Im folgenden Beispiel ist QueryA wahrscheinlich ein guter Kandidat für PLINQ, vorausgesetzt, dass die Select-Funktion eine Menge Arbeit umfasst.</span><span class="sxs-lookup"><span data-stu-id="ba372-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="ba372-125">QueryB ist wahrscheinlich nicht geeignet, da es nicht genügend Arbeitsvorgänge in der Select-Anweisung ist und der Aufwand der Parallelisierung wird die meisten oder alle der Beschleunigung der offset.</span><span class="sxs-lookup"><span data-stu-id="ba372-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="ba372-126">Die Anzahl der logischen Kerne im System (Grad an Parallelität).</span><span class="sxs-lookup"><span data-stu-id="ba372-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="ba372-127">Dieser Punkt ist eine offensichtliche begleitende im vorherigen Abschnitt, Abfragen, die optimal parallelen ausführen schneller auf Computern mit mehr Kerne, da die Arbeit auf mehrere gleichzeitige Threads aufgeteilt werden kann.</span><span class="sxs-lookup"><span data-stu-id="ba372-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="ba372-128">Die Gesamtmenge an Beschleunigung hängt davon ab, welcher Prozentsatz der gesamten Arbeit der Abfrage parallelisiert wird.</span><span class="sxs-lookup"><span data-stu-id="ba372-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="ba372-129">Sollte Sie jedoch nicht davon ausgegangen, dass alle Abfragen, zweimal so ausgeführt werden schnell auf einem Computer mit acht Kernen als eine vier-Core-Computer.</span><span class="sxs-lookup"><span data-stu-id="ba372-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="ba372-130">Beim Abfragen für eine optimale Leistung zu optimieren, ist es wichtig, zum Messen der tatsächlichen Ergebnisse auf Computern mit einer unterschiedlichen Anzahl von Kernen.</span><span class="sxs-lookup"><span data-stu-id="ba372-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="ba372-131">Dieser Punkt bezieht sich auf #1 zeigen: größeren Datasets sind erforderlich, um größere Computerressourcen nutzen.</span><span class="sxs-lookup"><span data-stu-id="ba372-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="ba372-132">Die Anzahl und Art der Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="ba372-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="ba372-133">PLINQ stellt den AsOrdered-Operator für Situationen, in denen die Reihenfolge der Elemente in der Quellsequenz beibehalten werden muss.</span><span class="sxs-lookup"><span data-stu-id="ba372-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="ba372-134">Es ist ein gewisser Aufwand verbunden mit der Reihenfolge, aber dieser Nachteil wird in der Regel sehr geringem.</span><span class="sxs-lookup"><span data-stu-id="ba372-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="ba372-135">GROUP BY und Join-Vorgängen verursachen ebenso Verwaltungsaufwand.</span><span class="sxs-lookup"><span data-stu-id="ba372-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="ba372-136">PLINQ führt am besten, wenn es zulässig ist, um Elemente in der quellauflistung in beliebiger Reihenfolge verarbeitet und an dem nächsten Operator übergeben werden, sobald sie bereit sind.</span><span class="sxs-lookup"><span data-stu-id="ba372-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="ba372-137">Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ba372-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="ba372-138">Die Form der Ausführung einer Abfrage.</span><span class="sxs-lookup"><span data-stu-id="ba372-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="ba372-139">Wenn Sie die Ergebnisse einer Abfrage durch Aufrufen von ToArray oder ToList gespeichert sind, müssen die Ergebnisse von allen parallelen Threads in den einzelnen Datenstruktur zusammengeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ba372-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="ba372-140">Führen Sie dazu eine unvermeidbar rechnerischen Kosten.</span><span class="sxs-lookup"><span data-stu-id="ba372-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="ba372-141">Wenn Sie die Ergebnisse mithilfe einer Foreach (For Each in Visual Basic)-Schleife durchlaufen, müssen die Ergebnisse von den Arbeitsthreads ebenso auf den Enumerator Thread serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="ba372-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="ba372-142">Aber wenn Sie eine Aktion basierend auf dem Ergebnis von jedem Thread ausführen möchten, können Sie ForAll-Methode zum Durchführen dieser Aufgaben auf mehreren Threads verwenden.</span><span class="sxs-lookup"><span data-stu-id="ba372-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="ba372-143">Der Typ der Zusammenführungsoptionen.</span><span class="sxs-lookup"><span data-stu-id="ba372-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="ba372-144">PLINQ kann so konfiguriert werden, dass entweder die Ausgabe gepuffert und erzeugt es in Blöcken oder alle auf einmal nach dem das gesamte Resultset, oder sich auf einzelne Ergebnisse Datenstrom erzeugt wird, wie sie erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="ba372-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="ba372-145">Das vorherige Ergebnis ist eine verringerte Gesamtausführungszeit und die zweite Ergebnisse in eine verringerte Latenz zwischen zurückgegebene Elemente.</span><span class="sxs-lookup"><span data-stu-id="ba372-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="ba372-146">Während die Zusammenführungsoptionen nicht immer eine erhebliche Auswirkungen auf die gesamtleistung der Abfrage verfügen, können sie wahrgenommene Leistung Auswirkungen, da sie, wie langen einen Benutzer steuern muss warten, um Ergebnisse anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="ba372-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="ba372-147">Weitere Informationen finden Sie unter [Merge Options in PLINQ (Zusammenführungsoptionen in PLINQ)](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ba372-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="ba372-148">Die Art der Partitionierung.</span><span class="sxs-lookup"><span data-stu-id="ba372-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="ba372-149">In einigen Fällen kann eine unausgeglichene Arbeitslast eine PLINQ-Abfrage über eine indizierbaren quellauflistung führen.</span><span class="sxs-lookup"><span data-stu-id="ba372-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="ba372-150">In diesem Fall können Sie die abfrageleistung zu erhöhen, indem Sie einen benutzerdefinierten Partitionierer erstellen können.</span><span class="sxs-lookup"><span data-stu-id="ba372-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="ba372-151">Weitere Informationen finden Sie unter [Custom Partitioners for PLINQ and TPL (Benutzerdefinierte Partitionierer für PLINQ und TPL)](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="ba372-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="ba372-152">Wenn PLINQ den sequenziellen Modus auswählt</span><span class="sxs-lookup"><span data-stu-id="ba372-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="ba372-153">PLINQ versucht immer, führen Sie eine Abfrage mindestens so schnell, wie die Abfrage sequenziell ausgeführt würde.</span><span class="sxs-lookup"><span data-stu-id="ba372-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="ba372-154">Obwohl PLINQ nicht wie rechenintensiv teuer sind die Benutzerdelegaten oder wie groß die Eingabequelle ist, es für bestimmte Abfrage "Shapes." angezeigt wird</span><span class="sxs-lookup"><span data-stu-id="ba372-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="ba372-155">Insbesondere sucht nach Abfrageoperatoren oder Kombinationen aus Operatoren, die in der Regel eine auszuführende Abfrage langsamer im parallelen Modus verursachen.</span><span class="sxs-lookup"><span data-stu-id="ba372-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="ba372-156">Wenn solche Formen gefunden wird, fällt PLINQ standardmäßig auf den sequenziellen Modus zurück.</span><span class="sxs-lookup"><span data-stu-id="ba372-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="ba372-157">Nach dem Messen der Leistung für eine bestimmte Abfrage können Sie jedoch feststellen, dass sie tatsächlich schneller im parallelen Modus ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ba372-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="ba372-158">In solchen Fällen können Sie die <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag über die <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> aufzurufende Methode anzuweisen, die PLINQ zum parallelisieren der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="ba372-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="ba372-159">Weitere Informationen finden Sie unter [How to: Specify the Execution Mode in PLINQ (Vorgehensweise: Angeben des Ausführungsmodus in PLINQ)](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="ba372-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="ba372-160">Die folgende Liste beschreibt die Abfrageformen, die PLINQ standardmäßig in den sequenziellen Modus ausgeführt wird:</span><span class="sxs-lookup"><span data-stu-id="ba372-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="ba372-161">Abfragen, die eine Select enthalten indiziert, indizierte SelectMany oder ElementAt-Klausel nach einer Sortierung oder Filterung-Operator, der ursprünglichen Indizes angeordnet oder entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="ba372-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="ba372-162">Abfragen, die eine Take TakeWhile, überspringen SkipWhile-Operator enthalten und Indizes in der Quellsequenz sind nicht in der ursprünglichen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ba372-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="ba372-163">Abfragen, die ZIP- oder SequenceEquals enthalten, es sei denn, eine der Datenquellen einen ursprünglich geordneten Index enthält und die andere Datenquelle indizierbar ist (d. h. ein Array oder eine IList(T)).</span><span class="sxs-lookup"><span data-stu-id="ba372-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="ba372-164">Abfragen, die Concat enthalten, es sei denn, es indizierbaren Datenquellen angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="ba372-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="ba372-165">Abfragen, die enthalten umzukehren, es sei denn, die mit einer Datenquelle indizierbaren angewendet.</span><span class="sxs-lookup"><span data-stu-id="ba372-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ba372-166">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="ba372-166">See Also</span></span>  
 [<span data-ttu-id="ba372-167">Parallel LINQ (PLINQ) (Paralleles LINQ (PLINQ))</span><span class="sxs-lookup"><span data-stu-id="ba372-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
