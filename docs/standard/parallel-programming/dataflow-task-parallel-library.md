---
title: "Datenfluss (Task Parallel Library) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Task Parallel Library, Datenfluss"
  - "TPL-Datenflussbibliothek"
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Datenfluss (Task Parallel Library)
<a name="top"></a>Die Task Parallel Library (TPL) stellt Datenflusskomponenten, um die Stabilität der parallelitätsfähigen Applikationen zu erhöhen. Diese Datenflusskomponenten werden zusammen als bezeichnet die *TPL-Datenflussbibliothek*. Dieses Datenflussmodell begünstigt die akteurbasierte Programmierung durch eine prozessinterne Nachrichtenübergabe für simple Datenfluss- und Pipelineaufgaben. Die Datenflusskomponenten basieren auf den Typen und der Planungsinfrastruktur der TPL und sind in die C#-, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]- und F#-Sprachunterstützung für asynchrone Programmierung integriert. Diese Datenflusskomponenten sind hilfreich, wenn mehrere Vorgänge vorliegen, die asynchron miteinander kommunizieren müssen, oder wenn Sie Daten verarbeiten möchten, die gerade verfügbar werden. Denken Sie beispielsweise an eine Anwendung, die Bilddaten von einer Webcam verarbeitet. Durch das Datenflussmodell kann die Anwendung Bildframes verarbeiten, sobald diese verfügbar sind. Wenn die Anwendung Bildframes beispielsweise durch hell Korrektur oder rote-Augen, können Sie erstellen ein *Pipeline* von Datenflusskomponenten. Jede Phase der Pipeline kann grober strukturierte Parallelitätsfunktionen verwenden, wie z. B. die von der TPL bereitgestellten Funktionen zum Transformieren des Bilds.  
  
 Dieses Dokument enthält eine Übersicht über die TPL-Datenflussbibliothek. Es bietet Informationen über das Programmiermodell, die vordefinierten Datenflussblocktypen sowie die Konfiguration der Datenflussblöcke für die speziellen Anforderungen Ihrer Anwendungen.  
  
> [!TIP]
>  Die TPL-Datenflussbibliothek (<xref:System.Threading.Tasks.Dataflow?displayProperty=fullName> Namespace) ist nicht mit verteilt die [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. So installieren Sie die <xref:System.Threading.Tasks.Dataflow> -Namespace öffnen Sie das Projekt in [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], wählen Sie **NuGet-Pakete verwalten** aus dem Menü Projekt, und suchen Sie online nach der `Microsoft.Tpl.Dataflow` Paket.  
  
 Dieses Dokument enthält folgende Abschnitte:  
  
-   [Programmiermodell](#model)  
  
-   [Vordefinierte Datenflussblocktypen](#predefined_types)  
  
-   [Konfigurieren des Datenflussblockverhaltens](#behavior)  
  
-   [Benutzerdefinierte Datenflussblöcke](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Programmiermodell  
 Die TPL-Datenflussbibliothek bietet eine Grundlage für die Nachrichtenübergabe und die Parallelisierung CPU-intensiver und E/A-intensiver Anwendungen mit hohem Durchsatz und niedriger Latenz. Außerdem erhalten Sie damit explizite Kontrolle darüber, wie Daten gepuffert und im System übermittelt werden. Stellen Sie sich zum besseren Verständnis des Datenflussprogrammiermodells eine Anwendung vor, die Bilder asynchron vom Datenträger lädt und ein Kompositum dieser Bilder erstellt. Herkömmliche Programmiermodelle erfordern in der Regel die Verwendung von Rückrufen und Synchronisierungsobjekten wie Sperren, um Aufgaben und den Zugriff auf freigegebene Daten zu koordinieren. Mit dem Datenflussprogrammiermodell können Sie Datenflussobjekte erstellen, die Bilder beim Lesen vom Datenträger verarbeiten. Unter dem Datenflussmodell deklarieren Sie, wie Daten behandelt werden, sobald diese verfügbar werden, und legen außerdem Abhängigkeiten zwischen Daten fest. Da die Laufzeit Abhängigkeiten zwischen Daten verwaltet, können Sie häufig die Anforderung vermeiden, Zugriff auf freigegebene Daten synchronisieren zu müssen. Da die Arbeit von der Laufzeit basierend auf dem asynchronen Eintreffen von Daten geplant wird, können Reaktionsgeschwindigkeit und Durchsatz des Datenflusses verbessert werden, indem die zugrunde liegenden Threads effizient verwaltet werden. Ein Beispiel, das Datenflussprogrammiermodell bildverarbeitung in einer Windows Forms-Anwendung implementiert, finden Sie unter [Exemplarische Vorgehensweise: Datenfluss in einer Windows Forms-Anwendung](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Quellen und Ziele  
 Die TPL-Datenflussbibliothek besteht aus *Datenflussblöcke*, Daten Puffern und verarbeiten die Daten sind strukturiert. Die TPL definiert drei Arten von Datenflussblöcken: *quellblöcken*, *Ziel Blöcke*, und *weitergabeblöcke*. Ein Quellblock fungiert als Datenquelle, aus der gelesen werden kann. Ein Zielblock fungiert als Datenempfänger, in den geschrieben werden kann. Ein Weitergabeblock fungiert als Quellblock und als Zielblock, aus dem gelesen und in den geschrieben werden kann. Die TPL definiert die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=fullName> Schnittstelle, um Quellen darzustellen <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=fullName> um Ziele darzustellen und <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=fullName> um Weitergaben darzustellen.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> erbt von <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, und <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</TInput, TOutput>  
  
 Die TPL-Datenflussbibliothek enthält mehrere vordefinierte datenflussblocktypen, die Implementierung der <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, und <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> Schnittstellen.\</TInput, TOutput> Diese datenflussblocktypen werden in diesem Dokument im Abschnitt beschriebenen [vordefinierte Datenflussblocktypen](#predefined_types).  
  
### <a name="connecting-blocks"></a>Verbinden von Blöcken  
 Sie können Datenflussblöcke mit Formular verbinden *Pipelines*, lineare Sequenzen von Datenflussblöcken, oder *Netzwerke*, Diagramme von Datenflussblöcken konfiguriert wird. Eine Pipeline ist eine Form von Netzwerk. In einer Pipeline oder einem Netzwerk geben Quellen asynchron Daten an Ziele weiter, sobald diese Daten verfügbar werden. Die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> -Methode verknüpft einen quelldatenflussblock mit einem Zielblock. Eine Quelle kann mit null oder mehr Zielen verknüpft werden. Ziele können mit null oder mehr Quellen verknüpft werden. Sie können Datenflussblöcke in einer Pipeline oder einem Netzwerk gleichzeitig hinzufügen oder entfernen. Die vordefinierten Datenflussblocktypen behandeln alle Threadsicherheitsaspekte bezüglich Verknüpfungen und des Lösens von Verknüpfungen.  
  
 Ein Beispiel für die Verbindung von Datenflussblöcken zum Erstellen einer einfachen Pipeline, finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer Datenflusspipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Ein Beispiel für die Verbindung von Datenflussblöcken zum ein komplexes Netzwerks, finden Sie unter [Exemplarische Vorgehensweise: Datenfluss in einer Windows Forms-Anwendung](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Ein Beispiel für die Verknüpfung ein Ziels mit einer Quelle, nachdem die Quelle dem Ziel eine Nachricht anbietet, finden Sie unter [wie: Verknüpfungen für Datenflussblöcke](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtern  
 Beim Aufrufen der <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> Methode, um eine Quelle in ein Ziel, verknüpfen Sie einen Delegaten, der bestimmt, ob der Zielblock akzeptiert oder eine Nachricht basierend auf den Wert der Nachricht ablehnt angeben können. Dieser Filtermechanismus ist eine hilfreiche Möglichkeit, um sicherzustellen, dass nur bestimmte Werte von einem Datenflussblock empfangen werden. Für die meisten der vordefinierten Datenflussblocktypen gilt, dass eine Nachricht von der Quelle dem nächsten Ziel angeboten wird, wenn ein Quellblock mit mehreren Zielblöcken verbunden ist und ein Zielblock die Nachricht ablehnt. Die Reihenfolge, in der Nachrichten von einer Quelle Zielen angeboten werden, wird durch die Quelle definiert und kann je nach Typ der Quelle variieren. Die meisten Quellblocktypen bieten eine Nachricht nicht weiter an, nachdem diese von einem Ziel akzeptiert wurde. Eine Ausnahme von dieser Regel ist die <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> -Klasse, die jede Nachricht allen Zielen anbietet, auch wenn einige Ziele die Nachricht ablehnen. Ein Beispiel, die Filterung verwendet wird, um nur bestimmte Nachrichten zu verarbeiten, finden Sie unter [Exemplarische Vorgehensweise: Datenfluss in einer Windows Forms-Anwendung](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Da jeder vordefinierte Quelldatenflussblocktyp sicherstellt, dass Nachrichten in der Reihenfolge weitergegeben werden, in der sie empfangen werden, muss jede Nachricht vom Quellblock gelesen werden, bevor der Quellblock die nächste Nachricht verarbeiten kann. Wenn Sie daher Filter verwenden, um mehrere Ziele mit einer Quelle zu verbinden, sollten Sie sicherstellen, dass jede Nachricht von mindestens einem Zielblock empfangen wird. Andernfalls kann bei der Anwendung ein Deadlock auftreten.  
  
### <a name="message-passing"></a>Nachrichtenübergabe  
 Das Datenflussprogrammiermodell bezieht sich auf das Konzept der *Nachrichtenübergabe*, bei dem unabhängige Komponenten eines Programms miteinander kommunizieren, die Nachrichten gesendet. Eine Möglichkeit, Nachrichten zwischen Anwendungskomponenten weitergegeben wird, rufen Sie die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> und <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=fullName> Methoden zum Senden von Nachrichten an zieldatenflussblöcke (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> agiert synchron, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> agiert asynchron) und die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, und <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> Methoden, um Nachrichten von quellblöcken zu empfangen. Sie können diese Methoden mit Datenflusspipelines oder -netzwerken kombinieren, indem Sie Eingabedaten an den Hauptknoten (ein Zielblock) senden und Ausgabedaten vom Terminalknoten der Pipeline bzw. von den Terminalknoten des Netzwerks (ein oder mehrere Quellblöcke) empfangen. Können Sie auch die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> -Methode zum Lesen aus dem ersten der bereitgestellten Quellen, die Daten zur Verfügung und Aktion für diese Daten ausführen.  
  
 Quellblöcke bieten Zielblöcken Daten an, durch Aufrufen der <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=fullName> Methode. Der Zielblock reagiert auf eine angebotene Nachricht auf eine von drei Arten: Er kann die Nachricht akzeptieren, ablehnen oder zurückstellen. Wenn das Ziel die Meldung akzeptiert die <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> -Methode gibt <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Wenn das Ziel die Nachricht ablehnt der <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> -Methode gibt <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Wenn das Ziel erfordert, dass er nicht mehr alle Nachrichten aus der Quelle empfängt <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> gibt <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Die vordefinierten Quellblocktypen bieten verknüpften Zielen keine Nachrichten an, nachdem ein solcher Rückgabewert empfangen wird, und die Verknüpfung zu solchen Zielen wird automatisch gelöst.  
  
 Wenn ein Zielblock die Nachricht für die spätere Verwendung zurückstellt der <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> -Methode gibt <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Ein Zielblock, eine Nachricht zurückstellt, können spätere Aufrufe der <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=fullName> Methode, um zu versuchen, die angebotene Nachricht zu reservieren. In diesem Moment ist die Nachricht entweder weiterhin verfügbar und kann vom Zielblock verwendet werden, oder die Nachricht wurde von einem anderen Ziel angenommen. Wenn der Zielblock die Nachricht später benötigt oder die Nachricht nicht mehr benötigt, ruft er die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> oder <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> Methode bzw.. Nachrichtenreservierung wird in der Regel von Datenflussblocktypen verwendet, die sich im nicht gierigen Modus befinden. "Nicht gieriger Modus" wird weiter unten in diesem Dokument erläutert. Anstatt zu reservieren eine zurückgestellte Nachricht, ein Zielblock können Sie auch die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> -Methode versucht, die zurückgestellte Nachricht direkt zu verarbeiten.  
  
### <a name="dataflow-block-completion"></a>Abschluss von Datenflussblöcken  
 Datenflussblöcke unterstützen auch das Konzept der *Abschluss*. Ein Datenflussblock, der sich im abgeschlossenen Zustand befindet, führt keine weitere Arbeit mehr aus. Jeder Datenflussblock verfügt über eine zugeordnete <xref:System.Threading.Tasks.Task?displayProperty=fullName> -Objekts, auch bezeichnet als ein *Abschlussaufgabe*, den Abschlusszustand des Blocks darstellt. Da Sie warten, können ein <xref:System.Threading.Tasks.Task> -Objekt abgeschlossen wird mithilfe von Abschlussaufgaben, warten, bis einer oder mehreren Terminalknoten eines Datenflussnetzwerks Fertig stellen. Die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> Schnittstelle definiert die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> -Methode, die eine Anforderung zum Abschließen der Datenflussblock informiert, und die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> -Eigenschaft, die die Abschlussaufgabe für den Datenflussblock zurückgibt. Beide <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> und <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> erben die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> Schnittstelle.  
  
 Es gibt zwei Möglichkeiten, um zu bestimmen, ob ein Datenflussblock ohne Fehler abgeschlossen wurde, ob mindestens ein Fehler aufgetreten ist oder ob er abgebrochen wurde. Die erste Möglichkeit besteht im Aufrufen der <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> Methode für die Abschlussaufgabe in einem `try` - `catch` Block (`Try` - `Catch` in Visual Basic). Das folgende Beispiel erstellt eine <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> -Objekt, das löst <xref:System.ArgumentOutOfRangeException> ist der Eingabewert kleiner als&0; (null). <xref:System.AggregateException> wird ausgelöst, wenn dieses Beispiel ruft <xref:System.Threading.Tasks.Task.Wait%2A> für die Abschlussaufgabe. Die <xref:System.ArgumentOutOfRangeException> erfolgt über die <xref:System.AggregateException.InnerExceptions%2A> Eigenschaft der <xref:System.AggregateException> Objekt.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 In diesem Beispiel wird der Fall erläutert, in dem eine Ausnahme im Delegaten eines Ausführungsdatenflussblocks unbehandelt bleibt. Es wird empfohlen, Ausnahmen in den Codetexten solcher Blöcke zu behandeln. Wenn dies jedoch nicht möglich ist, verhält sich der Block, als ob er abgebrochen wurde, und verarbeitet keine eingehenden Nachrichten.  
  
 Wenn ein Datenflussblock explizit abgebrochen wird die <xref:System.AggregateException> Objekt enthält <xref:System.OperationCanceledException> in der <xref:System.AggregateException.InnerExceptions%2A> Eigenschaft. Weitere Informationen über das Abbrechen von Datenflüssen finden Sie unter "Aktivieren des Abbruchs" weiter unten in diesem Dokument.  
  
 Die zweite Möglichkeit, den Abschlussstatus eines Datenflussblocks zu bestimmen, ist die Verwendung einer Fortsetzung außerhalb der Abschlussaufgabe oder die Verwendung der asynchronen Sprachfunktionen von C# und Visual Basic, um auf die Abschlussaufgabe asynchron zu warten. Der Delegat, den Sie zum Bereitstellen der <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> -Methode akzeptiert ein <xref:System.Threading.Tasks.Task> -Objekt, das die vorangehende Aufgabe darstellt. Im Fall von der <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> -Eigenschaft nimmt der Delegat für die Fortsetzung die Abschlussaufgabe selbst. Das folgende Beispiel ähnelt das vorherige Beispiel, außer dass auch mithilfe der <xref:System.Threading.Tasks.Task.ContinueWith%2A> Methode, um eine Abschlussaufgabe zu erstellen, die den Status des gesamten datenflussvorgangs ausgibt.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Sie können auch Eigenschaften verwenden, z. B. <xref:System.Threading.Tasks.Task.IsCanceled%2A> im Hauptteil der Fortsetzungsaufgabe um zusätzliche Informationen über den Abschlussstatus eines datenflussblocks zu bestimmen. Weitere Informationen zu Fortsetzungsaufgaben und deren Beziehung zu Abbruch- und Fehlerbehandlung finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [Aufgabenabbruch](../../../docs/standard/parallel-programming/task-cancellation.md), [Ausnahmebehandlung](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md), und [NIB: Gewusst wie: Behandeln Ausnahmen, die von Aufgaben ausgelöste](http://msdn.microsoft.com/de-de/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[go to top](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Vordefinierte Datenflussblocktypen  
 Die TPL-Datenflussbibliothek enthält mehrere vordefinierte Datenflussblocktypen. Diese Typen sind in drei Kategorien unterteilt: *pufferblöcke*, *ausführungsblöcke*, und *gruppierungsblöcke*. In den folgenden Abschnitten werden die Blocktypen dieser Kategorien beschrieben.  
  
### <a name="buffering-blocks"></a>Pufferblöcke  
 Pufferblöcke enthalten Daten zur Verwendung durch Datenconsumer. Die TPL-Datenflussbibliothek enthält drei pufferblocktypen: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=fullName>, und <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=fullName>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 Die <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> -Klasse stellt eine allgemeine Struktur des asynchronen messaging dar. Diese Klasse speichert eine FIFO-Nachrichtenwarteschlange (First In, First Out), in die mehrere Quellen Nachrichten schreiben oder aus der mehrere Ziele Nachrichten auslesen können. Wenn ein Ziel empfängt eine Nachricht von einer <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> -Objekt, wird diese Nachricht aus der Nachrichtenwarteschlange entfernt. Daher zwar ein <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> -Objekt mehrere Ziele haben kann, die jede Nachricht von nur einem Ziel empfangen werden. Die <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Klasse ist hilfreich, wenn Sie mehrere Nachrichten an eine andere Komponente übergeben möchten und diese Komponente alle Nachrichten empfangen muss.  
  
 Im folgende grundlegende Beispiel stellt mehrere <xref:System.Int32> -Werte in einer <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> -Objekt und anschließend wieder aus dem Objekt gelesen.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Ein vollständiges Beispiel, das veranschaulicht, wie Nachrichten schreiben und Lesen von Nachrichten von einer <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Objekt, finden Sie unter [Gewusst wie: Schreiben und Lesen von Nachrichten aus einem Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 Die <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasse ist hilfreich, wenn mehrere Nachrichten an eine andere Komponente übergeben werden müssen, aber diese Komponente nur den letzten Wert benötigt. Diese Klasse ist darüber hinaus auch hilfreich, wenn Sie eine Nachricht an mehreren Komponenten übertragen möchten.  
  
 Die folgenden grundlegenden Beispiel Beiträge ein <xref:System.Double> -Wert in einen <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> -Objekt und dann gelesen aus dem Objekt mehrmals. Da Werte nicht entzogen werden <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Objekte Nachdem sie gelesen wurden, der gleiche Wert steht jedem.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Ein vollständiges Beispiel, das veranschaulicht, wie Sie <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> eine Nachricht an mehrere Zielblöcke gesendet wird, finden Sie unter [wie: einen Taskplaner in einem Dataflow Block angeben](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 Die <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> -Klasse ähnelt der <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> Klasse, außer dass eine <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> -Objekt nur einmal geschrieben werden kann. Können Sie sich vorstellen <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> ähnlich wie die C#- [Readonly](../Topic/readonly%20\(C%23%20Reference\).md) ([ReadOnly](../Topic/ReadOnly%20\(Visual%20Basic\).md) in [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)])-Schlüsselwort, abgesehen davon, dass ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Objekt wird jedoch unveränderlich, nachdem es einen Wert anstatt einer Konstruktion empfängt. Wie die <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> -Klasse, wenn ein Ziel eine Nachricht empfängt ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> -Objekt, wird diese Nachricht aus dem Objekt nicht entfernt. Daher empfangen mehrere Ziele eine Kopie der Nachricht. Die <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Klasse ist hilfreich, wenn Sie nur die erste von mehreren Nachrichten weitergeben möchten.  
  
 Das folgende grundlegende Beispiel sendet mehrere <xref:System.String> -Werte in einer <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> -Objekt und dann der Wert aus diesem Objekt gelesen. Da ein <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> Objekt einmal geschrieben werden kann nur nach einem <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> -Objekt eine Nachricht empfängt, werden nachfolgende Nachrichten verworfen.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Ein vollständiges Beispiel, das veranschaulicht, wie Sie <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> den Wert des ersten Vorgangs empfangen, die beendet wird, finden Sie unter [wie: Verknüpfungen für Datenflussblöcke](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Ausführungsblöcke  
 Ausführungsblöcke rufen einen vom Benutzer bereitgestellten Delegaten für jedes Element empfangener Daten auf. Die TPL-Datenflussbibliothek enthält drei Typen von ausführungsblöcken: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=fullName>, und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=fullName>.\</TInput, TOutput> \</TInput, TOutput>  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 Die <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasse ist ein Zielblock, der einen Delegaten aufruft, wenn es Daten empfängt. Stellen Sie sich eine <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Objekt wie ein Delegat, der asynchron ausgeführt wird, wenn Daten verfügbar werden. Der Delegat, den Sie zum Bereitstellen einer <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Objekt kann vom Typ <xref:System.Action> oder `System.Func\<TInput, Task>`. Bei Verwendung einer <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> -Objekt mit <xref:System.Action>, Verarbeitung jedes Eingabeelements wird als abgeschlossen betrachtet, wenn der Delegat zurückgegeben. Bei Verwendung einer <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> -Objekt mit `System.Func\<TInput, Task>`, Verarbeitung jedes Eingabeelements gilt nur dann abgeschlossen, wenn das zurückgegebene <xref:System.Threading.Tasks.Task> -Objekt abgeschlossen ist. Mithilfe dieser beiden Mechanismen können <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> für synchrone und asynchrone Verarbeitung jedes Eingabeelements.  
  
 Das folgende grundlegende Beispiel sendet mehrere <xref:System.Int32> -Werte in einer <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Objekt. Die <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> -Objekt gibt diese Werte in der Konsole aus. Im Beispiel wird der Block dann in den abgeschlossenen Zustand versetzt, und es wird gewartet, bis alle Datenflussaufgaben abgeschlossen sind.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Vollständige Beispiele für die Verwendung von Delegaten mit der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasse, finden Sie unter [Gewusst wie: Ausführen Aktion Wenn ein Datenflussblock Daten empfängt](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Die <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> -Klasse ähnelt der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasse, die sie als Quelle und als Ziel fungiert.\</TInput, TOutput> Der Delegat, der Übergabe an eine <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> -Objekts gibt einen Wert vom Typ `TOutput`.</TInput, TOutput> Der Delegat, den Sie zum Bereitstellen einer <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> Objekt kann vom Typ `System.Func<TInput, TOutput>` oder `System.Func<TInput, Task>`.\</TInput, TOutput> Bei Verwendung einer <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> -Objekt mit `System.Func\<TInput, TOutput>`, Verarbeitung jedes Eingabeelements wird als abgeschlossen betrachtet, wenn der Delegat zurückgegeben.</TInput, TOutput> Bei Verwendung einer <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> verwendete Objekt `System.Func<TInput, Task<TOutput>>`, Verarbeitung jedes Eingabeelements gilt nur dann abgeschlossen, wenn das zurückgegebene <xref:System.Threading.Tasks.Task> -Objekt abgeschlossen ist.\</TInput, TOutput> Wie bei <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, mithilfe dieser beiden Mechanismen können <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> für synchrone und asynchrone Verarbeitung jedes Eingabeelements.\</TInput, TOutput>  
  
 Das folgende grundlegende Beispiel erstellt eine <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> -Objekt, das die Quadratwurzel der Eingabe berechnet.</TInput, TOutput> Die <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> -Objekt nimmt <xref:System.Int32> -Werte als Eingabe und erzeugt <xref:System.Double> -Werte als Ausgabe.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Vollständige Beispiele für die Verwendung <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in einem Netzwerk von Datenflussblöcken, Image-Verarbeitung in einer Windows Forms-Anwendung ausführt, finden Sie unter [Exemplarische Vorgehensweise: Datenfluss in einer Windows Forms-Anwendung](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).\</TInput, TOutput>  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Die <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Klasse ähnelt der <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> Klasse, außer dass <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> NULL oder mehr Ausgabewerte erzeugt, für jeden Eingabewert, anstatt nur eines für jeden Eingabewert Ausgabewerts.</TInput, TOutput> </TInput, TOutput> </TInput, TOutput> Der Delegat, den Sie zum Bereitstellen einer <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> Objekt kann vom Typ `System.Func<TInput, IEnumerable<TOutput>>` oder `type System.Func<TInput, Task<IEnumerable<TOutput>>>`.\</TInput, TOutput> Bei Verwendung einer <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Objekt mit `System.Func<TInput, IEnumerable<TOutput>>`, Verarbeitung jedes Eingabeelements wird als abgeschlossen betrachtet, wenn der Delegat zurückgegeben.</TInput, TOutput> Bei Verwendung einer <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Objekt mit `System.Func<TInput, Task<IEnumerable<TOutput>>>`, Verarbeitung jedes Eingabeelements gilt nur dann abgeschlossen, wenn das zurückgegebene `System.Threading.Tasks.Task<IEnumerable<TOutput>>` -Objekt abgeschlossen ist.\</TInput, TOutput>  
  
 Das folgende grundlegende Beispiel erstellt eine <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Objekt, das Zeichenfolgen in ihre einzelnen Zeichensequenzen aufteilt.</TInput, TOutput> Die <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Objekt nimmt <xref:System.String> -Werte als Eingabe und erzeugt <xref:System.Char> -Werte als Ausgabe.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Vollständige Beispiele für die Verwendung <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> mehrere unabhängige Ausgaben für jede Eingabe in einer Datenflusspipeline erzeugt werden, finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer Datenflusspipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).\</TInput, TOutput>  
  
#### <a name="degree-of-parallelism"></a>Grad der Parallelität  
 Jede <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Objekt puffert eingehende Nachrichten, bis der Block bereit für die Verarbeitung ist.</TInput, TOutput> </TInput, TOutput> In der Standardeinstellung verarbeiten diese Klassen Nachrichten nacheinander in der Reihenfolge, in der sie empfangen werden. Sie können auch angeben, den Grad der Parallelität zu <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> -Objekte mehrere Nachrichten gleichzeitig verarbeiten.\</TInput, TOutput> \</TInput, TOutput> Weitere Informationen über die gleichzeitige Ausführung finden Sie im Abschnitt "Festlegen des Grads der Parallelität" weiter unten in diesem Dokument. Ein Beispiel, den Grad der Parallelität so ein ausführungsdatenflussblock mehrere Nachrichten gleichzeitig verarbeiten kann, finden Sie unter [Gewusst wie: Festlegen des Grads der Parallelität in einem Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Übersicht über Delegattypen  
 Der folgenden Tabelle sind die Delegattypen, die Sie bereitstellen können <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> Objekte.\</TInput, TOutput> \</TInput, TOutput> In dieser Tabelle wird auch angegeben, ob der Delegattyp synchron oder asynchron arbeitet.  
  
|Typ|Synchroner Delegattyp|Asynchroner Delegattyp|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602></TInput, TOutput>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602></TInput, TOutput>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Sie können auch Lambda-Ausdrücke verwenden, wenn Sie mit Ausführungsblocktypen arbeiten. Ein Beispiel, das zeigt, wie Sie einen Lambda-Ausdruck mit einem Ausführungsblock finden Sie unter [Gewusst wie: Ausführen Aktion Wenn ein Datenflussblock Daten empfängt](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Gruppierungsblöcke  
 Gruppierungsblöcke kombinieren Daten aus einer oder mehreren Quellen und unter verschiedenen Einschränkungen. Die TPL-Datenflussbibliothek enthält drei Typen von gruppierungsblöcken: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, und <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.\</T1, T2> \</T1, T2>  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 Die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Klasse kombiniert Sätze von Eingabedaten, die als Batches, in Arrays von Ausgabedaten bezeichnet werden. Beim Erstellen, geben Sie die Größe von jedem Batch eine <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Objekt. Wenn die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Objekt die angegebene Anzahl von Eingabeelementen empfängt, wird asynchron Eingabeelementen ein Array, das die Elemente enthält. Wenn ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Objekt enthält nicht genügend Elemente zum Bilden eines Batches jedoch auf den abgeschlossenen Zustand Eingabeelementen, wird ein abschließendes Array, das die restlichen Eingabeelementen enthält.  
  
 Die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Klasse arbeitet entweder im *gierige* oder *nicht gierige* Modus. Im gierigen Modus, der Standardwert ist, eine <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Objekt akzeptiert jede Nachricht, dass es angeboten wird, und gibt ein Array weiter, nachdem es die angegebene Anzahl von Elementen empfangen. Im nicht gierigen Modus eine <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Objekt alle eingehenden Nachrichten zurück, bis genügend Quellen, Nachrichten an den Block angeboten wurden, um einen Batch zu bilden. Der gierige Modus erzielt in der Regel eine bessere Leistung als der nicht gierige Modus, da er weniger Verarbeitungsaufwand erfordert. Sie können den nicht gierigen Modus jedoch verwenden, wenn Sie die Nutzung von mehreren Quellen auf atomische Weise koordinieren müssen. Nicht gierigen Modus angeben, indem <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> auf `False` in der `dataflowBlockOptions` -Parameter in der <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> Konstruktor.  
  
 Im folgende grundlegende Beispiel stellt mehrere <xref:System.Int32> -Werte in einer <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Objekt, das zehn Elemente in einem Batch enthält. Um sicherzustellen, dass alle Werte von weitergeben der <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, dieses Beispiel ruft die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> Methode. Die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> -Methode legt die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Objekt in den abgeschlossenen Zustand, und daher die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Objekt alle verbleibenden Elemente einem abschließenden Batch weitergegeben.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Ein vollständiges Beispiel, das verwendet <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> zur Verbesserung der Effizienz von datenbankeinfügevorgängen finden Sie unter [Exemplarische Vorgehensweise: Verwendung von BatchBlock und BatchedJoinBlock Effizienz verbessern](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 Die <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> Klassen sammeln Eingabeelemente und weiterzugeben <xref:System.Tuple%602?displayProperty=fullName> oder <xref:System.Tuple%603?displayProperty=fullName> Objekte, die diese Elemente enthalten.\</T1, T2, T3> \</T1, T2> \</T1, T2, T3> \</T1, T2> Die <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> Klassen erben nicht von <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</T1, T2, T3> </T1, T2> Stattdessen verfügen sie über Eigenschaften, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, und <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, implementieren <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Wie <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> im gierigen oder im nicht gierigen Modus ausgeführt werden.</T1, T2, T3> </T1, T2> Im gierigen Modus, der Standardwert ist, eine <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> oder <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> Objekt akzeptiert jede Nachricht, dass es angeboten wird, und gibt ein Tupel weiter, nachdem jedes der zugehörigen Ziele mindestens eine Nachricht empfängt.</T1, T2, T3> </T1, T2> Im nicht gierigen Modus eine <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> oder <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> -Objekt alle eingehende Nachrichten zurückstellt, bis allen Zielen die Daten angeboten wurden, die zum Erstellen eines Tupels erforderlich sind.\</T1, T2, T3> \</T1, T2> An diesem Punkt initiiert der Block ein Zweiphasencommit-Protokoll, um alle erforderlichen Elemente aus den Quellen atomar abzurufen. Durch diese Zurückstellung ist es möglich, dass eine andere Entität die Daten in der Zwischenzeit nutzt, sodass das gesamte System mit der Verarbeitung fortschreitet.  
  
 Das folgende grundlegende Beispiel zeigt einen Fall, in dem ein <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> -Objekt mehrere Daten benötigt, einen Wert zu berechnen.</T1, T2, T3> In diesem Beispiel wird ein <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> -Objekt, das zwei erfordert <xref:System.Int32> Werte und ein <xref:System.Char> Wert, der eine arithmetische Operation durchzuführen.\</T1, T2, T3>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Ein vollständiges Beispiel, das verwendet <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> Objekte im nicht gierigen Modus zur kooperativen Nutzung einer Ressource finden Sie unter [wie: JoinBlock zum Lesen aus mehreren Quellen](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).\</T1, T2>  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> und <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> -Klasse sammeln Batches von Eingabeelementen und weitergeben `System.Tuple(IList(T1), IList(T2))` oder `System.Tuple(IList(T1), IList(T2), IList(T3))` -Objekten, die diese Elemente enthalten.\</T1, T2, T3> \</T1, T2> Stellen Sie sich <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> als Kombination aus <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> und <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</T1, T2> </T1, T2> Geben Sie die Größe von jedem Batch, bei der Erstellung einer <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> Objekt.\</T1, T2> <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> verfügt auch über Eigenschaften, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> und <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, implementieren <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</T1, T2> Wenn die angegebene Anzahl von Eingabeelementen werden von allen Zielen empfangen die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> -Objekt asynchron weitergegeben ein `System.Tuple(IList(T1), IList(T2))` -Objekt, das die Elemente enthält.\</T1, T2>  
  
 Das folgende grundlegende Beispiel erstellt eine <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> -Objekt, das Ergebnisse enthält <xref:System.Int32> Werten und den Fehlern, die <xref:System.Exception> Objekte.</T1, T2> In diesem Beispiel werden mehrere Vorgänge durchgeführt, und schreibt die Ergebnisse in der <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> -Eigenschaft und Fehler in der <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> -Eigenschaft, der die <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> Objekt.\</T1, T2> Da die Anzahl der erfolgreichen und fehlgeschlagenen Vorgänge im Voraus unbekannt ist die <xref:System.Collections.Generic.IList%601> -Objekte ermöglichen, dass jedes Ziel NULL oder mehr Werte empfängt.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Ein vollständiges Beispiel, das verwendet <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> zum Erfassen der Ergebnisse und Ausnahmen, die auftreten, während das Programm aus einer Datenbank liest, finden Sie unter [Exemplarische Vorgehensweise: Verwendung von BatchBlock und BatchedJoinBlock Effizienz verbessern](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).\</T1, T2>  
  
 [[go to top](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Konfigurieren des Datenflussblockverhaltens  
 Sie können zusätzliche Optionen aktivieren, durch die Bereitstellung einer <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName> -Objekt an den Konstruktor von datenflussblocktypen. Diese Optionen steuern das Verhalten wie z. B. den Planer, der die zugrunde liegende Aufgabe und den Grad der Parallelität verwaltet. Die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> verfügt außerdem über abgeleitete Typen, die Verhalten anzugeben, die für bestimmte datenflussblocktypen spezifisch ist. In der folgenden Tabelle ist zusammengefasst, welcher Optionstyp den einzelnen Datenflussblocktypen zugeordnet ist.  
  
|Datenflussblocktyp|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> Typ|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Die folgenden Abschnitte enthalten zusätzliche Informationen über die wichtigen Arten von Datenfluss über die verfügbaren Optionen der <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=fullName>, und <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=fullName> Klassen.  
  
### <a name="specifying-the-task-scheduler"></a>Festlegen des Aufgabenplaners  
 Jeder vordefinierte Datenflussblock verwendet den TPL-Aufgabenplanungsmechanismus zum Durchführen von Aktivitäten, wie das Weitergeben von Daten an ein Ziel, das Empfangen von Daten aus einer Quelle und das Ausführen benutzerdefinierter Delegate, wenn Daten verfügbar werden. <xref:System.Threading.Tasks.TaskScheduler> ist eine abstrakte Klasse, die einen Aufgabenplaner darstellt, die Aufgaben in Warteschlangen. Der standardmäßige Taskplaner <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, verwendet die <xref:System.Threading.ThreadPool> -Klasse in die Warteschlange und Ausführen der Arbeitsaufgabe. Sie können den Standardtaskplaner überschreiben, indem die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> Eigenschaft, wenn Sie ein datenflussblockobjekt erstellen.  
  
 Wenn der gleiche Aufgabenplaner mehrere Datenflussblöcke verwaltet, kann er Richtlinien für sie erzwingen. Wenn mehrere Datenflussblöcke jeweils den exklusiven Planer des gleichen Ziel konfiguriert beispielsweise <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> -Objekt, die gesamte Arbeit, die auf diesen Blöcken ausgeführt wird, serialisiert wird. Auch wenn diese Blöcke den parallele Planer des gleichen Ziel konfiguriert <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> -Objekt, und dieser Planer eine maximale nebenläufigkeitsebene konfiguriert ist, alle Arbeit von diesen Blöcken auf diese Anzahl gleichzeitiger Vorgänge beschränkt ist. Ein Beispiel für die Verwendung der <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> -Klasse Lesevorgänge parallel, Schreibvorgänge jedoch exklusiv von allen anderen Vorgängen erfolgen, finden Sie unter [wie: einen Taskplaner in einem Dataflow Block angeben](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Weitere Informationen zum Aufgabenplaner in der TPL finden Sie unter der <xref:System.Threading.Tasks.TaskScheduler> Thema-Klasse.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Festlegen des Grads der Parallelität  
 Standardmäßig werden die drei ausführungsblocktypen, die die TPL-Datenflussbibliothek bereitstellt, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, mehrere Nachrichten gleichzeitig verarbeitet.\</TInput, TOutput> \</TInput, TOutput> Diese Datenflussblocktypen verarbeiten Nachrichten ebenfalls in der Reihenfolge, in der sie empfangen werden. Um diese Datenflussblöcke Nachrichten gleichzeitig verarbeiten zu aktivieren, legen Sie die <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=fullName> -Eigenschaft beim Erstellen des datenflussblockobjekts.  
  
 Der Standardwert von <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> ist 1. Dadurch wird sichergestellt, dass der Datenflussblock mehrere Nachrichten gleichzeitig verarbeitet. Durch das Festlegen dieser Eigenschaft auf einen Wert, der größer als 1 ist, kann der Datenflussblock mehrere Nachrichten gleichzeitig verarbeiten. Wenn diese Eigenschaft auf <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName> kann die zugrunde liegende Aufgabenplaner den maximalen Grad an Parallelität zu verwalten.  
  
> [!IMPORTANT]
>  Wenn Sie einen maximalen Grad an Parallelität angeben, der größer als 1 ist, werden mehrere Nachrichten gleichzeitig verarbeitet. Daher werden Nachrichten möglicherweise nicht in der Reihenfolge verarbeitet, in der sie empfangen werden. Die Reihenfolge, in der die Nachrichten vom Blocks ausgegeben werden, ist jedoch ordnungsgemäß sortiert.  
  
 Da die <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> -Eigenschaft den maximalen Grad an Parallelität darstellt, wird der Datenflussblock möglicherweise mit einem geringeren Grad an Parallelität ausgeführt, als Sie angeben. Der Datenflussblock kann zum Erfüllen seiner Funktionsanforderungen oder aufgrund eines Mangels an verfügbaren Systemressourcen einen geringeren Grad an Parallelität verwenden. Ein Datenflussblock wird nie mit mehr Parallelität ausgeführt als Sie angeben.  
  
 Der Wert der <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> -Eigenschaft ist exklusiv für jedes datenflussblockobjekt. Wenn beispielsweise für vier Datenflussblockobjekte als maximaler Grad an Parallelität jeweils 1 angegeben wird, können u. U. alle vier Datenflussblockobjekte parallel ausgeführt werden.  
  
 Ein Beispiel, den maximalen Grad an Parallelität für lang andauernde Operationen parallel auftreten können, finden Sie unter [Gewusst wie: Angeben des Grads der Parallelität in einem Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Festlegen der Anzahl von Nachrichten pro Aufgabe  
 Die vordefinierten Datenflussblocktypen verwenden Aufgaben, um mehrere Eingabeelemente zu verarbeiten. Dadurch kann die Anzahl der zum Verarbeiten von Daten erforderlichen Aufgabenobjekte minimiert werden, sodass Anwendungen effizienter ausgeführt werden können. Wenn Daten von den Aufgaben aus einem Satz von Datenflussblöcken verarbeitet werden, müssen die Aufgaben von anderen Datenflussblöcken jedoch möglicherweise auf Verarbeitungszeit warten, indem Nachrichten in die Warteschlange gestellt werden. Um eine bessere Ausgewogenheit zwischen datenflussaufgaben zu aktivieren, legen Sie die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> Eigenschaft. Wenn <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> Wert <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName>, dies ist die Standardeinstellung, die von einem Datenflussblock verwendete Aufgabe verarbeitet alle Nachrichten verfügbar sind. Wenn <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> festgelegt ist auf einen anderen Wert als <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, der Datenflussblock verarbeitet höchstens diese Anzahl an Nachrichten pro <xref:System.Threading.Tasks.Task> Objekt. Obwohl durch das Festlegen der <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> Eigenschaft Fairness zwischen Aufgaben erhöhen kann, wird das System mehr Aufgaben als nötig, erstellen die Leistung abnehmen kann.  
  
### <a name="enabling-cancellation"></a>Aktivieren des Abbruchs  
 Die TPL bietet einen Mechanismus, durch den Aufgaben Abbrüche kooperative koordinieren können. Legen Sie zum Aktivieren der Datenflussblöcke diesen Abbruchmechanismus nutzen die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> Eigenschaft. Wenn dies <xref:System.Threading.CancellationToken> Objekt in den abgebrochenen Zustand, alle Datenflussblöcke, die dieses Token überwachen beendet die Ausführung ihres aktuellen Elements, jedoch Verarbeitung nachfolgender Elemente nicht starten. Diese Datenflussblöcke löschen außerdem alle gepufferten Nachrichten, geben Verbindungen zu allen Quell- und Zielblöcken frei und wechseln in den abgebrochenen Zustand. Durch den Übergang in den abgebrochenen Zustand, der <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> Eigenschaft verfügt über die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft festgelegt, um <xref:System.Threading.Tasks.TaskStatus>, wenn eine Ausnahme während der Verarbeitung aufgetreten ist. In diesem Fall <xref:System.Threading.Tasks.Task.Status%2A> Wert <xref:System.Threading.Tasks.TaskStatus>.  
  
 Ein Beispiel für die Verwendung von Abbrüchen in einer Windows Forms-Anwendung, finden Sie unter [Gewusst wie: Abbrechen einer Dataflow-Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Weitere Informationen über Abbrüche in der TPL finden Sie unter [Aufgabenabbruch](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Festlegen von gierigem Verhalten im Vergleich zu nicht gierigem Verhalten  
 Mehrere gruppierungsdatenflussblocktypen können entweder in Betrieb *gierige* oder *nicht gierige* Modus. In der Standardeinstellung arbeiten die vordefinierten Datenflussblocktypen im gierigen Modus.  
  
 Blockieren Sie für einen Join Typen wie z. B. <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, bedeutet der gierige Modus, dass Daten vom Block sofort angenommen, auch wenn die entsprechenden Daten mit den join noch nicht verfügbar ist.</T1, T2> Nicht gieriger Modus bedeutet, dass der Block alle eingehenden Nachrichten zurückstellt, bis eine Nachricht an jedem der zugehörigen Ziele verfügbar ist, um die Gruppierung zu vervollständigen. Wenn eine der zurückgestellten Nachrichten nicht mehr verfügbar ist, gibt der Gruppierungsblock alle zurückgestellten Nachrichten frei und startet den Prozess neu. Für die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Klasse ist das gierige und nicht gierige Verhalten ähnlich, außer dass im nicht gierigen Modus ist ein <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> -Objekt alle eingehenden Nachrichten zurück, bis genügend verfügbare aus verschiedenen Quellen, um einen Batch zu vervollständigen.  
  
 Um nicht gierigen Modus für einen Datenflussblock anzugeben, legen Sie <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> auf `False`. Ein Beispiel für die Verwendung nicht gierigen Modus mehrere gruppierungsblöcke eine Datenquelle effizienter gemeinsam verwenden können, finden Sie unter [wie: JoinBlock zum Lesen aus mehreren Quellen](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[go to top](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Benutzerdefinierte Datenflussblöcke  
 Obwohl die TPL-Datenflussbibliothek viele vordefinierte Blocktypen bereitstellt, können Sie zusätzliche Blockstypen mit einem benutzerdefinierten Verhalten erstellen. Implementieren der <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> oder <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> Schnittstellen direkt, oder verwenden Sie die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Methode, um einen komplexen Block zu erstellen, die das Verhalten vorhandener Blocktypen kapselt.\</TInput, TOutput> Beispiele zur Verwendung benutzerdefinierter datenflussblockfunktionen finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer benutzerdefinierten Datenflussblocktyp](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[go to top](#top)]  
  
## <a name="related-topics"></a>Verwandte Themen  
  
|Titel|Beschreibung|  
|-----------|-----------------|  
|[Gewusst wie: Schreiben und Lesen von Nachrichten aus einem Datenflussblock](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Veranschaulicht das Schreiben und Lesen von Nachrichten aus einer <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> Objekt.|  
|[Gewusst wie: Implementieren eines Producer-Consumer-Musters](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Beschreibt, wie mit dem Datenflussmodell ein Producer-Consumer-Muster implementiert wird, bei dem der Producer Nachrichten an einen Datenflussblock sendet und der Consumer Nachrichten aus diesem Block liest.|  
|[Gewusst wie: Aktion ausführen, wenn ein Datenflussblock Daten empfängt.](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Beschreibt das Bereitstellen von Delegaten, die ausführungsdatenflussblocktypen <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, und <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.\</TInput, TOutput> \</TInput, TOutput>|  
|[Exemplarische Vorgehensweise: Erstellen einer Datenflusspipeline](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Beschreibt, wie eine Datenflusspipeline erstellt wird, die Text aus dem Web herunterlädt und Vorgänge für diesen Text ausführt.|  
|[Gewusst wie: Verknüpfungen für Datenflussblöcke aufheben](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Veranschaulicht, wie die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> Methode, um einem Zielblock und der zugehörigen Quelle aufheben, nachdem die Quelle dem Ziel eine Nachricht anbietet.|  
|[Exemplarische Vorgehensweise: Datenfluss in einer Windows Forms-Anwendung verwenden](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Veranschaulicht, wie ein Netzwerk von Datenflussblöcken erstellt wird, die eine Bildverarbeitung in einer Windows Forms-Anwendung durchführen.|  
|[Gewusst wie: einen Datenflussblock Abbrechen](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Veranschaulicht die Verwendung von Abbrüchen in einer Windows Forms-Anwendung.|  
|[Gewusst wie: JoinBlock zum Lesen von Daten aus mehreren Quellen verwenden](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Erläutert, wie die <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> Klasse, um einen Vorgang auszuführen, wenn Daten verfügbar, aus mehreren Quellen und zum nicht gierigen Modus verwenden sind, um mehrere gruppierungsblöcke eine Datenquelle effizienter gemeinsam verwenden können.\</T1, T2>|  
|[Gewusst wie: angeben den Grad der Parallelität in einem Datenflussblock](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Beschreibt das Festlegen der <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> -Eigenschaft können Sie ein ausführungsdatenflussblock mehrere Nachrichten gleichzeitig verarbeiten zu aktivieren.|  
|[Gewusst wie: einen Taskplaner in einem Datenflussblock angeben](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Veranschaulicht, wie ein bestimmter Aufgabenplaner zugeordnet wird, wenn Sie Datenfluss in Ihrer Anwendung verwenden.|  
|[Exemplarische Vorgehensweise: Verwendung von BatchBlock und BatchedJoinBlock zur Verbesserung der Effizienz](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Beschreibt, wie die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Klasse steigert die Effizienz der Datenbank einfügen, Operationen und zum Verwenden der <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> Klasse zum Erfassen der Ergebnisse und Ausnahmen, die auftreten, während das Programm aus einer Datenbank liest.\</T1, T2>|  
|[Exemplarische Vorgehensweise: Erstellen eines Datenflussblock-Typs](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Veranschaulicht zwei Möglichkeiten, einen Datenflussblocktyp zu erstellen, der benutzerdefiniertes Verhalten implementiert.|  
|[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Stellt die TPL vor, eine Bibliothek, die die parallele Programmierung in [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]-Anwendungen vereinfacht.|