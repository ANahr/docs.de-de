---
title: "Entladbare Assemblys für die dynamische typgenerierung"
description: 
ms.date: 08/29/2017
ms.prod: .net
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- reflection, dynamic assembly
- assemblies, collectible
- collectible assemblies, retrieving
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 2c9a613f4cc13c3e4189a59ace2e05d01d1bcb4f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/18/2017
---
# <a name="collectible-assemblies-for-dynamic-type-generation"></a><span data-ttu-id="1316f-102">Entladbare Assemblys für die dynamische typgenerierung</span><span class="sxs-lookup"><span data-stu-id="1316f-102">Collectible assemblies for dynamic type generation</span></span>

<span data-ttu-id="1316f-103">*Entladbare Assemblys* sind dynamische Assemblys, die entladen werden können, ohne Entladen der Anwendungsdomäne, in dem sie erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="1316f-103">*Collectible assemblies* are dynamic assemblies that can be unloaded without unloading the application domain in which they were created.</span></span> <span data-ttu-id="1316f-104">Alle verwaltetem und unverwaltetem Speicher verwendet, die durch eine entladbare Assembly und die darin enthaltenen Typen kann freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="1316f-104">All managed and unmanaged memory used by a collectible assembly and the types it contains can be reclaimed.</span></span> <span data-ttu-id="1316f-105">Informationen wie z. B. der Name der Assembly wird aus internen Tabellen entfernt.</span><span class="sxs-lookup"><span data-stu-id="1316f-105">Information such as the assembly name is removed from internal tables.</span></span>

<span data-ttu-id="1316f-106">Verwenden Sie zum Aktivieren der Entladung der <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> kennzeichnen, wenn Sie eine dynamische Assembly erstellen.</span><span class="sxs-lookup"><span data-stu-id="1316f-106">To enable unloading, use the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> flag when you create a dynamic assembly.</span></span> <span data-ttu-id="1316f-107">Die Assembly ist flüchtig (d. h., es kann nicht gespeichert werden) und im beschriebenen Einschränkungen unterliegt den [Beschränkungen entladbarer Assemblys](#restrictions-on-collectible-assemblies) Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="1316f-107">The assembly is transient (that is, it cannot be saved) and is subject to limitations described in the [Restrictions on Collectible Assemblies](#restrictions-on-collectible-assemblies) section.</span></span> <span data-ttu-id="1316f-108">Die common Language Runtime (CLR) entlädt entladbare Assemblys automatisch, wenn Sie alle Objekte, die mit der Assembly verknüpfte freigeben.</span><span class="sxs-lookup"><span data-stu-id="1316f-108">The common language runtime (CLR) unloads a collectible assembly automatically when you release all objects associated with the assembly.</span></span> <span data-ttu-id="1316f-109">In jeder anderen Hinsicht entladbarer Assemblys erstellt und auf die gleiche Weise wie andere dynamische Assemblys verwendet.</span><span class="sxs-lookup"><span data-stu-id="1316f-109">In all other respects, collectible assemblies are created and used in the same way as other dynamic assemblies.</span></span>

## <a name="lifetime-of-collectible-assemblies"></a><span data-ttu-id="1316f-110">Lebensdauer entladbarer Assemblys</span><span class="sxs-lookup"><span data-stu-id="1316f-110">Lifetime of collectible assemblies</span></span>

<span data-ttu-id="1316f-111">Die Lebensdauer einer entladbare Assembly wird gesteuert, indem das Vorhandensein von Verweisen auf die darin enthaltenen Typen und die Objekte, die von diesen Typen erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="1316f-111">The lifetime of a collectible assembly is controlled by the existence of references to the types it contains and the objects that are created from those types.</span></span> <span data-ttu-id="1316f-112">Die common Language Runtime entladen eine Assembly nicht, solange mindestens einer der folgenden vorhanden (`T` ist jeder Typ, der in der Assembly definiert ist):</span><span class="sxs-lookup"><span data-stu-id="1316f-112">The common language runtime does not unload an assembly as long as one or more of the following exist (`T` is any type that is defined in the assembly):</span></span> 

- <span data-ttu-id="1316f-113">Eine Instanz von `T`.</span><span class="sxs-lookup"><span data-stu-id="1316f-113">An instance of `T`.</span></span>

- <span data-ttu-id="1316f-114">Eine Instanz eines Arrays von `T`.</span><span class="sxs-lookup"><span data-stu-id="1316f-114">An instance of an array of `T`.</span></span>
 
- <span data-ttu-id="1316f-115">Eine Instanz eines generischen Typs, der verfügt `T` als eines seiner Typargumente.</span><span class="sxs-lookup"><span data-stu-id="1316f-115">An instance of a generic type that has `T` as one of its type arguments.</span></span> <span data-ttu-id="1316f-116">Dies schließt generische Sammlungen des `T`, selbst wenn diese Auflistung leer ist.</span><span class="sxs-lookup"><span data-stu-id="1316f-116">This includes generic collections of `T`, even if that collection is empty.</span></span>

- <span data-ttu-id="1316f-117">Eine Instanz von <xref:System.Type> oder <xref:System.Reflection.Emit.TypeBuilder> darstellt, die `T`.</span><span class="sxs-lookup"><span data-stu-id="1316f-117">An instance of <xref:System.Type> or <xref:System.Reflection.Emit.TypeBuilder> that represents `T`.</span></span> 

   > [!IMPORTANT]
   > <span data-ttu-id="1316f-118">Sie müssen alle Objekte freigeben, die Teile der Assembly darstellen.</span><span class="sxs-lookup"><span data-stu-id="1316f-118">You must release all objects that represent parts of the assembly.</span></span> <span data-ttu-id="1316f-119">Die <xref:System.Reflection.Emit.ModuleBuilder> , definiert `T` behält einen Verweis auf die <xref:System.Reflection.Emit.TypeBuilder>, und die <xref:System.Reflection.Emit.AssemblyBuilder> Objekt verwaltet einen Verweis auf die <xref:System.Reflection.Emit.ModuleBuilder>, sodass Verweise auf diese Objekte freigegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="1316f-119">The <xref:System.Reflection.Emit.ModuleBuilder> that defines `T` keeps a reference to the <xref:System.Reflection.Emit.TypeBuilder>, and the <xref:System.Reflection.Emit.AssemblyBuilder> object keeps a reference to the <xref:System.Reflection.Emit.ModuleBuilder>, so references to these objects must be released.</span></span> <span data-ttu-id="1316f-120">Auch das Vorhandensein eines eine <xref:System.Reflection.Emit.LocalBuilder> oder ein <xref:System.Reflection.Emit.ILGenerator> verwendet bei der Erstellung von `T` wird verhindert, dass entladen.</span><span class="sxs-lookup"><span data-stu-id="1316f-120">Even the existence of a <xref:System.Reflection.Emit.LocalBuilder> or an <xref:System.Reflection.Emit.ILGenerator> used in the construction of `T` prevents unloading.</span></span>

- <span data-ttu-id="1316f-121">Ein statischer Verweis auf `T` von einem anderen dynamisch definierte Typ `T1` , die durch das Ausführen von Code weiterhin erreichbar ist.</span><span class="sxs-lookup"><span data-stu-id="1316f-121">A static reference to `T` by another dynamically defined type `T1` that is still reachable by executing code.</span></span> <span data-ttu-id="1316f-122">Beispielsweise `T1` abgeleitet möglicherweise `T`, oder `T` möglicherweise, dass der Typ eines Parameters in einer Methode des `T1`.</span><span class="sxs-lookup"><span data-stu-id="1316f-122">For example, `T1` might derive from `T`, or `T` might be the type of a parameter in a method of `T1`.</span></span>
 
- <span data-ttu-id="1316f-123">Ein **ByRef** in einem statischen Feld, das zu gehört `T`.</span><span class="sxs-lookup"><span data-stu-id="1316f-123">A **ByRef** to a static field that belongs to `T`.</span></span>

- <span data-ttu-id="1316f-124">Ein <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, oder <xref:System.RuntimeMethodHandle> bezieht, die sich auf `T` oder mit einer Komponente von `T`.</span><span class="sxs-lookup"><span data-stu-id="1316f-124">A <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, or <xref:System.RuntimeMethodHandle> that refers to `T` or to a component of `T`.</span></span>

- <span data-ttu-id="1316f-125">Eine Instanz eines Reflektionsobjekts, die indirekt verwendet werden konnte oder direkt für den Zugriff auf die <xref:System.Type> Objekt, das darstellt `T`.</span><span class="sxs-lookup"><span data-stu-id="1316f-125">An instance of any reflection object that could be used indirectly or directly to access the <xref:System.Type> object that represents `T`.</span></span> <span data-ttu-id="1316f-126">Z. B. die <xref:System.Type> -Objekt für `T` abgerufen werden kann, von einem Arraytyp, dessen Elementtyp `T`, oder aus einem generischen Typ, der verfügt `T` als Typargument.</span><span class="sxs-lookup"><span data-stu-id="1316f-126">For example, the <xref:System.Type> object for `T` can be obtained from an array type whose element type is `T`, or from a generic type that has `T` as a type argument.</span></span> 

- <span data-ttu-id="1316f-127">Eine Methode `M` in der Aufrufliste für einen beliebigen Thread, in dem `M` ist eine Methode `T` oder eine auf Modulebene-Methode, die in der Assembly definiert ist.</span><span class="sxs-lookup"><span data-stu-id="1316f-127">A method `M` on the call stack of any thread, where `M` is a method of `T` or a module-level method that is defined in the assembly.</span></span>

- <span data-ttu-id="1316f-128">Ein Delegat auf eine statische Methode, die in einem Modul der Assembly definiert ist.</span><span class="sxs-lookup"><span data-stu-id="1316f-128">A delegate to a static method that is defined in a module of the assembly.</span></span>

<span data-ttu-id="1316f-129">Wenn nur ein Element aus dieser Liste für nur einen Typ oder eine Methode in der Assembly vorhanden ist, kann die Common Language Runtime die Assembly nicht entfernen.</span><span class="sxs-lookup"><span data-stu-id="1316f-129">If only one item from this list exists for only one type or one method in the assembly, the runtime cannot unload the assembly.</span></span>

> [!NOTE]
> <span data-ttu-id="1316f-130">Die Common Language Runtime wird nicht tatsächlich die Assembly entladen, bis für alle Elemente in der Liste Finalizer ausgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="1316f-130">The runtime does not actually unload the assembly until finalizers have run for all items in the list.</span></span>

<span data-ttu-id="1316f-131">Zwecks Überwachung Lebensdauer einen konstruierten generischen Typ wie z. B. `List<int>` (in c#) oder `List(Of Integer)` (in Visual Basic) ist, erstellt und verwendet die Generierung einer entladbare Assembly gilt wurden entweder in der Assembly definiert, enthält die generische Typdefinition oder in einer Assembly enthält, die die Definition eines seiner Typargumente.</span><span class="sxs-lookup"><span data-stu-id="1316f-131">For purposes of tracking lifetime, a constructed generic type such as `List<int>` (in C#) or `List(Of Integer)` (in Visual Basic) that is created and used in the generation of a collectible assembly is considered to have been defined either in the assembly that contains the generic type definition or in an assembly that contains the definition of one of its type arguments.</span></span> <span data-ttu-id="1316f-132">Die genaue Assembly, die verwendet wird, ist ein Implementierungsdetail und kann geändert.</span><span class="sxs-lookup"><span data-stu-id="1316f-132">The exact assembly that is used is an implementation detail and subject to change.</span></span>
 
## <a name="restrictions-on-collectible-assemblies"></a><span data-ttu-id="1316f-133">Einschränkungen für entladbare Assemblys</span><span class="sxs-lookup"><span data-stu-id="1316f-133">Restrictions on collectible assemblies</span></span>

<span data-ttu-id="1316f-134">Entladbare Assemblys gelten die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="1316f-134">The following restrictions apply to collectible assemblies:</span></span> 

- <span data-ttu-id="1316f-135">**Der Code statische Verweise** </span><span class="sxs-lookup"><span data-stu-id="1316f-135">**Static references** </span></span>  
  <span data-ttu-id="1316f-136">Typen in eine gewöhnliche dynamische Assembly sind keine statische Verweise auf Typen, die in einer entladbare Assembly definiert sind.</span><span class="sxs-lookup"><span data-stu-id="1316f-136">Types in an ordinary dynamic assembly cannot have static references to types that are defined in a collectible assembly.</span></span> <span data-ttu-id="1316f-137">Wenn Sie einen normalen Typ definieren, die von einem Typ in einer entladbare Assembly erbt beispielsweise eine <xref:System.NotSupportedException> Ausnahme wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1316f-137">For example, if you define an ordinary type that inherits from a type in a collectible assembly, a <xref:System.NotSupportedException> exception is thrown.</span></span> <span data-ttu-id="1316f-138">Ein Typ in einer entladbare Assembly kann Code statische Verweise auf einen Typ in einer anderen entladbare Assembly haben, aber dies erweitert die Lebensdauer der Assembly, die die Lebensdauer der verweisenden Assembly verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="1316f-138">A type in a collectible assembly can have static references to a type in another collectible assembly, but this extends the lifetime of the referenced assembly to the lifetime of the referencing assembly.</span></span>

- <span data-ttu-id="1316f-139">**COM-interop** </span><span class="sxs-lookup"><span data-stu-id="1316f-139">**COM interop** </span></span>  
   <span data-ttu-id="1316f-140">Keine COM-Schnittstellen können innerhalb einer entladbaren Assembly definiert werden, und keine Instanzen von Typen in einer entladbare Assembly in COM-Objekte konvertiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1316f-140">No COM interfaces can be defined within a collectible assembly, and no instances of types within a collectible assembly can be converted into COM objects.</span></span> <span data-ttu-id="1316f-141">Ein Typ in einer entladbare Assembly kann nicht als COM callable Wrapper (CCW) oder Common Language Runtime callable Wrapper (RCW) dienen.</span><span class="sxs-lookup"><span data-stu-id="1316f-141">A type in a collectible assembly cannot serve as a COM callable wrapper (CCW) or runtime callable wrapper (RCW).</span></span> <span data-ttu-id="1316f-142">Allerdings können Typen in Assemblys entladbarer Objekte, die COM-Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="1316f-142">However, types in collectible assemblies can use objects that implement COM interfaces.</span></span>

- <span data-ttu-id="1316f-143">**Plattformaufruf** </span><span class="sxs-lookup"><span data-stu-id="1316f-143">**Platform invoke** </span></span>  
   <span data-ttu-id="1316f-144">Methoden, auf die <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut kann nicht kompiliert werden, wenn sie in einer entladbare Assembly deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="1316f-144">Methods that have the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute will not compile when they are declared in a collectible assembly.</span></span> <span data-ttu-id="1316f-145">Die <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> Anweisung kann nicht in der Implementierung eines Typs in eine entladbare Assembly verwendet werden, und solche Typen können nicht zu nicht verwaltetem Code gemarshallt werden.</span><span class="sxs-lookup"><span data-stu-id="1316f-145">The <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> instruction cannot be used in the implementation of a type in a collectible assembly, and such types cannot be marshaled to unmanaged code.</span></span> <span data-ttu-id="1316f-146">Allerdings können Sie in systemeigenen Code mit Aufrufen eines Einstiegspunkts, das in einer nicht-entladbare Assembly deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="1316f-146">However, you can call into native code by using an entry point that is declared in a non-collectible assembly.</span></span>
 
- <span data-ttu-id="1316f-147">**Marshalling** </span><span class="sxs-lookup"><span data-stu-id="1316f-147">**Marshaling** </span></span>  
   <span data-ttu-id="1316f-148">Objekte (in bestimmten, Delegaten), die in entladbare Assemblys definiert sind, können nicht gemarshallt werden.</span><span class="sxs-lookup"><span data-stu-id="1316f-148">Objects (in particular, delegates) that are defined in collectible assemblies cannot be marshaled.</span></span> <span data-ttu-id="1316f-149">Dies ist eine Einschränkung für alle flüchtigen ausgegebenen Typen.</span><span class="sxs-lookup"><span data-stu-id="1316f-149">This is a restriction on all transient emitted types.</span></span>

- <span data-ttu-id="1316f-150">**Das Laden einer Assembly** </span><span class="sxs-lookup"><span data-stu-id="1316f-150">**Assembly loading** </span></span>  
   <span data-ttu-id="1316f-151">Reflektionsausgabe ist der einzige Mechanismus, der zum Laden von Assemblys entladbare unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="1316f-151">Reflection emit is the only mechanism that is supported for loading collectible assemblies.</span></span> <span data-ttu-id="1316f-152">Assemblys, die geladen werden, indem Sie jede sonstige Form von das Laden einer Assembly können nicht entladen werden.</span><span class="sxs-lookup"><span data-stu-id="1316f-152">Assemblies that are loaded by using any other form of assembly loading cannot be unloaded.</span></span>
 
- <span data-ttu-id="1316f-153">**Kontext gebundene Objekte**  </span><span class="sxs-lookup"><span data-stu-id="1316f-153">**Context-bound objects**  </span></span>  
   <span data-ttu-id="1316f-154">Kontextunabhängige Variablen werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1316f-154">Context-static variables are not supported.</span></span> <span data-ttu-id="1316f-155">Typen in einer entladbare Assembly können nicht erweitert werden <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="1316f-155">Types in a collectible assembly cannot extend <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1316f-156">Jedoch kann Code entladbarer Assemblys verwendet kontextgebundene-Objekte, die definiert, werden an anderer Stelle.</span><span class="sxs-lookup"><span data-stu-id="1316f-156">However, code in collectible assemblies can use context-bound objects that are defined elsewhere.</span></span>

- <span data-ttu-id="1316f-157">**Threadstatische Daten**     </span><span class="sxs-lookup"><span data-stu-id="1316f-157">**Thread-static data**     </span></span>  
   <span data-ttu-id="1316f-158">Threadstatische Variablen werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1316f-158">Thread-static variables are not supported.</span></span>

## <a name="see-also"></a><span data-ttu-id="1316f-159">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="1316f-159">See also</span></span>

[<span data-ttu-id="1316f-160">Ausgeben von dynamischen Methoden und Assemblys</span><span class="sxs-lookup"><span data-stu-id="1316f-160">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
