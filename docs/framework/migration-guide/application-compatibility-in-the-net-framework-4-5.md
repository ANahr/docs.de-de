---
title: "Anwendungskompatibilit&#228;t in .NET Framework 4.5 | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Anwendungskompatibilität, .NET Framework"
  - "Wichtige Änderungen [.NET Framework]"
ms.assetid: 5c50747c-806c-44a9-ac58-5bbe12a284fa
caps.latest.revision: 76
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 76
---
# Anwendungskompatibilit&#228;t in .NET Framework 4.5
In diesem Thema werden Anwendungskompatibilitätsprobleme zwischen .NET Framework 4 und 4.5 beschrieben, einschließlich der Fixes und Änderungen auf Grundlage von Kundenfeedback. Für die meisten dieser Änderungen sind keine Programmieränderungen in den Anwendungen erforderlich. In den Fällen, in denen Änderungen erforderlich sind, finden Sie Informationen in der Spalte "Auswirkungen" der Tabellen.  
  
> [!IMPORTANT]
>  Beachten Sie, dass [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] von [!INCLUDE[winxp](../../../includes/winxp-md.md)] nicht unterstützt wird.  
  
 Weitere Informationen zu Kompatibilitätsproblemen zwischen .NET Framework 4.5 und 4.5.1 finden Sie unter [Anwendungskompatibilität in 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md).  
  
 In diesem Thema werden wichtige Änderungen in den folgenden Bereichen beschrieben:  
  
-   [Kernspeicher](#core)  
  
-   [Daten](#sql)  
  
-   [Netzwerk](#network)  
  
-   [Serialisierung](#serialize)  
  
-   [Drucken](#Printing)  
  
-   [Tools und Ressourcen](#tools)  
  
-   [ASP.NET](#asp)  
  
-   [ClickOnce](#ClickOnce)  
  
-   [Managed Extensibility Framework \(MEF\)](#mef)  
  
-   [Webanwendungen](#web)  
  
-   [Windows Communication Foundation \(WCF\)](#wcf)  
  
-   [Windows Forms](#winForms)  
  
-   [Windows Presentation Foundation \(WPF\)](#wpf)  
  
-   [Windows Workflow Foundation (WF)](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md#wwf)  
  
-   [XML, XSLT](#xml)  
  
 Dieses Thema umfasst keine Typen und Member, die in [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] als veraltet deklariert wurden. Eine Liste dieser veralteten Typen und Member finden Sie unter [Veraltete Elemente in der Klassenbibliothek](../../../docs/framework/whats-new/whats-obsolete.md). Weitere Informationen zu neuen Funktionen finden Sie unter [Neues](../../../docs/framework/whats-new/index.md).  
  
<a name="core"></a>   
## Kernspeicher  
 Neben den folgenden Anwendungskompatibilitätsproblemen finden Sie im Abschnitt [Serialisierung](#serialize) Probleme in Bezug auf die Serialisierung.  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Die Methoden [BlockingCollection\<T\>.TryTakeFromAny\(BlockingCollection\<T\>\<xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> und <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName>|Die [BlockingCollection\<T\>.TryTakeFromAny\(BlockingCollection\<T\>\<xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName>\-Methode gibt nicht mehr – 1 zurück oder löst keine Ausnahme mehr aus. Die <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName>\-Methode löst keine Ausnahme mehr aus, wenn eine der Auflistungen als abgeschlossen gekennzeichnet ist.|Diese Änderung ermöglicht das Verwenden von Auflistungen, wenn eine der Auflistungen entweder leer oder abgeschlossen ist, die andere Auflistung aber weiterhin abrufbare Elemente enthält.|  
|<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName>|Wenn eine Assembly aus kompilierten regulären Ausdrücken mit [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] erstellt wird und [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] als Ziel verwendet, wird beim Versuch, die regulären Ausdrücke in dieser Assembly auf einem System mit installiertem [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] zu verwenden, eine Ausnahme ausgelöst.|Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten:<br /><br /> Erstellen Sie die Assembly, die die regulären Ausdrücke enthält, mit [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)].<br /><br /> Verwenden Sie einen interpretierten regulären Ausdruck.|  
|<xref:System.Threading.Tasks.Task?displayProperty=fullName>\-Freigabe|Mit Ausnahme von `Task.IAsyncResult.AsyncWaitHandle` lösen <xref:System.Threading.Tasks.Task?displayProperty=fullName>\-Methoden keine <xref:System.ObjectDisposedException>\-Ausnahme mehr aus, nachdem das Objekt freigegeben wurde.|Diese Änderung unterstützt die Verwendung von zwischengespeicherten Aufgaben. Beispielsweise kann eine Methode eine zwischengespeicherte Aufgabe zurückgeben, um einen bereits abgeschlossenen Vorgang darzustellen, anstatt eine neue Aufgabe zuzuordnen. Dies war in früheren .NET Framework\-Versionen nicht möglich, da jeder Consumer der Aufgabe diese freigeben konnte und somit unbrauchbar machte.|  
|Nicht überwachte Ausnahmen in <xref:System.Threading.Tasks.Task?displayProperty=fullName>\-Vorgängen|Da die <xref:System.Threading.Tasks.Task?displayProperty=fullName>\-Klasse einen asynchronen Vorgang darstellt, fängt sie alle nicht schwerwiegenden Ausnahmen ab, die während einer asynchronen Verarbeitung auftreten. Wenn eine Ausnahme in [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] nicht überwacht wird und der Code nie auf die Aufgabe wartet, wird die Ausnahme nicht mehr im Finalizer\-Thread weitergegeben und führt dazu, dass der Prozess während der Garbage Collection abstürzt.|Diese Änderung erhöht die Zuverlässigkeit von Anwendungen, die mithilfe der <xref:System.Threading.Tasks.Task>\-Klasse nicht überwachte asynchrone Verarbeitungen ausführen. Das frühere Verhalten kann mit einem entsprechenden Handler für das <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=fullName>\-Ereignis wiederhergestellt werden.|  
|<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName>\-Methoden mit Timeout\-Argumenten|In [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] war das Verhalten dieser Methoden inkonsistent. Wenn vor dem abgelaufenen Timeoutintervall eine oder mehrere Aufgaben vor dem Methodenaufruf abgeschlossen oder abgebrochen wurden, löste die Methode eine <xref:System.AggregateException>\-Ausnahme aus. Wenn vor dem abgelaufenen Timeoutintervall keine Aufgaben vor dem Methodenaufruf abgeschlossen oder abgebrochen wurden, aber eine oder mehrere Aufgaben nach dem Methodenaufruf in diesen Zustand eingetreten waren, gab die Methode `false` zurück.<br /><br /> In [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] geben diese Methodenüberladungen jetzt `false` zurück, falls noch Aufgaben ausgeführt werden, wenn das Timeoutintervall abläuft, und sie lösen nur dann eine <xref:System.AggregateException>\-Ausnahme aus, wenn eine Eingabeaufgabe abgebrochen wurde \(unabhängig davon, ob sie vor oder nach dem Aufruf der Methode abgebrochen wurde\) und keine anderen Aufgaben mehr ausgeführt werden.|Durch diese Änderung ist das Verhalten der Methode jetzt konsistent. Es ist jedoch möglich \(wenn auch unwahrscheinlich\), dass Anwendungscode davon abhängig ist, dass <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName>\-Überladungen mit aktiviertem Timeout eine Ausnahme auslösen, wenn mindestens eine Aufgabe bereits vor Ablauf des Timeoutintervalls fehlerhaft war oder abgebrochen wurde. In diesem Fall kann die <xref:System.Threading.Tasks.Task.IsCanceled%2A?displayProperty=fullName>\-Eigenschaft für diesen Zweck verwendet werden.|  
|Unterstützung für Typweiterleitung bei Festlegung von Zielversionen|Durch eine neue CodeDOM\-Funktion kann ein Compiler anhand der Zielversion von mscorlib.dll anstelle der [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]\-Version von mscorlib.dll kompilieren.|Diese Änderung verhindert Compilerwarnungen \(und Kompilierungsfehler, wenn Warnungen als Fehler behandelt werden\), wenn CodeDOM zwei Definitionen für Typen findet, bei denen eine Typweiterleitung ausgeführt wurde. Diese Änderung hat möglicherweise nur dann unbeabsichtigte Nebeneffekte, wenn verschiedene Versionen von Verweisassemblys an einem einzigen Speicherort kombiniert werden.|  
|<xref:System.Collections.Generic.List%601.ForEach%2A?displayProperty=fullName>|Der Enumerator löst eine <xref:System.InvalidOperationException>\-Ausnahme aus, wenn ein Element in der Auflistung geändert wird.|Diese Änderung gilt nur für Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgerichtet sind, und sollte keine negativen Auswirkungen haben. Sie gewährleistet die Datenintegrität und erhöht die Wahrscheinlichkeit, dass Racebedingungen identifiziert werden.|  
|<xref:System.Uri?displayProperty=fullName>|In Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgerichtet sind, haben zwei Änderungen der IRI \(International Resource Identifier\)\-Analysen eine Auswirkung auf URIs:<br /><br /> [\<iriParsing\>](../../../docs/framework/configure-apps/file-schema/network/iriparsing-element-uri-settings.md) ist standardmäßig aktiviert und kann nicht deaktiviert werden. Zuvor war es standardmäßig deaktiviert.<br /><br /> Unicode Normalization Form C \(NFC\) wird für Nichthost\-Teile von URIs nicht mehr ausgeführt. Zuvor wurde NFC für den gesamten URI ausgeführt, wenn `<iriParsing>` aktiviert war.|URIs, deren Dateinamen nicht nach NFC \(Normalization Form C\) normalisiert sind, werden nicht nach Format C normalisiert. Verwendet die IRI\-Analyse beim Zugreifen auf Dateien mit normalisierten Dateinamen nicht normalisierte Zeichenfolgen, treten möglicherweise Anwendungsfehler auf. Dies betrifft nur Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] abzielen.|  
|<xref:System.Uri?displayProperty=fullName>|Eine ungültige `mailto:`\-URL löst eine Ausnahme im <xref:System.Uri>\-Klassenkonstruktor aus.|Dies betrifft nur Anwendungen, die neu kompiliert wurden und auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] abzielen.|  
|<xref:System.Uri?displayProperty=fullName>|In Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgerichtet sind, werden nachgestellte Punkte am Ende eines Pfadsegments in einer ursprünglichen URI\-Zeichenfolge \(beispielsweise `http://www.proseware.com/LLC./About.aspx`\) beibehalten. \(Beachten Sie, dass Pfadsegmente aus genau ein oder zwei Punkten, wie beispielsweise `http://www.proseware.com/..` oder `http://www.proseware.com/./default.htm`, entfernt werden, Pfadsegmente mit mehr als zwei aufeinander folgenden Punkten \(z. B. `http://localhost/dir1/.../dir2`\) jedoch beibehalten werden.|Diese Änderung betrifft nur Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] abzielen. Bei Anwendungen, die darauf basieren, dass die nachgestellten Punkte entfernt werden, treten möglicherweise Fehler auf.|  
|<xref:System.Uri?displayProperty=fullName>|In Anwendungen, die [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] als Ziel haben, sind Abfragen in einem `file://`\-URI zulässig. Das Zeichen "?" wird nicht mit Escapezeichen versehen, da es als Teil des Pfads interpretiert wird.|Diese Änderung betrifft nur Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] abzielen. Bei Anwendungen, die sich darauf verlassen, dass das Zeichen "?" mit Escapezeichen versehen wird, treten möglicherweise Fehler auf.|  
|<xref:System.Uri?displayProperty=fullName>|In Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgerichtet sind, werden Unicode\-Steuerzeichen von U\+0080 bis U\+009F falsch codiert.|Normalerweise werden Unicode\-Steuerzeichen in URIs nicht verwendet.|  
|<xref:System.Uri.EscapeDataString%2A?displayProperty=fullName>, <xref:System.Uri.EscapeUriString%2A?displayProperty=fullName> und <xref:System.Uri.UnescapeDataString%2A?displayProperty=fullName>|Die Liste reservierter und nicht reservierter Zeichen unterstützt nun [RFC 3986](http://tools.ietf.org/html/rfc3986).|Spezielle Änderungen:<br /><br /> <xref:System.Uri.EscapeDataString%2A> versieht reservierte Zeichen basierend auf RFC 3986 mit Escapezeichen.<br /><br /> <xref:System.Uri.EscapeUriString%2A> versieht reservierte Zeichen nicht mit Escapezeichen.<br /><br /> <xref:System.Uri.UnescapeDataString%2A> löst keine Ausnahme aus, wenn eine ungültige Escapesequenz gefunden wird.<br /><br /> Bei nicht reservierten Zeichen mit Escapezeichen werden letztere entfernt.|  
|<xref:System.Uri.IsWellFormedUriString%2A?displayProperty=fullName>|Ab .NET Framework 4.5 werden Zeichenfolgen in Übereinstimmung mit [RFC 3986](http://tools.ietf.org/html/rfc3986) und [RFC 3987](http://tools.ietf.org/html/rfc3987) immer als wohlgeformt betrachtet. In früheren Versionen von .NET Framework wird eine Zeichenfolge ausschließlich als wohlgeformt in Übereinstimmung mit RFC 3986 und RFC 3987 angesehen, wenn die URI\-Analyse und die IDN\-Analyse aktiviert sind.|Für Apps, die sich an .NET Framework 4.5 oder höher richten, gibt diese Methode für einige URIs `false` zurück. Diese URIs gelten für Apps, die sich an frühere Versionen von .NET Framework richten, als wohlgeformt. Ein relativer URI, der im ersten Segment einen Doppelpunkt enthält \(z.B. „2013.05.29\_14:33:41“\), gilt nicht länger als wohlgeformt.<br /><br /> Beachten Sie, dass diese Änderung nur Apps betrifft, die sich an .NET Framework 4.5 oder höher richten.|  
|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName> kann jetzt auf die <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName>\-Eigenschaft zugreifen. Nicht ordnungsgemäße Implementierungen von <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> können jetzt in <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>\-Methodenaufrufen zu undefiniertem Verhalten führen.|Die resultierende Aufgabe wird nicht abgeschlossen, wenn die Implementierung der <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName>\-Eigenschaft fälschlicherweise `true` zurückgibt.|  
  
<a name="sql"></a>   
## Daten  
  
### SQLClient  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Herstellen einer Verbindung mit einer SQL Server\-Datenbank aus verwaltetem Code, der unter [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgeführt wird.|Der vorhandene synchrone API\-Codepfad wurde geändert, um eine asynchrone Unterstützung hinzuzufügen.|Sind Non\-IFS\-Winsock\-Basisdienstanbieter \(BSPs\) oder Mehrschicht\-Dienstanbieter \(LSPs\) installiert, kann möglicherweise keine Verbindung mit SQL Server hergestellt werden. Weitere Informationen finden Sie unter [SetFileCompletionNotificationModes\-API verursacht Probleme bei EA\-Abschlussport mit installiertem Non\-IFS\-LSP](http://go.microsoft.com/fwlink/p/?LinkId=256032) auf der Microsoft Support\-Website.|  
|<xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>\-Typ|Verbindungen mit Datenbanken von SQL Server 1997 werden nicht mehr unterstützt.|Anwendungen, die unter [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgeführt werden, können mit Datenbanken von SQL Server 1997 keine Verbindung herstellen.|  
|<xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>\-Typ|Verbindungen mit SQL Server\-Datenbanken mit VIA \(Virtual Interface Adapter\)\-Protokoll werden nicht mehr unterstützt.|Anwendungen, die unter [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ausgeführt werden, können mit SQL Server\-Datenbanken, die VIA verwenden, keine Verbindung herstellen.|  
|<xref:System.Data.SqlClient.SqlBulkCopy?displayProperty=fullName>\-Typ|Beim Einfügen von Daten in eine Spalte verwendet <xref:System.Data.SqlClient.SqlBulkCopy> die Codierung der Zielspalte, und nicht die Standardcodierung für `VARCHAR`\- und `CHAR`\-Typen.|Diese Änderung schließt die Gefahr einer möglichen Datenbeschädigung aus, die bei Verwenden der Standardcodierung verursacht wird, wenn diese nicht von der Zielspalte verwendet wird. In seltenen Fällen kann eine vorhandene Anwendung eine <xref:System.Data.SqlClient.SqlException>\-Ausnahme auslösen, wenn die Änderung der Codierung Daten erzeugt, die zu groß für die Zielspalte sind.|  
|<xref:System.Data.SqlClient?displayProperty=fullName>\-Sortierreihenfolge|`sql_variant`\-Daten verwenden `sql_variant`\-Sortierreihenfolgen anstatt Datenbanksortierreihenfolgen.|Diese Änderung behandelt potenzielle Datenbeschädigungen, die verursacht werden, wenn sich die Datenbanksortierreihenfolge von der `sql_variant`\-Sortierreihenfolge unterscheidet. Bei Anwendungen, die auf den beschädigten Daten basieren, treten möglicherweise Fehler auf.|  
  
### Entity Framework  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Mit der <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName>\-Methode erstellte Protokolldateien|Wenn die <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A>\-Methode entweder direkt oder durch Code First mit dem SqlClient\-Anbieter und einem `AttachDBFilename`\-Wert in der Verbindungszeichenfolge aufgerufen wird, erstellt sie eine Protokolldatei namens *Dateiname*\_log.ldf anstelle von *Dateiname*.ldf \(wobei *Dateiname* der vom `AttachDBFilename`\-Wert angegebene Name der Datei ist\).|Diese Änderung verbessert das Debuggen, indem eine Protokolldatei bereitgestellt wird, die nach den SQL Server\-Spezifikationen benannt wird. Dies sollte keine unerwarteten Nebeneffekte aufweisen.|  
|Datendefinitionssprachen \(Data Definition Language, DDL\)\-APIs|Das Verhalten von DDL\-APIs beim Angeben von `AttachDBFilename` hat sich wie folgt geändert:<br /><br /> Verbindungszeichenfolgen müssen keinen `Initial Catalog`\-Wert angeben. Bislang waren `AttatchDBFilename` und `Initial Catalog` gleichermaßen erforderlich.<br /><br /> Wenn sowohl `AttatchDBFilename` als auch `Initial Catalog` angegeben werden und die angegebene MDF\-Datei vorhanden ist, gibt die <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName>\-Methode `true` zurück. Bislang hat sie `false` zurückgegeben.<br /><br /> Wenn sowohl `AttatchDBFilename` als auch `Initial Catalog` angegeben werden und die angegebene MDF\-Datei vorhanden ist, werden mit dem Aufrufen der <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName>\-Methode die Dateien gelöscht.<br /><br /> Wird <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> aufgerufen, wenn die Verbindungszeichenfolge einen `AttachDBFilename`\-Wert mit einer MDF angibt, die nicht vorhanden ist, und einen `Initial Catalog`, der nicht vorhanden ist, löst die Methode eine <xref:System.InvalidOperationException>\-Ausnahme aus. Zuvor hat sie eine <xref:System.Data.SqlClient.SqlException>\-Ausnahme ausgelöst.|Diese Änderungen erleichtern das Erstellen von Tools und Anwendungen, die die DDL\-APIs verwenden. Diese Änderungen können sich in den folgenden Szenarien auf die Anwendungskompatibilität auswirken:<br /><br /> Der Benutzer schreibt Code, der einen `DROP DATABASE`\-Befehl ausführt, anstatt direkt <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> aufzurufen, wenn <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName>`true` zurückgibt. Ist die Datenbank nicht angefügt, die MDF\-Datei jedoch vorhanden, wird vorhandener Code hierdurch unbrauchbar.<br /><br /> Der Benutzer schreibt Code, der erwartet, dass die <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName>\-Methode eine <xref:System.Data.SqlClient.SqlException>\-Ausnahme anstelle einer <xref:System.InvalidOperationException>\-Ausnahme auslöst, wenn der `Initial Catalog` und die MDF\-Datei nicht vorhanden sind.|  
|Die Methoden <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName> und <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A?displayProperty=fullName>|Tritt bei dem Erstellen von Datenbankobjekten ein Fehler auf, nachdem eine leere Datenbank erstellt wurde, versucht die Methode, die Datenbankerstellung abzulegen, und gibt die ursprüngliche <xref:System.Data.SqlClient.SqlException> Ausnahme weiter. Tritt bei dem Versuch, die Datenbank abzulegen, ein Fehler auf, löst die Methode eine <xref:System.InvalidOperationException>\-Ausnahme aus.|Diese Änderung verhindert die Erstellung einer leeren, unbrauchbaren Datenbank. Mit einer Ausnahmebehandlung lässt sich eine gewisse Änderung herbeiführen, da das erfolgreiche Entfernen der Datenbank jetzt die ursprüngliche <xref:System.Data.SqlClient.SqlException> Ausnahme weitergibt.|  
|Die Methoden <xref:System.Data.Objects.ObjectContext.Translate%2A?displayProperty=fullName> und <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A?displayProperty=fullName>|Wenn `T` ein Enumerationstyp ist, gibt die Methode ordnungsgemäß Daten aus der Datenbank zurück.  Zuvor wurden Enumerationstypen nicht unterstützt, sodass das Ergebnis immer zu NULL umgewandelt oder in den Enumerationstyp konvertiert wurde. Zugrunde liegende Typen, die nicht von Entity Framework unterstützt werden, z. B. <xref:System.UInt16>, <xref:System.UInt32> und <xref:System.UInt64>; immer noch NULL zurückgeben oder mit einem zugrunde liegenden Wert NULL in den Enumerationstyp konvertiert werden.|Die Unterstützung von Enumerationen ist neu im Entity Framework in [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Hängt Entwicklercode vom Ergebnis NULL ab, könnte je nach spezifischem Code ein Anwendungsfehler auftreten.|  
  
### LINQ  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|<xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName>\-Methode|Die Methode gibt eine zwischengespeicherte interne Instanz zurück, anstatt einen neuen <xref:System.Collections.Generic.IEnumerable%601>\-Typ.|Diese Änderung verbessert die Leistung. Bei Code, der aus mehreren Aufrufen an <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName> zwei eindeutige leeren Typen abrufen muss, tritt jedoch ein Fehler auf.|  
  
<a name="network"></a>   
## Netzwerk  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Typen und Member vom <xref:System.Net.PeerToPeer.Collaboration?displayProperty=fullName>\-Namespace|Die Typen und Member werden von [!INCLUDE[win8](../../../includes/win8-md.md)] nicht unterstützt. Werden sie aufgerufen, wird eine <xref:System.PlatformNotSupportedException>\-Ausnahme ausgelöst.|Anwendungen können diese Typen und Member unter [!INCLUDE[win8](../../../includes/win8-md.md)] nicht mehr verwenden.|  
|Serialisierung und Deserialisierung von <xref:System.Net.Mail.MailMessage>\-Objekten|In .NET Framework 4.5 können E\-Mail\-Nachrichten Nicht\-ASCII\-Zeichen enthalten. In .NET Framework 4 werden nur ASCII\-Zeichen unterstützt.|<xref:System.Net.Mail.MailMessage>\-Objekte, die Nicht\-ASCII\-Zeichen enthalten, und unter .NET Framework 4.5 serialisiert werden, können unter .NET Framework 4 nicht deserialisiert werden.|  
  
<a name="Printing"></a>   
## Drucken  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|<xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>|Diese Eigenschaft macht den Datenstrom eines Druckauftrags verfügbar und ermöglicht es dem Benutzer, unformatierte Daten an die Druckkomponenten des zugrunde liegenden Betriebssystems zu senden, indem in diesen Datenstrom geschrieben wird.<br /><br /> Ab .NET Framework 4.5 unter Windows 8 und höheren Windows\-Betriebssystemversionen müssen in diesen Datenstrom geschriebene Daten als Paketdatenstrom im XPS\-Format vorliegen.|Zum Ausgeben der Druckinhalte können Sie einen der folgenden Schritte ausführen:<br /><br /> Verwenden Sie die <xref:System.Windows.Xps.XpsDocumentWriter>\-Klasse, um Druckinhalte auszugeben. Dies ist die empfohlene Alternative.<br /><br /> Stellen Sie sicher, dass die Daten, die an den von der <xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>\-Eigenschaft zurückgegebenen Datenstrom gesendet werden, im XPS\-Format als Paketdatenstrom vorliegen.|  
  
<a name="serialize"></a>   
## Serialisierung  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Serialisierung mit der <xref:System.Xml.Serialization.XmlSerializer>\-Klasse|In WCF 4.5 wurde die <xref:System.Xml.Serialization.XmlSerializer>\-Klasse optimiert, um deren Abhängigkeit vom C\#\-Compiler zu beseitigen. Diese Änderung bietet deutliche Leistungssteigerungen für Kaltstartszenarien.|Die Änderung kann Probleme im XML\-Serialisierungscode verursachen, der in WCF 4 kompiliert wurde, wird aber für WCF 4.5 ausgeführt. Wenn bei der Ausführung von vorhandenem XML\-Serialisierungscode in WCF 4.5 Probleme auftreten, verwenden Sie das folgende Konfigurationselement, um zum XmlSerializer\-Verhalten in WCF 4 zurückzukehren:<br /><br /> `<configuration>    <system.xml.serialization>    <xmlSerializer useLegacySerializerGeneration="true"/>    </system.xml.serialization> </configuration>`|  
|Serialisierung und Deserialisierung mit der <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter?displayProperty=fullName>\-Klasse|Durch die Serialisierung mithilfe von <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> kann der interne Status eines Objekts codiert werden, der zwischen verschiedenen Versionen von .NET Framework unterschiedlich sein kann.  Wenn Unterschiede vorliegen, kann es beim Deserialisieren zu Problemen von in einer Version von .NET Framework serialisierten Inhalten in anderen Versionen kommen.|Die <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>\-Klasse verspricht keine versionsübergreifende Kompatibilität. Verwenden Sie stattdessen die Klassen <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=fullName> und <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=fullName>.|  
  
<a name="tools"></a>   
## Tools und Ressourcen  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|MSBuild|Wird MSBuild mit Eingabeaufforderung ausgeführt, werden die Projektmappenkonfigurationsdateien, die Builds bestimmter Projekte deaktivieren, berücksichtigt.|MSBuild zeigt bei Aufrufen durch Visual Studio und bei Ausführen mit Eingabeaufforderung ein identisches Verhalten. Es müssen keine separaten Projektmappen erstellt oder Projekte aus einer Projektmappe entfernt werden, um eine Teilmenge von Projekten in einer Projektmappe zu erstellen.|  
|MSBuild|Die `TreatAsLocalProperty`\-Eigenschaft in MSBuild\-Projektdateien verhindert, dass bestimmte Eigenschaften, einschließlich der `OutDir`\-Eigenschaft, auf globaler Ebene überschrieben werden.|Überschreibungen der `OutDir`\-Eigenschaft führen möglicherweise zum Abbruch, wenn `OutDir` eine globale Eigenschaft ist, die nach dem Importieren der MS.Common.Targets\-Datei überschrieben wird.|  
|Windows\-Fehlerbericht: Watson\-Buckets|Verwaltete Abstürze werden auf Grundlage mehrerer Kriterien nach Kategorien gruppiert, wozu bisher die Assemblyversion gehörte. In [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] wird anstelle der Assemblyversion die Dateiversion verwendet.|Da sich die Assemblyversion nur in den Hauptversionen unterscheidet, lässt sich mit der Dateiversion anstelle der Assemblyversion als Kategorie die spezifische Version einer Assembly ermitteln, die in einem verwalteten Absturz involviert war.|  
|MSBuild|Daten aus Projekten in der <xref:Microsoft.Build.Evaluation.ProjectCollection?displayProperty=fullName>\-Sammlung werden nicht automatisch vom Garbage Collector freigegeben.|Wenn Sie Projekte explizit in die Sammlung <xref:Microsoft.Build.Evaluation.ProjectCollection> laden, sollten Sie die <xref:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject%28Microsoft.Build.Evaluation.Project%29>\-Methode für jedes Element der Sammlung aufrufen.|  
  
<a name="asp"></a>   
## ASP.NET  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|ASP.NET IIS\-Registrierungstool \(Aspnet\_regiis.exe\)|Unter [!INCLUDE[win8](../../../includes/win8-md.md)] werden die Optionen `–i` und `–u` zum Installieren und Deinstallieren von ASP.NET nicht unterstützt.|Um ASP.NET 4.5 mit IIS 8 zu installieren oder zu deinstallieren, verwenden Sie das Dialogfeld **Windows\-Funktionen aktivieren oder deaktivieren**, das Server\-Verwaltungstool oder das `dism.exe`\-Befehlszeilentool.|  
|<xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName>\-Steuerelement|Das <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName>\-Ereignis führt nicht mehr dazu, dass das <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName>\-Steuerelement Datenbindungen für Änderungen an Erstellungs\-\/Update\-\/Löschparametern aufruft.|Diese Änderung schließt unnötige Roundtrips zur Datenbank sowie ein Zurücksetzen der Werte von Steuerelementen aus und erzeugt Verhaltensweisen, die mit anderen Datensteuerelementen, z. B. <xref:System.Web.UI.WebControls.SqlDataSource> und <xref:System.Web.UI.WebControls.ObjectDataSource> konsistent sind. Diese Änderung erzeugt im unwahrscheinlichen Fall, dass Anwendungen im <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName>\-Ereignis auf Aufrufen der Datenbindung basieren, ein anderes Verhalten.|  
|<xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>\-, <xref:System.Net.WebUtility.UrlDecode%2A?displayProperty=fullName>\- und [System.Web.Helpers.Json.Decode](https://msdn.microsoft.com/library/system.web.helpers.json.decode.aspx)\-Methoden|Decodierungsmethoden decodieren nicht mehr standardmäßig ungültige Eingabesequenzen in ungültige UTF\-16\-Zeichenfolgen. Stattdessen geben sie die ursprüngliche Eingabe zurück.|Die Änderung der Decoderausgabe sollte nur von Bedeutung sein, wenn Sie Binärdaten statt der UTF\-16\-Daten in Zeichenfolgen speichern. Um dieses Verhalten explizit zu steuern, legen Sie das `aspnet:AllowRelaxedUnicodeDecoding`\-Attribut des [\<appSettings\>](http://msdn.microsoft.com/de-de/0d65a3f1-c522-423d-89b6-44921b6daebb)\-Elements auf `true` fest, um Legacyverhalten zu aktivieren, oder auf `false`, um das aktuelle Verhalten zu aktivieren.|  
|<xref:System.Net.WebUtility.HtmlEncode%2A?displayProperty=fullName>\-Methode|Bei Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] abzielen, durchlaufen Zeichen, die sich außerhalb des Basic Multilingual Plane \(BMP\) befinden, einen erfolgreichen Roundtrip, wenn sie an die <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>\-Methode übergeben werden.|Diese Änderung sollte keine Auswirkungen auf aktuelle Anwendungen haben. Um das ursprüngliche Verhalten wiederherzustellen, legen Sie das `targetFramework`\-Attribut des [\<httpRuntime\>](http://msdn.microsoft.com/library/e1f13641\(v=vs.100\).aspx)\-Elements auf eine andere Zeichenfolge als "4.5" fest. Sie können die `unicodeEncodingConformance`\- und `unicodeDecodingConformance`\-Attribute des `<webUtility>`\-Konfigurationselements auch festlegen, um dieses Verhalten unabhängig von der Zielversion von .NET Framework zu steuern.|  
|<xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=fullName>\-Eigenschaft|UTF\-7\-Codierung ist nicht zulässig.|Teilweise treten bei Daten für Anwendungen, die von eingehenden UTF\-7\-Daten abhängen, Decodierungsprobleme auf. Dies dürfte selten passieren, aber Sie können Legacyverhalten mithilfe des `aspnet:AllowUtf7RequestContentEncoding`\-Attributs des [\<appSettings\>](http://msdn.microsoft.com/de-de/0d65a3f1-c522-423d-89b6-44921b6daebb)\-Elements wiederherstellen.|  
|<xref:System.Web.HttpUtility.JavaScriptStringEncode%2A?displayProperty=fullName>|Ab [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] wird das kaufmännische Und\-Zeichen \(&\) von der Methode mit einem Escapezeichen versehen.|Wenn Ihre App vom vorherigen Verhalten dieser Methode abhängig ist, können Sie dem [appSettings\-Element von ASP.NET](http://msdn.microsoft.com/de-de/bb60e711-0669-4118-a54d-8dd71e009a00) eine `aspnet:JavaScriptDoNotEncodeAmpersand`\-Einstellung in der Konfigurationsdatei hinzufügen.|  
|Die Methoden <xref:System.Web.Security.MachineKey.Encode%2A?displayProperty=fullName> und <xref:System.Web.Security.MachineKey.Decode%2A?displayProperty=fullName>|Diese Methoden sind jetzt veraltet.|Die Kompilierung von Code, der diese Methoden aufruft, erzeugt eine Compilerwarnung. Die empfohlenen Alternativen sind <xref:System.Web.Security.MachineKey.Protect%2A?displayProperty=fullName> und <xref:System.Web.Security.MachineKey.Unprotect%2A?displayProperty=fullName>.|  
  
<a name="ClickOnce"></a>   
## ClickOnce  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Mit ClickOnce veröffentlichte Apps, die ein SHA\-256\-Codesignaturzertifikat verwenden.|Die ausführbare Datei ist mit SHA256 signiert. Früher wurde sie mit SHA1 signiert, unabhängig davon, ob das Codesignaturzertifikat SHA\-1 oder SHA\-256 war. Dies gilt für:<br /><br /> Alle Anwendungen, die mit Visual Studio 2012 oder höher erstellt wurden.<br /><br /> Anwendungen, die mit Visual Studio 2010 oder früher auf Systemen mit vorhandenem .NET Framework 4.5 erstellt wurden.<br /><br /> Darüber hinaus wird das ClickOnce\-Manifest, wenn .NET Framework 4.5 oder höher vorhanden ist, auch mit SHA\-256 für SHA\-256\-Zertifikate signiert, unabhängig von der .NET Framework\-Version, mit der es kompiliert wurde.|Die Änderung bei der Signierung der ausführbaren ClickOnce\-Datei betrifft nur Windows Server 2003\-Systeme. Für diese ist die Installation von [KB 938397](http://support.microsoft.com/kb/938397) erforderlich.<br /><br /> Die Änderung bei der Signierung des Manifests mit SHA\-256 führt, selbst wenn eine App .NET Framework 4 oder frühere Versionen erfordert, eine Laufzeitabhängigkeit von .NET Framework 4.5 oder einer höheren Version ein. Dieses Problem wurde in Visual Studio 2013 Update 3 und [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] behoben. Informationen zur [!INCLUDE[net_v46](../../../includes/net-v46-md.md)]\-Lösung finden Sie unter [Änderungen zur Laufzeit](../../../docs/framework/migration-guide/runtime-changes-in-the-net-framework-4-6.md).|  
  
<a name="mef"></a>   
## Managed Extensibility Framework \(MEF\)  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|<xref:System.ComponentModel.Composition.Primitives.ComposablePartCatalog?displayProperty=fullName> und abgeleitete Klassen|Ab [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] implementieren MEF\-Kataloge <xref:System.Collections.IEnumerable> und können daher nicht mehr verwendet werden, um ein Serialisierungsprogramm \(<xref:System.Xml.Serialization.XmlSerializer>\-Objekt\) zu erstellen.|Wenn Sie versuchen, einen MEF\-Katalog zu serialisieren, wird eine Ausnahme ausgelöst.|  
  
<a name="web"></a>   
## Webanwendungen  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Verwaltete Browserhostingsteuerelemente von .NET Framework 1.1 und 2.0|Das Hosting dieser Steuerelemente wird in Internet Explorer blockiert.|Internet Explorer kann eine Anwendung, die verwaltete Browserhostingsteuerelemente verwendet, nicht starten. Das vorherige Verhalten kann wiederhergestellt werden, indem der EnableIEHosting\-Wert des Registrierungsunterschlüssels HKLM\/SOFTWARE\/MICROSOFT\/.NETFramework für x86\-Systeme und für 32\-Bit\-Prozesse auf x64\-Systemen auf 1 festgelegt wird und der EnableIEHosting\-Wert des Registrierungsunterschlüssels HKLM\/SOFTWARE\/Wow6432Node\/Microsoft\/.NETFramework für 64\-Bit\-Prozesse auf x64\-Systemen auf 1 festgelegt wird.|  
  
<a name="wcf"></a>   
## Windows Communication Foundation \(WCF\)  
 Neben den folgenden Anwendungskompatibilitätsproblemen finden Sie im Abschnitt [Serialisierung](#serialize) Probleme in Bezug auf die Serialisierung.  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|Nachrichten in WCF\-Webdiensten, die in IIS \(Internetinformationsdienste\) oder ASP.NET Development Server gehostet werden, die `maxRequestLength` \(in ASP.NET\) oder `maxReceivedMessageSize` \(in WCF\) überschreiten|Der HTTP\-Statuscode wurde von 400 \(Ungültige Anforderung\) in 413 \(Anforderungsentität zu groß\) geändert, und Nachrichten, die entweder die festgelegte `maxRequestLength` oder `maxReceivedMessageSize` überschreiten, lösen eine <xref:System.ServiceModel.ProtocolException>\-Ausnahme aus. Dies gilt auch für Fälle, in denen der Übergangsmodus <xref:System.ServiceModel.TransferMode> ist.|Diese Änderung erleichtert das Debuggen, wenn die Nachrichtenlänge die von ASP.NET oder WCF zulässigen Begrenzungen überschreitet.<br /><br /> Sie müssen jeden Code ändern, der die Verarbeitung auf Grundlage eines HTTP 400\-Statuscode ausführt.|  
|`Replace` in OData\-URLs|Die `Replace`\-Methode in OData\-URLs ist standardmäßig deaktiviert.|Wenn OData `Replace` deaktiviert ist \(jetzt standardmäßig\), löst die Benutzeranforderung eine Ausnahme aus, und die Anforderung schlägt fehl.|  
|<xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName>|Das <xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName>\-Objekt fügt keinen standardmäßigen Endpunkt mehr hinzu, wenn ein expliziter Endpunkt vom Anwendungscode hinzugefügt wurde.|Wenn eine Clientanwendung versucht, eine Verbindung mit einem Endpunkt herzustellen, der nicht mehr standardmäßig hinzugefügt wird, tritt ein HTTP\-Fehler auf.|  
  
<a name="winForms"></a>   
## Windows Forms  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|System.Drawing.dll|Die `CheckForOverflowUnderflow`\-Eigenschaft für die Assembly wird auf `true` festgelegt.|Zuvor wurde das Ergebnis im Fall von Überläufen automatisch abgeschnitten. Nun wird eine <xref:System.OverflowException>\-Ausnahme ausgelöst.|  
|<xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>\-Konstruktor|Der Konstruktor ist veraltet.|Der Konstruktor funktioniert nicht auf 64\-Bit\-Systemen. Verwenden Sie stattdessen den <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Drawing.Imaging.EncoderParameterValueType%2CSystem.IntPtr%29?displayProperty=fullName>\-Konstruktor.|  
  
<a name="wpf"></a>   
## Windows Presentation Foundation \(WPF\)  
 Neben den folgenden Anwendungskompatibilitätsproblemen finden Sie im Abschnitt [Serialisierung](#serialize) Probleme in Bezug auf die Serialisierung.  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|<xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A?displayProperty=fullName>\-Eigenschaft|Die Standardgrenze der maximalen Anzahl von Rückgängig\-Vorgängen für die <xref:System.Windows.Controls.TextBox>\- und <xref:System.Windows.Controls.RichTextBox>\-Klassen wurde von – 1 \(keine Begrenzung\) auf 100 geändert.|Diese Änderung sollte keine negativen Auswirkungen haben. Sie können jedoch explizit die <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A>\-Eigenschaft festlegen, nachdem Sie das Steuerelement instanziiert haben.|  
|<xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>\-Enumeration|Die <xref:System.Windows.Controls.PageRangeSelection>\- und <xref:System.Windows.Controls.PageRangeSelection>\-Member wurden der Enumeration hinzugefügt.|Diese Änderung sollte keine Auswirkungen auf vorhandene Anwendungen haben. Für vorhandene Member, die diese Enumeration verwenden, ist der Standardwert <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>.|  
|<xref:System.Windows.DataTemplate>\-Elemente|<xref:System.Windows.DataTemplate>\-Elemente werden jetzt in der Steuerelementansicht der Benutzeroberflächenautomatisierungs\-Struktur \(UIA\) angezeigt.|Diese Änderung verbessert die Barrierefreiheit. Allerdings wirkt sie sich auf Testtools aus, deren Suche benachbarter Elemente auf der vorherigen Struktur der UIA\-Struktur basiert.|  
|Synchronisierung der <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName>\-Eigenschaft und der Eigenschaft, an die sie gebunden ist|In einigen Fällen stellt die <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName>\-Eigenschaft einen früheren Wert des datengebundenen Eigenschaftswerts dar, wenn die Eigenschaft während eines Datenbindungsschreibvorgangs geändert wird.|Dies sollte keine negativen Auswirkungen haben. Sie können jedoch das vorherige Verhalten wiederherstellen, indem Sie die <xref:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty%2A?displayProperty=fullName>\-Eigenschaft auf `false` festlegen.|  
|<xref:System.Windows.Controls.TextBox?displayProperty=fullName>\-Eigenschaft|Wenn ein <xref:System.Windows.Controls.TextBox?displayProperty=fullName>\-Steuerelement inaktiv ist, wird markierter Text innerhalb des Felds in einer anderen Farbe angezeigt, als wenn das Textfeld aktiv ist.|Sie können das vorherige Verhalten wiederherstellen, indem Sie die <xref:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported%2A?displayProperty=fullName>\-Eigenschaft auf `false` festlegen.|  
|<xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>|Wenn ein von <xref:System.Windows.Controls.Primitives.MultiSelector> abgeleitetes Steuerelement, für das <xref:System.Windows.Controls.Primitives.MultiSelector.CanSelectMultipleItems%2A> auf `true` festgelegt wurde, über Duplikate in der <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>\-Sammlung verfügt, kommen die doppelten Elemente mehr als einmal vor. Beim Entfernen dieser Elemente aus der Datenquelle \(z.B. durch Aufrufen von `Items.Clear`\) werden sie nicht aus der <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>\-Sammlung entfernt. Es wird nur die erste Instanz entfernt.<br /><br /> Die anschließende Verwendung der <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>\-Sammlung, z.B. der Aufruf von `SelectedItems.Clear`, kann Probleme wie <xref:System.ArgumentException> verursachen, da die <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>\-Sammlung Elemente enthält, die sich nicht mehr in der Datenquelle befinden.|Dieses Problem wurde in [!INCLUDE[net_v462](../../../includes/net-v462-md.md)] behandelt. Wenn eine <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>\-Sammlung doppelte Elemente enthielt, die Sie entfernt haben, und Sie weiterhin mit der <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>\-Sammlung arbeiten möchten, müssen Sie ein Upgrade auf [!INCLUDE[net_v462](../../../includes/net-v462-md.md)] ausführen.|  
|<xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>|In [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] gibt die Methode einen Verweis auf die aktuelle Instanz zurück. In [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] gibt sie eine neue Instanz zurück.|Code, der davon ausgeht, dass gleiche Verweise angeben, dass sich der ausführende Thread im richtigen Kontext befindet, wird nun ordnungsgemäß ausgeführt. Aufgrund der Änderung sollte Code, der <xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName> aufruft, jedoch getestet werden.|  
|Überwachen Sie `WM_POWERBROADCAST`\-Meldungen mithilfe eines durch den Aufruf der <xref:System.Windows.Interop.HwndSource.AddHook%2A?displayProperty=fullName>\-Methode hinzugefügten Handlers.|Ein Fenster muss explizit für `WM_POWERBROADCAST`\-Benachrichtigungen registriert werden, indem sein Handle an die [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx)\-Funktion übergeben wird. Über [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] nahm WPF dies automatisch für alle Fenster vor. Ab [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] registriert WPF automatisch ein spezielles Fenster, es registriert jedoch die meisten App\-Fenster nicht automatisch.|Code, der `WM_POWERBROADCAST`\-Benachrichtigungen verarbeitet, wird nicht ausgeführt.<br /><br /> Um weiterhin `WM_POWERBROADCAST`\-Benachrichtigungen zu empfangen, rufen Sie die [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx)\-Funktion auf, um ein WPF\-Fenster \(normalerweise das Hauptanwendungsfenster\) für `WM_POWERBROADCAST`\-Benachrichtigungen zu registrieren. In WPF\-Apps, die Sie mit C\# entwickeln, ist zudem erforderlich, dass Sie das Feld **Unsicheren Code zulassen** auf der Registerkarte **Build** auswählen.<br /><br /> Wenn Sie zudem ein Fenster registrieren, das nicht bis zum Herunterfahren der Anwendung beibehalten wird, sollten Sie seine Registrierung aufheben, indem Sie die [UnregisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373237.aspx)\-Funktion aufrufen, und das `HPOWERNOTIFY`\-Handle an das Fenster übergeben, das durch den Aufruf der [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx)\-Funktion zurückgegeben wird.|  
  
<a name="wwf"></a>   
## Windows Workflow Foundation \(WF\)  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|System.Activities.dll\-Sicherheit|Die Assembly ist mit dem <xref:System.Security.AllowPartiallyTrustedCallersAttribute>\-Attribut gekennzeichnet.|Abgeleitete Klassen können nicht mit <xref:System.Security.SecurityCriticalAttribute> gekennzeichnet werden. Zuvor mussten abgeleitete Typen mit <xref:System.Security.SecurityCriticalAttribute> gekennzeichnet werden. Diese Änderung sollte jedoch keine tatsächlichen Auswirkungen haben.|  
|WF 3.0\-Typen und \-Member|Die Typen und Member von WF 3.0 sind jetzt als veraltet gekennzeichnet.|Der Versuch, Quellcode zu kompilieren, der WF 3.0\-Typen oder \-Member verwendet, generiert einen Compilerfehler. Sie sollten die WF 4\-Typen und \-Member in den <xref:System.Activities>\-Namespaces verwenden.|  
|<xref:System.Activities.Presentation.DragDropHelper?displayProperty=fullName>\-Klasse|Die <xref:System.Activities.Presentation.DragDropHelper>\-Klasse enthält neue Methoden, die Drag & Drop\-Vorgänge mit mehreren Objekten unterstützen. Vorhandene Drag & Drop\-Methoden, die das Ziehen eines einzelnen Objekts unterstützen, sind veraltet. \(Weitere Informationen finden Sie unter [Veraltete Elemente in der Klassenbibliothek](../../../docs/framework/whats-new/whats-obsolete.md).\)|Auch wenn die früheren Methoden veraltet sind, werden sie weiterhin vom Compiler und von Common Language Runtime unterstützt. Die neuen Methoden bieten jedoch eine höhere Funktionalität. Es wird empfohlen, einige der vorhandenen Methoden wie folgt zu ersetzen:<br /><br /> Verwenden Sie <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName> anstelle von <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName>.<br /><br /> Verwenden Sie <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Activities.Presentation.WorkflowViewElement%29> anstelle von <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Windows.DragEventArgs%29>.<br /><br /> Verwenden Sie <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItems%28System.Windows.DragEventArgs%29> anstelle von <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItem%28System.Windows.DragEventArgs%29>.<br /><br /> Verwenden Sie <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObjects%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29> anstelle von <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObject%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29>.|  
|Überladungsauflösung von Aufrufen an die <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>\-Methode|[!INCLUDE[net_v45](../../../includes/net-v45-md.md)] fügt neue Überladungen hinzu, die einen Parameter des Typs <xref:System.Action?displayProperty=fullName> enthalten. Wird der vorhandene Code neu kompiliert, lösen Compiler Aufrufe an <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>\-Methoden mit einem <xref:System.Delegate>\-Parameter möglicherweise als Aufrufe an <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>\-Methoden mit einem <xref:System.Action?displayProperty=fullName>\-Parameter auf.|Wird ein Aufruf an eine <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>\-Überladung mit einem <xref:System.Delegate>\-Parameter als Aufruf an eine <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>\-Überladung mit einem <xref:System.Action?displayProperty=fullName>\-Parameter aufgelöst, kann es zu folgenden unterschiedlichen Verhaltensweisen kommen:<br /><br /> Tritt eine Ausnahme auf, werden die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter?displayProperty=fullName>\- und <xref:System.Windows.Threading.Dispatcher.UnhandledException?displayProperty=fullName>\-Ereignisse nicht ausgelöst. Stattdessen werden Ausnahmen durch das <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>\-Ereignis behandelt.<br /><br /> Bis der Vorgang abgeschlossen ist, werden Aufrufe an einige Member, z. B. <xref:System.Windows.Threading.DispatcherOperation.Result%2A?displayProperty=fullName>, blockiert.|  
|<xref:System.Activities.Expressions.Literal%601?displayProperty=fullName>\-Klasse|Das zugeordnete <xref:System.Windows.Markup.ValueSerializer>\-Objekt konvertiert ein <xref:System.DateTime>\- oder <xref:System.DateTimeOffset>\-Objekt, dessen Komponenten `Second` und `Millisecond` ungleich 0 \(null\) sind und \(für einen <xref:System.DateTime>\-Wert\) dessen <xref:System.DateTime.Kind%2A?displayProperty=fullName>\-Eigenschaft nicht <xref:System.DateTimeKind> ist, in eine Eigenschaftenelementsyntax anstatt in eine Zeichenfolge.|Durch diese Änderung kann bei <xref:System.DateTime>\- und <xref:System.DateTimeOffset>\-Werten ein Roundtrip ausgeführt werden. Benutzerdefinierte XAML\-Parser, die davon ausgehen, dass sich Eingabe\-XAML in der Attributsyntax befindet, funktionieren nicht ordnungsgemäß.|  
  
<a name="xml"></a>   
## XML, XSLT  
  
|Funktion|Änderung|Auswirkungen|  
|--------------|--------------|------------------|  
|`XDocument.Validate`\-Methode|Wenn der <xref:System.Xml.Linq.LoadOptions?displayProperty=fullName>\-Wert an die <xref:System.Xml.Linq.XDocument.Load%2A>\-Methode übergeben wird und ein Validierungsfehler auftritt, enthalten die <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName>\- und <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName>\-Eigenschaften jetzt Zeileninformationen.|Ausnahmebehandlungscode, der von den Werten der <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName>\- und <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName>\-Eigenschaften abhängt, funktioniert nicht mehr.|  
|Laden von XML\-Dateien mit <xref:System.Xml.XmlTextReader?displayProperty=fullName>|Die DTD\-Entitätserweiterung ist auf 10.000.000 Zeichen beschränkt.|Das Laden von XML\-Dateien ohne DTD\-Entitätserweiterung oder mit eingeschränkter DTD\-Entitätserweiterung ist davon nicht betroffen. Dateien mit DTD\-Entitäten, die auf mehr als 10.000.000 Zeichen erweitert werden, können nicht geladen werden und lösen nun eine Ausnahme aus.|  
|Vorwärtskompatibilitätsmodus für die <xref:System.Xml.Xsl.XslCompiledTransform?displayProperty=fullName>\-Klasse|In [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] verursachte die XSLT 1.0\-Vorwärtskompatibilität folgende Probleme:<br /><br /> Beim Laden eines Stylesheets trat ein Fehler auf, wenn die Version auf 2.0 festgelegt war und der Parser ein unbekanntes XSLT 1.0\-Konstrukt feststellte.<br /><br /> Das `xsl:sort`\-Konstrukt konnte keine Daten sortieren, wenn die Stylesheetversion auf 1.1 festgelegt war.<br /><br /> In [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] wurden diese Probleme behoben, und der XSLT 1.0\-Vorwärtskompatibilitätsmodus funktioniert ordnungsgemäß.|Der XSLT 1.0\-Vorwärtskompatibilitätsmodus funktioniert jetzt wie zuvor.|  
|Ausnahmemeldungen, wenn eine XSLT\-Datei zu komplex ist|In [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] lautet die Fehlermeldung bei einer zu komplexen XSLT\-Datei wie folgt: "Das Stylesheet ist zu komplex." In früheren Versionen hieß die Fehlermeldung "XSLT\-Compilerfehler."|Anwendungscode, der vom Text der Fehlermeldung abhängt, funktioniert nicht mehr. Die Ausnahmetypen sind jedoch nach wie vor identisch, daher sollte diese Änderung keine tatsächlichen Auswirkungen haben.|  
|XML\-Schemavalidierung für xsd:anyURI|In [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ist die XML\-Schemavalidierung strikter. Wenn Sie xsd:anyURI verwenden, um einen URI wie ein mailto\-Protokoll zu überprüfen, tritt bei der Validierung ein Fehler auf, wenn der URI Leerzeichen enthält. In früheren Versionen von .NET Framework war die Validierung erfolgreich.|Die Änderung betrifft nur Anwendungen, die auf [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] abzielen.|  
  
## Siehe auch  
 [Veraltete Elemente in der Klassenbibliothek](../../../docs/framework/whats-new/whats-obsolete.md)   
 [Neues](../../../docs/framework/whats-new/index.md)   
 [Anwendungskompatibilität](../../../docs/framework/migration-guide/application-compatibility.md)   
 [Anwendungskompatibilität in 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md)   
 [Anwendungskompatibilität in 4.5.2](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-2.md)