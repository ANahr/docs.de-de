---
title: "Definieren von benutzerdefinierten Typen für die Verwendung mit .NET Framework-XAML-Diensten"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: "11"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: c7cce479c7c7a5f6c7112f08f1e15f3bc7e4d366
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/22/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="b34c8-102">Definieren von benutzerdefinierten Typen für die Verwendung mit .NET Framework-XAML-Diensten</span><span class="sxs-lookup"><span data-stu-id="b34c8-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="b34c8-103">Wenn Sie definieren benutzerdefinierter Typen, die Geschäftsobjekte oder Typen, die keine Abhängigkeit auf bestimmten Frameworks sind, stehen bestimmte bewährten Methoden für XAML, die Sie befolgen können.</span><span class="sxs-lookup"><span data-stu-id="b34c8-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="b34c8-104">Wenn Sie diese Methoden befolgen, können .NET Framework-XAML-Dienste und die XAML-Readern und XAML-Writern die Verwendung von XAML-Eigenschaften des Typs ermitteln und geben sie entsprechende Darstellung in einem XAML-Knotenstream mit XAML-Typsystem.</span><span class="sxs-lookup"><span data-stu-id="b34c8-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="b34c8-105">Dieses Thema beschreibt bewährte Methoden für Typdefinitionen, Memberdefinitionen und CLR-Typen oder Member Attributierung.</span><span class="sxs-lookup"><span data-stu-id="b34c8-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="b34c8-106">Konstruktormuster und Typdefinitionen für XAML</span><span class="sxs-lookup"><span data-stu-id="b34c8-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="b34c8-107">Um als Objektelement in XAML instanziiert werden, muss eine benutzerdefinierte Klasse die folgenden Anforderungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="b34c8-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="b34c8-108">Die benutzerdefinierte Klasse muss öffentlich sein und einen (parameterlosen) öffentlichen Standardkonstruktor verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="b34c8-109">(Hinweise zu Strukturen finden Sie im folgenden Abschnitt.)</span><span class="sxs-lookup"><span data-stu-id="b34c8-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="b34c8-110">Die benutzerdefinierte Klasse darf nicht auf eine geschachtelte Klasse sein.</span><span class="sxs-lookup"><span data-stu-id="b34c8-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="b34c8-111">Die zusätzlichen "Punkt" im Pfad voller Name Klassennamespace Division mehrdeutig ist, und verursacht einen Konflikt mit anderen XAML-Funktionen, z. B. angefügte Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="b34c8-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="b34c8-112">Ein Objekt als Objektelement instanziiert werden kann, kann das erstellte Objekt Element das Eigenschaftenformular des beliebiger Eigenschaften vollständig aufgefüllt, die das Objekt als deren zugrunde liegenden Typs akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="b34c8-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="b34c8-113">Sie können immer noch Objektwerte für Typen, die diese Kriterien nicht erfüllen bereitstellen, wenn Sie einen Wertkonverter aktivieren.</span><span class="sxs-lookup"><span data-stu-id="b34c8-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="b34c8-114">Weitere Informationen finden Sie unter [Typkonverter und Markuperweiterungen für XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="b34c8-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="b34c8-115">Strukturen</span><span class="sxs-lookup"><span data-stu-id="b34c8-115">Structures</span></span>  
 <span data-ttu-id="b34c8-116">Strukturen sind immer in XAML durch CLR-Definition erstellt werden können.</span><span class="sxs-lookup"><span data-stu-id="b34c8-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="b34c8-117">Dies ist, da ein CLR-Compiler implizit einen Standardkonstruktor für eine Struktur erstellt.</span><span class="sxs-lookup"><span data-stu-id="b34c8-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="b34c8-118">Dieser Konstruktor initialisiert alle Eigenschaftswerte auf ihre Standardwerte.</span><span class="sxs-lookup"><span data-stu-id="b34c8-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="b34c8-119">In einigen Fällen ist das Standardverhalten für die Konstruktion für eine Struktur nicht wünschenswert.</span><span class="sxs-lookup"><span data-stu-id="b34c8-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="b34c8-120">Dies kann sein, da die Struktur vorgesehen ist, Werte und die Funktion grundsätzlich als Union zu füllen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="b34c8-121">Als Union die enthaltenen Werte über sich gegenseitig ausschließende Interpretationen verfügen, und daher keine Eigenschaften festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="b34c8-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="b34c8-122">Ein Beispiel einer solchen Struktur im WPF-Vokabular ist <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="b34c8-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="b34c8-123">Solche Strukturen sollten einen Typkonverter implementieren, damit, dass die Werte können in Attributform, ausgedrückt werden mithilfe von Zeichenfolgenkonventionen, die die verschiedenen Interpretationen oder Modi der Strukturwerte zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="b34c8-124">Die Struktur sollte über einen nicht standardmäßigen Konstruktor ein ähnliches Verhalten auch für die Codekonstruktion verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="b34c8-125">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="b34c8-125">Interfaces</span></span>  
 <span data-ttu-id="b34c8-126">Schnittstellen können als zugrunde liegende Typen von Elementen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b34c8-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="b34c8-127">Das XAML-Typsystem überprüft die zuweisbare Liste und erwartet, dass das Objekt, das als Wert angegeben wird, auf die Schnittstelle zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="b34c8-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="b34c8-128">Es ist kein Konzept wie die Schnittstelle als einen XAML-Typ dargestellt werden sollen, solange ein relevanten zugeordnet werden kann die Verwendung von XAML-Konstruktion-Anforderungen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b34c8-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="b34c8-129">Factorymethoden</span><span class="sxs-lookup"><span data-stu-id="b34c8-129">Factory Methods</span></span>  
 <span data-ttu-id="b34c8-130">Factorymethoden sind eine XAML 2009-Funktion.</span><span class="sxs-lookup"><span data-stu-id="b34c8-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="b34c8-131">Sie ändern das XAML-Prinzip, dass Objekte über Standardkonstruktoren verfügen müssen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="b34c8-132">Factorymethoden werden nicht in diesem Thema dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="b34c8-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="b34c8-133">Finden Sie unter [X: FactoryMethod-Direktive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="b34c8-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="b34c8-134">Enumerationen</span><span class="sxs-lookup"><span data-stu-id="b34c8-134">Enumerations</span></span>  
 <span data-ttu-id="b34c8-135">Enumerationen haben systemeigene Typkonvertierungsverhalten XAML.</span><span class="sxs-lookup"><span data-stu-id="b34c8-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="b34c8-136">Enumeration Konstantennamen in XAML angegeben werden für den zugrunde liegenden Enumerationstyp aufgelöst, und den Enumerationswert für eine XAML-Objektwriter zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="b34c8-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="b34c8-137">XAML unterstützt eine Flags-Stil-Verwendung für Enumerationen mit <xref:System.FlagsAttribute> angewendet.</span><span class="sxs-lookup"><span data-stu-id="b34c8-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="b34c8-138">Weitere Informationen finden Sie unter [XAML-Syntax im Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="b34c8-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="b34c8-139">([XAML-Syntax im Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) geschrieben wird, die WPF-Zielgruppe, aber die meisten der Informationen in diesem Thema ist relevant für XAML, die nicht spezifisch für ein bestimmtes implementierende Framework ist.)</span><span class="sxs-lookup"><span data-stu-id="b34c8-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="b34c8-140">Elementdefinitionen</span><span class="sxs-lookup"><span data-stu-id="b34c8-140">Member Definitions</span></span>  
 <span data-ttu-id="b34c8-141">Typen können für die Verwendung von XAML-Member definieren.</span><span class="sxs-lookup"><span data-stu-id="b34c8-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="b34c8-142">Es ist möglich, dass Typen, die Elemente zu, die XAML-verwendbar sind definieren, auch wenn diese bestimmte Art nicht XAML verwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="b34c8-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="b34c8-143">Dies ist aufgrund von CLR-Vererbung möglich.</span><span class="sxs-lookup"><span data-stu-id="b34c8-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="b34c8-144">So lange ein Typ, der das Element erbt unterstützt die Verwendung von XAML als einen Typ und das Element unterstützt die Verwendung von XAML-Verwendung für den zugrunde liegenden Typ oder verfügt über eine systemeigene XAML-Syntax, die verfügbar sind, ist diese Member XAML verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="b34c8-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="b34c8-145">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="b34c8-145">Properties</span></span>  
 <span data-ttu-id="b34c8-146">Wenn Sie die Eigenschaften als öffentliche CLR-Eigenschaft unter Verwendung der typischen CLR definieren `get` und `set` Accessor Muster und sprachspezifischen Keywording, XAML-Typsystem kann gemeldet werden, für die Eigenschaft als ein Element mit dem entsprechenden Informationen bereitgestellt <xref:System.Xaml.XamlMember> Eigenschaften, z. B. <xref:System.Xaml.XamlMember.IsReadPublic%2A> und <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="b34c8-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="b34c8-147">Bestimmte Eigenschaften können eine Textsyntax aktivieren, durch Anwenden von <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="b34c8-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="b34c8-148">Weitere Informationen finden Sie unter [Typkonverter und Markuperweiterungen für XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="b34c8-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="b34c8-149">In Ermangelung einer Textsyntax oder systemeigenen XAML-Konvertierung und ohne weitere Dereferenzierung, z. B. eine Markuperweiterungsverwendung, die den Typ einer Eigenschaft (<xref:System.Xaml.XamlMember.TargetType%2A> in der XAML-Typsystem) muss in der Lage, eine Instanz für eine XAML-Objektwriter zurückzugeben, indem zum Behandeln von t Arget Typ als CLR-Typ.</span><span class="sxs-lookup"><span data-stu-id="b34c8-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="b34c8-150">Wenn XAML 2009 verwendet wird, [X: Reference-Markuperweiterung](../../../docs/framework/xaml-services/x-reference-markup-extension.md) können verwendet werden, um Werte bereitzustellen, wenn die vorausgegangenen Ausführungen nicht erfüllt werden; dies ist jedoch mehr als ein Typ Definition Problem ein Problem beim Ressourceneinsatz.</span><span class="sxs-lookup"><span data-stu-id="b34c8-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="b34c8-151">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="b34c8-151">Events</span></span>  
 <span data-ttu-id="b34c8-152">Wenn Sie Ereignisse als öffentliches CLR-Ereignis definieren, kann das XAML-Typsystem als ein Element mit dem das Ereignis melden <xref:System.Xaml.XamlMember.IsEvent%2A> als `true`.</span><span class="sxs-lookup"><span data-stu-id="b34c8-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="b34c8-153">Die Ereignishandler Verkabelung ist nicht innerhalb des Bereichs von .NET Framework XAML Services-Funktionen. Dies ist die Implementierung und spezifische Frameworks links ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="b34c8-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="b34c8-154">Methoden</span><span class="sxs-lookup"><span data-stu-id="b34c8-154">Methods</span></span>  
 <span data-ttu-id="b34c8-155">Inlinecode für Methoden ist nicht standardmäßig XAML-Funktion.</span><span class="sxs-lookup"><span data-stu-id="b34c8-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="b34c8-156">In den meisten Fällen Sie nicht direkt auf verweisen Methodenmember aus XAML und die Rolle der Methoden in XAML wird nur für bestimmte XAML-Muster unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="b34c8-157">[X: FactoryMethod-Direktive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) ist eine Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="b34c8-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="b34c8-158">Felder</span><span class="sxs-lookup"><span data-stu-id="b34c8-158">Fields</span></span>  
 <span data-ttu-id="b34c8-159">CLR-Entwurfsrichtlinien vermeiden nicht statische Felder.</span><span class="sxs-lookup"><span data-stu-id="b34c8-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="b34c8-160">Für statische Felder, die Sie Werte für statische Felder zugreifen können nur über [X: statische Markuperweiterung](../../../docs/framework/xaml-services/x-static-markup-extension.md); in diesem Fall Sie sind nicht auf diese Weise nichts Besonderes in der CLR-Definition für ein Feld verfügbar machen [X: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) Verwendungen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="b34c8-161">Anfügbare Member</span><span class="sxs-lookup"><span data-stu-id="b34c8-161">Attachable Members</span></span>  
 <span data-ttu-id="b34c8-162">Anfügbare Member werden in XAML über einen Accessor-Methode Muster für einen definierenden Typ verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="b34c8-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="b34c8-163">Der definierende Typ selbst muss nicht als Objekt XAML verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="b34c8-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="b34c8-164">Ein allgemeines Muster ist eine Dienstklasse deklarieren, dessen Rolle, anfügbaren Members besitzen und das zugehörige Verhalten implementiert, aber keine anderen Funktion z. B. eine Benutzeroberflächendarstellung dienen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="b34c8-165">Für die folgenden Abschnitte, die Platzhalter *PropertyName* den Namen des anfügbaren Members darstellt.</span><span class="sxs-lookup"><span data-stu-id="b34c8-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="b34c8-166">Dieser Name muss in gültig sein der [XamlName-Grammatik](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="b34c8-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="b34c8-167">Seien Sie vorsichtig, der Namenskonflikte zwischen diesen Mustern und anderen Methoden eines Typs.</span><span class="sxs-lookup"><span data-stu-id="b34c8-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="b34c8-168">Wenn ein Element vorhanden, das einem Muster entspricht ist, kann es als Pfad einer anfügbaren Members-Verwendung durch einen XAML-Prozessor interpretiert werden, auch wenn Ihre Absicht nicht ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="b34c8-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="b34c8-169">Der Accessor GetPropertyName-Methode</span><span class="sxs-lookup"><span data-stu-id="b34c8-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="b34c8-170">Die Signatur für den Accessoren `Get`*PropertyName* muss Folgende sein:</span><span class="sxs-lookup"><span data-stu-id="b34c8-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="b34c8-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="b34c8-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="b34c8-172">Das `target`-Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="b34c8-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b34c8-173">Dadurch können Sie die Verwendung des anfügbaren Members Bereich; Verwendungen außerhalb des beabsichtigten Bereichs löst Ausnahmen für ungültige Umwandlung, die dann von einem XAML-Analysefehler angefügt sind.</span><span class="sxs-lookup"><span data-stu-id="b34c8-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="b34c8-174">Der Name des Parameters `target` ist nicht erforderlich, aber ist mit dem Namen `target` gemäß der Konvention in den meisten Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="b34c8-175">Der Rückgabewert kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="b34c8-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="b34c8-176">Zur Unterstützung einer <xref:System.ComponentModel.TypeConverter> aktiviert Textsyntax für die Attributverwendung des anfügbaren Members, gelten <xref:System.ComponentModel.TypeConverterAttribute> auf die `Get` *PropertyName* Accessor.</span><span class="sxs-lookup"><span data-stu-id="b34c8-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="b34c8-177">Anwenden auf die `get` statt der `set` mag unkonventionell; allerdings kann diese Konvention unterstützen das Konzept des nur-Lese anfügbare Member, die serialisierbar sind, ist die Designer-Szenarien nützlich.</span><span class="sxs-lookup"><span data-stu-id="b34c8-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="b34c8-178">Der SetPropertyName Accessor</span><span class="sxs-lookup"><span data-stu-id="b34c8-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="b34c8-179">Die Signatur für den Satz*PropertyName* Accessor muss:</span><span class="sxs-lookup"><span data-stu-id="b34c8-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="b34c8-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="b34c8-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="b34c8-181">Die `target` Objekt kann als einen spezifischeren Typ in der Implementierung, mit derselben Logik und die Konsequenzen angegeben werden, wie im vorherigen Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="b34c8-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="b34c8-182">Das `value`-Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="b34c8-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="b34c8-183">Denken Sie daran, dass der Wert für diese Methode die Eingabe aus der XAML-Verwendung in der Regel in Attributform stammen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="b34c8-184">In Attributform müssen Wert Konverter-Unterstützung für die eine Textsyntax vorhanden sein, und Sie Attribut auf die `Get` *PropertyName* Accessor.</span><span class="sxs-lookup"><span data-stu-id="b34c8-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="b34c8-185">Anfügbare Member speichert</span><span class="sxs-lookup"><span data-stu-id="b34c8-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="b34c8-186">Die Zugriffsmethoden sind in der Regel nicht ausreichend, um bieten eine Möglichkeit zum anfügbaren Members-Werte in einem Objektdiagramm zu platzieren oder zum Abrufen von Werten aus dem Objektdiagramm und korrekt zu serialisieren.</span><span class="sxs-lookup"><span data-stu-id="b34c8-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="b34c8-187">Zum Bereitstellen dieser Funktionalität der `target` Objekte in den vorherigen Accessorsignaturen müssen zum Speichern von Werten in der Lage sein.</span><span class="sxs-lookup"><span data-stu-id="b34c8-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="b34c8-188">Speichermechanismus sollte mit dem Prinzip des anfügbaren Members entsprechen, die die Member Zielen handelt, in denen anfügbaren Members nicht in der Liste der Member ist.</span><span class="sxs-lookup"><span data-stu-id="b34c8-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="b34c8-189">.NET Framework XAML Services stellt eine Implementierung, die auch für anfügbaren Members über die APIs speichert <xref:System.Xaml.IAttachedPropertyStore> und <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="b34c8-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="b34c8-190"><xref:System.Xaml.IAttachedPropertyStore>wird durch die Verwendung von XAML-Writer verwendet, um die Implementierung zu ermitteln und implementiert werden sollte, für den Typ, der die `target` Accessor.</span><span class="sxs-lookup"><span data-stu-id="b34c8-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="b34c8-191">Die statische <xref:System.Xaml.AttachablePropertyServices> APIs werden verwendet, im Text der Zugriffsmethoden und verweisen auf anfügbaren Members von seiner <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="b34c8-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="b34c8-192">XAML-bezogene CLR-Attributen</span><span class="sxs-lookup"><span data-stu-id="b34c8-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="b34c8-193">Attributierung ordnungsgemäß Ihre Typen, Member und Assemblys ist wichtig, in der Reihenfolge nach der Verwendung von XAML-System Typinformationen für .NET Framework XAML Services-Bericht.</span><span class="sxs-lookup"><span data-stu-id="b34c8-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="b34c8-194">Dies ist relevant, wenn Sie beabsichtigen, Ihre Typen für die Verwendung mit Verwendung von XAML-Systemen, die direkt auf .NET Framework XAML Services XAML-Readern und XAML-Writer basieren, oder wenn Sie definieren, oder verwenden ein XAML-Writern Framework, das auf die XAML-Readern und XAML-Writern basiert.</span><span class="sxs-lookup"><span data-stu-id="b34c8-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="b34c8-195">Eine Liste der einzelnen XAML-bezogene Attribute, die für die Verwendung von XAML-Unterstützung benutzerdefinierter Typen relevant sind, finden Sie unter [XAML-Related CLR-Attribute für benutzerdefinierte Typen und Bibliotheken](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="b34c8-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="b34c8-196">Verwendung</span><span class="sxs-lookup"><span data-stu-id="b34c8-196">Usage</span></span>  
 <span data-ttu-id="b34c8-197">Verwendung von benutzerdefinierten Typen erfordert, dass der Markupautor zuordnen muss ein Präfix für die Assembly und die CLR-Namespace, die den benutzerdefinierten Typ enthalten.</span><span class="sxs-lookup"><span data-stu-id="b34c8-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="b34c8-198">Dieses Verfahren ist nicht in diesem Thema dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="b34c8-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="b34c8-199">Zugriffsebene</span><span class="sxs-lookup"><span data-stu-id="b34c8-199">Access Level</span></span>  
 <span data-ttu-id="b34c8-200">XAML bietet eine Möglichkeit zum Laden und Instanziieren von Typen, die über eine `internal` Zugriffsebene.</span><span class="sxs-lookup"><span data-stu-id="b34c8-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="b34c8-201">Diese Funktion wird bereitgestellt, sodass Benutzercode eigenen Typen definieren kann, und klicken Sie dann Instanziieren dieser Klassen von Markup, das auch Teil des gleichen Bereiches Benutzer Code ist.</span><span class="sxs-lookup"><span data-stu-id="b34c8-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="b34c8-202">Ein Beispiel aus WPF ist immer, wenn Benutzercode definiert eine <xref:System.Windows.Controls.UserControl> , dient als eine Möglichkeit zum Umgestalten einer Verhalten der Benutzeroberfläche, aber nicht als Teil eines Erweiterungsmechanismus, die impliziert werden könnte, indem Sie deklarieren die unterstützende Klasse mit `public` Zugriffsebene.</span><span class="sxs-lookup"><span data-stu-id="b34c8-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="b34c8-203">Solche eine <xref:System.Windows.Controls.UserControl> können deklariert werden, mit `internal` zugreifen, wenn die zugrunde liegende Code in derselben Assembly kompiliert wird, aus dem es als einen XAML-Typ verweist.</span><span class="sxs-lookup"><span data-stu-id="b34c8-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="b34c8-204">Für eine Anwendung, die XAML mit voller Vertrauenswürdigkeit lädt und verwendet <xref:System.Xaml.XamlObjectWriter>, Laden von Klassen mit `internal` Zugriffsebene ist immer aktiviert.</span><span class="sxs-lookup"><span data-stu-id="b34c8-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="b34c8-205">Für eine Anwendung, die XAML unter teilweiser Vertrauenswürdigkeit lädt, können Sie steuern die Zugriffsmerkmale Ebene über der <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="b34c8-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="b34c8-206">Verzögerungsmechanismen (z. B. das WPF-vorlagensystem) muss darüber hinaus können keine Zugriffsberechtigungen Ebene weitergegeben, und erhalten diese für die letztendliche zur Laufzeit auswertungen; Dies wird intern behandelt, durch das Übergeben der <xref:System.Xaml.Permissions.XamlAccessLevel> Informationen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="b34c8-207">WPF-Implementierung</span><span class="sxs-lookup"><span data-stu-id="b34c8-207">WPF Implementation</span></span>  
 <span data-ttu-id="b34c8-208">WPF XAML verwendet ein teilweise vertrauenswürdigen Zugriffsmodell, in dem Wenn BAML unter teilweiser Vertrauenswürdigkeit geladen wird, ist der Zugriff auf eingeschränkte <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> für die Assembly, die die BAML-Quelle ist.</span><span class="sxs-lookup"><span data-stu-id="b34c8-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="b34c8-209">Für Deferral, WPF verwendet <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> als Mechanismus für die Weitergabe von Informationen der Zugriff.</span><span class="sxs-lookup"><span data-stu-id="b34c8-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="b34c8-210">In der Terminologie von WPF XAML eine *internen Typ* ist ein Typ, der von der gleichen Assembly definiert ist, auch das verweisende XAML enthält.</span><span class="sxs-lookup"><span data-stu-id="b34c8-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="b34c8-211">Ein solchen Typs zugeordnet werden kann, durch einen XAML-Namespace, der die Assembly bewusst ausgelassen = Teil einer Zuordnung, z. B. `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="b34c8-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="b34c8-212">Wenn BAML einen internen Typ verweist und Typ verfügt über `internal` Zugriffsebene Dies generiert eine `GeneratedInternalTypeHelper` Klasse für die Assembly.</span><span class="sxs-lookup"><span data-stu-id="b34c8-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="b34c8-213">Wenn Sie vermeiden möchten `GeneratedInternalTypeHelper`, entweder müssen Sie verwenden `public` Zugriffsebene verlagern Sie die relevante Klasse in einer separaten Assembly und müssen diese Assembly abhängig machen.</span><span class="sxs-lookup"><span data-stu-id="b34c8-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b34c8-214">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="b34c8-214">See Also</span></span>  
 [<span data-ttu-id="b34c8-215">XAML-bezogene CLR-Attribute für benutzerdefinierte Typen und Bibliotheken</span><span class="sxs-lookup"><span data-stu-id="b34c8-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 <span data-ttu-id="b34c8-216">[XAML Services](../../../docs/framework/xaml-services/index.md) (XAML-Dienste)</span><span class="sxs-lookup"><span data-stu-id="b34c8-216">[XAML Services](../../../docs/framework/xaml-services/index.md)</span></span>
