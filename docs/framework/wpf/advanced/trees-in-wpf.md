---
title: Strukturen in WPF
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
caps.latest.revision: "20"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 56237bccb2bf61994c6114fa01d15c254267ca20
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/21/2017
---
# <a name="trees-in-wpf"></a>Strukturen in WPF
In vielen Technologien werden Elemente und Komponenten in einer Baumstruktur organisiert, in denen Entwickler die Objektknoten direkt in der Struktur bearbeiten, um das Rendering oder das Verhalten einer Anwendung zu beeinflussen. Außerdem verwendet [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] mehrere Baumstrukturmetaphern, um Beziehungen zwischen Programmelementen festzulegen. Da die WPF-Entwickler meist eine Anwendung im Code erstellen können oder Teile der Anwendung in XAML festlegen, obwohl sie konzeptionell über die Baumstrukturobjektmetapher denken, rufen sie trotzdem eine bestimmte API auf oder verwenden bestimmte Markups, um dies zu tun, anstatt einige allgemeine API-Strukturobjektmanipulationen vorzunehmen, wie Sie sie möglicherweise im XML-DOM verwenden. WPF macht zwei Hilfsklassen, die eine Strukturansicht Metapher bereitstellen <xref:System.Windows.LogicalTreeHelper> und <xref:System.Windows.Media.VisualTreeHelper>. Die Begriffe „visuelle Struktur“ und „logische Struktur“ werden auch in der WPF-Dokumentation verwendet, da diese Strukturen für das Verstehen des Verhaltens bestimmter WPF-Schlüsselfunktionen hilfreich sind. In diesem Thema definiert, was der visuellen Struktur und die logische Struktur darstellen, wird erläutert, wie solche Strukturen zu einem allgemeinen beziehen und führt <xref:System.Windows.LogicalTreeHelper> und <xref:System.Windows.Media.VisualTreeHelper>s.  
  

  
<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Strukturen in WPF  
 Die umfassendste Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ist die Objektstruktur. Wenn Sie eine Anwendungsseite in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] festlegen und anschließend [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] laden, wird die Baumstruktur basierend auf den Schachtelungsbeziehungen der Elemente im Markup erstellt. Wenn Sie eine Anwendung oder einen Teil der Anwendung im Code festlegen, wird die Baumstruktur basierend darauf erstellt, wie Sie Eigenschaftswerte für Eigenschaften zuweisen, die das Inhaltsmodell für ein bestimmtes Objekt implementieren. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] gibt es zwei Möglichkeiten, wie die vollständige Objektstruktur konzipiert wird und an die öffentliche API gemeldet werden kann: Als logische Struktur und als visuelle Struktur. Die Unterschiede zwischen logischer Struktur und visueller Struktur sind nicht immer unbedingt wichtig, aber sie können gelegentlich Probleme mit bestimmten [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Subsystemen verursachen und Auswählen im Markup oder im Code beeinträchtigen.  
  
 Obwohl Sie nicht immer die logische Struktur oder die visuelle Struktur direkt bearbeiten, ist das Verstehen der Konzepte, wie die Strukturen interagieren, nützlich, um WPF als eine Technologie zu verstehen. Sich WPF als eine Baumstrukturmetapher vorzustellen, ist auch wichtig, um zu verstehen, wie Eigenschaftsvererbung und Ereignisrouting in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] funktionieren.  
  
> [!NOTE]
>  Da die Objektstruktur eher ein Konzept als eine tatsächliche API ist, ist es eine weitere Möglichkeit, sich das Konzept als Objektdiagramm vorzustellen. In der Praxis gibt es Beziehungen zwischen Objekten während der Laufzeit, die die Baumstrukturmetapher aufschlüsseln können. Trotzdem ist die Baumstrukturmetapher, insbesondere bei XAML-definierten Benutzeroberflächen, ausreichend relevant, sodass die meisten WPF-Dokumentationen den Begriff „Objektstruktur“ verwenden werden, wenn auf dieses allgemeine Konzept verwiesen wird.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Die logische Struktur  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fügen Sie Inhalte zu Benutzeroberflächenelementen hinzu, indem Sie Eigenschaften der Objekte festlegen, die diese Elemente unterstützen. Z. B. Hinzufügen von Elementen zu einer <xref:System.Windows.Controls.ListBox> Steuerelement ändern, indem Sie seine <xref:System.Windows.Controls.ItemsControl.Items%2A> Eigenschaft. Dadurch sind Sie Platzieren von Elementen in der <xref:System.Windows.Controls.ItemCollection> also die <xref:System.Windows.Controls.ItemsControl.Items%2A> Eigenschaftswert. Auf ähnliche Weise zum Hinzufügen von Objekten auf einer <xref:System.Windows.Controls.DockPanel>, bearbeiten Sie seine <xref:System.Windows.Controls.Panel.Children%2A> Eigenschaftswert. Hier hinzufügen-Objekten, die <xref:System.Windows.Controls.UIElementCollection>. Ein Codebeispiel finden Sie unter [Add an Element Dynamically (Dynamisches Hinzufügen eines Elements)](http://msdn.microsoft.com/en-us/d00f258a-7973-4de7-bc54-a3fc1f638419).  
  
 In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]Platzieren von Elementen in einer <xref:System.Windows.Controls.ListBox> oder Steuerelemente oder andere Elemente der Benutzeroberfläche in eine <xref:System.Windows.Controls.DockPanel>, Sie auch verwenden, die <xref:System.Windows.Controls.ItemsControl.Items%2A> und <xref:System.Windows.Controls.Panel.Children%2A> Eigenschaften, entweder explizit oder implizit, wie im folgenden Beispiel.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Wenn Sie diesen XAML-Code als XML unter einem Dokumentobjektmodell verarbeiten würden und die auskommentierten Tags als implizit eingeschlossen hätten (was zulässig gewesen wäre), hätte die entstandene XML-DOM-Struktur Elemente für `<ListBox.Items>` und für die anderen impliziten Elemente eingeschlossen. XAML verarbeitet jedoch nicht auf diese Weise, und wenn Sie das Markup lesen und in Objekte schreiben, enthält das daraus entstehende Objektdiagramm nicht wirklich `ListBox.Items`. Er verfügt jedoch über eine <xref:System.Windows.Controls.ListBox> Eigenschaft mit dem Namen `Items` , enthält eine <xref:System.Windows.Controls.ItemCollection>, und dass <xref:System.Windows.Controls.ItemCollection> initialisiert ist jedoch leer, wenn die <xref:System.Windows.Controls.ListBox> XAML verarbeitet wird. Klicken Sie dann jedes untergeordnete Objektelement, das als Inhalt vorhanden ist die <xref:System.Windows.Controls.ListBox> hinzugefügt wird die <xref:System.Windows.Controls.ItemCollection> durch Parseraufrufe `ItemCollection.Add`. Dieses Beispiel über die Verarbeitung von XAML in einer Objektstruktur ist bisher scheinbar ein Beispiel, bei dem die erstellte Objektstruktur im Grunde die logische Struktur ist.  
  
 Die logische Struktur ist jedoch nicht das gesamte Objektdiagramm, das für die Anwendungsbenutzeroberfläche zur Laufzeit vorhanden ist, dies gilt selbst wenn die impliziten XAML-Syntaxelemente nicht berücksichtigt werden. Der Hauptgrund dafür sind die visuellen Objekte und Vorlagen. Betrachten Sie beispielsweise die <xref:System.Windows.Controls.Button>. Die logische Struktur meldet die <xref:System.Windows.Controls.Button> Objekt sowie seine Zeichenfolge `Content`. Es gibt jedoch noch mehr zu dieser Schaltfläche in der Laufzeit-Objektstruktur. Insbesondere die Schaltfläche wird nur angezeigt, auf dem Bildschirm die Möglichkeit, weil eine bestimmte <xref:System.Windows.Controls.Button> Steuerelementvorlage angewendet wurde. Die visuellen Elemente, die aus einer angewendeten Vorlage stammen (z. B. die Vorlage definiert <xref:System.Windows.Controls.Border> von dunkelgrau auf die Schaltfläche mit den visual) werden nicht in der logischen Struktur gemeldet, selbst wenn Sie während der Laufzeit der logischen Struktur betrachten (z. B. Ereignisbehandlung Eingabe aus der sichtbare Benutzeroberfläche und Lesen von der logischen Struktur). Sie müssten stattdessen die visuelle Struktur untersuchen, um die visuellen Vorlagen zu suchen.  
  
 Weitere Informationen dazu, wie die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Syntax das erstellte Objektdiagramm sowie die implizite Syntax in XAML zuordnet, finden Sie unter [Ausführliche Erläuterung der XAML-Syntax](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) oder [Übersicht über XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Der Zweck der logischen Struktur  
 Die logische Struktur ist vorhanden, damit Inhaltsmodelle ihre potenziellen untergeordneten Objekte leicht durchlaufen können und damit Inhaltsmodelle erweiterbar sind. Darüber hinaus bietet die logische Struktur ein Framework für bestimmte Benachrichtigungen, z.B. wenn alle Objekte in der logischen Struktur geladen werden. Im Grunde ist die logische Struktur eine Annäherung an ein Laufzeit-Objektdiagramm auf der Frameworkebene, das visuelle Elemente ausschließt, aber für viele Abfragevorgänge für Ihre eigene Laufzeit-Anwendungskomposition ausreichend ist.  
  
 Darüber hinaus werden sowohl statische und dynamische Ressourcenverweise aufgelöst, von der logischen Struktur aufwärts durchsehen <xref:System.Windows.FrameworkElement.Resources%2A> Auflistungen, auf dem ersten anfordernde Objekt, und klicken Sie dann oben in der logischen Struktur zu fortfahren und jeden <xref:System.Windows.FrameworkElement> (oder <xref:System.Windows.FrameworkContentElement>) für eine andere `Resources` Wert, der enthält einem <xref:System.Windows.ResourceDictionary>, möglicherweise mit diesem Schlüssel. Die logische Struktur wird für die Ressourcensuche verwendet, wenn sowohl die logische Struktur als auch die visuelle Struktur vorhanden sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suche finden Sie unter [XAML-Ressourcen](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Zusammensetzung der logischen Struktur  
 Die logische Struktur wird definiert, auf die WPF-Frameworkebene, was bedeutet, dass das WPF-Basis-Element, die relevantesten für logische Strukturen ist entweder steht <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Aber Sie können sehen, wenn Sie tatsächlich verwenden die <xref:System.Windows.LogicalTreeHelper> -API, enthält die logische Struktur manchmal Knoten, die weder <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Die logische Struktur für die Instanz, meldet der <xref:System.Windows.Controls.TextBlock.Text%2A> Wert eine <xref:System.Windows.Controls.TextBlock>, ist eine Zeichenfolge.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Überschreiben der logischen Struktur  
 Erfahrene Steuerelementautoren können die logische Struktur überschreiben, indem Sie mehrere [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] überschreiben, die festlegen, wie ein allgemeines Objekt- oder Inhaltsmodell Objekte innerhalb der logischen Struktur hinzufügt oder entfernt. Ein Beispiel zum Überschreiben der logischen Struktur finden Sie unter [Überschreiben der logischen Struktur](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Vererbung von Eigenschaftswerten  
 Die Vererbung von Eigenschaftswerten funktioniert mithilfe einer Hybridstruktur. Die eigentlichen Metadaten, enthält die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> Eigenschaft, die Vererbung von Eigenschaften ermöglicht, ist die WPF-Frameworkebene <xref:System.Windows.FrameworkPropertyMetadata> Klasse. Das übergeordnete Element, das den ursprünglichen Wert enthält und das untergeordnete Objekt, das diesen Wert erbt müssen daher beide werden <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>, und sie müssen beide einige logische Struktur verwendet werden. Allerdings kann für vorhandene WPF-Eigenschaften, die die Vererbung von Eigenschaften unterstützen, die Vererbung von Eigenschaftswerten durch ein beteiligtes Objekt aufrechterhalten werden, das nicht in der logischen Struktur ist. Dies ist vor allem relevant, wenn Vorlagenelemente alle geerbten Eigenschaftswerte verwenden, die entweder auf die Instanz festgelegt wurden, die als Vorlage verwendet wird, oder auf noch höheren Ebenen der Seitenebenen-Zusammensetzung und aus diesem Grund höher in der logischen Struktur sind. Damit die Vererbung von Eigenschaftswerten über eine solche Grenze hinweg konsistent funktioniert, muss die erbende Eigenschaft als angefügte Eigenschaft registriert werden, und Sie sollten dieses Muster befolgen, wenn Sie beabsichtigen, eine benutzerdefinierte Abhängigkeitseigenschaft mit Eigenschaftenvererbungsverhalten festzulegen. Die genaue Struktur, die für die Vererbung von Eigenschaften verwendet wurde, kann nicht vollständig von einer Hilfsprogrammklassen-Dienstmethode vorhergesehen werden, dies gilt selbst während der Laufzeit. Weitere Informationen finden Sie unter [ Vererbung von Eigenschaftswerten](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Die visuelle Struktur  
 Neben dem Konzept der logischen Struktur, gibt es auch das Konzept der visuellen Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Die visuelle Struktur beschreibt die Struktur der visuellen Objekte, dargestellt durch die <xref:System.Windows.Media.Visual> Basisklasse. Wenn Sie eine Vorlage für ein Steuerelement erstellen, werden Sie die visuelle Struktur festlegen oder neu festlegen, die für dieses Steuerelement angewendet wird. Die visuelle Struktur ist auch für Entwickler interessant, die die Kontrolle über Zeichnungen auf niedrigerer Ebene aus Leistungs- und Optimierungsgründen möchten. Eine Belichtung der visuellen Struktur als Teil der konventionellen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Programmierschnittstellen ist, dass das Ereignis für ein Routingereignis größtenteils entlang der visuellen Struktur steuert, nicht aber entlang der logischen Struktur. Diese Besonderheit des Routingereignisverhaltens ist möglicherweise nicht sofort erkennbar, es sei denn, Sie sind ein Autor des Steuerelements. Routingereignisse über die visuelle Struktur ermöglichen Steuerelemente, die die Komposition auf der visuellen Ebene implementieren, um Ereignisse zu bearbeiten oder Ereignissetter zu erstellen.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Strukturen, Inhaltselemente und Inhaltshosts  
 Inhaltselemente (abgeleitete Klassen <xref:System.Windows.ContentElement>) sind nicht Teil der visuellen Struktur; sie erben nicht von <xref:System.Windows.Media.Visual> und verfügen nicht über eine visuelle Darstellung. Um eine Benutzeroberfläche überhaupt, angezeigt werden eine <xref:System.Windows.ContentElement> muss gehostet werden, in einem Inhaltshost, die sowohl eine <xref:System.Windows.Media.Visual> und einem logischen Struktur Beteiligten. Ein solches Objekt in der Regel wird eine <xref:System.Windows.FrameworkElement>. Sie können konzipieren, dass der Inhaltshost wie ein „Browser“ für den Inhalt ist und wählt, wie der Inhalt innerhalb des Bildschirmbereichs, den der Host steuert, anzuzeigen ist. Wenn der Inhalt gehostet wird, kann der Inhalt zu einem Teilnehmer bestimmter Prozessstrukturen gemacht werden, die normalerweise der visuellen Struktur zugeordnet sind. Im Allgemeinen die <xref:System.Windows.FrameworkElement> Hostklasse enthält Implementierungscode, der ein gehostetes fügt <xref:System.Windows.ContentElement> der Ereignisroute über Unterknoten der logischen Struktur der, obwohl der gehostete Inhalt ist nicht Teil der visuellen Struktur "true". Dies ist erforderlich, damit eine <xref:System.Windows.ContentElement> können Quelle ein Routingereignis, das auf ein Element als ihm selbst weiterleitet.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Traversierung der Struktur  
 Die <xref:System.Windows.LogicalTreeHelper> -Klasse stellt die <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, und <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> Methoden zum Durchlaufen der logischen Struktur. In den meisten Fällen sollte Sie nicht die logische Struktur von vorhandenen Steuerelementen durchlaufen müssen, da diese Steuerelemente fast immer ihre logisch untergeordneten Elemente als dedizierte Auflistungseigenschaft verfügbar machen, die Auflistungszugriff, wie z.B. `Add`, einen Indexer und so weiter, unterstützt. Strukturdurchlauf wird hauptsächlich vom Autor des Steuerelements verwendet wird, die keine beabsichtigten Steuerelementmuster z. B. ableiten <xref:System.Windows.Controls.ItemsControl> oder <xref:System.Windows.Controls.Panel> Auflistungseigenschaften bereits definiert sind, und beabsichtigen, ihre eigenen Sammlung bereitstellen Unterstützung für Eigenschaften.  
  
 Die visuelle Struktur unterstützt auch eine Hilfsklasse für das Durchlaufen der visuellen Struktur <xref:System.Windows.Media.VisualTreeHelper>. Die visuelle Struktur nicht abgelesen bequem steuerelementspezifischen Eigenschaften, sodass der <xref:System.Windows.Media.VisualTreeHelper> Klasse ist die empfohlene Vorgehensweise für die visuelle Struktur durchlaufen, wenn für Ihr Szenario Programmierung, die erforderlich ist. Weitere Informationen finden Sie unter [Übersicht über das WPF-Grafikenrendering](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  Manchmal ist es notwendig, die visuelle Struktur einer angewendeten Vorlage zu untersuchen. Gehen Sie bei dieser Technik vorsichtig vor. Auch wenn Sie eine visuelle Struktur für ein Steuerelement durchlaufen, wobei Sie die Vorlage definieren, Consumer des Steuerelements können immer die Vorlage ändern durch Festlegen der <xref:System.Windows.Controls.Control.Template%2A> Eigenschaft für Instanzen und sogar die Endbenutzer kann die angewendete Vorlage beeinflussen, indem Sie ändern die Systemdesign.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Routen für Routingereignisse als „Struktur“  
 Wie bereits erwähnt, durchläuft die Route aller angegebenen Routingereignisse entlang eines einzelnen und vordefinierten Pfads einer Struktur, die eine Mischung aus den Darstellungen visueller und logischer Strukturen ist. Die Ereignisroute kann innerhalb der Struktur nach oben oder nach unten passieren, je nachdem, ob es ein Tunnel- oder Bubbling-Routingereignis ist. Das Konzept der Ereignisroute hat keine direkt unterstützende Hilfsprogrammklasse, die verwendet werden kann, um die Ereignisroute unabhängig vom Auslösen eines Ereignisses, das tatsächlich weiterleitet, zu „durchlaufen“. Es ist eine Klasse, die Route darstellt <xref:System.Windows.EventRoute>, aber die Methoden dieser Klasse sind im Allgemeinen nur zur internen Verwendung.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Ressourcenwörterbücher und Strukturen  
 Wörterbuchressourcensuche für alle `Resources`, die auf einer Seite festgelegt sind, durchlaufen im Grunde die logische Struktur. Objekte, die nicht in der logischen Struktur sind, können auf verschlüsselte Ressourcen verweisen, aber die Ressourcensuchsequenz beginnt an dem Punkt, an dem das Objekt mit der logischen Struktur verbunden ist. In WPF können nur logische Strukturknoten ein `Resources` -Eigenschaft, enthält eine <xref:System.Windows.ResourceDictionary>, daher es nicht sinnvoll ist, in das Durchlaufen der visuellen Struktur gesucht schlüsselgebundene Ressourcen aus einer <xref:System.Windows.ResourceDictionary>.  
  
 Die Ressourcensuche kann jedoch auch über die unmittelbare logische Struktur hinaus erweitert werden. Bei Anwendungsmarkups kann die Ressourcensuche auf Anwendungsebene von Ressourcenwörterbüchern weitergeführt werden, und anschließend bei der Designunterstützung und den Systemwerten fortgesetzt werden, die als statische Eigenschaften oder Schlüssel referenziert werden. Designs selbst können auch auf Systemwerte außerhalb der logischen Struktur des Designs verweisen, wenn die Ressourcenverweise dynamisch sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suchlogik, finden Sie unter [XAML-Ressourcen](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
## <a name="see-also"></a>Siehe auch  
 [Übersicht über die Eingabe](../../../../docs/framework/wpf/advanced/input-overview.md)  
 [Übersicht über das WPF-Grafikrendering](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)  
 [Übersicht über Routingereignisse](../../../../docs/framework/wpf/advanced/routed-events-overview.md)  
 [Initialisierung für Objektelemente außerhalb einer Objektstruktur](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)  
 [WPF-Architektur](../../../../docs/framework/wpf/advanced/wpf-architecture.md)
