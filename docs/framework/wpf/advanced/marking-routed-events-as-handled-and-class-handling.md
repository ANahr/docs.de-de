---
title: Markieren von Routingereignissen als behandelt und Klassenbehandlung
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 2d696c85be0f46c5f08e1770f0d695dbb4d50cb9
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Markieren von Routingereignissen als behandelt und Klassenbehandlung
Handler für ein Routingereignis können das Ereignis innerhalb der Ereignisdaten als behandelt markieren. Das Behandeln des Ereignisses verkürzt die Route. Die Klassenbehandlung ist ein Programmierkonzept, das von Routingereignissen unterstützt wird. Ein Klassenhandler hat die Möglichkeit, ein bestimmtes Routingereignis auf Klassenebene mit einem Ereignishandler zu verarbeiten, der vor jedem Instanzenhandler auf jeder Instanz der Klasse aufgerufen wird.  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Erforderliche Komponenten  
 In diesem Thema werden unter [Übersicht über Routingereignisse](../../../../docs/framework/wpf/advanced/routed-events-overview.md) eingeführte Konzepte näher erläutert.  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Markieren von Ereignissen als behandelt  
 Beim Festlegen des Wert von der <xref:System.Windows.RoutedEventArgs.Handled%2A> Eigenschaft `true` im Ereignis die Daten für ein Routingereignis, dies wird als bezeichnet "das Ereignis als behandelt markiert". Es gibt keine absolute Regel dafür, wann Sie Routingereignisse als Anwendungsentwickler oder als Autor von Steuerelementen, der auf vorhandenen Routingereignisse reagiert oder neue Routingereignisse implementiert, als behandelt markieren sollten. Das Konzept „behandelt“, so wie es in den Ereignisdaten des Routingereignisses ausgeführt wird, sollte als begrenztes Protokoll für die Antworten Ihrer eigenen Anwendung auf verschiedene weitergeleitete Ereignisse in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] sowie für alle benutzerdefinierten Routingereignisse verwendet werden. Eine weitere Möglichkeit, das Problem als „behandelt“ zu markieren ist, wenn Code auf eine Weise signifikant und relativ vollständig auf das Routingereignis geantwortet hat. In der Regel sollte es nicht mehr als eine signifikante Antwort geben, die separate Handlerimplementierungen für Routingereignisse erfordern muss. Wenn mehr Antworten erforderlich sind, sollte der erforderliche Code über Anwendungslogik implementiert werden, die in einem einzelnen Handler, nicht mithilfe des Weiterleitungssystems des Routingereignisses verkettet ist. Das Konzept von „erheblich“ ist ebenfalls subjektiv und hängt von der Anwendung oder dem Code ab. „Signifikante Antworten“ sind z.B.: das Festlegen des Fokus, die Änderung des öffentlichen Zustands, das Festlegen von Eigenschaften, die sich auf die visuelle Darstellung auswirken, und das Auslösen neuer Ereignisse. Beispiele für nicht signifikante Antworten sind: die Änderung des privaten Status (mit keiner visuellen Auswirkung oder eine programmgesteuerte Darstellung), das Protokollieren von Ereignissen, oder das Anzeigen eines Ereignisses und die Wahl, nicht darauf zu reagieren.  
  
 Das Routingereignis Systemverhalten dieses Modell "signifikanten Antworten" für die Verwendung von behandelten Zustand eines Routingereignisses verstärkt, da im Handler hinzugefügt [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] oder die common-Signatur <xref:System.Windows.UIElement.AddHandler%2A> werden nicht als Antwort auf ein Routingereignis aufgerufen, in dem das Ereignis Daten werden bereits als behandelt markiert. Der zusätzliche Aufwand für das Hinzufügen eines ereignishandlers mit durchlaufen müssen die `handledEventsToo` Parameter-Version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) um verarbeiten weitergeleitete Ereignisse, die von früheren Teilnehmer verarbeitet markiert sind in der ereignismeldung weiterzuleiten.  
  
 In einigen Fällen markieren Steuerelemente selbst bestimmte Routingereignisse als behandelt. Mit einem behandelten Rountingereignis gibt der Autor eines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Steuerelements zu verstehen, dass die Antwort des Steuerelements auf das Routingereignis signifikant bzw. im Rahmen der Implementierung vollständig ist und dass das Ereignis keine weitere Behandelung benötigt. Dies erfolgt normalerweise durch Hinzufügen eines Klassenhandlers für ein Ereignis oder durch Überschreiben eines der virtuellen Klassenhandler, die in einer Basisklasse vorhanden sind. Sie können dieses Ereignisbehandlung, wenn notwendig, umgehen. Informationen dazu finden Sie weiter unten im Abschnitt [Umgehen der Ereignisunterdrückung von Steuerelementen](#WorkingAroundEventSuppressionByControls) in diesem Thema.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Preview" Vs (Tunneling-Ereignisse). Bubbling-Ereignissen und Ereignisbehandlung  
 Vorschaurountingereignisse sind Ereignisse, die einer Tunnelingroute in der Elementstruktur folgen. Die „Vorschau“ in der Benennungskonvention weist auf das allgemeine Prinzip bei Eingabeereignissen hin, nach dem Vorschau-/ Tunneling-Routingereignisse vor den entsprechenden Bubbling-Rountingereignissen ausgelöst werden. Außerdem haben Eingaberountingereignisse mit einem Tunneling- und einem Bubblingereignis eine andere Behandlungslogik. Wenn das Tunneling-/ Vorschauroutingereignis von einem Ereignislistener als behandelt markiert wurde, dann wird das Bubblingereignis als behandelt markiert, noch bevor alle Listener des Bubblingereignisses es erhalten. Die Tunneling- und Bubblingroutingereignisse sind technisch separate Ereignisse. Sie teilen sich aber absichtlich dieselbe Ereignisdateninstanz, um dieses Verhalten zu ermöglichen.  
  
 Die Verbindung zwischen Tunneling- und Bubbling-Rountingereignissen wird mithilfe der internen Implementierung erreicht, die angibt, wie jede gegebene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Klasse die eigenen deklarierten Routingereignisse auslöst. Dies gilt für alle gekoppelten Eingaberountingereignisse. Es besteht keine Verbindung zwischen einem Tunneling- und einem Bubbling-Routnigereignis, die dasselbe Benennungsschema nutzen, wenn diese Implementierung auf Klassenebene nicht vorhanden: Ohne diese Implementierung wären beide Routingereignisse zwei vollständig getrennt und würden weder in der Sequenz ausgelöst werden, noch dieselben Ereignisdaten haben.  
  
 Weitere Informationen dazu, wie Sie Tunneling-/Bubbling-Eingabeereignispaare in einer benutzerdefinierten Klasse implementieren, finden Sie unter [Erstellen eines benutzerdefinierten Routingereignisses](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Klassenhandler und Instanzhandler  
 Rountingereignisse sollten Sie zwei verschiedene Arten von Ereignislistenern beachten: Klassenlistener und Instanzlistener. Klasse Listener vorhanden sind, da die Typen mit eine bestimmten aufgerufen haben <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in ihrer statischen Konstruktor oder eine Klasse virtuelle Handlermethode von einer Element-Basisklasse überschrieben haben. Instanzlistener werden bestimmte Instanzen /-Elemente, in denen ein oder mehrere Handler für das Routingereignis durch einen Aufruf von angefügt haben wurde <xref:System.Windows.UIElement.AddHandler%2A>. Vorhandene [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Routingereignisse Aufrufe an <xref:System.Windows.UIElement.AddHandler%2A> als Teil der [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] Ereignis Wrapper hinzufügen{} und Entfernen von{} Implementierungen des Ereignisses, also auch wie den einfachen [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] -Mechanismus von Anfügen der Ereignishandler über einen Attributsyntax aktiviert ist. Daher selbst die einfache [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Verwendung letztlich ist identisch mit dem ein <xref:System.Windows.UIElement.AddHandler%2A> aufrufen.  
  
 Elemente innerhalb der visuellen Struktur werden auf registrierte Handlerimplementierungen überprüft. Handler werden möglicherweise in der gesamten Route aufgerufen, und zwar in der Reihenfolge, die im Typ der Routingstrategie für das Routingereignis inhärent ist. Bubbling-Routingereignisse rufen z.B. zuerst die Handler auf, die dem gleichen Element zugeordnet sind, das das Routingereignis ausgelöst hat. Das Routingereignis bubblet dann zu dem nächsten übergeordneten Element und so weiter, bis das Stammelement der Anwendung erreicht ist.  
  
 Wenn aus der Perspektive des Stammelements in einer Bubblingroute die Klassenbehandlung oder ein beliebiges Element, das sich näher an der Quelle des Routingereignisses befindet, Handler aufrufen, die die Ereignisargumente als behandelt markieren, werden Handler in den Stammelementen nicht aufgerufen, und die Ereignisroute wird effektiv verkürzt, bevor das Stammelement erreicht wird. Die Route wird jedoch nicht vollständig angehalten, da Handler mithilfe der bestimmten Bedingung hinzugefügt werden können, dass sie trotzdem noch aufgerufen werden sollen, auch wenn ein Klassen- oder Instanzhandler das Routingereignis als behandelt markiert hat. Informationen hierzu finden Sie im Abschnitt [Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) weiter unten in diesem Thema.  
  
 Auf einer tieferen Ebene als die Ereignisroute operieren möglicherweise mehrere Klassenhandler auf jeder gegebenen Instanz einer Klasse. Das liegt daran, dass das Klassenbehandlungsmodell für Routingereignisse es allen möglichen Klassen in einer Klassenhierarchie ermöglicht, einen eigenen Klassenhandler für jedes Routingereignis zu registrieren. Jeder Klassenhandler wird einem internen Speicher hinzugefügt, und wenn die Ereignisroute für eine Anwendung erstellt wird, werden die Klassenhandler werden alle der Ereignisroute hinzugefügt. Klassenhandler werden der Route so hinzugefügt, dass der am stärksten abgeleitete Klassenhandler zuerst und die Klassenhandler aus jeder nachfolgenden Basisklasse im Anschluss aufgerufen werden. Klassenhandler werden im Allgemeinen nicht registriert, sodass sie auch auf Routingereignisse reagieren, die bereits als behandelt markiert wurden. Dieser Mechanismus zur Klassenbehandlung ermöglicht eine dieser zwei Optionen:  
  
-   Abgeleitete Klassen können die Klassenbehandlung ergänzen, die von der Basisklasse geerbt wird, indem ein Handler hinzugefügt wird, der das Routingereignis nicht als behandelt markiert, da der Basisklassenhandler nach dem Handler der abgeleiteten Klasse aufgerufen wird.  
  
-   Abgeleitete Klassen können die Klassenbehandlung der Basisklasse ersetzen, indem ein Klassenhandler hinzugefügt wird, der das Routingereignis als behandelt markiert. Bei diesem Ansatz sollten Sie sorgfältig vorgehen, da er möglicherweise das vorgesehene Design des Basissteuerelements in Bereichen wie der visuelle Darstellung, der Zustandslogik, der Eingabeverarbeitung und der Befehlsbehandlung ändert.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Klassenbehandlung von Routingereignissen durch Steuerelementbasisklassen  
 Auf jedem gegebene Elementknoten in einer Ereignisroute haben Klassenlistener die Möglichkeit, vor jedem Instanzlistener auf dem Element auf das Routingereignis zu reagieren. Aus diesem Grund werden Klassenhandler manchmal verwendet, um Routingereignisse zu unterdrücken, die von der Implementierung einer bestimmten Steuerelementklasse nicht weitergegeben werden sollen, oder um eine besondere Behandlung des Routingereignisses bereitzustellen, das eine Funktion der Klasse ist. Eine Klasse kann z.B. ein eigenes klassenspezifisches Ereignis auslösen, das weitere Details über die Bedeutung einer Benutzereingabebedingung im Kontext der jeweiligen Klasse enthält. Die Implementierung der Klasse kann das allgemeinere Routingereignis dann als behandelt markieren. Klassenhandler werden in der Regel hinzugefügt, dass sie nicht aufgerufen werden, für Routingereignisse behandelt Ereignisse, in dem freigegebene Ereignisdaten bereits markiert, aber atypischen Fällen auch eine <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> Signatur, die Klassenhandler zum Aufrufen, auch wenn Routingereignisse werden registriert als behandelt markiert.  
  
### <a name="class-handler-virtuals"></a>Virtuelle Klassenhandler  
 Einige Elemente, insbesondere Basiselemente wie z. B. <xref:System.Windows.UIElement>, machen leer "auf * Ereignis" und "OnPreview\*Ereignis" virtuelle Methoden, die die Liste der öffentlichen Routingereignisse entsprechen. Diese virtuellen Methoden können überschrieben werden, um einen Klassenhandler für dieses Routingereignis zu implementieren. Diese virtuellen Methoden der Basiselementklasse registriert werden, da ihre Klassenhandler für diese Ereignis mit weitergeleitet <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> wie zuvor beschrieben. Die virtuellen On\*Event-Methoden vereinfachen die Implementierung der Klassenbehandlung für die relevanten Routingereignisse, ohne eine spezielle Initialisierung in statischen Konstruktoren für jeden Typ zu erfordern. Sie können z. B. hinzufügen, eine Klassenbehandlung für das <xref:System.Windows.UIElement.DragEnter> Ereignis in einem <xref:System.Windows.UIElement> abgeleitete Klasse durch Überschreiben der <xref:System.Windows.UIElement.OnDragEnter%2A> virtuelle Methode. In der Überschreibung können Sie das Routingereignis behandeln, andere Ereignisse auslösen, klassenspezifische Logik initialisieren, die Elementeigenschaften für Instanzen ändern kann, oder jede beliebige Kombination dieser Aktionen ausführen. Sie sollten die Basisimplementierung solcher Überschreibungen generell aufrufen, selbst wenn Sie das Ereignis als behandelt markieren. Das Aufrufen der Basisimplementierung wird dringend empfohlen, da sich die virtuelle Methode in der Basisklasse befindet. Das geschützte virtuelle Standardmuster, bei dem die Basisimplementierungen aus jeder virtuellen Methode aufgerufen werden, ersetzt und entspricht einem ähnlichen Mechanismus, der nativ in der Klassenbehandlung von Routingereignissen vorkommt. Dabei werden Klassenhandler für alle Klassen in einer Klassenhierarchie auf jeder Instanz aufgerufen, beginnend mit dem Handler der am stärksten abgeleiteten Klasse und anschließend mit den Handlern der Basisklasse. Sie sollten den Aufruf der Basisimplementierung nur weglassen, wenn Ihre Klasse eine explizite Anforderung enthält, die Logik der Basisklassenbehandlung zu ändern. Es hängt von der Art Ihrer Implementierung ab, ob Sie die Basisimplementierung vor oder nach dem überschreibenden Code aufrufen.  
  
#### <a name="input-event-class-handling"></a>Klassenbehandlung von Eingabeereignissen  
 Virtuelle Methoden des Klassenhandlers werden alle so registriert, dass sie nur dann aufgerufen werden, wenn gemeinsam genutzte Ereignisdaten nicht bereits als behandelt markiert wurden. Außerdem werden nur bei Eingabeereignissen die Tunneling- und Bubblingversionen in der Regel nacheinander ausgelöst und verwenden dieselben Ereignisdaten. Dazu sollten Sie ein Ereignis für ein bestimmtes Paar von Eingabeereignis-Klassenhandlern, von denen einer die Tunneling-und der andere die Bubblingversion darstellt, nicht sofort als behandelt markieren. Wenn Sie die virtuelle Methode der Tunneling-Klassenbehandlung implementieren, um das Ereignis als behandelt zu markieren, wird der Bubbling-Klassenhandler daran gehindert, aufgerufen zu werden (außerdem wird verhindert, dass alle normal registrierten Instanzhandler für das Tunneling- oder das Bubblingereignis aufgerufen werden).  
  
 Nach Abschluss der Klassenbehandlung für einen Knoten werden die Instanzlistener berücksichtigt.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Hinzufügen von Instanzhandlern, die ausgelöst werden, obwohl Ereignisse als behandelt markiert wurden  
 Die <xref:System.Windows.UIElement.AddHandler%2A> Methode stellt eine bestimmte Überladung, mit dem Sie Handler hinzuzufügen, die vom Ereignissystem aufgerufen werden, wenn ein Ereignis der Behandlungselement in der Route selbst wenn die Ereignisdaten, um zu kennzeichnen, die bereits von ein anderen Handler erreicht bereit. das Ereignis als behandelt. Dies wird in der Regel nicht ausgeführt. Ereignishandler können generell geschrieben werden, um alle Bereiche des Anwendungscodes anzupassen, die von einem Ereignis beeinflusst werden können, unabhängig davon, wo es in einer Elementstruktur behandelt wurde, auch wenn mehrere Ergebnisse gewünscht sind. Darüber hinaus gibt es in der Regel nur ein Element, das auf dieses Ereignis reagieren muss, und die entsprechende Anwendungslogik ist bereits geschehen. Für Ausnahmefälle steht die `handledEventsToo`-Überladung zur Verfügung, in der ein anderes Element in einer Elementstruktur oder Zusammensetzung von Steuerelementen ein Ereignis bereits als behandelt markiert hat, während andere, in der Elementstruktur höhere oder niedrigere Elemente (je nach Route) ihre eigenen Handler aber aufrufen möchten.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Markieren von behandelten Ereignisse als nicht behandelt  
 Im Allgemeinen weitergeleitete Ereignisse, die als behandelt markiert werden sollten nicht gekennzeichnet werden, nicht behandelte (<xref:System.Windows.RoutedEventArgs.Handled%2A> legen wieder auf `false`) auch von Handlern, die auf `handledEventsToo`. Allerdings haben einige Ereignisse Ereignisdarstellungen auf hoher und niedriger Ebene, die sich überlappen können, wenn das Ereignis auf höherer Ebene an einer Position in der Struktur und das Ereignis auf niedrigerer Ebene an einer anderen Position angezeigt wird. Betrachten Sie beispielsweise die Groß-/Kleinschreibung, in dem ein untergeordnetes Element eine allgemeine Tastenereignis wie z. B. überwacht <xref:System.Windows.UIElement.TextInput> während ein übergeordneten Elements wie z. B. auf ein Low-Level-Ereignis lauscht <xref:System.Windows.UIElement.KeyDown>. Wenn das übergeordnete Element das Ereignis auf niedrigerer Ebene behandelt, kann das Ereignis auf höherer Ebene sogar im untergeordneten Element unterdrückt werden, das intuitiv als Erstes die Möglichkeit haben sollte, das Ereignis zu behandeln.  
  
 In diesen Situationen kann es erforderlich sein, für das Ereignis auf niedrigerer Ebene sowohl dem übergeordneten als auch dem untergeordneten Element Handler hinzuzufügen. Die Handlerimplementierung für das untergeordnete Element kann das Ereignis auf niedrigerer Ebene als behandelt markieren, aber die Handlerimplementierung des übergeordneten Elements würde dies wieder rückgängig machen, damit andere Elemente weiter oben in der Struktur (und das Ereignis auf höherer Ebene) die Möglichkeit haben, zu reagieren. Diese Situation ist aber relativ selten.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Beabsichtigtes Unterdrücken von Eingabeereignissen für die Zusammensetzung von Steuerelementen  
 Das Hauptszenario, in dem die Klassenbehandlung von Routingereignissen dazu verwendet wird, sind Eingabeereignisse und zusammengesetzte Steuerelemente. Ein zusammengesetztes Steuerelement besteht per definitionem aus mehreren praktischen Steuerelementen oder Steuerelement-Basisklassen. Häufig möchte der Autor des Steuerelements alle möglichen Eingabeereignisse verbinden, die von den einzelnen Unterkomponenten ausgelöst werden können, um das gesamte Steuerelement als Ereignisquelle zu melden. In einigen Fällen möchte der Autor des Steuerelements die Ereignisse von Komponenten möglicherweise vollständig unterdrücken oder ein komponentendefiniertes Ereignis ersetzen, das weitere Informationen enthält oder ein spezifischeres Verhalten impliziert. Das kanonische Beispiel für eine beliebige Komponentenautor sofort sichtbar ist wie eine [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> behandelt alle Mausereignis, das schließlich in ein intuitives Ereignis aufgelöst wird, dass alle Schaltflächen verfügen: eine <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis.  
  
 Der <xref:System.Windows.Controls.Button> Basisklasse (<xref:System.Windows.Controls.Primitives.ButtonBase>) leitet sich von <xref:System.Windows.Controls.Control> der wiederum abgeleitet aus <xref:System.Windows.FrameworkElement> und <xref:System.Windows.UIElement>, und einen Großteil der Ereignisinfrastruktur, die erforderlich sind, für die Verarbeitung von Benutzereingaben Steuerelement am wird die <xref:System.Windows.UIElement> Ebene. Insbesondere <xref:System.Windows.UIElement> verarbeitet allgemeine <xref:System.Windows.Input.Mouse> Ereignisse, die Treffertests für den Cursor innerhalb seiner Grenzen zu behandeln, und bietet verschiedene Ereignisse für die am häufigsten verwendeten Aktionen, wie z. B. Schaltfläche <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> bietet auch eine leere virtuelle <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> als vorab registrierten Klassenhandler für <xref:System.Windows.UIElement.MouseLeftButtonDown>, und <xref:System.Windows.Controls.Primitives.ButtonBase> überschrieben. Auf ähnliche Weise <xref:System.Windows.Controls.Primitives.ButtonBase> verwendet Klassenhandler für <xref:System.Windows.UIElement.MouseLeftButtonUp>. In den Außerkraftsetzungen, die Daten für das Ereignis übergeben werden, die Implementierungen kennzeichnen, dass die <xref:System.Windows.RoutedEventArgs> -Instanz als behandelt, indem <xref:System.Windows.RoutedEventArgs.Handled%2A> auf `true`, und dieselben Ereignisdaten ist, was entlang der Rest der Route, die andere Klassenhandler fortgesetzt und auch zum Instanzhandler oder Ereignissetter. Darüber hinaus die <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> Außerkraftsetzung neben löst die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis. Das Endergebnis für die meisten Listener werden, die die <xref:System.Windows.UIElement.MouseLeftButtonDown> und <xref:System.Windows.UIElement.MouseLeftButtonUp> Ereignisse "ausgeblendet", und stattdessen durch ersetzt <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, ein Ereignis, die Weitere Informationen enthält, da bekannt ist, dass dieses Ereignis stammt aus einer Schaltfläche "true" und nicht einige Zusammengesetzte Stück vollständig von der Schaltfläche oder ein anderes Element.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Umgehen der Ereignisunterdrückung von Steuerelementen  
 Manchmal kann dieses Ereignis unterdrückende Verhalten in einzelnen Steuerelementen einige allgemeinere Absichten der Ereignisbehandlungslogik der Anwendung behindern. Für die Instanz, wenn aus irgendeinem Grund musste die Anwendung auf einen Handler für <xref:System.Windows.UIElement.MouseLeftButtonDown> befindet sich auf das Stammelement der Anwendung und werden Sie bemerken, dass es sich bei einem Mausklick auf eine Schaltfläche aufgerufen würde, nicht <xref:System.Windows.UIElement.MouseLeftButtonDown> oder <xref:System.Windows.UIElement.MouseLeftButtonUp> Handler auf der Stammebene. Das Ereignis selbst würde aufbubblen (wie gesagt, Ereignisroutes werden nicht tatsächlich beendet, das Routingereignissystem ändert nur deren Aufrufverhalten für Ereignishandler, nachdem sie als behandelt markiert wurden). Wenn das Routingereignis die Schaltfläche, erreicht die <xref:System.Windows.Controls.Primitives.ButtonBase> Klassenbehandlung markiert die <xref:System.Windows.UIElement.MouseLeftButtonDown> behandelt, da zu ersetzen, die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis mit mehr Bedeutung. Aus diesem Grund alle standardmäßigen <xref:System.Windows.UIElement.MouseLeftButtonDown> Handler weiter oben in der Route würde nicht aufgerufen werden. Es gibt zwei Verfahren, mit denen Sie sicherzustellen können, dass die Handler unter diesen Umständen aufgerufen werden würden.  
  
 Das erste Verfahren ist absichtlich Hinzufügen der Handler mit der `handledEventsToo` Signatur <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Dieses Verfahren zum Anhängen eines Ereignishandlers ist aber nur im Code und nicht in Markup möglich. Die einfache Syntax für die Angabe des Ereignishandlernamens als Ereignisattributwert über [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] ermöglicht dieses Verhalten nicht.  
  
 Das zweite Verfahren funktioniert nur für Eingabeereignisse, in denen die Tunneling- und Bubblingversionen des Routingereignisses kombiniert werden. Für diese Routingereignisse können Sie stattdessen der Vorschau-/Tunnelingversion des Routingereignisses Handler hinzufügen. Dieses Routingereignis tunnelt ausgehend vom Stamm durch die Route, damit der Code für die Behandlung der Schaltflächenklasse es nicht abfängt, vorausgesetzt, dass Sie den Vorschauhandler in einer Vorgängerebene in der Anwendungsstruktur angefügt haben. Wenn Sie diesen Ansatz verwenden, sollten Sie beim Markieren von Vorschauereignissen als behandelt vorsichtig vorgehen. Für das Beispiel mit <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> im Stammelement behandelt werden, wenn Sie das Ereignis als markiert <xref:System.Windows.RoutedEventArgs.Handled%2A> in die Handlerimplementierung würde unterdrückt die <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis. Dies ist in der Regel kein erwünschtes Verhalten.  
  
## <a name="see-also"></a>Siehe auch  
 <xref:System.Windows.EventManager>  
 [Vorschauereignisse](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [Erstellen eines benutzerdefinierten Routingereignisses](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [Übersicht über Routingereignisse](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
