---
title: Gemeinsame Verwendung von Nachrichtenschleifen zwischen Win32 und WPF
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
caps.latest.revision: "10"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: dcf8baa87038bc5625d46968b39d759daae25cbc
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/21/2017
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="44137-102">Gemeinsame Verwendung von Nachrichtenschleifen zwischen Win32 und WPF</span><span class="sxs-lookup"><span data-stu-id="44137-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="44137-103">In diesem Thema wird beschrieben, wie eine Nachrichtenschleife für die Zusammenarbeit mit implementieren [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], entweder mithilfe der vorhandenen Nachricht Schleife Datenanzeige im <xref:System.Windows.Threading.Dispatcher> oder erstellen eine separate Nachrichtenschleife auf die [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] des Codes interoperation Seite.</span><span class="sxs-lookup"><span data-stu-id="44137-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="44137-104">ComponentDispatcher und die Nachrichtenschleife</span><span class="sxs-lookup"><span data-stu-id="44137-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="44137-105">Für die Unterstützung von Interoperation und ein normales Szenario besteht darin zu implementieren <xref:System.Windows.Interop.IKeyboardInputSink>, oder Unterklassen von Klassen, die bereits implementiert <xref:System.Windows.Interop.IKeyboardInputSink>, wie z. B. <xref:System.Windows.Interop.HwndSource> oder <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="44137-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="44137-106">Allerdings befasst Senke Tastaturfunktionen alle möglichen Schleife Anforderungen sich nicht, die Sie möglicherweise beim Senden und Empfangen von Nachrichten über die Grenzen der interoperation.</span><span class="sxs-lookup"><span data-stu-id="44137-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="44137-107">Um formalisieren Nachricht Anwendungsarchitektur, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] bietet die <xref:System.Windows.Interop.ComponentDispatcher> Klasse, die ein einfaches Protokoll für eine Nachrichtenschleife anzuwendendes definiert.</span><span class="sxs-lookup"><span data-stu-id="44137-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="44137-108"><xref:System.Windows.Interop.ComponentDispatcher>ist eine statische Klasse, die mehrere Member verfügbar macht.</span><span class="sxs-lookup"><span data-stu-id="44137-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="44137-109">Der Bereich der einzelnen Methoden ist implizit an den aufrufenden Thread gebunden.</span><span class="sxs-lookup"><span data-stu-id="44137-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="44137-110">Eine Nachrichtenschleife muss aufgerufen werden, einige davon [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] in kritischen Zeiten (wie im nächsten Abschnitt definiert).</span><span class="sxs-lookup"><span data-stu-id="44137-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="44137-111"><xref:System.Windows.Interop.ComponentDispatcher>bietet Ereignisse, denen andere Komponenten (z. B. die Tastatursenke) überwachen können.</span><span class="sxs-lookup"><span data-stu-id="44137-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="44137-112">Die <xref:System.Windows.Threading.Dispatcher> -Klasse ruft die entsprechende <xref:System.Windows.Interop.ComponentDispatcher> Methoden in der entsprechenden Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="44137-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="44137-113">Der Code ist verantwortlich für das aufrufen, wenn Sie Ihre eigene Nachrichtenschleife implementieren, <xref:System.Windows.Interop.ComponentDispatcher> Methoden auf ähnliche Weise.</span><span class="sxs-lookup"><span data-stu-id="44137-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="44137-114">Aufrufen von <xref:System.Windows.Interop.ComponentDispatcher> rufen Methoden auf einen Thread nur Ereignishandler, die in diesem Thread registriert wurden.</span><span class="sxs-lookup"><span data-stu-id="44137-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="44137-115">Schreiben von Nachrichtenschleifen</span><span class="sxs-lookup"><span data-stu-id="44137-115">Writing Message Loops</span></span>  
 <span data-ttu-id="44137-116">Im folgenden finden Sie eine Prüfliste der <xref:System.Windows.Interop.ComponentDispatcher> Member verwendet wird, wenn Sie Ihre eigene Nachrichtenschleife schreiben:</span><span class="sxs-lookup"><span data-stu-id="44137-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="44137-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: die Nachrichtenschleife sollte aufrufen, um anzugeben, dass der Thread modal ist.</span><span class="sxs-lookup"><span data-stu-id="44137-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="44137-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: die Nachrichtenschleife sollte rufen Sie diese Option, um anzugeben, dass der Thread auf diesen zurückgesetzt wurde.</span><span class="sxs-lookup"><span data-stu-id="44137-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="44137-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: die Nachrichtenschleife sollte rufen Sie diese Option, um anzugeben, dass <xref:System.Windows.Interop.ComponentDispatcher> auslösen soll die <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> Ereignis.</span><span class="sxs-lookup"><span data-stu-id="44137-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="44137-120"><xref:System.Windows.Interop.ComponentDispatcher>löst keine <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> Wenn <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> ist `true`, aber möglicherweise Nachrichtenschleifen aufrufen auswählen <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> selbst wenn <xref:System.Windows.Interop.ComponentDispatcher> nicht auf das er im modalen Zustand.</span><span class="sxs-lookup"><span data-stu-id="44137-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="44137-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: die Nachrichtenschleife sollte aufrufen, um anzugeben, dass eine neue Nachricht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="44137-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="44137-122">Der Rückgabewert gibt an, ob ein Listener einen <xref:System.Windows.Interop.ComponentDispatcher> Ereignis behandelt, die Nachricht.</span><span class="sxs-lookup"><span data-stu-id="44137-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="44137-123">Wenn <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> gibt `true` (behandelt), der Verteiler sollte keine weiteren Aktionen mit der Meldung.</span><span class="sxs-lookup"><span data-stu-id="44137-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="44137-124">Wenn der Rückgabewert ist `false`, wird erwartet, dass der Verteiler rufen die [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] Funktion `TranslateMessage`, rufen Sie anschließend `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="44137-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="44137-125">ComponentDispatcher und bestehende Meldungsbehandlung</span><span class="sxs-lookup"><span data-stu-id="44137-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="44137-126">Im folgenden finden Sie eine Prüfliste der <xref:System.Windows.Interop.ComponentDispatcher> Elemente verwendet werden, wenn Sie auf den inhärenten verlassen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Nachrichtenschleife.</span><span class="sxs-lookup"><span data-stu-id="44137-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="44137-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: Gibt zurück, ob die Anwendung modale verlassen hat (z. B. eine modale Nachrichtenschleife verfügt über ein Push ausgeführt wurde).</span><span class="sxs-lookup"><span data-stu-id="44137-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="44137-128"><xref:System.Windows.Interop.ComponentDispatcher>Dieser Status kann nachverfolgt werden, da die Klasse die Anzahl der verwaltet <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> und <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> aufrufen, die von der Nachrichtenschleife.</span><span class="sxs-lookup"><span data-stu-id="44137-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="44137-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>und <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> Ereignisse folgen die Standardregeln für das Delegieren von aufrufen.</span><span class="sxs-lookup"><span data-stu-id="44137-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="44137-130">Delegaten werden in einer nicht angegebenen Reihenfolge aufgerufen, und alle Delegaten werden aufgerufen, auch wenn das erste Schema die Nachricht markiert, als behandelt.</span><span class="sxs-lookup"><span data-stu-id="44137-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="44137-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: Gibt an eine geeignete und effiziente Verarbeitung im Leerlauf befindet, führen Sie (es gibt keine ausstehenden Nachrichten für den Thread).</span><span class="sxs-lookup"><span data-stu-id="44137-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="44137-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>wird nicht ausgelöst werden, wenn der Thread modal ist.</span><span class="sxs-lookup"><span data-stu-id="44137-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="44137-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: für alle Nachrichten, die von die Meldungsverteilschleife verarbeitet ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="44137-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="44137-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: für alle Nachrichten, die nicht während der behandelt wurden ausgelöst <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="44137-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="44137-135">Eine Nachricht gilt als behandelt If nach der <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> Ereignis oder <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> Ereignis, das `handled` in Ereignisdaten als Verweis übergebener Parameter ist `true`.</span><span class="sxs-lookup"><span data-stu-id="44137-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="44137-136">Ereignishandler sollte die Meldung ignorieren, wenn `handled` ist `true`, da das bedeutet, dass die unterschiedliche Handler behandelt die Nachricht zuerst.</span><span class="sxs-lookup"><span data-stu-id="44137-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="44137-137">Ereignishandler auf beide Ereignisse können die Nachricht zu ändern.</span><span class="sxs-lookup"><span data-stu-id="44137-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="44137-138">Der Verteiler sollte die geänderte Nachricht und nicht die ursprüngliche unveränderte Nachricht senden.</span><span class="sxs-lookup"><span data-stu-id="44137-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="44137-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>alle Listener, aber die architektonische Absicht übermittelt wird, die nur die Fenster der obersten Ebene mit dem HWND, an dem die gerichteten Nachrichten sollten Code als Antwort auf die Nachricht aufrufen.</span><span class="sxs-lookup"><span data-stu-id="44137-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="44137-140">Wie behandelt HwndSource ComponentDispatcher-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="44137-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="44137-141">Wenn die <xref:System.Windows.Interop.HwndSource> ist ein Fenster der obersten Ebene (kein übergeordnetes Element HWND), wird folglich mit <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="44137-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="44137-142">Wenn <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> ausgelöst wird, und wenn die Nachricht vorgesehen ist die <xref:System.Windows.Interop.HwndSource> oder untergeordneten Fenster <xref:System.Windows.Interop.HwndSource> Aufrufe der <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> Tastatur Senke Sequenz.</span><span class="sxs-lookup"><span data-stu-id="44137-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="44137-143">Wenn die <xref:System.Windows.Interop.HwndSource> ist ein Fenster der obersten Ebene (verfügt über einen übergeordneten HWND), werden keine Verarbeitung.</span><span class="sxs-lookup"><span data-stu-id="44137-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="44137-144">Nur die Fenster auf oberster Ebene ist, führen Sie die Behandlung erwartet, und es muss ein Fenster auf oberster Ebene mit Unterstützung für die Senke Tastatur als Teil jeder interoperation Szenario sein.</span><span class="sxs-lookup"><span data-stu-id="44137-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="44137-145">Wenn <xref:System.Windows.Interop.HwndHost.WndProc%2A> auf eine <xref:System.Windows.Interop.HwndSource> wird aufgerufen, ohne eine entsprechende Tastenkombination Senke Methode zuerst aufgerufen wird, empfängt die Anwendung Tastaturereignisse der höheren Ebene wie z. B. <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="44137-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="44137-146">Allerdings werden keine Tastatur Senke Methoden die umgeht wünschenswert Eingabemodell Tastaturfunktionen z. B. Unterstützung von Zugriffstasten aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="44137-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="44137-147">Dies kann passieren, wenn die Nachrichtenschleife nicht richtig des relevanten Threads auf benachrichtigt wurde die <xref:System.Windows.Interop.ComponentDispatcher>, oder weil das übergeordnete Element HWND nicht die richtige Tastatur Senke Antworten aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="44137-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="44137-148">Eine Meldung, die auf der Tastatursenke geht möglicherweise nicht an das HWND gesendet werden, wenn Sie zuvor hinzugefügt haben, Hooks für diese Nachricht mithilfe der <xref:System.Windows.Interop.HwndSource.AddHook%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="44137-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="44137-149">Möglicherweise wurde die Nachricht auf Nachrichtenebene für die Datapump direkt und nicht übermittelt werden, um behandelt die `DispatchMessage` Funktion.</span><span class="sxs-lookup"><span data-stu-id="44137-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="44137-150">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="44137-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="44137-151">Interaktion zwischen WPF und Win32</span><span class="sxs-lookup"><span data-stu-id="44137-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="44137-152">Threadmodell</span><span class="sxs-lookup"><span data-stu-id="44137-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="44137-153">Übersicht über die Eingabe</span><span class="sxs-lookup"><span data-stu-id="44137-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
