---
title: "Metadaten f&#252;r Abh&#228;ngigkeitseigenschaften | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "APIs, Metadaten"
  - "Abhängigkeitseigenschaften, Metadaten"
  - "Metadaten, Für Abhängigkeitseigenschaften"
  - "Überschreiben von Metadaten"
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
caps.latest.revision: 24
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 23
---
# Metadaten f&#252;r Abh&#228;ngigkeitseigenschaften
Das [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]\-Eigenschaftensystem enthält ein Metadatenberichtssystem, das mehr als nur die Daten von Eigenschaften berichtet, indem die Reflektion verwendet oder allgemeine [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]\-Merkmale angegeben werden.  Die Metadaten für eine [Abhängigkeitseigenschaft](GTMT) können auch eindeutig von der Klasse zugewiesen werden, die eine [Abhängigkeitseigenschaft](GTMT) definiert, sie können geändert werden, wenn die [Abhängigkeitseigenschaft](GTMT) einer anderen Klasse hinzugefügt wird, und sie können von allen abgeleiteten Klassen spezifisch überschrieben werden, die die [Abhängigkeitseigenschaft](GTMT) von der definierenden Basisklasse erben.  
  
   
  
<a name="prerequisites"></a>   
## Vorbereitungsmaßnahmen  
 In diesem Thema wird vorausgesetzt, dass Sie sich aus Sicht eines Consumers vorhandener Abhängigkeitseigenschaften in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]\-Klassen auskennen und die [Übersicht über Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) gelesen haben.  Um den Beispielen in diesem Thema folgen zu können, sollten Sie außerdem mit der Verwendung von [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] und dem Schreiben von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]\-Anwendungen vertraut sein.  
  
<a name="dp_metadata_contents"></a>   
## Verwenden von Metadaten für Abhängigkeitseigenschaften  
 Metadaten für Abhängigkeitseigenschaften sind als Objekt vorhanden, das Sie abfragen können, um die Merkmale einer Abhängigkeitseigenschaft zu erhalten.  Auf diese Metadaten wird häufig auch vom Eigenschaftensystem zugegriffen, während es die jeweiligen Abhängigkeitseigenschaften verarbeitet.  Das Metadatenobjekt für eine Abhängigkeitseigenschaft kann die folgenden Arten von Informationen enthalten:  
  
-   Standardwert für die Abhängigkeitseigenschaft, wenn für die Abhängigkeitseigenschaft basierend auf lokalem Wert, Stil, Vererbung usw. kein anderer Wert ermittelt werden kann.  Ausführliche Informationen dazu, wo Standardwerte in der vom Eigenschaftensystem verwendeten Rangfolge beim Zuweisen von Werten für Abhängigkeitseigenschaften stehen, finden Sie unter [Priorität von Abhängigkeitseigenschaftswerten](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
-   Verweise auf Rückrufimplementierungen, die sich auf die Koersion oder auf Änderungsbenachrichtigungsverhalten pro Besitzer auswirken.  Beachten Sie, dass diese Rückrufe häufig mit einer nicht öffentlichen Zugriffsebene definiert werden. Das Abrufen der eigentlichen Verweise aus den Metadaten ist also im Allgemeinen nicht möglich, es sei denn, die Verweise liegen im zulässigen Zugriffsbereich.  Weitere Informationen zu Rückrufen von Abhängigkeitseigenschaften finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Wenn die fragliche Abhängigkeitseigenschaft als Eigenschaft auf [WPF\-Frameworkebene](GTMT) angesehen wird, enthalten die Metadaten ggf. Merkmale von [WPF\-Frameworkebene](GTMT)\-Abhängigkeitseigenschaften, die die Informationen und Zustände von Diensten wie dem [WPF\-Frameworkebene](GTMT)\-Layoutmodul und der Eigenschaftenvererbungslogik berichten.  Weitere Informationen zu diesem Aspekt der Metadaten für Abhängigkeitseigenschaften finden Sie unter [Framework\-Eigenschaftenmetadaten](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).  
  
<a name="APIs"></a>   
## Metadaten\-APIs  
 Der Typ, der die meisten Metadateninformationen berichtet, die vom Eigenschaftensystem verwendet werden, ist die <xref:System.Windows.PropertyMetadata>\-Klasse.  Metadateninstanzen werden optional angegeben, wenn Abhängigkeitseigenschaften beim Eigenschaftensystem registriert werden, und können erneut für zusätzliche Typen angegeben werden, die sich entweder selbst als Besitzer hinzufügen oder die Metadaten überschreiben, die sie von der Abhängigkeitseigenschaftendefinition der Basisklasse erben.  \(In Fällen, in denen eine Eigenschaftenregistrierung keine Metadaten angibt, werden standardmäßige <xref:System.Windows.PropertyMetadata> mit Standardwerten für die jeweilige Klasse erstellt.\) Die registrierten Metadaten werden als <xref:System.Windows.PropertyMetadata> zurückgegeben, wenn Sie die verschiedenen <xref:System.Windows.DependencyProperty.GetMetadata%2A>\-Überladungen aufrufen, die Metadaten von einer Abhängigkeitseigenschaft einer <xref:System.Windows.DependencyObject>\-Instanz abrufen.  
  
 Die <xref:System.Windows.PropertyMetadata>\-Klasse wird dann abgeleitet, um spezifischere Metadaten für Architekturaspekte bereitzustellen, z. B. [WPF\-Frameworkebene](GTMT)\-Klassen.  <xref:System.Windows.UIPropertyMetadata> fügt ein Animationsberichtssystem hinzu, und <xref:System.Windows.FrameworkPropertyMetadata> stellt die [WPF\-Frameworkebene](GTMT) \-Eigenschaften bereit, die im vorherigen Abschnitt erwähnt wurden.  Wenn Abhängigkeitseigenschaften registriert werden, können dabei diese abgeleiteten <xref:System.Windows.PropertyMetadata>\-Klassen verwendet werden.  Wenn die Metadaten untersucht werden, kann der <xref:System.Windows.PropertyMetadata>\-Basistyp ggf. in die abgeleiteten Klassen umgewandelt werden, damit Sie die spezifischeren Eigenschaften prüfen können.  
  
> [!NOTE]
>  Die Eigenschaftenmerkmale, die in <xref:System.Windows.FrameworkPropertyMetadata> angegeben werden können, werden in dieser Dokumentation auch als "Flags" bezeichnet.  Beim Erstellen von neuen Metadateninstanzen zur Verwendung in Abhängigkeitseigenschaft\-Registrierungen oder Metadatenüberschreibungen geben Sie diese Werte an, indem Sie die Flag\-Enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> verwenden und potenziell verkettete Werte der Enumeration dem <xref:System.Windows.FrameworkPropertyMetadata>\-Konstruktor bereitstellen.  Nach der Erstellung werden diese Optionsmerkmale jedoch innerhalb eines <xref:System.Windows.FrameworkPropertyMetadata>\-Elements als eine Serie boolescher Eigenschaften offengelegt, nicht der Enumerationswert der Erstellung.  Mithilfe der booleschen Eigenschaften können Sie die einzelnen bedingten Elemente überprüfen, anstatt eine Maske auf einen Wert der Flag\-Enumeration anwenden zu müssen, um die gewünschten Informationen zu erhalten.  Der Konstruktor verwendet das verkette <xref:System.Windows.FrameworkPropertyMetadataOptions>\-Element, um die Länge der Konstruktorsignatur auf ein angemessenes Maß zu begrenzen. Die erstellten Metadaten legen jedoch die diskreten Eigenschaften offen, um das Abfragen der Metadaten intuitiver zu gestalten.  
  
<a name="override_or_subclass"></a>   
## Wann werden Metadaten überschrieben und wann wird eine Klasse abgeleitet?  
 Das [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]\-Eigenschaftensystem verfügt über Funktionen zum Ändern einiger Merkmale von Abhängigkeitseigenschaften, ohne dass dabei eine neue Implementierung erforderlich ist.  Dies wird erreicht, indem für die Abhängigkeitseigenschaft eine andere Instanz der Eigenschaftenmetadaten als die erstellt wird, die für einen bestimmten Typ vorhanden ist.  Beachten Sie, dass es sich bei den meisten vorhandenen Abhängigkeitseigenschaften nicht um virtuelle Eigenschaften handelt, also kann eine "Neuimplementierung" für geerbte Klassen streng genommen nur erreicht werden, indem der vorhandene Member gespiegelt wird \(Shadowing\).  
  
 Wenn das Szenario, das Sie für eine Abhängigkeitseigenschaft eines Typs aktivieren möchten, sich nicht erreichen lässt, indem Sie die Merkmale vorhandener Abhängigkeitseigenschaften ändern, kann es erforderlich sein, dass Sie eine abgeleitete Klasse erstellen. Anschließend müssen Sie für die abgeleitete Klasse dann eine benutzerdefinierte Abhängigkeitseigenschaft deklarieren.  Eine benutzerdefinierte Abhängigkeitseigenschaft verhält sich genauso wie Abhängigkeitseigenschaften, die von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]\-[!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] definiert werden.  Weitere Informationen zu benutzerdefinierten Abhängigkeitseigenschaften finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Ein wichtiges Merkmal einer Abhängigkeitseigenschaft, das Sie nicht überschreiben können, ist ihr Werttyp.  Wenn Sie eine Abhängigkeitseigenschaft erben, die nahezu über das gewünschte Verhalten verfügt, Sie jedoch einen anderen Typ benötigen, müssen Sie eine benutzerdefinierte Abhängigkeitseigenschaft implementieren und die Eigenschaften ggf. mithilfe einer Typumwandlung oder einer anderen Implementierung für Ihre benutzerdefinierte Klasse verknüpfen.  Außerdem können Sie einen vorhandenen <xref:System.Windows.ValidateValueCallback> nicht ersetzen, da dieser Rückruf im Registrierungsfeld selbst vorhanden ist, nicht innerhalb der Metadaten.  
  
<a name="scenarios"></a>   
## Szenarios zum Ändern vorhandener Metadaten  
 Wenn Sie mit den Metadaten einer vorhandenen Abhängigkeitseigenschaft arbeiten, besteht ein gängiges Szenario zum Ändern von Metadaten einer Abhängigkeitseigenschaft darin, den Standardwert zu ändern.  Das Ändern oder Hinzufügen von Eigenschaftensystemrückrufen ist ein erweitertes Szenario.  Sie können dies in Erwägung ziehen, wenn Ihre Implementierung einer abgeleiteten Klasse zwischen Abhängigkeitseigenschaften über verschiedene Beziehungen verfügt.  Eine der Bedingungen bei der Verwendung eines Programmiermodells, das sowohl Code als auch die deklarative Nutzung unterstützt, besteht darin, dass Eigenschaften in beliebiger Reihenfolge festgelegt werden können.  Aus diesem Grund müssen alle abhängigen Eigenschaften erst bei Bedarf \(just in time\) ohne Kontext festgelegt werden, ohne dass eine Reihenfolge für die Festlegung bekannt ist, z. B. wie bei einem Konstruktor.  Weitere Informationen zu diesem Aspekt von Eigenschaftensystemen finden Sie unter [Rückrufe und Validierung von Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  Beachten Sie, dass es sich bei Validierungsrückrufen nicht um einen Teil der Metadaten handelt. Sie sind Teil des Bezeichners einer Abhängigkeitseigenschaft.  Deshalb können Sie Validierungsrückrufe nicht ändern, indem Sie die Metadaten überschreiben.  
  
 Es kann vorkommen, dass Sie für vorhandene Abhängigkeitseigenschaften auch die Eigenschaftenmetadatenoptionen der [WPF\-Frameworkebene](GTMT) ändern müssen.  Diese Optionen kommunizieren bekannte Bedingungen von Eigenschaften der [WPF\-Frameworkebene](GTMT) an andere Prozesse der [WPF\-Frameworkebene](GTMT), z. B. an das Layoutsystem.  Das Festlegen der Optionen wird in der Regel nur beim Registrieren einer neuen Abhängigkeitseigenschaft vorgenommen. Es ist jedoch auch möglich, die Eigenschaftenmetadaten der [WPF\-Frameworkebene](GTMT) als Teil eines <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>\- oder <xref:System.Windows.DependencyProperty.AddOwner%2A>\-Aufrufs zu ändern.  Die spezifischen Werte und weitere Informationen finden Sie unter [Framework\-Eigenschaftenmetadaten](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).  Weitere Informationen dazu, wie Sie diese Optionen für neu registrierte Abhängigkeitseigenschaften festlegen müssen, finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### Überschreiben von Metadaten  
 Der Zweck des Überschreibens von Metadaten besteht vor allem darin, Ihnen die Möglichkeit zu geben, die verschiedenen von den Metadaten abgeleiteten Verhalten zu ändern, die auf die auf Ihrem Typ basierende Abhängigkeitseigenschaft angewendet werden.  Die Gründe hierfür werden im Abschnitt [Metadaten](#dp_metadata_contents) näher erläutert.  Weitere Informationen und Codebeispiele finden Sie unter [Überschreiben von Metadaten für eine Abhängigkeitseigenschaft](../../../../docs/framework/wpf/advanced/how-to-override-metadata-for-a-dependency-property.md).  
  
 Sie können Eigenschaftenmetadaten für eine Abhängigkeitseigenschaft während des Registrierungsaufrufs angeben \(<xref:System.Windows.DependencyProperty.Register%2A>\).  In vielen Fällen ist es jedoch ratsam, für Ihre Klasse typspezifische Metadaten anzugeben, wenn diese die Abhängigkeitseigenschaft erbt.  Sie erreichen dies, indem Sie die <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>\-Methode aufrufen.  In einem Beispiel mit [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]\-[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] ist die <xref:System.Windows.FrameworkElement>\-Klasse der Typ, der die <xref:System.Windows.UIElement.Focusable%2A>\-Abhängigkeitseigenschaft zuerst registriert.  Die <xref:System.Windows.Controls.Control>\-Klasse überschreibt Metadaten für die Abhängigkeitseigenschaft jedoch, um ihren eigenen Anfangsstandardwert anzugeben, indem dieser von `false` in `true` geändert wird, und verwendet andernfalls die ursprüngliche <xref:System.Windows.UIElement.Focusable%2A>\-Implementierung.  
  
 Wenn Sie Metadaten überschreiben, werden die einzelnen Metadatenmerkmale entweder zusammengeführt oder ersetzt.  
  
-   <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> wird zusammengeführt.  Wenn Sie einen neuen <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> hinzufügen, wird dieser Rückruf in den Metadaten gespeichert.  Wenn Sie in der Überschreibung keinen <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> angeben, wird der Wert von <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> als Verweis des nächsten Vorgängers höher gestuft, der diesen in den Metadaten angegeben hat.  
  
-   Das eigentliche Verhalten des Eigenschaftensystems für <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> besteht darin, dass Implementierungen für alle Metadatenbesitzer in der Hierarchie beibehalten und der Tabelle hinzugefügt werden. Für das Eigenschaftensystem gilt die Ausführungsreihenfolge, dass Rückrufe der am stärksten abgeleiteten Klasse zuerst aufgerufen werden.  
  
-   <xref:System.Windows.PropertyMetadata.DefaultValue%2A> wird ersetzt.  Wenn Sie in der Überschreibung keinen <xref:System.Windows.PropertyMetadata.DefaultValue%2A> angeben, stammt der Wert von <xref:System.Windows.PropertyMetadata.DefaultValue%2A> vom nächsten Vorgänger, der diesen in den Metadaten angegeben hat.  
  
-   <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>\-Implementierungen werden ersetzt.  Wenn Sie einen neuen <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> hinzufügen, wird dieser Rückruf in den Metadaten gespeichert.  Wenn Sie in der Überschreibung keinen <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> angeben, wird der Wert von <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> als Verweis des nächsten Vorgängers höher gestuft, der diesen in den Metadaten angegeben hat.  
  
-   Das Verhalten des Eigenschaftensystems besteht darin, dass nur der <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in den unmittelbaren Metadaten aufgerufen wird.  Es werden keine Verweise auf andere <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>\-Implementierungen in der Hierarchie beibehalten.  
  
 Dieses Verhalten wird von <xref:System.Windows.PropertyMetadata.Merge%2A> implementiert und kann für abgeleitete Metadatenklassen überschrieben werden.  
  
#### Überschreiben der Metadaten von angefügten Eigenschaften  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] werden [angefügte Eigenschaften](GTMT) als Abhängigkeitseigenschaften implementiert.  Dies bedeutet, dass sie auch über Eigenschaftenmetadaten verfügen, die einzelne Klassen überschreiben können.  Die Bereichsüberlegungen für eine angefügte Eigenschaft in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] gehen in der Regel dahin, dass für alle <xref:System.Windows.DependencyObject>\-Elemente eine angefügte Eigenschaft festgelegt werden kann.  Aus diesem Grund können alle abgeleiteten <xref:System.Windows.DependencyObject>\-Klassen die Metadaten für eine angefügte Eigenschaft überschreiben, da die Festlegung für eine Instanz der Klasse erfolgen kann.  Sie können Standardwerte, Rückrufe oder [WPF\-Frameworkebene](GTMT)\-Eigenschaften zum Berichten von Merkmalen überschreiben.  Wenn die angefügte Eigenschaft für eine Instanz Ihrer Klasse festgelegt wird, gelten diese überschriebenen Eigenschaftenmetadaten\-Merkmale.  Sie können z. B. den Standardwert überschreiben, damit der Überschreibungswert für Instanzen Ihrer Klasse als Wert der angefügten Eigenschaft berichtet wird, solange die Eigenschaft nicht anderweitig eingerichtet wurde.  
  
> [!NOTE]
>  Die <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>\-Eigenschaft ist für angefügte Eigenschaften nicht relevant.  
  
<a name="dp_add_owner"></a>   
### Hinzufügen einer Klasse als Besitzer einer vorhandenen Abhängigkeitseigenschaft  
 Eine Klasse kann sich selbst als Besitzer einer Abhängigkeitseigenschaft hinzufügen, die bereits registriert wurde, indem sie die <xref:System.Windows.DependencyProperty.AddOwner%2A>\-Methode verwendet.  Auf diese Weise kann die Klasse eine Abhängigkeitseigenschaft verwenden, die ursprünglich für einen anderen Typ registriert wurde.  Bei der hinzufügenden Klasse handelt es sich normalerweise nicht um eine abgeleitete Klasse des Typs, der die Abhängigkeitseigenschaft als Besitzer zuerst registriert hat.  Ihre Klasse und die dazugehörigen abgeleiteten Klassen können also eine [Abhängigkeitseigenschaft](GTMT)\-Implementierung "erben", ohne dass sich die ursprüngliche Besitzerklasse und die hinzufügende Klasse in derselben "wahren" Klassenhierarchie befinden.  Außerdem kann die hinzufügende Klasse \(sowie auch alle abgeleiteten Klassen\) für die ursprüngliche Abhängigkeitseigenschaft dann typspezifische Metadaten bereitstellen.  
  
 Zusätzlich dazu, dass sich die Klasse über die entsprechenden Methoden des Eigenschaftensystems selbst als Besitzer hinzufügt, sollte die hinzufügende Klasse für sich selbst weitere öffentliche Member deklarieren, um die [Abhängigkeitseigenschaft](GTMT) zu einem vollständigen Teilnehmer am Eigenschaftensystem zu machen, der sowohl per Code als auch per Markup zugänglich ist.  Eine Klasse, die eine vorhandene Abhängigkeitseigenschaft hinzufügt, verfügt in Bezug auf das Offenlegen des Objektmodells für die jeweilige Abhängigkeitseigenschaft über dieselben Zuständigkeiten wie eine Klasse, die eine neue benutzerdefinierte Abhängigkeitseigenschaft definiert.  Der erste Member, der offengelegt wird, ist ein Abhängigkeitseigenschaft\-Bezeichnerfeld.  Dieses Feld sollte ein `public static readonly`\-Feld vom Typ <xref:System.Windows.DependencyProperty> sein, das dem Rückgabewert des <xref:System.Windows.DependencyProperty.AddOwner%2A>\-Aufrufs zugewiesen ist.  Der zweite zu definierende Member ist die [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]\-Wrappereigenschaft.  Der Wrapper erleichtert es Ihnen erheblich, Ihre Abhängigkeitseigenschaft per Code zu bearbeiten \(Sie vermeiden jeweils Aufrufe von <xref:System.Windows.DependencyObject.SetValue%2A>, denn Sie müssen diesen Aufruf nur einmal im Wrapper selbst durchführen\).  Der Wrapper wird genauso implementiert, wie dies auch beim Registrieren einer benutzerdefinierten [Abhängigkeitseigenschaft](GTMT) der Fall wäre.  Weitere Informationen zur Implementierung einer [Abhängigkeitseigenschaft](GTMT) finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) und [Hinzufügen eines Besitzertyps für eine Abhängigkeitseigenschaft](../../../../docs/framework/wpf/advanced/how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### AddOwner und angefügte Eigenschaften  
 Sie können <xref:System.Windows.DependencyProperty.AddOwner%2A> für eine Abhängigkeitseigenschaft aufrufen, die von der Besitzerklasse als angefügte Eigenschaft definiert ist.  Der Grund hierfür ist normalerweise, dass die vorherige angefügte Eigenschaft als nicht angefügte Abhängigkeitseigenschaft offengelegt werden soll.  Anschließend legen Sie den <xref:System.Windows.DependencyProperty.AddOwner%2A>\-Rückgabewert als `public static readonly`\-Feld für die Verwendung als Abhängigkeitseigenschaftbezeichner offen und definieren geeignete Wrappereigenschaften, so dass die Eigenschaft in der Membertabelle erscheint und die Verwendung nicht angefügter Eigenschaften in Ihrer Klasse unterstützt.  
  
## Siehe auch  
 <xref:System.Windows.PropertyMetadata>   
 <xref:System.Windows.DependencyObject>   
 <xref:System.Windows.DependencyProperty>   
 <xref:System.Windows.DependencyProperty.GetMetadata%2A>   
 [Übersicht über Abhängigkeitseigenschaften](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   
 [Framework\-Eigenschaftenmetadaten](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)