---
title: ICorProfilerInfo2::DoStackSnapshot-Methode
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 338120932b0bcbe390332515856aaeaa3bc34a56
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/04/2018
ms.locfileid: "33461697"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="aa325-102">ICorProfilerInfo2::DoStackSnapshot-Methode</span><span class="sxs-lookup"><span data-stu-id="aa325-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="aa325-103">Durchläuft die verwalteten Frames auf dem Stapel für den angegebenen Thread und sendet die Informationen an den Profiler in einem Rückruf.</span><span class="sxs-lookup"><span data-stu-id="aa325-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="aa325-104">Syntax</span><span class="sxs-lookup"><span data-stu-id="aa325-104">Syntax</span></span>  
  
```  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
#### <a name="parameters"></a><span data-ttu-id="aa325-105">Parameter</span><span class="sxs-lookup"><span data-stu-id="aa325-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="aa325-106">[in] Die ID des Zielthreads.</span><span class="sxs-lookup"><span data-stu-id="aa325-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="aa325-107">Übergeben von null in `thread` ergibt sich eine Momentaufnahme des aktuellen Threads.</span><span class="sxs-lookup"><span data-stu-id="aa325-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="aa325-108">Wenn eine `ThreadID` von ein anderen Thread übergeben wird, hält dieser Thread, führt die Momentaufnahme und setzt die common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="aa325-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="aa325-109">[in] Ein Zeiger auf die Implementierung der [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) Methode, die von der CLR, um den Profiler Informationen über jeden verwalteten Frame und die Ausführung von nicht verwalteten Frames bereitzustellen aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="aa325-109">[in] A pointer to the implementation of the [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="aa325-110">Die `StackSnapshotCallback` Methode wird vom Profilerwriter implementiert.</span><span class="sxs-lookup"><span data-stu-id="aa325-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="aa325-111">[in] Der Wert der [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) -Enumeration, die gibt die Menge der Daten für jeden Frame von zu übergebenden `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="aa325-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="aa325-112">[in] Ein Zeiger auf die Clientdaten, die direkt über, um übergeben wird die `StackSnapshotCallback` Rückruffunktion.</span><span class="sxs-lookup"><span data-stu-id="aa325-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="aa325-113">[in] Ein Zeiger auf eine Win32- `CONTEXT` -Struktur, die verwendet wird, um den Stackwalk zu starten.</span><span class="sxs-lookup"><span data-stu-id="aa325-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="aa325-114">Die Win32 `CONTEXT` Struktur enthält die Werte der CPU-Register und den Zustand der CPU zu einem bestimmten Zeitpunkt darstellt.</span><span class="sxs-lookup"><span data-stu-id="aa325-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="aa325-115">Bestimmen des Installationsorts für den Stackwalk zu beginnen, wenn der Anfang des Stapels nicht verwalteten Hilfscode ist CLR Startwerts; Andernfalls ist der Ausgangswert ignoriert.</span><span class="sxs-lookup"><span data-stu-id="aa325-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="aa325-116">Für einen asynchronen Durchlauf muss kein Ausgangswert angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="aa325-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="aa325-117">Wenn Sie einen synchronen Durchlauf durchführen, ist kein Ausgangswert erforderlich.</span><span class="sxs-lookup"><span data-stu-id="aa325-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="aa325-118">Die `context` Parameter ist nur gültig, wenn das COR_PRF_SNAPSHOT_CONTEXT-Flag, in übergeben wurde der `infoFlags` Parameter.</span><span class="sxs-lookup"><span data-stu-id="aa325-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="aa325-119">[in] Die Größe des der `CONTEXT` -Struktur, die verweist die `context` Parameter.</span><span class="sxs-lookup"><span data-stu-id="aa325-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="aa325-120">Hinweise</span><span class="sxs-lookup"><span data-stu-id="aa325-120">Remarks</span></span>  
 <span data-ttu-id="aa325-121">Übergeben von null `thread` ergibt sich eine Momentaufnahme des aktuellen Threads.</span><span class="sxs-lookup"><span data-stu-id="aa325-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="aa325-122">Momentaufnahmen können von anderen Threads erstellt werden, nur, wenn der Zielthread zu dem Zeitpunkt unterbrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="aa325-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="aa325-123">Wenn der Profiler den Stapel zu durchlaufen möchte, ruft er `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="aa325-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="aa325-124">Bevor die CLR über diesen Aufruf zurückgegeben wird, ruft der `StackSnapshotCallback` mehrere Male einmal für jeden verwalteten Frame (oder die Ausführung von nicht verwalteten Frames) auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="aa325-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="aa325-125">Wenn bei der nicht verwalteten Frames auftreten, müssen Sie sie selbst durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="aa325-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="aa325-126">Die Reihenfolge, in dem der Stapel durchlaufen wird, ist in umgekehrter Reihenfolge wie die Frames auf dem Stapel abgelegt wurden: Frame (zuletzt verschoben) zuerst, Hauptframe (zuerst verschoben) von anderen zuletzt Blattelemente.</span><span class="sxs-lookup"><span data-stu-id="aa325-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="aa325-127">Weitere Informationen dazu, wie Sie den Profiler zum Durchlaufen verwalteter Stapel programmieren, finden Sie unter [Stackwalk in .NET Framework 2.0 Profiler: Grundlagen und mehr](http://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="aa325-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](http://go.microsoft.com/fwlink/?LinkId=73638).</span></span>  
  
 <span data-ttu-id="aa325-128">Ein Stackwalk kann synchron oder asynchron sein, wie in den folgenden Abschnitten erläutert.</span><span class="sxs-lookup"><span data-stu-id="aa325-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="aa325-129">Synchroner Stackwalk</span><span class="sxs-lookup"><span data-stu-id="aa325-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="aa325-130">Ein synchroner Stackwalk umfasst das Durchlaufen des Stapels für den aktuellen Thread als Antwort auf einen Rückruf.</span><span class="sxs-lookup"><span data-stu-id="aa325-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="aa325-131">Das seeding oder anhalten, ist nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="aa325-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="aa325-132">Stellen Sie einen synchronen Aufruf durch, wenn als Antwort auf die CLR einen Aufruf der des Profilers [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (oder [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) Methoden, rufen Sie `DoStackSnapshot` Durchlaufen des Stapels für die aktuellen Thread.</span><span class="sxs-lookup"><span data-stu-id="aa325-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (or [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="aa325-133">Dies ist nützlich, wenn Sie der Stapel bei einer Benachrichtigung wie z. B. illustriert anzeigen möchten [ICorProfilerCallback:: ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="aa325-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="aa325-134">Rufen Sie einfach `DoStackSnapshot` innerhalb Ihrer `ICorProfilerCallback` Methode, und übergeben null in der `context` und `thread` Parameter.</span><span class="sxs-lookup"><span data-stu-id="aa325-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="aa325-135">Asynchrone Stackwalk</span><span class="sxs-lookup"><span data-stu-id="aa325-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="aa325-136">Ein asynchroner Stackwalk umfasst das Durchlaufen des Stapels von einem anderen Thread oder das Durchlaufen des aktuellen Threads nicht als Reaktion auf einen Rückruf, sondern durch den aktuellen Thread Anweisungszeiger hijacking.</span><span class="sxs-lookup"><span data-stu-id="aa325-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="aa325-137">Ein asynchrone Walk erfordert einen Ausgangswert ist der Anfang des Stapels nicht verwaltetem Code, der nicht Teil einer Plattform ist aufrufen (PInvoke) oder COM-Aufruf jedoch Hilfscode in die CLR selbst.</span><span class="sxs-lookup"><span data-stu-id="aa325-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="aa325-138">Beispielsweise ist Code, Just-in-Time (JIT) kompilieren oder Garbage Collection ausführt, Hilfscode.</span><span class="sxs-lookup"><span data-stu-id="aa325-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="aa325-139">Sie erhalten einen Ausgangswert an, indem Sie direkt durch das Anhalten des Zielthreads, und durchlaufen einen Stapel selbst, bis Sie den obersten gefunden Frame verwaltet.</span><span class="sxs-lookup"><span data-stu-id="aa325-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="aa325-140">Nachdem der Zielthread angehalten wird, erhalten Sie aktuelle Registerkontext der Zielthread.</span><span class="sxs-lookup"><span data-stu-id="aa325-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="aa325-141">Als Nächstes zu bestimmen, ob der Registerkontext durch Aufrufen von nicht verwaltetem Code zeigt [ICorProfilerInfo:: GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) – Wenn zurückgegeben wird ein `FunctionID` gleich 0 (null), wird der Frame nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="aa325-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="aa325-142">Durchlaufen Sie jetzt den Stapel, bis Sie den ersten verwalteten Frame zu erreichen, und berechnen Sie den Ausgangswert Kontext auf Grundlage des Registerkontexts für diesen Rahmen.</span><span class="sxs-lookup"><span data-stu-id="aa325-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="aa325-143">Rufen Sie `DoStackSnapshot` mit den Ausgangswert Kontext auf den asynchronen Stackwalk zu beginnen.</span><span class="sxs-lookup"><span data-stu-id="aa325-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="aa325-144">Wenn Sie keinen Ausgangswert angeben `DoStackSnapshot` verwalteten Frames am oberen Ende des Stapels überspringen und folglich erhalten Sie einen unvollständige Stackwalk.</span><span class="sxs-lookup"><span data-stu-id="aa325-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="aa325-145">Wenn Sie einen Ausgangswert angeben, muss er auf JIT-kompilierten oder Native Image Generator (Ngen.exe) zeigen-generierter Code; andernfalls `DoStackSnapshot` gibt den Fehlercode CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX zurück.</span><span class="sxs-lookup"><span data-stu-id="aa325-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="aa325-146">Asynchrone Stackwalks können Sie bequem Deadlocks verursachen oder zugriffsverletzungen, es sei denn, Sie die folgenden Richtlinien beachten:</span><span class="sxs-lookup"><span data-stu-id="aa325-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
-   <span data-ttu-id="aa325-147">Wenn Sie direkt über Threads anhalten, denken Sie daran, dass nur ein Thread, der nicht verwalteten Code ausgeführt hat ein anderer Thread angehalten werden kann.</span><span class="sxs-lookup"><span data-stu-id="aa325-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
-   <span data-ttu-id="aa325-148">Immer-block in Ihre [ICorProfilerCallback:: ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) Rückruf bis Stackwalk des betreffenden Threads abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="aa325-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
-   <span data-ttu-id="aa325-149">Aufrechterhalten Sie eine Sperre kann nicht werden, während der Profiler in eine CLR-Funktion aufruft, die eine Garbagecollection auslösen können.</span><span class="sxs-lookup"><span data-stu-id="aa325-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="aa325-150">Halten Sie also keine Sperre der Besitzerthread ein Aufrufs vorgenommen werden kann, das eine Garbagecollection auslöst.</span><span class="sxs-lookup"><span data-stu-id="aa325-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="aa325-151">Zudem besteht ein Risiko von Deadlocks beim Aufrufen `DoStackSnapshot` von einem anderen Thread, die der Profiler erstellt hat, damit Sie den Stapel eines separaten Zielthreads durchlaufen können.</span><span class="sxs-lookup"><span data-stu-id="aa325-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="aa325-152">Beim ersten erstellten Thread wechselt bestimmte `ICorProfilerInfo*` Methoden (einschließlich `DoStackSnapshot`), die CLR wird pro Thread, CLR-spezifische Initialisierung auf diesem Thread ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="aa325-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="aa325-153">Wenn der Profiler den Zielthread angehalten wurde, dessen Stapel zu durchlaufen werden soll, und Zielthread aufgetreten ist, eine Sperre für die Durchführung dieser threadspezifischen Initialisierung erforderlich verfügen, wird ein Deadlock auftreten.</span><span class="sxs-lookup"><span data-stu-id="aa325-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="aa325-154">Um diese Deadlocks zu vermeiden, stellen Sie in einen ersten Aufruf `DoStackSnapshot` aus dem Thread erstellt mit dem Profiler zum Durchlaufen ein separaten Zielthread, aber den Zielthread nicht zunächst anhalten.</span><span class="sxs-lookup"><span data-stu-id="aa325-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="aa325-155">Diese ersten Aufruf wird sichergestellt, dass die threadspezifische Initialisierung ohne Deadlock abgeschlossen werden kann.</span><span class="sxs-lookup"><span data-stu-id="aa325-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="aa325-156">Wenn `DoStackSnapshot` erfolgreich ist, und gibt mindestens einen Frame nach diesem Punkt werden sie alle Zielthread und Aufruf anzuhalten, Profiler erstellte Thread sicher `DoStackSnapshot` , den Stapel der Zielthread zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="aa325-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="aa325-157">Anforderungen</span><span class="sxs-lookup"><span data-stu-id="aa325-157">Requirements</span></span>  
 <span data-ttu-id="aa325-158">**Plattformen:** finden Sie unter [Systemanforderungen](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="aa325-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="aa325-159">**Header:** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="aa325-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="aa325-160">**Bibliothek:** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="aa325-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="aa325-161">**.NET Framework-Versionen:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="aa325-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aa325-162">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="aa325-162">See Also</span></span>  
 [<span data-ttu-id="aa325-163">ICorProfilerInfo-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="aa325-163">ICorProfilerInfo Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)  
 [<span data-ttu-id="aa325-164">ICorProfilerInfo2-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="aa325-164">ICorProfilerInfo2 Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
