---
title: Threadsynchronisierung (Visual Basic) | Microsoft-Dokumentation
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
caps.latest.revision: 3
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 240937905254120f777ce140049084279c35005c
ms.contentlocale: de-de
ms.lasthandoff: 04/12/2017

---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="60f79-102">Threadsynchronisierung (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="60f79-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="60f79-103">In den folgenden Abschnitten wird beschrieben, Funktionen und Klassen, die zum Synchronisieren des Zugriffs auf Ressourcen in Multithreadanwendungen verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="60f79-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="60f79-104">Einer der Vorteile der Verwendung von mehreren Threads in einer Anwendung ist, dass jeder Thread asynchron ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="60f79-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="60f79-105">Für Windows-Clientanwendungen können zeitintensive Aufgaben im Hintergrund während des Anwendungsfensters ausgeführt werden, und Steuerelemente reaktionsfähig bleiben.</span><span class="sxs-lookup"><span data-stu-id="60f79-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="60f79-106">Für Server-Applications multithreading bietet die Möglichkeit, jede eingehende Anforderung mit einem anderen Thread zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="60f79-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="60f79-107">Andernfalls würde jede neue Anforderung erst verarbeitet, erhalten die vorherige Anforderung vollständig erfüllt wurde.</span><span class="sxs-lookup"><span data-stu-id="60f79-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="60f79-108">Allerdings muss der asynchrone Natur des Threads bedeutet, die Zugriff auf Ressourcen wie Dateihandles, Netzwerkschnittstellen und Speicher koordiniert werden.</span><span class="sxs-lookup"><span data-stu-id="60f79-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="60f79-109">Andernfalls konnte in zwei oder mehr Threads dieselbe Ressource zur gleichen Zeit, jede keine Kenntnis von den anderen Aktionen zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="60f79-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="60f79-110">Das Ergebnis ist unvorhersehbar Daten beschädigt.</span><span class="sxs-lookup"><span data-stu-id="60f79-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="60f79-111">Für einfache Operationen für ganzzahlige numerische Datentypen Synchronisieren von Threads mit Mitgliedern der <xref:System.Threading.Interlocked>Klasse</xref:System.Threading.Interlocked> möglich</span><span class="sxs-lookup"><span data-stu-id="60f79-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="60f79-112">Für alle anderen Daten können Typen und nicht threadsicheren Ressourcen kann multithreading nur sicher ausgeführt werden mit den Konstrukten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="60f79-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="60f79-113">Hintergrundinformationen zur Multithreadprogrammierung finden Sie unter:</span><span class="sxs-lookup"><span data-stu-id="60f79-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="60f79-114">Grundlagen des verwalteten Threadings</span><span class="sxs-lookup"><span data-stu-id="60f79-114">Managed Threading Basics</span></span>](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)  
  
-   [<span data-ttu-id="60f79-115">Verwenden von Threads und Threading</span><span class="sxs-lookup"><span data-stu-id="60f79-115">Using Threads and Threading</span></span>](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)  
  
-   [<span data-ttu-id="60f79-116">Verwaltetes Threading Best Practices</span><span class="sxs-lookup"><span data-stu-id="60f79-116">Managed Threading Best Practices</span></span>](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="60f79-117">Die lock- und SyncLock-Schlüsselwörter</span><span class="sxs-lookup"><span data-stu-id="60f79-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="60f79-118">Visual Basic `SyncLock` Anweisung um sicherzustellen, dass ein Codeblock ohne Unterbrechung vollständig ausgeführt wird von anderen Threads verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="60f79-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="60f79-119">Dies geschieht durch Abrufen einer Sperre gegenseitigen Ausschluss für ein bestimmtes Objekt für die Dauer des Codeblocks.</span><span class="sxs-lookup"><span data-stu-id="60f79-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="60f79-120">Ein `SyncLock` -Anweisung wird ein Objekt als Argument zugewiesen, und ist ein Codeblock, der nur von einem Thread zu einem Zeitpunkt ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="60f79-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="60f79-121">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="60f79-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="60f79-122">Das Argument bereitgestellt, um die `SyncLock` Schlüsselwort muss ein Objekt basierend auf ein Verweistyp sein und wird verwendet, um den Umfang der Sperre zu definieren.</span><span class="sxs-lookup"><span data-stu-id="60f79-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="60f79-123">Im obigen Beispiel der sperrenbereich ist für diese Funktion beschränkt, da keine Verweise auf das Objekt `lockThis` außerhalb der Funktion vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="60f79-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="60f79-124">Wenn Sie ein solchen Verweis vorhanden war, würde Sperre auf dieses Objekt erweitern.</span><span class="sxs-lookup"><span data-stu-id="60f79-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="60f79-125">Genau genommen wird das bereitgestellte Objekt verwendet, ausschließlich für die Identifizierung der Ressourcen von mehreren Threads freigegeben wird, sodass sie bezeichnen werden kann.</span><span class="sxs-lookup"><span data-stu-id="60f79-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="60f79-126">In der Praxis jedoch dieses Objekt dargestellt in der Regel die Ressource, für die die Threadaktivität Synchronisierung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="60f79-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="60f79-127">Beispielsweise ist ein Container-Objekt von mehreren Threads verwendet werden, dann kann der Container übergeben werden, um Sperren und der synchronisierte Codeblock hinter der Sperre werden auf den Container zugreifen.</span><span class="sxs-lookup"><span data-stu-id="60f79-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="60f79-128">Solange andere Threads Sperren für die gleiche enthalten, bevor Sie darauf zugreifen und dann Zugriff auf das Objekt sicher synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="60f79-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="60f79-129">Im Allgemeinen ist es am besten vermeiden Sie das Sperren auf einer `public` Typ oder Objektinstanzen außerhalb der Kontrolle Ihrer Anwendung.</span><span class="sxs-lookup"><span data-stu-id="60f79-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="60f79-130">Z. B. `lockThis` kann da Sperrung Code außerhalb Ihrer Kontrolle auf das Objekt ebenfalls problematisch, wenn die Instanz öffentlich zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="60f79-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="60f79-131">Dies könnte Deadlocks verursachen, in denen zwei oder mehr Threads für die Version des gleichen Objekts warten.</span><span class="sxs-lookup"><span data-stu-id="60f79-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="60f79-132">Sperren von öffentlichen Datentypen, im Gegensatz zu einem Objekt können Sie aus demselben Grund Probleme verursachen.</span><span class="sxs-lookup"><span data-stu-id="60f79-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="60f79-133">Sperren von Zeichenfolgenliteralen ist besonders riskant, da Literalzeichenfolgen sind *Internpool* von der common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="60f79-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="60f79-134">Dies bedeutet, dass eine Instanz von jedem Zeichenfolgenliteral für das gesamte Programm vorhanden ist, genaue das gleiche Objekt dar, das Literal in allen Anwendungsdomänen, die auf allen Threads ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="60f79-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="60f79-135">Daher führt eine Sperre für eine Zeichenfolge mit dem gleichen Inhalt an einer beliebigen Stelle in den Prozess Anwendungssperren alle Instanzen der Zeichenfolge in der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="60f79-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="60f79-136">Daher empfiehlt es sich um eine private oder geschützte Member zu sperren, der nicht intern gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="60f79-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="60f79-137">Einige Klassen bieten Member speziell für Sperren.</span><span class="sxs-lookup"><span data-stu-id="60f79-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="60f79-138">Der <xref:System.Array>Typ, z. B. bietet <xref:System.Array.SyncRoot%2A>.</xref:System.Array.SyncRoot%2A> </xref:System.Array></span><span class="sxs-lookup"><span data-stu-id="60f79-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="60f79-139">Viele Auflistungstypen bieten eine `SyncRoot` auch Member.</span><span class="sxs-lookup"><span data-stu-id="60f79-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="60f79-140">Weitere Informationen zu den `SyncLock` -Anweisung finden Sie unter den folgenden Themen:</span><span class="sxs-lookup"><span data-stu-id="60f79-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="60f79-141">SyncLock-Anweisung</span><span class="sxs-lookup"><span data-stu-id="60f79-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   @System.Threading.Monitor  
  
## <a name="monitors"></a><span data-ttu-id="60f79-142">Monitore</span><span class="sxs-lookup"><span data-stu-id="60f79-142">Monitors</span></span>  
 <span data-ttu-id="60f79-143">Wie die `SyncLock` Schlüsselwort Monitore verhindern von Codeblöcken gleichzeitige Ausführung von mehreren Threads.</span><span class="sxs-lookup"><span data-stu-id="60f79-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="60f79-144">Die <xref:System.Threading.Monitor.Enter%2A>Methode kann nur ein Thread in die folgenden Anweisungen fortgesetzt; alle anderen Threads werden blockiert, bis der Ausführende Thread <xref:System.Threading.Monitor.Exit%2A>.</xref:System.Threading.Monitor.Exit%2A> ruft</xref:System.Threading.Monitor.Enter%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="60f79-145">Dies ist vergleichbar mit dem `SyncLock` Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="60f79-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="60f79-146">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="60f79-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="60f79-147">Dies ist äquivalent zu:</span><span class="sxs-lookup"><span data-stu-id="60f79-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="60f79-148">Mithilfe der `SyncLock` Schlüsselwort ist im allgemeinen Verwendung der <xref:System.Threading.Monitor>direkte, sowohl da `SyncLock` ist präziser, und da `SyncLock` wird sichergestellt, dass der zugrunde liegenden Monitor freigegeben wird, selbst wenn der geschützte Code eine Ausnahme auslöst.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="60f79-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="60f79-149">Dies erfolgt mit der `Finally` -Schlüsselwort, die ausgeführt werden, den zugehörigen Codeblock unabhängig davon, ob eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="60f79-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="60f79-150">Synchronisierungsereignisse und Wait-Handles</span><span class="sxs-lookup"><span data-stu-id="60f79-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="60f79-151">Mithilfe einer Sperre oder einem Monitor wird verhindert, dass die gleichzeitige Ausführung von Codeblöcken Thread unterschieden, aber diese Konstrukte lassen sich nicht auf einen Thread ein Ereignis in einen anderen zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="60f79-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="60f79-152">Dies erfordert *Synchronisierungsereignisse*, sind Objekte, die einen der beiden Zustände haben signalisiert "und" nicht signalisiert ", können, zu aktivieren und Anhalten von Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="60f79-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="60f79-153">Threads können vom wird versucht, auf die Synchronisation warten, die zwischen unterbrochen, und durch Ändern des Ereignisstatus signalisiert aktiviert werden können.</span><span class="sxs-lookup"><span data-stu-id="60f79-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="60f79-154">Wenn ein Thread versucht, auf ein Ereignis zu warten, das bereits signalisiert wird, wird der Thread ohne Verzögerung fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="60f79-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="60f79-155">Es gibt zwei Arten von Synchronisierungsereignisse: <xref:System.Threading.AutoResetEvent>, und <xref:System.Threading.ManualResetEvent>.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="60f79-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="60f79-156">Unterscheiden sich nur in <xref:System.Threading.AutoResetEvent>ändert sich von signalisiert zu nicht signalisierten automatisch es jeweils einen Thread aktiviert.</xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="60f79-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="60f79-157">Dagegen eine <xref:System.Threading.ManualResetEvent>kann eine beliebige Anzahl von Threads über den signalisierten Zustand zu aktivieren und wird nur in den signalisierten Zustand über, wenn die <xref:System.Threading.EventWaitHandle.Reset%2A>wird aufgerufen.</xref:System.Threading.EventWaitHandle.Reset%2A> </xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="60f79-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="60f79-158">Threads können erfolgen, und Warten auf Ereignisse durch Aufrufen einer der Wait-Methoden, wie z. B. <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, oder <xref:System.Threading.WaitHandle.WaitAll%2A>.</xref:System.Threading.WaitHandle.WaitAll%2A> </xref:System.Threading.WaitHandle.WaitAny%2A> </xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="60f79-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>bewirkt, dass der Thread wartet, bis ein einzelnes Ereignis signalisiert wird, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName>blockiert einen Thread, bis ein oder mehrere angegebene Ereignisse signalisiert werden, und <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName>den Thread blockiert, bis alle angegebenen Ereignisse signalisiert werden.</xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName></xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="60f79-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="60f79-160">Ein Ereignis wird signalisiert, wenn seine <xref:System.Threading.EventWaitHandle.Set%2A>wird aufgerufen.</xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="60f79-161">Im folgenden Beispiel ein Thread erstellt und gestartet, indem die `Main` Funktion.</span><span class="sxs-lookup"><span data-stu-id="60f79-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="60f79-162">Der neue Thread wartet auf ein Ereignis mit der <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode.</xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="60f79-163">Der Thread wird angehalten, bis das Ereignis durch den primären Thread signalisiert wird, die ausgeführt wird, die `Main` Funktion.</span><span class="sxs-lookup"><span data-stu-id="60f79-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="60f79-164">Sobald das Ereignis signalisiert wird, gibt die zusätzlichen Threads zurück.</span><span class="sxs-lookup"><span data-stu-id="60f79-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="60f79-165">In diesem Fall, da das Ereignis nur entweder für einen Thread-Aktivierung verwendet wird die <xref:System.Threading.AutoResetEvent>oder <xref:System.Threading.ManualResetEvent>Klassen verwendet werden.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="60f79-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="60f79-166">Mutex-Objekt</span><span class="sxs-lookup"><span data-stu-id="60f79-166">Mutex Object</span></span>  
 <span data-ttu-id="60f79-167">Ein *Mutex* ähnelt einem Monitor; es wird verhindert, dass die gleichzeitige Ausführung eines Codeblocks durch mehrere Threads gleichzeitig.</span><span class="sxs-lookup"><span data-stu-id="60f79-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="60f79-168">Tatsächlich ist der Name "Mutex" eine Kurzform des Begriffs "sich gegenseitig ausschließende."</span><span class="sxs-lookup"><span data-stu-id="60f79-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="60f79-169">Im Gegensatz zu Monitoren kann jedoch ein Mutex verwendet werden, prozessübergreifend Threads zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="60f79-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="60f79-170">Ein Mutex wird durch die <xref:System.Threading.Mutex>Klasse</xref:System.Threading.Mutex> dargestellt.</span><span class="sxs-lookup"><span data-stu-id="60f79-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="60f79-171">Ein Mutex wird aufgerufen, wenn für die prozessübergreifende Synchronisierung verwendet wird, eine *benannten Mutex* daran, dass es in einer anderen Anwendung verwendet wird und daher nicht mithilfe einer globalen oder statischen Variablen gemeinsam genutzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="60f79-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="60f79-172">Es muss ein Name zugewiesen werden, so, dass beide Anwendungen dieselbe Mutex-Objekt zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="60f79-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="60f79-173">Obwohl ein Mutex für die prozessinterne Threadsynchronisierung verwendet werden kann, <xref:System.Threading.Monitor>wird im Allgemeinen empfohlen, da Monitore speziell für .NET Framework entwickelt wurden und daher eine bessere Nutzung der Ressourcen.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="60f79-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="60f79-174">Im Gegensatz dazu die <xref:System.Threading.Mutex>ist ein Wrapper für ein Win32-Konstrukt.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="60f79-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="60f79-175">Zwar leistungsstärker als ein Monitor, benötigt ein Mutex Interop-Übergänge, die rechenintensiver sind als die von der <xref:System.Threading.Monitor>Klasse.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="60f79-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="60f79-176">Ein Beispiel für die Verwendung eines Mutex, finden Sie unter [Mutexe](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span><span class="sxs-lookup"><span data-stu-id="60f79-176">For an example of using a mutex, see [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="60f79-177">Interlocked-Klasse</span><span class="sxs-lookup"><span data-stu-id="60f79-177">Interlocked Class</span></span>  
 <span data-ttu-id="60f79-178">Sie können die Methoden der die <xref:System.Threading.Interlocked>Klasse, um Probleme zu vermeiden, die auftreten können, wenn mehrere Threads gleichzeitig versuchen, aktualisieren oder den gleichen Wert vergleichen.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="60f79-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="60f79-179">Die Methoden dieser Klasse können Sie problemlos erhöhen, verringern, austauschen und Vergleichen von Werten aus einem beliebigen Thread.</span><span class="sxs-lookup"><span data-stu-id="60f79-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="60f79-180">ReaderWriter-Sperren</span><span class="sxs-lookup"><span data-stu-id="60f79-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="60f79-181">In einigen Fällen empfiehlt es sich um eine Ressource zu sperren, nur, wenn Daten geschrieben werden und mehrere Clients gleichzeitig Daten lesen, wenn Daten nicht aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="60f79-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="60f79-182">Die <xref:System.Threading.ReaderWriterLock>-Klasse gewährleistet exklusiven Zugriff auf eine Ressource, während ein Thread die Ressource ändert, erlaubt jedoch einen nicht exklusiven Zugriff beim Lesen der Ressource.</xref:System.Threading.ReaderWriterLock></span><span class="sxs-lookup"><span data-stu-id="60f79-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="60f79-183">ReaderWriter-Sperren sind eine nützliche Alternative zu exklusiven Sperren, die andere Threads wartet, selbst wenn diese Threads keine Daten aktualisieren müssen.</span><span class="sxs-lookup"><span data-stu-id="60f79-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="60f79-184">Deadlocks</span><span class="sxs-lookup"><span data-stu-id="60f79-184">Deadlocks</span></span>  
 <span data-ttu-id="60f79-185">Threadsynchronisierung in Multithreadanwendungen sehr nützlich ist, aber es besteht immer die Gefahr einer `deadlock`, bei dem mehrere Threads aufeinander warten und die Anwendung zu unterbrechen.</span><span class="sxs-lookup"><span data-stu-id="60f79-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="60f79-186">Ein Deadlock ist analog zu einer Situation, in der Autos an eine vier-Wege-Stop beendet werden, und jede Person wartet auf den anderen wechseln.</span><span class="sxs-lookup"><span data-stu-id="60f79-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="60f79-187">Vermeiden von Deadlocks ist wichtig. der Schlüssel ist eine sorgfältige Planung.</span><span class="sxs-lookup"><span data-stu-id="60f79-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="60f79-188">Sie können häufig Deadlocks Vorhersagen von Multithreadanwendungen abbilden, bevor Sie mit dem Programmieren beginnen.</span><span class="sxs-lookup"><span data-stu-id="60f79-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="60f79-189">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="60f79-189">See Also</span></span>  
 <span data-ttu-id="60f79-190"><xref:System.Threading.Thread></xref:System.Threading.Thread></span><span class="sxs-lookup"><span data-stu-id="60f79-190"><xref:System.Threading.Thread></span></span>   
 <span data-ttu-id="60f79-191"><xref:System.Threading.WaitHandle.WaitOne%2A></xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-191"><xref:System.Threading.WaitHandle.WaitOne%2A></span></span>   
 <span data-ttu-id="60f79-192"><xref:System.Threading.WaitHandle.WaitAny%2A></xref:System.Threading.WaitHandle.WaitAny%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-192"><xref:System.Threading.WaitHandle.WaitAny%2A></span></span>   
 <span data-ttu-id="60f79-193"><xref:System.Threading.WaitHandle.WaitAll%2A></xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-193"><xref:System.Threading.WaitHandle.WaitAll%2A></span></span>   
 <span data-ttu-id="60f79-194"><xref:System.Threading.Thread.Join%2A></xref:System.Threading.Thread.Join%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-194"><xref:System.Threading.Thread.Join%2A></span></span>   
 <span data-ttu-id="60f79-195"><xref:System.Threading.Thread.Start%2A></xref:System.Threading.Thread.Start%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-195"><xref:System.Threading.Thread.Start%2A></span></span>   
 <span data-ttu-id="60f79-196"><xref:System.Threading.Thread.Sleep%2A></xref:System.Threading.Thread.Sleep%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-196"><xref:System.Threading.Thread.Sleep%2A></span></span>   
 <span data-ttu-id="60f79-197"><xref:System.Threading.Monitor></xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="60f79-197"><xref:System.Threading.Monitor></span></span>   
 <span data-ttu-id="60f79-198"><xref:System.Threading.Mutex></xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="60f79-198"><xref:System.Threading.Mutex></span></span>   
 <span data-ttu-id="60f79-199"><xref:System.Threading.AutoResetEvent></xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="60f79-199"><xref:System.Threading.AutoResetEvent></span></span>   
 <span data-ttu-id="60f79-200"><xref:System.Threading.ManualResetEvent></xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="60f79-200"><xref:System.Threading.ManualResetEvent></span></span>   
 <span data-ttu-id="60f79-201"><xref:System.Threading.Interlocked></xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="60f79-201"><xref:System.Threading.Interlocked></span></span>   
 <span data-ttu-id="60f79-202"><xref:System.Threading.WaitHandle></xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="60f79-202"><xref:System.Threading.WaitHandle></span></span>   
 <span data-ttu-id="60f79-203"><xref:System.Threading.EventWaitHandle></xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="60f79-203"><xref:System.Threading.EventWaitHandle></span></span>   
 <span data-ttu-id="60f79-204"><xref:System.Threading></xref:System.Threading></span><span class="sxs-lookup"><span data-stu-id="60f79-204"><xref:System.Threading></span></span>   
 <span data-ttu-id="60f79-205"><xref:System.Threading.EventWaitHandle.Set%2A></xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="60f79-205"><xref:System.Threading.EventWaitHandle.Set%2A></span></span>   
<span data-ttu-id="60f79-206"> [Multithreadanwendungen (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span><span class="sxs-lookup"><span data-stu-id="60f79-206"> [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span></span>  
<span data-ttu-id="60f79-207"> [SyncLock-Anweisung](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span><span class="sxs-lookup"><span data-stu-id="60f79-207"> [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span></span>  
<span data-ttu-id="60f79-208"> [Mutexe](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span><span class="sxs-lookup"><span data-stu-id="60f79-208"> [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span></span>  
 @System.Threading.Monitor   
<span data-ttu-id="60f79-209"> [Interlocked-Vorgänge](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span><span class="sxs-lookup"><span data-stu-id="60f79-209"> [Interlocked Operations](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span></span>  
<span data-ttu-id="60f79-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span><span class="sxs-lookup"><span data-stu-id="60f79-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span></span>  
<span data-ttu-id="60f79-211"> [Synchronisieren von Daten für Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span><span class="sxs-lookup"><span data-stu-id="60f79-211"> [Synchronizing Data for Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span></span>
