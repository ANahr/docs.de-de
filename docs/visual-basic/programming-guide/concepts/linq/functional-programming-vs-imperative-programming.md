---
title: Funktionale Programmierung und Imperative Programmierung (Visual Basic) | Microsoft-Dokumentation
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 6a1f3b57-00e6-447d-9906-74c7c4d5d85c
caps.latest.revision: 3
author: dotnet-bot
ms.author: dotnetcontent
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: d1791e1409ce1e55d6c58b5d326fa38f79eeaa9c
ms.contentlocale: de-de
ms.lasthandoff: 04/12/2017


---
# <a name="functional-programming-vs-imperative-programming-visual-basic"></a><span data-ttu-id="397a2-102">Funktionale Programmierung und Imperative Programmierung (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="397a2-102">Functional Programming vs. Imperative Programming (Visual Basic)</span></span>
<span data-ttu-id="397a2-103">In diesem Thema werden die Gemeinsamkeiten und die Unterschiede der funktionalen Programmierung und der herkömmlichen imperativen (prozeduralen) Programmierung erläutert.</span><span class="sxs-lookup"><span data-stu-id="397a2-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="397a2-104">Funktionale Programmierung und Imperative Programmierung</span><span class="sxs-lookup"><span data-stu-id="397a2-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="397a2-105">Die *funktionale Programmierung* Paradigma explizit erstellt wurde, um eine reine funktionale Lösung von Problemen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="397a2-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="397a2-106">Funktionaler Programmierung ist eine Form der *deklarativen Programmierung*.</span><span class="sxs-lookup"><span data-stu-id="397a2-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="397a2-107">Im Gegensatz dazu die meisten normalen Programmiersprachen, einschließlich der objektorientierten Programmierung (OOP) Sprachen wie c#, Visual Basic, C++ und Java, in erster Linie Unterstützung konzipiert wurden *imperative* (prozedurale) Programmierung.</span><span class="sxs-lookup"><span data-stu-id="397a2-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="397a2-108">Beim imperativen Ansatz schreibt ein Entwickler Code, der detailliert die Schritte beschreibt, die der Computer zur Erfüllung der Aufgabe ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="397a2-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="397a2-109">Dies wird manchmal als *algorithmische* programmieren.</span><span class="sxs-lookup"><span data-stu-id="397a2-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="397a2-110">Beim funktionalen Ansatz hingegen wird das Problem als Satz von auszuführenden Funktionen formuliert.</span><span class="sxs-lookup"><span data-stu-id="397a2-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="397a2-111">Sie definieren sorgfältig, was für jede Funktion eingegeben wird und was die jeweilige Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="397a2-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="397a2-112">In der folgenden Tabelle werden einige der allgemeinen Unterschiede zwischen diesen beiden Ansätzen beschrieben:</span><span class="sxs-lookup"><span data-stu-id="397a2-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="397a2-113">Merkmal</span><span class="sxs-lookup"><span data-stu-id="397a2-113">Characteristic</span></span>|<span data-ttu-id="397a2-114">Imperativer Ansatz</span><span class="sxs-lookup"><span data-stu-id="397a2-114">Imperative approach</span></span>|<span data-ttu-id="397a2-115">Funktionaler Ansatz</span><span class="sxs-lookup"><span data-stu-id="397a2-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="397a2-116">Schwerpunkt bei der Programmierung</span><span class="sxs-lookup"><span data-stu-id="397a2-116">Programmer focus</span></span>|<span data-ttu-id="397a2-117">Art und Weise der Ausführung von Aufgaben (Algorithmen) und der Überwachung von Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="397a2-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="397a2-118">Art der gewünschten Informationen und der erforderlichen Transformationen</span><span class="sxs-lookup"><span data-stu-id="397a2-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="397a2-119">Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="397a2-119">State changes</span></span>|<span data-ttu-id="397a2-120">wichtig</span><span class="sxs-lookup"><span data-stu-id="397a2-120">Important.</span></span>|<span data-ttu-id="397a2-121">nicht existent</span><span class="sxs-lookup"><span data-stu-id="397a2-121">Non-existent.</span></span>|  
|<span data-ttu-id="397a2-122">Reihenfolge der Ausführung</span><span class="sxs-lookup"><span data-stu-id="397a2-122">Order of execution</span></span>|<span data-ttu-id="397a2-123">wichtig</span><span class="sxs-lookup"><span data-stu-id="397a2-123">Important.</span></span>|<span data-ttu-id="397a2-124">weniger wichtig</span><span class="sxs-lookup"><span data-stu-id="397a2-124">Low importance.</span></span>|  
|<span data-ttu-id="397a2-125">Primäre Datenflusskontrolle</span><span class="sxs-lookup"><span data-stu-id="397a2-125">Primary flow control</span></span>|<span data-ttu-id="397a2-126">Schleifen, Bedingungen und Funktions- (Methoden-)Aufrufe</span><span class="sxs-lookup"><span data-stu-id="397a2-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="397a2-127">Funktionsaufrufe, einschließlich Rekursion</span><span class="sxs-lookup"><span data-stu-id="397a2-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="397a2-128">Primäre Manipulationseinheit</span><span class="sxs-lookup"><span data-stu-id="397a2-128">Primary manipulation unit</span></span>|<span data-ttu-id="397a2-129">Instanzen von Strukturen oder Klassen</span><span class="sxs-lookup"><span data-stu-id="397a2-129">Instances of structures or classes.</span></span>|<span data-ttu-id="397a2-130">Funktionen als erstklassige Objekte und Datensammlungen</span><span class="sxs-lookup"><span data-stu-id="397a2-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="397a2-131">Die meisten Sprachen unterstützen zwar ein bestimmtes Programmierparadigma, viele allgemeine Sprachen sind aber ausreichend flexibel, um mehrere Paradigmen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="397a2-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="397a2-132">So können z. B. die meisten Sprachen, die Funktionszeiger enthalten, zur glaubwürdigen Unterstützung der funktionalen Programmierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="397a2-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="397a2-133">Darüber hinaus umfasst Visual Basic explizite spracherweiterungen zur Unterstützung der funktionalen Programmierung, einschließlich Lambda-Ausdrücke und typableitung.</span><span class="sxs-lookup"><span data-stu-id="397a2-133">Furthermore, Visual Basic includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="397a2-134">Eine Form der deklarativen, funktionalen Programmierung ist die LINQ-Technologie.</span><span class="sxs-lookup"><span data-stu-id="397a2-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="397a2-135">Funktionale Programmierung mit XSLT</span><span class="sxs-lookup"><span data-stu-id="397a2-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="397a2-136">Viele XSLT-Entwickler sind mit dem reinen funktionalen Ansatz vertraut.</span><span class="sxs-lookup"><span data-stu-id="397a2-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="397a2-137">Der effektivste Weg bei der Entwicklung eines XSLT-Stylesheets besteht darin, jede Vorlage als isolierte, zusammensetzbare Transformation zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="397a2-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="397a2-138">Die Reihenfolge der Ausführung ist dabei ohne jede Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="397a2-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="397a2-139">XSLT lässt keine Nebenwirkungen zu (lediglich die Escapemechanismen für die Ausführung von prozeduralem Code können Nebenwirkungen mit sich bringen, die zu funktionaler Unreinheit führen).</span><span class="sxs-lookup"><span data-stu-id="397a2-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="397a2-140">XSLT ist zwar ein wirksames Tool, dennoch sind einige seiner Eigenschaften nicht optimal.</span><span class="sxs-lookup"><span data-stu-id="397a2-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="397a2-141">So führt z. B. das Ausdrücken von Programmierkonstrukten in XML dazu, dass Code relativ weitschweifig und damit schwierig zu unterhalten ist.</span><span class="sxs-lookup"><span data-stu-id="397a2-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="397a2-142">Auch die schwere Abhängigkeit von der Rekursion zur Flusssteuerung kann dazu führen, dass Code schwer lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="397a2-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="397a2-143">Weitere Informationen zu XSLT finden Sie unter [XSLT-Transformationen](http://msdn.microsoft.com/library/202f8820-224c-494f-b61e-cd127eac6e03).</span><span class="sxs-lookup"><span data-stu-id="397a2-143">For more information about XSLT, see [XSLT Transformations](http://msdn.microsoft.com/library/202f8820-224c-494f-b61e-cd127eac6e03).</span></span>  
  
 <span data-ttu-id="397a2-144">Dennoch hat XSLT bewiesen, dass die Verwendung eines reinen funktionalen Ansatzes bei der Transformierung von XML von einer Form in eine andere sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="397a2-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="397a2-145">Die reine funktionale Programmierung mit LINQ to XML ähnelt in vielerlei Hinsicht XSLT.</span><span class="sxs-lookup"><span data-stu-id="397a2-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="397a2-146">Allerdings können mit die Programmierkonstrukten von LINQ to XML und Visual Basic Sie reine funktionale Transformationen schreiben, die besser lesbar und unterhaltbar als XSLT sind.</span><span class="sxs-lookup"><span data-stu-id="397a2-146">However, the programming constructs introduced by LINQ to XML and Visual Basic allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="397a2-147">Vorteile von reinen Funktionen</span><span class="sxs-lookup"><span data-stu-id="397a2-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="397a2-148">Der Hauptgrund für die Implementierung von funktionalen Transformationen als reinen Funktionen (Pure-Funktionen) besteht darin, dass reine Funktionen zusammenstellbar sind, d. h., sie sind in sich abgeschlossen und zustandslos.</span><span class="sxs-lookup"><span data-stu-id="397a2-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="397a2-149">Diese Eigenschaften bieten u. a. die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="397a2-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
-   <span data-ttu-id="397a2-150">Bessere Lesbarkeit und Verwaltbarkeit:</span><span class="sxs-lookup"><span data-stu-id="397a2-150">Increased readability and maintainability.</span></span> <span data-ttu-id="397a2-151">Jede Funktion ist für die Erledigung einer bestimmten Aufgabe anhand ihrer Argumente vorgesehen,</span><span class="sxs-lookup"><span data-stu-id="397a2-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="397a2-152">ohne sich dabei auf einen externen Zustand zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="397a2-152">The function does not rely on any external state.</span></span>  
  
-   <span data-ttu-id="397a2-153">Einfachere reiterative Entwicklung:</span><span class="sxs-lookup"><span data-stu-id="397a2-153">Easier reiterative development.</span></span> <span data-ttu-id="397a2-154">Da der Code einfacher umgestaltet werden kann, können Änderungen am Entwurf oft leichter implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="397a2-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="397a2-155">Nehmen wir z. B. an, Sie schreiben eine komplizierte Transformation und stellen dann fest, dass sich ein Teil des Codes in der Transformation mehrmals wiederholt.</span><span class="sxs-lookup"><span data-stu-id="397a2-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="397a2-156">Bei der Umgestaltung mit einer reinen Methode können Sie Ihre reine Methode ganz nach Belieben aufrufen, ohne auf irgendwelche Nebenwirkungen Rücksicht nehmen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="397a2-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
-   <span data-ttu-id="397a2-157">Einfacheres Testen und Debuggen:</span><span class="sxs-lookup"><span data-stu-id="397a2-157">Easier testing and debugging.</span></span> <span data-ttu-id="397a2-158">Da reine Funktionen einfacher in Isolation getestet werden können, können Sie Testcode schreiben, der die reine Funktion mit typischen Werten, gültigen Randfällen und ungültigen Randfällen aufruft.</span><span class="sxs-lookup"><span data-stu-id="397a2-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="397a2-159">Was müssen OOP-Entwickler beachten?</span><span class="sxs-lookup"><span data-stu-id="397a2-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="397a2-160">Bei der traditionellen objektorientierten Programmierung (OOP) verwenden die meisten Entwickler beim Programmieren den imperativen/prozeduralen Stil.</span><span class="sxs-lookup"><span data-stu-id="397a2-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="397a2-161">Für den Umstieg auf die Entwicklung in einem reinen funktionalen Stil müssen die Entwickler umdenken und ihre Herangehensweise an die Entwicklung ändern.</span><span class="sxs-lookup"><span data-stu-id="397a2-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="397a2-162">Zur Lösung von Problemen entwerfen OOP-Entwickler Klassenhierarchien, konzentrieren sich auf die richtige Kapselung und denken in Klassenvertragskategorien.</span><span class="sxs-lookup"><span data-stu-id="397a2-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="397a2-163">Im Vordergrund stehen das Verhalten und der Status von Objekttypen, und zu diesem Zweck werden Sprachfunktionen wie Klassen, Schnittstellen, Vererbung und Polymorphie bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="397a2-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="397a2-164">Dagegen werden die Berechnungsprobleme bei der funktionalen Programmierung als Übung für die Auswertung reiner funktionaler Transformationen von Datensammlungen angesehen.</span><span class="sxs-lookup"><span data-stu-id="397a2-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="397a2-165">Bei der funktionalen Programmierung werden Zustands- und änderbare Daten vermieden, stattdessen steht die Anwendung von Funktionen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="397a2-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="397a2-166">Glücklicherweise erfordert Visual Basic den kompletten Umstieg auf die funktionale Programmierung, da er sowohl den imperativen als auch den funktionalen Programmierungsansatz unterstützt.</span><span class="sxs-lookup"><span data-stu-id="397a2-166">Fortunately, Visual Basic doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="397a2-167">Der Entwickler kann daher selbst entscheiden, welcher Ansatz für ein bestimmtes Szenario am geeignetsten ist.</span><span class="sxs-lookup"><span data-stu-id="397a2-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="397a2-168">Bei vielen Programme werden beide Ansätze häufig miteinander kombiniert.</span><span class="sxs-lookup"><span data-stu-id="397a2-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="397a2-169">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="397a2-169">See Also</span></span>  
 <span data-ttu-id="397a2-170">[Einführung in reine funktionale Transformationen (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md) </span><span class="sxs-lookup"><span data-stu-id="397a2-170">[Introduction to Pure Functional Transformations (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md) </span></span>  
<span data-ttu-id="397a2-171"> [XSLT-Transformationen](http://msdn.microsoft.com/library/202f8820-224c-494f-b61e-cd127eac6e03) </span><span class="sxs-lookup"><span data-stu-id="397a2-171"> [XSLT Transformations](http://msdn.microsoft.com/library/202f8820-224c-494f-b61e-cd127eac6e03) </span></span>  
<span data-ttu-id="397a2-172"> [Umgestalten in reine Funktionen (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/refactoring-into-pure-functions.md)</span><span class="sxs-lookup"><span data-stu-id="397a2-172"> [Refactoring Into Pure Functions (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/refactoring-into-pure-functions.md)</span></span>
